# TODO.txt for /home/user/Algobots/bot_a.py

## File Overview
`bot_a.py` is a comprehensive, high-frequency trading bot for Bybit USDT Futures, designed for the Termux environment. It features selectable strategies (Dual Supertrend, StochRSI/Momentum, Ehlers Fisher, Ehlers MA Cross), robust risk management with ATR-based stop-loss and dynamic position sizing, exchange-native trailing stop-loss, and Termux SMS alerts. The bot emphasizes precision with Decimal types and includes extensive error handling and logging.

## Key Components & Code Snippets

### Configuration (`Config` class)
```python
class Config:
    def __init__(self) -> None:
        # ... loads many parameters from environment variables
```
-   **Task**: Implement a more flexible configuration loading mechanism that allows for:
    *   Loading from a dedicated `config.json` or `config.yaml` file.
    *   Overriding values from environment variables.
    *   Allowing command-line arguments to override specific parameters.
-   **Task**: Add more comprehensive validation for all configuration parameters, including range checks for numerical values and format checks for strings (e.g., `SYMBOL`, `INTERVAL`).
-   **Test Suggestion**: Write unit tests for the `Config` class to verify:
    *   Correct loading and type casting of all environment variables.
    *   Proper handling of missing required variables.
    *   Correct validation of strategy names and other parameters.

### Logging & Alerts (`logger`, `send_sms_alert`)
```python
logger: logging.Logger = logging.getLogger(__name__)
# ...
def send_sms_alert(message: str) -> bool:
    # ...
```
-   **Task**: Enhance the logging setup to include log rotation (e.g., `RotatingFileHandler`) to prevent log files from growing indefinitely.
-   **Task**: Implement a more robust and configurable alert system that supports multiple channels (e.g., Telegram, email, webhooks) beyond just Termux SMS.
-   **Test Suggestion**: Write unit tests for `send_sms_alert` by mocking `subprocess.run` to verify correct command execution and error handling.

### Exchange Initialization (`initialize_exchange`)
```python
def initialize_exchange() -> Optional[ccxt.Exchange]:
    # ...
```
-   **Task**: Implement a mechanism to dynamically determine if the bot should connect to testnet or mainnet based on a configuration parameter, rather than relying on hardcoded `options` in `ccxt.bybit`.
-   **Task**: Add more specific error handling for `ccxt.ExchangeError` types during initialization to provide more actionable feedback.
-   **Test Suggestion**: Mock `ccxt.bybit` and its methods (`load_markets`, `fetch_balance`) and write unit tests for `initialize_exchange` to verify:
    *   Successful exchange initialization and market loading.
    *   Correct handling of authentication, network, and exchange errors.

### Indicator Calculation Functions (`calculate_supertrend`, `analyze_volume_atr`, `calculate_stochrsi_momentum`, `calculate_ehlers_fisher`, `calculate_ehlers_ma`)
```python
def calculate_supertrend(df: pd.DataFrame, length: int, multiplier: Decimal, prefix: str = "") -> pd.DataFrame:
    # ...
def analyze_volume_atr(df: pd.DataFrame, atr_len: int, vol_ma_len: int) -> Dict[str, Optional[Decimal]]:
    # ...
```
-   **Task**: Ensure all indicator calculations consistently use `Decimal` for all intermediate and final values to maintain precision.
-   **Task**: Add comprehensive docstrings to all indicator functions, explaining parameters, return values, and any assumptions.
-   **Task**: Implement more robust error handling within indicator functions to gracefully handle `NaN` values or insufficient data.
-   **Test Suggestion**: Write comprehensive unit tests for each indicator function using small, known datasets and verifying the output DataFrames/Dictionaries and calculated values.

### Order Book Analysis (`analyze_order_book`)
```python
def analyze_order_book(exchange: ccxt.Exchange, symbol: str, depth: int, fetch_limit: int) -> Dict[str, Optional[Decimal]]:
    # ...
```
-   **Task**: Implement a real-time order book update mechanism using WebSockets instead of polling via REST API for `analyze_order_book`.
-   **Task**: Enhance the analysis to identify significant liquidity walls or imbalances at different price levels.
-   **Test Suggestion**: Mock `exchange.fetch_l2_order_book` and write unit tests for `analyze_order_book` with various order book structures to verify correct ratio and spread calculations.

### Position & Order Management (`get_current_position`, `set_leverage`, `close_position`, `calculate_position_size`, `wait_for_order_fill`)
```python
def get_current_position(exchange: ccxt.Exchange, symbol: str) -> Dict[str, Any]:
    # ...
def set_leverage(exchange: ccxt.Exchange, symbol: str, leverage: int) -> bool:
    # ...
def close_position(exchange: ccxt.Exchange, symbol: str, position_to_close: Dict[str, Any], reason: str = "Signal") -> Optional[Dict[str, Any]]:
    # ...
def calculate_position_size(equity: Decimal, risk_per_trade_pct: Decimal, ...) -> Tuple[Optional[Decimal], Optional[Decimal]]:
    # ...
def wait_for_order_fill(exchange: ccxt.Exchange, order_id: str, symbol: str, timeout_seconds: int) -> Optional[Dict[str, Any]]:
    # ...
```
-   **Task**: Implement a more robust position tracking system that uses WebSocket updates for real-time synchronization, rather than relying solely on polling `get_current_position`.
-   **Task**: Enhance `close_position` to handle partial fills and to ensure the position is fully closed, potentially with multiple attempts or a fallback to market order.
-   **Task**: Refine `calculate_position_size` to consider available margin and exchange-specific minimum/maximum order sizes more precisely.
-   **Task**: Implement a mechanism to track and manage open orders (e.g., limit orders, stop-loss/take-profit orders) and their lifecycle.
-   **Test Suggestion**: Write unit tests for `get_current_position` with various exchange responses (open position, no position, parsing errors).
-   **Test Suggestion**: Write comprehensive unit tests for `calculate_position_size` with different equity, risk, and price inputs.
-   **Test Suggestion**: Mock `exchange.create_market_order` and `exchange.fetch_order` and write unit tests for `close_position` and `wait_for_order_fill` to verify correct order execution and status tracking.

### Strategy Logic (`execute_strategy`)
```python
def execute_strategy(exchange: ccxt.Exchange, symbol: str, current_price: Decimal, ohlcv_df: pd.DataFrame, order_book_data: Dict[str, Optional[Decimal]]) -> Optional[str]:
    # ...
```
-   **Task**: Implement a more sophisticated signal generation and filtering mechanism that considers multiple indicators, market conditions (e.g., volatility), and risk parameters.
-   **Task**: Add logic to handle different types of signals (e.g., entry, exit, reversal) and prioritize them based on strategy rules.
-   **Test Suggestion**: Write unit tests for `execute_strategy` by mocking indicator functions and `order_book_data` to verify correct signal generation for each defined strategy.

### Main Bot Loop (`main` function)
```python
def main():
    # ...
```
-   **Task**: Implement a graceful shutdown mechanism that ensures all open positions are managed and resources are released before exiting.
-   **Task**: Add a command-line interface (CLI) for `main` to allow for easier control (e.g., dry-run mode, specify config file, enable/disable features).
-   **Test Suggestion**: Write an integration test for the `main` function that mocks API calls and simulates market data to verify the end-to-end flow of the bot.

## General Improvements
-   **Type Hinting**: Add comprehensive type hints to all functions and methods.
-   **Docstrings**: Add or improve docstrings for all functions and classes.
-   **Error Handling**: Implement robust error handling throughout the bot to provide more informative messages and prevent crashes.
-   **Modularity**: Further refactor the code into smaller, more focused modules and classes to improve maintainability and testability.
-   **Concurrency**: Explore using `asyncio` for non-blocking API calls and WebSocket handling to improve performance.
