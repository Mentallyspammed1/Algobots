"""Bybit Ultra Scalper Bot: A comprehensive, enterprise-grade trading bot for Bybit exchange.\n\nThis bot leverages Ehlers Fisher Transform and SuperTrend indicators for signal generation,\nand manages orders, positions, and WebSocket connections with enhanced robustness and logging.\n"""\n\nimport json\nimport time\nimport requests\nimport hmac\nimport hashlib\nimport asyncio\nimport websockets\nimport pandas as pd\nimport logging\n\n# Import configuration and custom indicators\nimport config\nfrom indicators import EhlersFilter, SuperTrend\n\n# Import specific TA indicators directly\nfrom ta.momentum import RSIIndicator, StochasticOscillator\n\n# --- Logging Setup ---\n# Configure logging to output to console and a file\nlog_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nroot_logger = logging.getLogger()\nroot_logger.setLevel(config.LOG_LEVEL)\n\n# Console Handler\nconsole_handler = logging.StreamHandler()\nconsole_handler.setFormatter(log_formatter)\nroot_logger.addHandler(console_handler)\n\n# File Handler\nfile_handler = logging.FileHandler(config.LOG_FILE)\nfile_handler.setFormatter(log_formatter)\nroot_logger.addHandler(file_handler)\n\nlogger = logging.getLogger(__name__)\n\n\nclass BybitClient:\n    """Handles interactions with the Bybit REST API for trading and account management."""\n\n    def __init__(self, api_key: str, api_secret: str, base_url: str):\n        """Initializes the BybitClient.\n\n        Args:\n            api_key: Your Bybit API key.\n            api_secret: Your Bybit API secret.\n            base_url: The base URL for the Bybit REST API (testnet or mainnet).\n        """\n        self.api_key = api_key\n        self.api_secret = api_secret\n        self.base_url = base_url\n        self.session = requests.Session()\n        logger.info(f"BybitClient initialized for base URL: {self.base_url}")\n\n    def _generate_signature(self, payload: dict) -> str:\n        """Generates the HMAC SHA256 signature for a request payload."""\n        param_str = '&'.join([f'{k}={v}' for k, v in sorted(payload.items())\\n                               if v is not None])\n        return hmac.new(self.api_secret.encode('utf-8'),\n                        param_str.encode('utf-8'),\n                        hashlib.sha256).hexdigest()\n\n    def send_signed_request(self, method: str, endpoint: str,\n                            payload: dict = None) -> dict | None:\n        """Sends a signed request to the Bybit API.\n\n        Args:\n            method: HTTP method (GET or POST).\n            endpoint: API endpoint path.\n            payload: Dictionary of request parameters.\n\n        Returns:\n            JSON response from the API or None if an error occurred.\n        """\n        if payload is None:\n            payload = {}\n\n        # Add common parameters\n        payload['api_key'] = self.api_key\n        payload['timestamp'] = int(time.time() * 1000)\n        payload['recv_window'] = 5000  # Default recv_window\n\n        signature = self._generate_signature(payload)\n        payload['sign'] = signature\n\n        headers = {'Content-Type': 'application/json'}\n        url = f"{self.base_url}{endpoint}"\n\n        try:\n            if method == 'GET':\n                response = self.session.get(url, params=payload,\n                                            headers=headers, timeout=10)\n            elif method == 'POST':\n                response = self.session.post(url, json=payload,\n                                             headers=headers, timeout=10)\n            else:\n                raise ValueError(f"Unsupported HTTP method: {method}")\n\n            response.raise_for_status()  # Raise HTTPError for bad responses\n            return response.json()\n        except requests.exceptions.Timeout:\n            logger.error(f"Request to {url} timed out after 10 seconds.")\n            return None\n        except requests.exceptions.RequestException as e:\n            logger.error(f"Request failed: {e}")\n            if hasattr(e, 'response') and e.response is not None:\n                logger.error(f"Response status: {e.response.status_code}, "\\n                             f"content: {e.response.text}")\n            return None\n        except json.JSONDecodeError:\n            logger.error(f"Failed to decode JSON from response: {response.text}")\n            return None\n\n    def send_public_request(self, method: str, endpoint: str,\n                            params: dict = None) -> dict | None:\n        """Sends a public (unsigned) request to the Bybit API.\n\n        Args:\n            method: HTTP method (GET).\n            endpoint: API endpoint path.\n            params: Dictionary of request parameters.\n\n        Returns:\n            JSON response from the API or None if an error occurred.\n        """\n        if params is None:\n            params = {}\n        url = f"{self.base_url}{endpoint}"\n        try:\n            if method == 'GET':\n                response = self.session.get(url, params=params, timeout=10)\n            else:\n                raise ValueError(f"Unsupported HTTP method for public request: "\\n                                 f"{method}")\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.Timeout:\n            logger.error(f"Public request to {url} timed out after 10 seconds.")\n            return None\n        except requests.exceptions.RequestException as e:\n            logger.error(f"Public request failed: {e}")\n            if hasattr(e, 'response') and e.response is not None:\n                logger.error(f"Response status: {e.response.status_code}, "\\n                             f"content: {e.response.text}")\n            return None\n        except json.JSONDecodeError:\n            logger.error(f"Failed to decode JSON from response: {response.text}")\n            return None\n\n    def get_kline(self, symbol: str, interval: str, limit: int = 200,\n                  end_time: int = None) -> list | None:\n        """Fetches kline (candlestick) data.\n\n        Args:\n            symbol: Trading pair symbol (e.g., "BTCUSDT").\n            interval: Candlestick interval (e.g., "1", "5", "60").\n            limit: Number of candlesticks to retrieve.\n            end_time: End timestamp for the data (in milliseconds).\n\n        Returns:\n            List of kline data or None.\n        """\n        endpoint = "/v5/market/kline"\n        params = {\n            'category': 'linear',\n            'symbol': symbol,\n            'interval': interval,\n            'limit': limit\n        }\n        if end_time:\n            params['end'] = end_time\n\n        response = self.send_public_request('GET', endpoint, params)\n        if response and response['retCode'] == 0:\n            return response['result']['list']\n        logger.error(f"Failed to get kline data: {response}")\n        return None\n\n    def place_order(self, symbol: str, side: str, qty: float,\n                    order_type: str = "Market", price: float = None,\n                    time_in_force: str = "GTC", reduce_only: bool = False,\n                    close_on_trigger: bool = False, stop_loss_px: float = None,\n                    take_profit_px: float = None) -> dict | None:\n        """Places a new order on the exchange.\n\n        Args:\n            symbol: Trading pair symbol.\n            side: Order side ("Buy" or "Sell").\n            qty: Order quantity.\n            order_type: Type of order ("Market" or "Limit").\n            price: Price for limit orders.\n            time_in_force: Time in force policy (e.g., "GTC", "IOC").\n            reduce_only: Whether the order is reduce-only.\n            close_on_trigger: Whether to close position on trigger.\n            stop_loss_px: Stop loss price.\n            take_profit_px: Take profit price.\n\n        Returns:\n            Order placement response or None.\n        """\n        endpoint = "/v5/order/create"\n        payload = {\n            'category': 'linear',\n            'symbol': symbol,\n            'side': side,\n            'orderType': order_type,\n            'qty': str(qty),\n            'timeInForce': time_in_force,\n            'reduceOnly': reduce_only,\n            'closeOnTrigger': close_on_trigger,\n            'isLeverage': 1,  # For isolated margin\n            'triggerDirection': 1 if side == 'Buy' else 2  # For TP/SL\n        }\n        if price:\n            payload['price'] = str(price)\n        if stop_loss_px:\n            payload['stopLoss'] = str(stop_loss_px)\n        if take_profit_px:\n            payload['takeProfit'] = str(take_profit_px)\n\n        response = self.send_signed_request('POST', endpoint, payload)\n        if response and response['retCode'] == 0:\n            logger.info(f"Order placed successfully: {response['result']}")\n            return response['result']\n        logger.error(f"Failed to place order: {response}")\n        return None\n\n    def get_open_orders(self, symbol: str) -> list | None:\n        """Retrieves a list of open orders for a given symbol."""\n        endpoint = "/v5/order/realtime"\n        params = {\n            'category': 'linear',\n            'symbol': symbol,\n        }\n        response = self.send_signed_request('GET', endpoint, params)\n        if response and response['retCode'] == 0:\n            return response['result']['list']\n        logger.error(f"Failed to get open orders: {response}")\n        return None\n\n    def cancel_order(self, symbol: str, order_id: str = None,\n                     order_link_id: str = None) -> dict | None:\n        """Cancels an active order by order ID or order link ID."""\n        endpoint = "/v5/order/cancel"\n        payload = {\n            'category': 'linear',\n            'symbol': symbol,\n        }\n        if order_id:\n            payload['orderId'] = order_id\n        if order_link_id:\n            payload['orderLinkId'] = order_link_id\n\n        response = self.send_signed_request('POST', endpoint, payload)\n        if response and response['retCode'] == 0:\n            logger.info(f"Order cancelled successfully: {response['result']}")\n            return response['result']\n        logger.error(f"Failed to cancel order: {response}")\n        return None\n\n    def get_position(self, symbol: str) -> dict | None:\n        """Retrieves the current position for a given symbol."""\n        endpoint = "/v5/position/list"\n        params = {\n            'category': 'linear',\n            'symbol': symbol,\n        }\n        response = self.send_signed_request('GET', endpoint, params)\n        if response and response['retCode'] == 0:\n            if response['result']['list']:\n                # Assuming only one position per symbol\n                return response['result']['list'][0]\n            return None\n        logger.error(f"Failed to get position: {response}")\n        return None\n\n    def set_leverage(self, symbol: str, leverage: float) -> bool:\n        """Sets the leverage for a trading pair."""\n        endpoint = "/v5/position/set-leverage"\n        payload = {\n            'category': 'linear',\n            'symbol': symbol,\n            'buyLeverage': str(leverage),\n            'sellLeverage': str(leverage)\n        }\n        response = self.send_signed_request('POST', endpoint, payload)\n        if response and response['retCode'] == 0:\n            logger.info(f"Leverage set to {leverage} for {symbol}")\n            return True\n        logger.error(f"Failed to set leverage: {response}")\n        return False\n\n    def get_wallet_balance(self, account_type: str = "UNIFIED") -> dict | None:\n        """Retrieves wallet balance information."""\n        endpoint = "/v5/account/wallet-balance"\n        params = {\n            'accountType': account_type\n        }\n        response = self.send_signed_request('GET', endpoint, params)\n        if response and response['retCode'] == 0:\n            return response['result']['list'][0]\n        logger.error(f"Failed to get wallet balance: {response}")\n        return None\n\n\nclass EhlersSupertrendStrategy:\n    """Implements a trading strategy using Ehlers Fisher Transform and SuperTrend."""\n\n    def __init__(self, client: BybitClient, symbol: str, interval: str,\n                 trade_qty: float, leverage: float, rsi_period: int,\n                 rsi_overbought: float, rsi_oversold: float,\n                 stoch_rsi_period: int, stoch_rsi_smooth_k: int,\n                 stoch_rsi_smooth_d: int, stoch_rsi_overbought: float,\n                 stoch_rsi_oversold: float, super_trend_period: int,\n                 super_trend_multiplier: float, eh_fisher_period: int,\n                 eh_fisher_smoothing: int, eh_fisher_overbought: float,\n                 eh_fisher_oversold: float, eh_fisher_trigger_buy: float,\n                 eh_fisher_trigger_sell: float, max_position_size: float,\n                 stop_loss_percent: float, take_profit_percent: float):\n        """Initializes the EhlersSupertrendStrategy.\n\n        Args:\n            client: An instance of BybitClient.\n            symbol: Trading pair symbol.\n            interval: Candlestick interval.\n            trade_qty: Quantity to trade per order.\n            leverage: Leverage to use.\n            rsi_period: Period for RSI calculation.\n            rsi_overbought: RSI overbought threshold.\n            rsi_oversold: RSI oversold threshold.\n            stoch_rsi_period: Period for Stochastic RSI calculation.\n            stoch_rsi_smooth_k: Smoothing for Stochastic RSI %K.\n            stoch_rsi_smooth_d: Smoothing for Stochastic RSI %D.\n            stoch_rsi_overbought: Stochastic RSI overbought threshold.\n            stoch_rsi_oversold: Stochastic RSI oversold threshold.\n            super_trend_period: Period for SuperTrend calculation.\n            super_trend_multiplier: Multiplier for SuperTrend ATR.\n            eh_fisher_period: Period for Ehlers Fisher Transform.\n            eh_fisher_smoothing: Smoothing for Ehlers Fisher Transform.\n            eh_fisher_overbought: Ehlers Fisher overbought threshold.\n            eh_fisher_oversold: Ehlers Fisher oversold threshold.\n            eh_fisher_trigger_buy: Ehlers Fisher buy trigger level.\n            eh_fisher_trigger_sell: Ehlers Fisher sell trigger level.\n            max_position_size: Maximum allowed position size.\n            stop_loss_percent: Percentage for stop loss calculation.\n            take_profit_percent: Percentage for take profit calculation.\n        """\n        self.client = client\n        self.symbol = symbol\n        self.interval = interval\n        self.trade_qty = trade_qty\n        self.leverage = leverage\n        self.max_position_size = max_position_size\n        self.stop_loss_percent = stop_loss_percent\n        self.take_profit_percent = take_profit_percent\n\n        self.ehlers_filter = EhlersFilter(period=eh_fisher_period,\n                                          smoothing=eh_fisher_smoothing)\n        self.super_trend = SuperTrend(period=super_trend_period,\n                                      multiplier=super_trend_multiplier)\n\n        self.rsi_period = rsi_period\n        self.rsi_overbought = rsi_overbought\n        self.rsi_oversold = rsi_oversold\n\n        self.stoch_rsi_period = stoch_rsi_period\n        self.stoch_rsi_smooth_k = stoch_rsi_smooth_k\n        self.stoch_rsi_smooth_d = stoch_rsi_smooth_d\n        self.stoch_rsi_overbought = stoch_rsi_overbought\n        self.stoch_rsi_oversold = stoch_rsi_oversold\n\n        self.eh_fisher_overbought = eh_fisher_overbought\n        self.eh_fisher_oversold = eh_fisher_oversold\n        self.eh_fisher_trigger_buy = eh_fisher_trigger_buy\n        self.eh_fisher_trigger_sell = eh_fisher_trigger_sell\n\n        self.df = pd.DataFrame()\n        self.in_position = False\n        self.position_side = None  # 'Buy' or 'Sell'\n        self.position_qty = 0.0\n        self.entry_price = 0.0\n\n        logger.info(f"Strategy initialized for {symbol} with interval {interval}")\n\n    async def initialize_data(self):\n        """Fetches initial historical data and calculates indicators."""\n        logger.info(f"Initializing historical data for {self.symbol}...")\n        klines = self.client.get_kline(self.symbol, self.interval, limit=200)\n        if klines:\n            self.df = self._process_kline_data(klines)\n            self.df = self._calculate_indicators(self.df)\n            logger.info(f"Historical data initialized. Current DF size: "\\n                        f"{len(self.df)}")\n        else:\n            logger.error("Failed to fetch initial kline data.")\n            raise Exception("Initial data fetch failed.")\n\n    def _process_kline_data(self, kline_data_list: list) -> pd.DataFrame:\n        """Processes raw kline data into a pandas DataFrame."""\n        # Ensure kline_data_list is a list of lists/tuples\n        if not isinstance(kline_data_list, list) or not all(isinstance(k, list)\\n                                                           for k in kline_data_list):\n            logger.error(f"Invalid kline data format: {kline_data_list}")\n            return pd.DataFrame()\n\n        df = pd.DataFrame(kline_data_list, columns=[\n            'start_time', 'open', 'high', 'low', 'close', 'volume', 'turnover'\n        ])\n        df['start_time'] = pd.to_datetime(df['start_time'], unit='ms', utc=True)\n        df[['open', 'high', 'low', 'close', 'volume', 'turnover']] = \\\n            df[['open', 'high', 'low', 'close', 'volume', 'turnover']].astype(float)\n        df = df.set_index('start_time')\n\n        # Ensure index is unique and sorted\n        df = df[~df.index.duplicated(keep='last')]\n        return df.sort_index()\n\n    def _calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n        """Calculates all necessary technical indicators for the strategy."""\n        if df.empty:\n            return df\n\n        # Ensure the DataFrame has the required columns for ta library\n        required_cols = ['open', 'high', 'low', 'close', 'volume']\n        if not all(col in df.columns for col in required_cols):\n            logger.warning("DataFrame missing required columns for TA indicators. "\\n                           "Skipping calculation.")\n            return df\n\n        # RSI\n        df['rsi'] = RSIIndicator(df['close'], window=self.rsi_period).rsi()\n\n        # Stochastic RSI\n        stoch_rsi = StochasticOscillator(\n            df['close'], window=self.stoch_rsi_period,\n            smooth_window=self.stoch_rsi_smooth_k, fillna=False\n        )\n        df['stoch_rsi_k'] = stoch_rsi.stoch_signal()  # K line\n        df['stoch_rsi_d'] = stoch_rsi.stoch()  # D line (often called %D or main StochRSI line)\n\n        # Ehlers Fisher Transform (using custom class)\n        df = self.ehlers_filter.calculate(df)\n\n        # SuperTrend (using custom class)\n        df = self.super_trend.calculate(df)\n\n        # Drop any NaN values that result from indicator calculations\n        df.dropna(inplace=True)\n        return df\n\n    async def update_data(self, kline_data: list):\n        """Updates the DataFrame with new kline data and recalculates indicators."""\n        new_kline_df = self._process_kline_data([kline_data])\n        if new_kline_df.empty:\n            logger.warning("Received empty or invalid kline data for update.")\n            return\n\n        # Check if the new kline is a duplicate or older\n        if not self.df.empty and new_kline_df.index.max() <= self.df.index.max():\n            # If it's an update to the latest candle, replace it\n            if new_kline_df.index.max() == self.df.index.max():\n                self.df.update(new_kline_df)\n                logger.debug(f"Updated latest kline: {new_kline_df.index.max()}")\n            else:\n                logger.debug(f"Received old kline data, ignoring: "\\n                             f"{new_kline_df.index.max()}")\n                return\n        else:\n            # Append new kline and keep only the last 200 for performance\n            self.df = pd.concat([self.df, new_kline_df]).iloc[-200:]\n            logger.debug(f"Appended new kline: {new_kline_df.index.max()}")\n\n        self.df = self._calculate_indicators(self.df)\n        logger.debug(f"Data updated and indicators recalculated. Current DF size: "\\n                     f"{len(self.df)}")\n\n    async def check_and_execute_trade(self):\n        """Checks for trade signals and executes trades based on strategy rules."""\n        min_data_len = max(self.rsi_period, self.stoch_rsi_period,\n                           self.ehlers_filter.period, self.super_trend.period) + 1\n        if self.df.empty or len(self.df) < min_data_len:\n            logger.warning("Not enough data to generate signals.")\n            return\n\n        latest_candle = self.df.iloc[-1]\n\n        # --- Signal Generation ---\n        buy_signal = False\n        sell_signal = False\n\n        # Ehlers Fisher Buy Signal: Fisher crosses above signal and trigger,\n        # and is not overbought\n        eh_fisher_buy_condition = (\n            latest_candle['eh_fisher'] > latest_candle['eh_fisher_signal']\n            and latest_candle['eh_fisher_signal'] < self.eh_fisher_trigger_buy\n            and latest_candle['eh_fisher'] < self.eh_fisher_overbought\n        )\n\n        # Ehlers Fisher Sell Signal: Fisher crosses below signal and trigger,\n        # and is not oversold\n        eh_fisher_sell_condition = (\n            latest_candle['eh_fisher'] < latest_candle['eh_fisher_signal']\n            and latest_candle['eh_fisher_signal'] > self.eh_fisher_trigger_sell\n            and latest_candle['eh_fisher'] > self.eh_fisher_oversold\n        )\n\n        # SuperTrend Buy Signal: Close above SuperTrend and SuperTrend direction is up\n        supertrend_buy_condition = (\n            latest_candle['close'] > latest_candle['supertrend']\n            and latest_candle['supertrend_direction'] == 1\n        )\n\n        # SuperTrend Sell Signal: Close below SuperTrend and SuperTrend direction is down\n        supertrend_sell_condition = (\n            latest_candle['close'] < latest_candle['supertrend']\n            and latest_candle['supertrend_direction'] == -1\n        )\n\n        # Combined Buy Signal\n        if eh_fisher_buy_condition and supertrend_buy_condition:\n            buy_signal = True\n            logger.info("Combined BUY signal detected!")\n\n        # Combined Sell Signal\n        if eh_fisher_sell_condition and supertrend_sell_condition:\n            sell_signal = True\n            logger.info("Combined SELL signal detected!")\n\n        # --- Position Management ---\n        current_position = self.client.get_position(self.symbol)\n        if current_position:\n            self.in_position = True\n            self.position_qty = float(current_position['size'])\n            self.position_side = current_position['side']\n            self.entry_price = float(current_position['avgPrice'])\n            logger.info(f"Current position: {self.position_side} "\\n                        f"{self.position_qty} at {self.entry_price}")\n        else:\n            self.in_position = False\n            self.position_qty = 0.0\n            self.position_side = None\n            self.entry_price = 0.0\n            logger.info("No open position.")\n\n        if not self.in_position:\n            if buy_signal:\n                await self._execute_trade('Buy')\n            elif sell_signal:\n                await self._execute_trade('Sell')\n        else:\n            # Check for reversal or exit conditions\n            if self.position_side == 'Buy' and sell_signal:\n                logger.info("Reversal: Buy position open, but sell signal detected. "\\n                            "Closing position and opening sell.")\n                await self._close_position()\n                await self._execute_trade('Sell')\n            elif self.position_side == 'Sell' and buy_signal:\n                logger.info("Reversal: Sell position open, but buy signal detected. "\\n                            "Closing position and opening buy.")\n                await self._close_position()\n                await self._execute_trade('Buy')\n            else:\n                logger.info("No new trade signals or reversal detected. "\\n                            "Holding current position.")\n\n    async def _execute_trade(self, side: str):\n        """Executes a trade (buy or sell) with calculated stop loss and take profit."""\n        if self.position_qty >= self.max_position_size:\n            logger.warning(f"Cannot open {side} trade: Max position size reached "\\n                           f"({self.position_qty}).")\n            return\n\n        # Calculate quantity to trade, ensuring it doesn't exceed max_position_size\n        qty_to_trade = min(self.trade_qty,\n                           self.max_position_size - self.position_qty)\n        if qty_to_trade <= 0:\n            logger.warning(f"Calculated trade quantity is zero or negative for "\\n                           f"{side} trade.")\n            return\n\n        # Get current price for SL/TP calculation\n        current_price = self.df['close'].iloc[-1]\n\n        stop_loss_px = None\n        take_profit_px = None\n\n        if side == 'Buy':\n            stop_loss_px = current_price * (1 - self.stop_loss_percent)\n            take_profit_px = current_price * (1 + self.take_profit_percent)\n        elif side == 'Sell':\n            stop_loss_px = current_price * (1 + self.stop_loss_percent)\n            take_profit_px = current_price * (1 - self.take_profit_percent)\n\n        logger.info(f"Attempting to place {side} order for {qty_to_trade} "\\n                    f"{self.symbol} with SL: {stop_loss_px:.2f}, "\\n                    f"TP: {take_profit_px:.2f}")\n\n        order_result = self.client.place_order(\n            symbol=self.symbol,\n            side=side,\n            qty=qty_to_trade,\n            order_type="Market",\n            stop_loss_px=stop_loss_px,\n            take_profit_px=take_profit_px\n        )\n\n        if order_result:\n            self.in_position = True\n            self.position_side = side\n            self.position_qty += qty_to_trade\n            # For market orders, entry price is close price\n            self.entry_price = current_price\n            logger.info(f"Successfully opened {side} position of {qty_to_trade} "\\n                        f"{self.symbol}.")\n        else:\n            logger.error(f"Failed to open {side} position.")\n\n    async def _close_position(self):\n        """Closes the current open position."""\n        if not self.in_position or self.position_qty == 0:\n            logger.info("No open position to close.")\n            return\n\n        # Determine opposite side to close the position\n        close_side = 'Sell' if self.position_side == 'Buy' else 'Buy'\n\n        logger.info(f"Attempting to close {self.position_side} position of "\\n                    f"{self.position_qty} {self.symbol}.")\n\n        order_result = self.client.place_order(\n            symbol=self.symbol,\n            side=close_side,\n            qty=self.position_qty,\n            order_type="Market",\n            reduce_only=True  # Ensure this order only reduces position\n        )\n\n        if order_result:\n            self.in_position = False\n            self.position_qty = 0.0\n            self.position_side = None\n            self.entry_price = 0.0\n            logger.info(f"Successfully closed position for {self.symbol}.")\n        else:\n            logger.error(f"Failed to close position for {self.symbol}.")\n\n\nclass WebSocketClient:\n    """Manages WebSocket connections for real-time market and account data."""\n\n    def __init__(self, public_ws_url: str, private_ws_url: str, api_key: str,\n                 api_secret: str, strategy: EhlersSupertrendStrategy):\n        """Initializes the WebSocketClient.\n\n        Args:\n            public_ws_url: URL for public WebSocket.\n            private_ws_url: URL for private WebSocket.\n            api_key: Bybit API key.\n            api_secret: Bybit API secret.\n            strategy: The trading strategy instance to update.\n        """\n        self.public_ws_url = public_ws_url\n        self.private_ws_url = private_ws_url\n        self.api_key = api_key\n        self.api_secret = api_secret\n        self.strategy = strategy\n        self.public_websocket = None\n        self.private_websocket = None\n        self.is_connected = False\n        self.reconnect_attempt = 0\n        self.last_ping_time = time.time()\n        logger.info(f"WebSocketClient initialized. Public WS: {self.public_ws_url}, "\\n                    f"Private WS: {self.private_ws_url}")\n\n    async def _connect_public(self) -> bool:\n        """Establishes connection to the public WebSocket and subscribes to kline data."""\n        try:\n            self.public_websocket = await websockets.connect(\n                self.public_ws_url, ping_interval=config.PING_INTERVAL,\n                ping_timeout=config.PING_TIMEOUT)\n            logger.info("Connected to public WebSocket.")\n            # Subscribe to kline data\n            await self.public_websocket.send(json.dumps({\n                "op": "subscribe",\n                "args": [f"kline.{config.INTERVAL}.{config.SYMBOL}"]\n            }))\n            logger.info(f"Subscribed to kline.{config.INTERVAL}.{config.SYMBOL}")\n            return True\n        except Exception as e:\n            logger.error(f"Failed to connect to public WebSocket: {e}")\n            return False\n\n    async def _connect_private(self) -> bool:\n        """Establishes connection to the private WebSocket and authenticates."""\n        try:\n            self.private_websocket = await websockets.connect(\n                self.private_ws_url, ping_interval=config.PING_INTERVAL,\n                ping_timeout=config.PING_TIMEOUT)\n            logger.info("Connected to private WebSocket.")\n\n            # Authenticate private channel\n            expires = int((time.time() + 10) * 1000)\n            param_str = f"GET/realtime{expires}"\n            signature = hmac.new(self.api_secret.encode('utf-8'),\n                                 param_str.encode('utf-8'),\n                                 hashlib.sha256).hexdigest()\n\n            await self.private_websocket.send(json.dumps({\n                "op": "auth",\n                "args": [self.api_key, expires, signature]\n            }))\n            auth_response = await self.private_websocket.recv()\n            auth_data = json.loads(auth_response)\n            if auth_data.get('success'):\n                logger.info("Private WebSocket authenticated successfully.")\n                # Subscribe to private topics (e.g., position, order)\n                await self.private_websocket.send(json.dumps({\n                    "op": "subscribe",\n                    "args": ["position", "order"]\n                }))\n                logger.info("Subscribed to private topics: position, order")\n                return True\n            else:\n                logger.error(f"Private WebSocket authentication failed: "\\n                             f"{auth_data}")\n                return False\n        except Exception as e:\n            logger.error(f"Failed to connect or authenticate private WebSocket: "\\n                         f"{e}")\n            return False\n\n    async def connect(self) -> bool:\n        """Connects to both public and private WebSockets."""\n        public_connected = await self._connect_public()\n        private_connected = await self._connect_private()\n        self.is_connected = public_connected and private_connected\n        if self.is_connected:\n            self.reconnect_attempt = 0\n            logger.info("All WebSockets connected.")\n        else:\n            logger.error("One or more WebSockets failed to connect.")\n        return self.is_connected\n\n    async def reconnect(self) -> bool:\n        """Attempts to reconnect to WebSockets with exponential backoff."""\n        self.is_connected = False\n        self.reconnect_attempt += 1\n        # Exponential backoff, max 60s\n        delay = min(config.RECONNECT_TIMEOUT_SECONDS *\\n                    (2 ** (self.reconnect_attempt - 1)), 60)\n        logger.warning(f"Reconnecting in {delay} seconds (attempt "\\n                       f"{self.reconnect_attempt})...")\n        await asyncio.sleep(delay)\n        return await self.connect()\n\n    async def listen_public(self):\n        """Listens for messages from the public WebSocket."""\n        while True:\n            try:\n                if not self.public_websocket or not self.public_websocket.open:\n                    logger.warning("Public WebSocket not open, attempting to reconnect.")\n                    if not await self._connect_public():\n                        await asyncio.sleep(config.RECONNECT_TIMEOUT_SECONDS)\n                        continue\n\n                message = await self.public_websocket.recv()\n                data = json.loads(message)\n\n                if 'data' in data and 'topic' in data:\n                    if data['topic'].startswith('kline'):\n                        await self.handle_websocket_kline_data(data['data'])\n                elif 'op' in data and data['op'] == 'pong':\n                    logger.debug("Received public pong.")\n                else:\n                    logger.debug(f"Received public message: {data}")\n\n            except websockets.exceptions.ConnectionClosedOK:\n                logger.info("Public WebSocket connection closed gracefully.")\n                break\n            except websockets.exceptions.ConnectionClosedError as e:\n                logger.error(f"Public WebSocket connection closed with error: {e}")\n                break\n            except Exception as e:\n                logger.error(f"Error in public WebSocket listener: {e}")\n                # Prevent tight loop on errors\n                await asyncio.sleep(1)\n\n    async def listen_private(self):\n        """Listens for messages from the private WebSocket."""\n        while True:\n            try:\n                if not self.private_websocket or not self.private_websocket.open:\n                    logger.warning("Private WebSocket not open, attempting to reconnect.")\n                    if not await self._connect_private():\n                        await asyncio.sleep(config.RECONNECT_TIMEOUT_SECONDS)\n                        continue\n\n                message = await self.private_websocket.recv()\n                data = json.loads(message)\n\n                if 'data' in data and 'topic' in data:\n                    if data['topic'] == 'position':\n                        logger.info(f"Position update: {data['data']}")\n                        # Trigger strategy to re-evaluate position\n                        await self.strategy.check_and_execute_trade()\n                    elif data['topic'] == 'order':\n                        logger.info(f"Order update: {data['data']}")\n                        # Trigger strategy to re-evaluate position\n                        await self.strategy.check_and_execute_trade()\n                elif 'op' in data and data['op'] == 'pong':\n                    logger.debug("Received private pong.")\n                else:\n                    logger.debug(f"Received private message: {data}")\n\n            except websockets.exceptions.ConnectionClosedOK:\n                logger.info("Private WebSocket connection closed gracefully.")\n                break\n            except websockets.exceptions.ConnectionClosedError as e:\n                logger.error(f"Private WebSocket connection closed with error: {e}")\n                break\n            except Exception as e:\n                logger.error(f"Error in private WebSocket listener: {e}")\n                # Prevent tight loop on errors\n                await asyncio.sleep(1)\n\n    async def handle_websocket_kline_data(self, kline_data_list: list):\n        """Handles incoming kline data from the WebSocket, updates strategy."""\n        if not isinstance(kline_data_list, list):\n            logger.error(f"Expected kline_data_list to be a list, got "\\n                         f"{type(kline_data_list)}")\n            return\n\n        for kline_data in kline_data_list:\n            if not isinstance(kline_data, dict):\n                logger.error(f"Expected kline_data to be a dict, got "\\n                             f"{type(kline_data)}")\n                continue\n\n            # Ensure the kline is closed before processing for strategy\n            if kline_data.get('confirm') is True:\n                logger.info(f"Processing confirmed kline: {kline_data}")\n                # Convert to the format expected by _process_kline_data\n                processed_kline = [\n                    kline_data['start'], kline_data['open'], kline_data['high'],\n                    kline_data['low'], kline_data['close'], kline_data['volume'],\n                    kline_data['turnover']\n                ]\n                await self.strategy.update_data(processed_kline)\n                await self.strategy.check_and_execute_trade()\n            else:\n                logger.debug(f"Received unconfirmed kline, ignoring for strategy: "\\n                             f"{kline_data}")\n\n    async def run(self):\n        """Main loop for running the WebSocket client and managing connections."""\n        while True:\n            if not self.is_connected and not await self.connect():\n                continue  # Try reconnecting again after delay\n\n            public_listener_task = asyncio.create_task(self.listen_public())\n            private_listener_task = asyncio.create_task(self.listen_private())\n\n            try:\n                await asyncio.gather(public_listener_task, private_listener_task)\n            except Exception as e:\n                logger.error(f"Main WebSocket run loop error: {e}")\n            finally:\n                public_listener_task.cancel()\n                private_listener_task.cancel()\n                if self.public_websocket:\n                    await self.public_websocket.close()\n                if self.private_websocket:\n                    await self.private_websocket.close()\n                logger.warning("WebSockets disconnected. Attempting to reconnect...")\n                await self.reconnect()\n\nasync def main():\n    """Main function to initialize and run the trading bot."""\n    logger.info("Starting Bybit Ultra Scalper Bot...")\n\n    # Initialize Bybit REST client\n    bybit_client = BybitClient(\n        api_key=config.API_KEY,\n        api_secret=config.API_SECRET,\n        base_url=config.BYBIT_REST_BASE_URL\n    )\n\n    # Set leverage\n    if not bybit_client.set_leverage(config.SYMBOL, config.LEVERAGE):\n        logger.error("Failed to set leverage. Exiting.")\n        return\n\n    # Initialize strategy\n    strategy = EhlersSupertrendStrategy(\n        client=bybit_client,\n        symbol=config.SYMBOL,\n        interval=config.INTERVAL,\n        trade_qty=config.TRADE_QTY,\n        leverage=config.LEVERAGE,\n        rsi_period=config.RSI_PERIOD,\n        rsi_overbought=config.RSI_OVERBOUGHT,\n        rsi_oversold=config.RSI_OVERSOLD,\n        stoch_rsi_period=config.STOCH_RSI_PERIOD,\n        stoch_rsi_smooth_k=config.STOCH_RSI_SMOOTH_K,\n        stoch_rsi_smooth_d=config.STOCH_RSI_SMOOTH_D,\n        stoch_rsi_overbought=config.STOCH_RSI_OVERBOUGHT,\n        stoch_rsi_oversold=config.STOCH_RSI_OVERSOLD,\n        super_trend_period=config.SUPER_TREND_PERIOD,\n        super_trend_multiplier=config.SUPER_TREND_MULTIPLIER,\n        eh_fisher_period=config.EH_FISHER_PERIOD,\n        eh_fisher_smoothing=config.EH_FISHER_SMOOTHING,\n        eh_fisher_overbought=config.EH_FISHER_OVERBOUGHT,\n        eh_fisher_oversold=config.EH_FISHER_OVERSOLD,\n        eh_fisher_trigger_buy=config.EH_FISHER_TRIGGER_BUY,\n        eh_fisher_trigger_sell=config.EH_FISHER_TRIGGER_SELL,\n        max_position_size=config.MAX_POSITION_SIZE,\n        stop_loss_percent=config.STOP_LOSS_PERCENT,\n        take_profit_percent=config.TAKE_PROFIT_PERCENT\n    )\n\n    # Fetch initial historical data\n    try:\n        await strategy.initialize_data()\n    except Exception as e:\n        logger.critical(f"Strategy initialization failed: {e}. Exiting.")\n        return\n\n    # Initialize and run WebSocket client\n    ws_client = WebSocketClient(\n        public_ws_url=config.BYBIT_WS_PUBLIC_BASE_URL,\n        private_ws_url=config.BYBIT_WS_PRIVATE_BASE_URL,\n        api_key=config.API_KEY,\n        api_secret=config.API_SECRET,\n        strategy=strategy\n    )\n    await ws_client.run()\n\n\nif __name__ == "__main__":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        logger.info("Bot stopped by user (KeyboardInterrupt).")\n    except Exception as e:\n        logger.error(f"An unhandled error occurred in main: {e}", exc_info=True)\n