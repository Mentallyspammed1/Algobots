<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bybit V5 Advanced Trading Terminal - AI Enhanced</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

  <script type="importmap">
  {
    "imports": {
      "@google/generative-ai": "https://esm.sh/@google/generative-ai"
    }
  }
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600;700&display=swap');
    
    :root {
      --bg-primary: #0a0a1e;
      --bg-secondary: #12122e;
      --bg-tertiary: #1a1a3a;
      --text-primary: #e8e8ff;
      --text-secondary: #a8a8c8;
      --neon-green: #00ff41;
      --neon-orange: #ff9f1c;
      --neon-red: #ff1744;
      --neon-cyan: #00e5ff;
      --neon-purple: #d500f9;
      --neon-yellow: #ffea00;
      --chart-bg: #0f0f2a;
      --shadow-neon: 0 0 20px rgba(0, 229, 255, 0.5);
      --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(0, 229, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(213, 0, 249, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 1;
    }
    
    .container {
      position: relative;
      z-index: 2;
    }
    
    .card {
      background: var(--bg-tertiary);
      border: 1px solid rgba(0, 229, 255, 0.2);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-neon);
      backdrop-filter: blur(10px);
      transition: var(--transition-smooth);
    }
    
    .card:hover {
      box-shadow: 0 0 30px rgba(0, 229, 255, 0.6);
      transform: translateY(-2px);
    }
    
    .card-header {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(0, 229, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .btn {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      color: var(--bg-primary);
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition-smooth);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 229, 255, 0.4);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-secondary {
      background: transparent;
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, var(--neon-red), var(--neon-orange));
    }
    
    .btn-success {
      background: linear-gradient(135deg, var(--neon-green), var(--neon-cyan));
    }
    
    input, textarea, select {
      background: var(--bg-primary);
      border: 2px solid rgba(0, 229, 255, 0.3);
      color: var(--text-primary);
      padding: 10px 14px;
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      transition: var(--transition-smooth);
      width: 100%;
    }
    
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--neon-cyan);
      box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
    }
    
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }
    
    .status-connected {
      background: var(--neon-green);
      box-shadow: 0 0 10px var(--neon-green);
    }
    
    .status-disconnected {
      background: var(--neon-red);
      box-shadow: 0 0 10px var(--neon-red);
    }
    
    .status-connecting {
      background: var(--neon-orange);
      box-shadow: 0 0 10px var(--neon-orange);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .metric-card {
      background: linear-gradient(135deg, rgba(0, 229, 255, 0.1), rgba(213, 0, 249, 0.1));
      border: 1px solid rgba(0, 229, 255, 0.3);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }
    
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      margin-top: 8px;
    }
    
    .metric-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .chart-container {
      position: relative;
      height: 400px;
      background: var(--chart-bg);
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }
    
    .tab-nav {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      border-bottom: 2px solid rgba(0, 229, 255, 0.2);
      padding-bottom: 8px;
    }
    
    .tab-btn {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      padding: 8px 16px;
      cursor: pointer;
      transition: var(--transition-smooth);
      font-weight: 500;
      position: relative;
    }
    
    .tab-btn.active {
      color: var(--neon-cyan);
    }
    
    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--neon-cyan);
      box-shadow: 0 0 10px var(--neon-cyan);
    }
    
    .log-container {
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
    }
    
    .log-entry {
      margin-bottom: 8px;
      padding: 4px 8px;
      border-left: 3px solid;
      background: rgba(255, 255, 255, 0.02);
    }
    
    .log-info { border-color: var(--neon-cyan); }
    .log-success { border-color: var(--neon-green); }
    .log-warning { border-color: var(--neon-orange); }
    .log-error { border-color: var(--neon-red); }
    
    .grid-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 30, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: var(--transition-smooth);
    }
    
    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(0, 229, 255, 0.2);
      border-top: 4px solid var(--neon-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 200px;
      background: var(--bg-primary);
      color: var(--text-primary);
      text-align: center;
      border-radius: 8px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid var(--neon-cyan);
      font-size: 0.75rem;
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
    }

    .data-table th, .data-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0, 229, 255, 0.1);
      text-align: left;
    }

    .data-table th {
      background-color: rgba(0, 229, 255, 0.1);
      font-weight: 600;
      color: var(--neon-cyan);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .data-table tbody tr:hover {
      background-color: rgba(0, 229, 255, 0.05);
    }
    
    @media (max-width: 768px) {
      .grid-metrics {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .card {
        padding: 16px;
      }
      
      .tab-nav {
        flex-wrap: wrap;
      }
    }
    
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, var(--neon-purple), var(--neon-cyan));
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <div class="container mx-auto p-6 max-w-7xl">
    <div class="text-center mb-8">
      <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-cyan-400 to-purple-500 bg-clip-text text-transparent mb-2">
        Advanced AI Trading Terminal
      </h1>
      <p class="text-text-secondary">Powered by Bybit V5 API & Google Gemini AI</p>
    </div>

    <div class="grid-metrics">
      <div class="metric-card">
        <div class="metric-label">Total P&L</div>
        <div class="metric-value" id="totalPnL">$0.00</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Win Rate</div>
        <div class="metric-value" id="winRate">0%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Sharpe Ratio</div>
        <div class="metric-value" id="sharpeRatio">0.00</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Max Drawdown</div>
        <div class="metric-value" id="maxDrawdown">0%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Active Trades</div>
        <div class="metric-value" id="activeTrades">0</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">24h Volume</div>
        <div class="metric-value" id="volume24h">$0</div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <span>⚙️ Configuration & API Settings</span>
        <button class="btn btn-secondary" id="toggleAdvancedBtn">Advanced Settings</button>
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label for="geminiApiKey">
            Google Gemini API Key
            <span class="tooltip">ⓘ
              <span class="tooltip-text">Your Google AI Studio API key for Gemini analysis. Stored encrypted in your browser.</span>
            </span>
          </label>
          <input type="password" id="geminiApiKey" placeholder="Enter Gemini API Key" />
        </div>
        <div>
          <label for="bybitApiKey">
            Bybit API Key
            <span class="tooltip">ⓘ
              <span class="tooltip-text">Your Bybit API key with trading permissions. Stored encrypted in your browser.</span>
            </span>
          </label>
          <input type="password" id="bybitApiKey" placeholder="Enter Bybit API Key" />
        </div>
        <div>
          <label for="bybitApiSecret">
            Bybit API Secret
            <span class="tooltip">ⓘ
              <span class="tooltip-text">Your Bybit API secret for authentication. Stored encrypted in your browser.</span>
            </span>
          </label>
          <input type="password" id="bybitApiSecret" placeholder="Enter Bybit API Secret" />
        </div>
      </div>

      <div id="advancedSettings" class="hidden">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
          <div>
            <label for="maxPosition">Max Position Size (Contracts)</label>
            <input type="number" id="maxPosition" value="0.01" step="0.001" min="0.001" />
          </div>
          <div>
            <label for="riskPerTrade">Risk Per Trade (%)</label>
            <input type="number" id="riskPerTrade" value="1" step="0.1" min="0.1" max="5" />
          </div>
          <div>
            <label for="leverage">Leverage</label>
            <select id="leverage">
              <option value="1">1x</option>
              <option value="2">2x</option>
              <option value="5">5x</option>
              <option value="10" selected>10x</option>
              <option value="20">20x</option>
              <option value="50">50x</option>
            </select>
          </div>
          <div>
            <label for="orderType">Default Order Type</label>
            <select id="orderType">
              <option value="Market" selected>Market</option>
              <option value="Limit">Limit</option>
              <option value="StopLimit">Stop Limit</option>
            </select>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div>
            <label for="tpPercent">Take Profit (%)</label>
            <input type="number" id="tpPercent" value="2" step="0.1" min="0.1" />
          </div>
          <div>
            <label for="slPercent">Stop Loss (%)</label>
            <input type="number" id="slPercent" value="1" step="0.1" min="0.1" />
          </div>
          <div>
            <label for="trailingStop">Trailing Stop (%)</label>
            <input type="number" id="trailingStop" value="0.5" step="0.1" min="0" />
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div class="flex items-center gap-4">
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableTpSl" checked class="w-5 h-5" />
              <span>Auto TP/SL</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableTrailing" class="w-5 h-5" />
              <span>Trailing Stop</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableKelly" class="w-5 h-5" />
              <span>Kelly Criterion</span>
            </label>
          </div>
          <div>
            <label for="tradingMode">Trading Mode</label>
            <select id="tradingMode">
              <option value="testnet" selected>Testnet</option>
              <option value="mainnet">Mainnet</option>
            </select>
          </div>
        </div>
      </div>

      <div class="flex gap-4 mt-4">
        <button class="btn btn-success" id="saveConfigBtn">Save Configuration</button>
        <button class="btn btn-secondary" id="loadConfigBtn">Load Saved Config</button>
        <button class="btn btn-danger" id="clearConfigBtn">Clear All</button>
        <span id="configStatus" class="flex items-center text-sm"></span>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <span>📊 Market Data & Analysis</span>
        <div class="flex gap-2">
          <span class="status-indicator" id="wsStatus"></span>
          <span id="wsStatusText">Disconnected</span>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label for="symbolSelect">Trading Symbol</label>
          <select id="symbolSelect">
            <option value="">Loading symbols...</option>
          </select>
        </div>
        <div>
          <label for="timeframe">Analysis Timeframe</label>
          <select id="timeframe">
            <option value="1m">1 Minute</option>
            <option value="5m" selected>5 Minutes</option>
            <option value="15m">15 Minutes</option>
            <option value="30m">30 Minutes</option>
            <option value="1h">1 Hour</option>
            <option value="4h">4 Hours</option>
            <option value="1d">1 Day</option>
          </select>
        </div>
        <div class="flex items-end gap-2">
          <button class="btn flex-1" id="connectBtn">Connect</button>
          <button class="btn btn-secondary flex-1" id="disconnectBtn">Disconnect</button>
        </div>
      </div>

      <div class="tab-nav">
        <button class="tab-btn active" data-tab="orderbook">Order Book</button>
        <button class="tab-btn" data-tab="chart">Price Chart</button>
        <button class="tab-btn" data-tab="indicators">Technical Indicators</button>
      </div>

      <div id="tab-orderbook" class="tab-content">
        <div class="chart-container">
          <canvas id="orderBookChart"></canvas>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
          <div class="log-container" id="bidBookDisplay">
            <div class="text-green-400 font-semibold mb-2">Bid Book</div>
          </div>
          <div class="log-container" id="askBookDisplay">
            <div class="text-red-400 font-semibold mb-2">Ask Book</div>
          </div>
        </div>
      </div>

      <div id="tab-chart" class="tab-content hidden">
        <div class="chart-container">
          <canvas id="priceChart"></canvas>
        </div>
      </div>

      <div id="tab-indicators" class="tab-content hidden">
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div class="metric-card">
            <div class="metric-label">RSI</div>
            <div class="metric-value" id="rsiValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">MACD</div>
            <div class="metric-value" id="macdValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">BB Width</div>
            <div class="metric-value" id="bbValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Volume</div>
            <div class="metric-value" id="volumeValue">--</div>
          </div>
        </div>
        <div class="chart-container mt-4">
          <canvas id="indicatorChart"></canvas>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <span>🤖 AI Analysis & Trading Signals</span>
        <button class="btn btn-secondary" id="customPromptBtn">Custom Prompt</button>
      </div>

      <div id="customPromptSection" class="hidden mb-4">
        <label for="customPrompt">Custom Analysis Prompt</label>
        <textarea id="customPrompt" rows="3" placeholder="Enter custom instructions for Gemini AI..."></textarea>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div>
          <label for="analysisMode">Analysis Mode</label>
          <select id="analysisMode">
            <option value="conservative">Conservative</option>
            <option value="balanced" selected>Balanced</option>
            <option value="aggressive">Aggressive</option>
            <option value="scalping">Scalping</option>
            <option value="swing">Swing Trading</option>
          </select>
        </div>
        <div class="flex items-end">
          <button class="btn w-full" id="analyzeBtn">🔍 Analyze Market</button>
        </div>
      </div>

      <div class="log-container" id="aiOutput">
        <div class="text-text-secondary">No analysis performed yet...</div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
        <button class="btn btn-success" id="executeBuyBtn">Execute Buy Signal</button>
        <button class="btn btn-danger" id="executeSellBtn">Execute Sell Signal</button>
        <button class="btn btn-secondary" id="executeHoldBtn">Hold Position</button>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <span>💼 Positions & Orders</span>
        <button class="btn btn-secondary" id="refreshPositionsBtn">Refresh</button>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        <div class="metric-card">
          <div class="metric-label">Position Size</div>
          <div class="metric-value" id="positionSize">0.000</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Entry Price</div>
          <div class="metric-value" id="entryPrice">--</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Unrealized P&L</div>
          <div class="metric-value" id="unrealizedPnL">$0.00</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Margin Used</div>
          <div class="metric-value" id="marginUsed">$0.00</div>
        </div>
      </div>

      <div class="tab-nav">
        <button class="tab-btn active" data-tab="positions">Active Positions</button>
        <button class="tab-btn" data-tab="openOrders">Open Orders</button>
        <button class="tab-btn" data-tab="history">Trade History</button>
      </div>

      <div id="tab-positions" class="tab-content">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Side</th>
                <th>Size</th>
                <th>Entry Price</th>
                <th>Liq. Price</th>
                <th>P&L</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="positionsDisplay">
              <tr><td colspan="7" class="text-text-secondary">No active positions</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="tab-openOrders" class="tab-content hidden">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Order ID</th>
                <th>Symbol</th>
                <th>Side</th>
                <th>Type</th>
                <th>Price</th>
                <th>Qty</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="ordersDisplay">
              <tr><td colspan="8" class="text-text-secondary">No open orders</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="tab-history" class="tab-content hidden">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Symbol</th>
                <th>Side</th>
                <th>Qty</th>
                <th>Price</th>
                <th>Fee</th>
                <th>P&L</th>
              </tr>
            </thead>
            <tbody id="historyDisplay">
              <tr><td colspan="7" class="text-text-secondary">No trade history</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <span>⚠️ Risk Management</span>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div class="metric-card">
          <div class="metric-label">Portfolio Risk</div>
          <div class="metric-value" id="portfolioRisk">Low</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">VaR (95%)</div>
          <div class="metric-value" id="varValue">$0.00</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Kelly %</div>
          <div class="metric-value" id="kellyPercent">0%</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Risk Score</div>
          <div class="metric-value" id="riskScore">0/100</div>
        </div>
      </div>

      <div class="chart-container mt-4">
        <canvas id="riskChart"></canvas>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <span>📜 Activity Log</span>
        <button class="btn btn-secondary" id="clearLogsBtn">Clear Logs</button>
      </div>
      
      <div class="log-container" id="activityLog" style="height: 200px;">
        <div class="text-text-secondary">System initialized...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { GoogleGenerativeAI } from "@google/generative-ai";

    const CONFIG = {
      BYBIT_WS_URL: {
        testnet: 'wss://stream-testnet.bybit.com/v5/public/linear',
        mainnet: 'wss://stream.bybit.com/v5/public/linear'
      },
      BYBIT_API_URL: {
        testnet: 'https://api-testnet.bybit.com',
        mainnet: 'https://api.bybit.com'
      },
      GEMINI_MODEL: 'gemini-1.5-flash',
      WS_PING_INTERVAL: 20000,
      WS_RECONNECT_DELAY: 5000,
      MAX_KLINES_DISPLAY: 200,
      ENCRYPTION_KEY: 'a-very-secret-key-that-should-be-more-complex'
    };

    class Utils {
      static encrypt(text, key) {
        return CryptoJS.AES.encrypt(text, key).toString();
      }

      static decrypt(encryptedText, key) {
        try {
          const bytes = CryptoJS.AES.decrypt(encryptedText, key);
          const originalText = bytes.toString(CryptoJS.enc.Utf8);
          return originalText;
        } catch (e) {
          return '';
        }
      }

      static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      static formatCurrency(amount, symbol = '$') {
        return `${symbol}${new Intl.NumberFormat('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(amount)}`;
      }

      static formatPercentage(value) {
        return `${(value * 100).toFixed(2)}%`;
      }

      static calculateRSI(closes, period = 14) {
        if (closes.length < period + 1) return null;
        let gains = [];
        let losses = [];
        for (let i = 1; i < closes.length; i++) {
          const diff = closes[i] - closes[i - 1];
          gains.push(Math.max(0, diff));
          losses.push(Math.max(0, -diff));
        }

        let avgGain = ss.mean(gains.slice(0, period));
        let avgLoss = ss.mean(losses.slice(0, period));

        for (let i = period; i < gains.length; i++) {
          avgGain = (avgGain * (period - 1) + gains[i]) / period;
          avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        }

        if (avgLoss === 0) return 100;
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
      }

      static calculateMACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        if (closes.length < slowPeriod) return { macd: null, signal: null, histogram: null };

        const ema = (data, period) => {
          if (data.length < period) return [];
          const k = 2 / (period + 1);
          let emas = [ss.mean(data.slice(0, period))];
          for (let i = period; i < data.length; i++) {
            emas.push((data[i] - emas[emas.length - 1]) * k + emas[emas.length - 1]);
          }
          return emas;
        };

        const fastEma = ema(closes, fastPeriod);
        const slowEma = ema(closes, slowPeriod);

        const macdLine = fastEma.slice(slowEma.length - fastEma.length).map((f, i) => f - slowEma[i]);
        if (macdLine.length < signalPeriod) return { macd: null, signal: null, histogram: null };

        const signalLine = ema(macdLine, signalPeriod);
        const histogram = signalLine.slice(macdLine.length - signalLine.length).map((s, i) => macdLine[i] - s);

        return {
          macd: macdLine[macdLine.length - 1],
          signal: signalLine[signalLine.length - 1],
          histogram: histogram[histogram.length - 1]
        };
      }

      static calculateBollingerBands(closes, period = 20, stdDev = 2) {
        if (closes.length < period) return { upper: null, middle: null, lower: null, width: null };
        
        const lastPeriodCloses = closes.slice(-period);
        const middle = ss.mean(lastPeriodCloses);
        const std = ss.standardDeviation(lastPeriodCloses);
        const upper = middle + std * stdDev;
        const lower = middle - std * stdDev;
        const width = (upper - lower) / middle * 100;

        return { upper, middle, lower, width };
      }
    }

    class EventEmitter {
      constructor() { this.events = {}; }
      on(event, listener) {
        if (!this.events[event]) this.events[event] = [];
        this.events[event].push(listener);
      }
      emit(event, ...args) {
        if (this.events[event]) this.events[event].forEach(listener => listener(...args));
      }
    }

    class BybitClient extends EventEmitter {
      constructor(config, logger) {
        super();
        this.config = config;
        this.logger = logger;
        this.apiKey = '';
        this.apiSecret = '';
        this.axiosInstance = axios.create();
        this.setupRateLimiting();
      }

      setCredentials(apiKey, apiSecret) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
      }

      setupRateLimiting() {
        this.axiosInstance.interceptors.response.use(response => {
          return response;
        }, error => {
          if (error.response && error.response.status === 429) {
            this.emit('rateLimitExceeded');
            this.logger('Bybit API rate limit exceeded.', 'warning');
          }
          return Promise.reject(error);
        });
      }

      async request(method, endpoint, params = {}, isPrivate = false) {
        const mode = document.getElementById('tradingMode').value;
        const baseURL = this.config.BYBIT_API_URL[mode];
        
        const headers = { 'Content-Type': 'application/json' };
        const timestamp = Date.now().toString();
        const recvWindow = '10000';

        if (isPrivate) {
          if (!this.apiKey || !this.apiSecret) {
            const errorMsg = "API credentials not set for private request.";
            this.logger(errorMsg, 'error');
            throw new Error(errorMsg);
          }
          
          headers['X-BAPI-API-KEY'] = this.apiKey;
          headers['X-BAPI-TIMESTAMP'] = timestamp;
          headers['X-BAPI-RECV-WINDOW'] = recvWindow;

          let signaturePayload;
          if (method === 'GET') {
            const query = new URLSearchParams(params).toString();
            signaturePayload = timestamp + this.apiKey + recvWindow + query;
          } else if (method === 'POST') {
            const body = JSON.stringify(params);
            signaturePayload = timestamp + this.apiKey + recvWindow + body;
          }
          
          headers['X-BAPI-SIGN'] = CryptoJS.HmacSHA256(signaturePayload, this.apiSecret).toString();
        }

        try {
          const response = await this.axiosInstance({
            method,
            url: `${baseURL}${endpoint}`,
            headers,
            params: method === 'GET' ? params : {},
            data: method === 'POST' ? params : {}
          });
          if (response.data.retCode !== 0) {
            throw new Error(`Bybit API Error: ${response.data.retMsg} (Code: ${response.data.retCode})`);
          }
          return response.data.result;
        } catch (error) {
          const errorMessage = error.response?.data?.retMsg || error.message;
          this.emit('error', errorMessage);
          this.logger(`Bybit API Request Failed: ${errorMessage}`, 'error');
          throw error;
        }
      }

      async getValidSymbols() {
        const result = await this.request('GET', '/v5/market/instruments-info', { category: 'linear' });
        return result.list
          .filter(s => s.status === 'Trading' && s.quoteCoin === 'USDT')
          .map(s => s.symbol)
          .sort();
      }
      
      async getKlines(symbol, interval, limit = CONFIG.MAX_KLINES_DISPLAY) {
        return this.request('GET', '/v5/market/kline', { category: 'linear', symbol, interval, limit });
      }

      async placeOrder(orderParams) {
        return this.request('POST', '/v5/order/create', { category: 'linear', ...orderParams }, true);
      }
      
      async getPositions(symbol = undefined) {
        const params = { category: 'linear' };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/position/list', params, true);
        return result.list;
      }

      async getOpenOrders(symbol = undefined) {
        const params = { category: 'linear' };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/order/realtime', params, true);
        return result.list;
      }

      async getTradeHistory(symbol = undefined, limit = 50) {
        const params = { category: 'linear', limit };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/trade/history', params, true);
        return result.list;
      }

      async getWalletBalance(coin = 'USDT') {
        const result = await this.request('GET', '/v5/account/wallet-balance', { accountType: 'UNIFIED', coin }, true);
        return result.list[0]?.coin[0] || null;
      }

      async cancelOrder(symbol, orderId) {
        return this.request('POST', '/v5/order/cancel', { category: 'linear', symbol, orderId }, true);
      }

      async setLeverage(symbol, buyLeverage, sellLeverage) {
        return this.request('POST', '/v5/position/set-leverage', { category: 'linear', symbol, buyLeverage, sellLeverage }, true);
      }
    }

    class BybitWebSocket extends EventEmitter {
      constructor(config, logger) {
        super();
        this.config = config;
        this.logger = logger;
        this.ws = null;
        this.isConnected = false;
        this.pingInterval = null;
        this.reconnectTimeout = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.currentTopics = new Set();
      }

      connect(mode) {
        if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
          this.logger('WebSocket is already connected or connecting.', 'warning');
          return;
        }

        this.logger('Connecting to WebSocket...', 'info');
        this.emit('status', 'connecting');
        
        this.ws = new WebSocket(this.config.BYBIT_WS_URL[mode]);

        this.ws.onopen = () => {
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.logger('WebSocket Connected.', 'success');
          this.emit('status', 'connected');
          this.startPing();
          this.resubscribeToTopics();
        };

        this.ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.op === 'pong') return;
          this.emit('message', data);
        };

        this.ws.onclose = () => {
          this.isConnected = false;
          this.stopPing();
          this.logger('WebSocket Disconnected.', 'warning');
          this.emit('status', 'disconnected');
          this.attemptReconnect(mode);
        };

        this.ws.onerror = (err) => {
          this.logger(`WebSocket Error: ${err.message}`, 'error');
          this.ws.close();
        };
      }
      
      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.stopPing();
          clearTimeout(this.reconnectTimeout);
          this.logger('Manually disconnected WebSocket.', 'info');
        }
      }

      subscribe(topics) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          const newTopics = topics.filter(topic => !this.currentTopics.has(topic));
          if (newTopics.length > 0) {
            this.ws.send(JSON.stringify({ op: 'subscribe', args: newTopics }));
            newTopics.forEach(topic => this.currentTopics.add(topic));
            this.logger(`Subscribed to: ${newTopics.join(', ')}`, 'info');
          }
        } else {
          topics.forEach(topic => this.currentTopics.add(topic)); // Add to currentTopics even if not connected, for resubscription
        }
      }
      
      unsubscribe(topics) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          const topicsToUnsubscribe = topics.filter(topic => this.currentTopics.has(topic));
          if (topicsToUnsubscribe.length > 0) {
            this.ws.send(JSON.stringify({ op: 'unsubscribe', args: topicsToUnsubscribe }));
            topicsToUnsubscribe.forEach(topic => this.currentTopics.delete(topic));
            this.logger(`Unsubscribed from: ${topicsToUnsubscribe.join(', ')}`, 'info');
          }
        } else {
          topics.forEach(topic => this.currentTopics.delete(topic));
        }
      }

      resubscribeToTopics() {
        if (this.currentTopics.size > 0) {
          this.subscribe([...this.currentTopics]);
        }
      }

      startPing() {
        this.stopPing();
        this.pingInterval = setInterval(() => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ op: 'ping' }));
          }
        }, this.config.WS_PING_INTERVAL);
      }

      stopPing() {
        if (this.pingInterval) {
          clearInterval(this.pingInterval);
          this.pingInterval = null;
        }
      }

      attemptReconnect(mode) {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
          this.reconnectAttempts++;
          const delay = this.config.WS_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts - 1);
          this.logger(`Attempting to reconnect in ${delay / 1000}s (Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`, 'warning');
          this.reconnectTimeout = setTimeout(() => this.connect(mode), delay);
        } else {
          this.logger('Max reconnection attempts reached. Please connect manually.', 'error');
          this.emit('status', 'disconnected');
        }
      }
    }

    class ChartManager {
      constructor(dom, logger) {
        this.dom = dom;
        this.logger = logger;
        this.charts = {};
        Chart.register(ChartjsAdapterDateFns);
        Chart.register(ChartAnnotation);
        Chart.register(window.Chart.FinancialController, window.Chart.FinancialElement, window.Chart.Financial);
      }

      initCharts() {
        this.charts.orderBook = new Chart(this.dom.orderBookChart, this._getOrderBookChartConfig());
        this.charts.price = new Chart(this.dom.priceChart, this._getPriceChartConfig());
        this.charts.indicator = new Chart(this.dom.indicatorChart, this._getIndicatorChartConfig());
        this.charts.risk = new Chart(this.dom.riskChart, this._getRiskChartConfig());
      }

      _getOrderBookChartConfig() {
        return {
          type: 'bar',
          data: { labels: [], datasets: [
            { label: 'Bids', data: [], backgroundColor: 'rgba(0, 255, 65, 0.5)' },
            { label: 'Asks', data: [], backgroundColor: 'rgba(255, 23, 68, 0.5)' }
          ]},
          options: {
            responsive: true, maintainAspectRatio: false,
            scales: { 
              x: { stacked: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'var(--text-secondary)' } }, 
              y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'var(--text-secondary)' } } 
            },
            plugins: { 
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) label += ': ';
                    if (context.parsed.y !== null) label += `${context.parsed.y.toFixed(3)} @ ${Utils.formatCurrency(context.parsed.x)}`;
                    return label;
                  }
                }
              }
            }
          }
        };
      }
      
      _getPriceChartConfig() {
        return {
          type: 'candlestick',
          data: { datasets: [{
            label: 'Candlestick',
            data: [],
            borderColor: 'rgba(0, 229, 255, 1)',
            borderWidth: 1,
            candlestick: {
              up: { backgroundColor: 'var(--neon-green)', borderColor: 'var(--neon-green)' },
              down: { backgroundColor: 'var(--neon-red)', borderColor: 'var(--neon-red)' },
              hover: { backgroundColor: 'var(--neon-cyan)', borderColor: 'var(--neon-cyan)' }
            }
          }]},
          options: {
            responsive: true, maintainAspectRatio: false,
            scales: {
              x: { 
                type: 'time', 
                time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'HH:mm', day: 'MMM D' } },
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y: { 
                position: 'right', 
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const data = context.parsed._custom;
                    return [
                      `Open: ${data.o.toFixed(2)}`,
                      `High: ${data.h.toFixed(2)}`,
                      `Low: ${data.l.toFixed(2)}`,
                      `Close: ${data.c.toFixed(2)}`
                    ];
                  }
                }
              }
            }
          }
        };
      }

      _getIndicatorChartConfig() {
        return {
          type: 'line',
          data: {
            datasets: [
              { label: 'RSI', data: [], borderColor: 'var(--neon-cyan)', borderWidth: 1, pointRadius: 0, yAxisID: 'y' },
              { label: 'MACD', data: [], borderColor: 'var(--neon-green)', borderWidth: 1, pointRadius: 0, yAxisID: 'y1' },
              { label: 'Signal', data: [], borderColor: 'var(--neon-orange)', borderWidth: 1, pointRadius: 0, yAxisID: 'y1' },
              { label: 'Histogram', data: [], backgroundColor: 'rgba(255,255,255,0.2)', borderWidth: 0, yAxisID: 'y1', type: 'bar' }
            ]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            scales: {
              x: {
                type: 'time',
                time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'HH:mm' } },
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y: {
                position: 'left',
                title: { display: true, text: 'RSI', color: 'var(--neon-cyan)' },
                grid: { color: 'rgba(255,255,255,0.05)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y1: {
                position: 'right',
                title: { display: true, text: 'MACD', color: 'var(--neon-green)' },
                grid: { color: 'rgba(255,255,255,0.05)' },
                ticks: { color: 'var(--text-secondary)' }
              }
            },
            plugins: {
              legend: { labels: { color: 'var(--text-primary)' } }
            }
          }
        };
      }

      _getRiskChartConfig() {
        return {
          type: 'doughnut',
          data: {
            labels: ['Current Risk', 'Available Risk'],
            datasets: [{
              data: [0, 100],
              backgroundColor: ['var(--neon-red)', 'rgba(0, 229, 255, 0.2)'],
              borderColor: 'transparent',
              hoverOffset: 4
            }]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: { color: 'var(--text-primary)' }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.label || '';
                    if (label) label += ': ';
                    if (context.parsed !== null) label += Utils.formatPercentage(context.parsed / 100);
                    return label;
                  }
                }
              }
            }
          }
        };
      }

      updateOrderBook(bids, asks) {
        const bidPrices = bids.map(b => b.price);
        const askPrices = asks.map(a => a.price);
        const allPrices = [...bidPrices, ...askPrices].sort((a,b) => a - b);
        
        const bidSizes = bids.map(b => b.size);
        const askSizes = asks.map(a => a.size);

        this.charts.orderBook.data.labels = allPrices;
        this.charts.orderBook.data.datasets[0].data = allPrices.map(p => bids.find(b => b.price === p)?.size || 0);
        this.charts.orderBook.data.datasets[1].data = allPrices.map(p => asks.find(a => a.price === p)?.size || 0);
        this.charts.orderBook.update('none');

        this.dom.bidBookDisplay.innerHTML = '<div class="text-green-400 font-semibold mb-2">Bid Book</div>' + bids.slice(0, 10).map(b => `<div>${b.size.toFixed(3)} @ ${Utils.formatCurrency(b.price)}</div>`).join('');
        this.dom.askBookDisplay.innerHTML = '<div class="text-red-400 font-semibold mb-2">Ask Book</div>' + asks.slice(0, 10).map(a => `<div>${a.size.toFixed(3)} @ ${Utils.formatCurrency(a.price)}</div>`).join('');
      }
      
      updatePriceChart(klines) {
        this.charts.price.data.datasets[0].data = klines.map(k => ({
          x: k.time * 1000, o: k.open, h: k.high, l: k.low, c: k.close
        }));
        this.charts.price.update('none');
      }

      updateIndicatorChart(klines, indicators) {
        const times = klines.map(k => k.time * 1000);
        const rsiData = indicators.rsiHistory || [];
        const macdLineData = indicators.macdHistory?.map(m => m.macd) || [];
        const signalLineData = indicators.macdHistory?.map(m => m.signal) || [];
        const histogramData = indicators.macdHistory?.map(m => m.histogram) || [];

        this.charts.indicator.data.labels = times;
        this.charts.indicator.data.datasets[0].data = rsiData.map((val, i) => ({ x: times[i], y: val }));
        this.charts.indicator.data.datasets[1].data = macdLineData.map((val, i) => ({ x: times[i], y: val }));
        this.charts.indicator.data.datasets[2].data = signalLineData.map((val, i) => ({ x: times[i], y: val }));
        this.charts.indicator.data.datasets[3].data = histogramData.map((val, i) => ({ x: times[i], y: val }));
        this.charts.indicator.update('none');
      }

      updateRiskChart(currentRiskPercent) {
        this.charts.risk.data.datasets[0].data = [currentRiskPercent, 100 - currentRiskPercent];
        this.charts.risk.update('none');
      }
    }

    class UIManager {
      constructor(dom) {
        this.dom = dom;
        this.toastContainer = this._createToastContainer();
      }

      _createToastContainer() {
        const container = document.createElement('div');
        container.className = 'fixed bottom-4 right-4 z-[10000] flex flex-col gap-2';
        document.body.appendChild(container);
        return container;
      }

      log(message, type = 'info') {
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
        this.dom.activityLog.prepend(entry);
        if (this.dom.activityLog.children.length > 100) {
          this.dom.activityLog.lastChild.remove();
        }
      }

      showLoading() {
        this.dom.loadingOverlay.classList.add('active');
      }

      hideLoading() {
        this.dom.loadingOverlay.classList.remove('active');
      }

      updateWsStatus(status) {
        this.dom.wsStatus.className = `status-indicator status-${status}`;
        this.dom.wsStatusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
      }

      updateMetrics(metrics) {
        this.dom.totalPnL.textContent = Utils.formatCurrency(metrics.totalPnL || 0);
        this.dom.winRate.textContent = Utils.formatPercentage(metrics.winRate || 0);
        this.dom.sharpeRatio.textContent = (metrics.sharpeRatio || 0).toFixed(2);
        this.dom.maxDrawdown.textContent = Utils.formatPercentage(metrics.maxDrawdown || 0);
        this.dom.activeTrades.textContent = metrics.activeTrades || 0;
        this.dom.volume24h.textContent = Utils.formatCurrency(metrics.volume24h || 0);
      }

      updateIndicatorValues(indicators) {
        this.dom.rsiValue.textContent = indicators.rsi ? indicators.rsi.toFixed(2) : '--';
        this.dom.macdValue.textContent = indicators.macd?.macd ? indicators.macd.macd.toFixed(2) : '--';
        this.dom.bbValue.textContent = indicators.bb?.width ? indicators.bb.width.toFixed(2) : '--';
        this.dom.volumeValue.textContent = indicators.volume ? Utils.formatCurrency(indicators.volume, '') : '--';
      }

      updatePositionInfo(position) {
        if (position) {
          this.dom.positionSize.textContent = parseFloat(position.size).toFixed(3);
          this.dom.entryPrice.textContent = Utils.formatCurrency(parseFloat(position.avgPrice));
          this.dom.unrealizedPnL.textContent = Utils.formatCurrency(parseFloat(position.unrealizedPnl));
          this.dom.marginUsed.textContent = Utils.formatCurrency(parseFloat(position.liabFee)); // Approx margin used
        } else {
          this.dom.positionSize.textContent = '0.000';
          this.dom.entryPrice.textContent = '--';
          this.dom.unrealizedPnL.textContent = '$0.00';
          this.dom.marginUsed.textContent = '$0.00';
        }
      }

      renderPositions(positions) {
        const tbody = this.dom.positionsDisplay;
        tbody.innerHTML = '';
        if (positions && positions.length > 0) {
          positions.forEach(p => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${p.symbol}</td>
              <td class="${p.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${p.side}</td>
              <td>${parseFloat(p.size).toFixed(3)}</td>
              <td>${Utils.formatCurrency(parseFloat(p.avgPrice))}</td>
              <td>${Utils.formatCurrency(parseFloat(p.liqPrice))}</td>
              <td class="${parseFloat(p.unrealizedPnl) >= 0 ? 'text-green-400' : 'text-red-400'}">${Utils.formatCurrency(parseFloat(p.unrealizedPnl))}</td>
              <td><button class="btn btn-danger btn-sm" data-order-id="${p.positionId}">Close</button></td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          tbody.innerHTML = `<tr><td colspan="7" class="text-text-secondary text-center">No active positions</td></tr>`;
        }
      }

      renderOpenOrders(orders) {
        const tbody = this.dom.ordersDisplay;
        tbody.innerHTML = '';
        if (orders && orders.length > 0) {
          orders.forEach(o => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${o.orderId}</td>
              <td>${o.symbol}</td>
              <td class="${o.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${o.side}</td>
              <td>${o.orderType}</td>
              <td>${Utils.formatCurrency(parseFloat(o.price))}</td>
              <td>${parseFloat(o.qty).toFixed(3)}</td>
              <td>${o.orderStatus}</td>
              <td><button class="btn btn-danger btn-sm" data-order-id="${o.orderId}">Cancel</button></td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          tbody.innerHTML = `<tr><td colspan="8" class="text-text-secondary text-center">No open orders</td></tr>`;
        }
      }

      renderTradeHistory(history) {
        const tbody = this.dom.historyDisplay;
        tbody.innerHTML = '';
        if (history && history.length > 0) {
          history.forEach(t => {
            const tr = document.createElement('tr');
            const pnl = parseFloat(t.execPnl);
            tr.innerHTML = `
              <td>${new Date(parseInt(t.execTime)).toLocaleString()}</td>
              <td>${t.symbol}</td>
              <td class="${t.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${t.side}</td>
              <td>${parseFloat(t.execQty).toFixed(3)}</td>
              <td>${Utils.formatCurrency(parseFloat(t.execPrice))}</td>
              <td>${parseFloat(t.execFee).toFixed(4)}</td>
              <td class="${pnl >= 0 ? 'text-green-400' : 'text-red-400'}">${Utils.formatCurrency(pnl)}</td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          tbody.innerHTML = `<tr><td colspan="7" class="text-text-secondary text-center">No trade history</td></tr>`;
        }
      }

      showToast(message, type = 'info', duration = 3000) {
        const toast = document.createElement('div');
        toast.className = `p-3 rounded-lg shadow-lg text-white text-sm flex items-center gap-2
                           ${type === 'success' ? 'bg-green-600' : ''}
                           ${type === 'error' ? 'bg-red-600' : ''}
                           ${type === 'warning' ? 'bg-orange-500' : ''}
                           ${type === 'info' ? 'bg-blue-500' : ''}`;
        toast.innerHTML = `
          <span>${message}</span>
          <button class="ml-auto text-white opacity-75 hover:opacity-100" onclick="this.parentElement.remove()">
            &times;
          </button>
        `;
        this.toastContainer.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
      }
    }

    class AIManager {
      constructor(config, logger) {
        this.config = config;
        this.logger = logger;
        this.genAI = null;
      }

      init(apiKey) {
        if (apiKey) {
          this.genAI = new GoogleGenerativeAI(apiKey);
        } else {
          this.logger('Gemini API Key not set. AI features disabled.', 'warning');
          this.genAI = null;
        }
      }

      async analyze(prompt, klines, orderBook, position, tradingMode) {
        if (!this.genAI) {
          throw new Error('Gemini AI not initialized. Please provide an API key.');
        }

        const model = this.genAI.getGenerativeModel({ model: this.config.GEMINI_MODEL });
        const analysisPrompt = this._buildAIPrompt(prompt, klines, orderBook, position, tradingMode);

        try {
          const result = await model.generateContent(analysisPrompt);
          const response = await result.response;
          const text = response.text();
          return this._parseAIOutput(text);
        } catch (error) {
          this.logger(`Gemini AI Generation Error: ${error.message}`, 'error');
          throw error;
        }
      }
      
      _buildAIPrompt(customPrompt, klines, orderBook, position, tradingMode) {
        const latestKline = klines[klines.length - 1];
        const closes = klines.map(k => k.close);
        const rsi = Utils.calculateRSI(closes);
        const macd = Utils.calculateMACD(closes);
        const bb = Utils.calculateBollingerBands(closes);

        const marketData = {
          latestPrice: latestKline?.close,
          volume: latestKline?.volume,
          orderBook: {
            bids: orderBook.bids.slice(0, 5).map(b => ({ price: b.price.toFixed(2), size: b.size.toFixed(3) })),
            asks: orderBook.asks.slice(0, 5).map(a => ({ price: a.price.toFixed(2), size: a.size.toFixed(3) }))
          },
          technicalIndicators: {
            rsi: rsi ? rsi.toFixed(2) : 'N/A',
            macd: macd.macd ? macd.macd.toFixed(2) : 'N/A',
            signal: macd.signal ? macd.signal.toFixed(2) : 'N/A',
            histogram: macd.histogram ? macd.histogram.toFixed(2) : 'N/A',
            bollingerBands: {
              upper: bb.upper ? bb.upper.toFixed(2) : 'N/A',
              middle: bb.middle ? bb.middle.toFixed(2) : 'N/A',
              lower: bb.lower ? bb.lower.toFixed(2) : 'N/A',
              width: bb.width ? bb.width.toFixed(2) : 'N/A'
            }
          },
          currentPosition: position ? {
            symbol: position.symbol,
            side: position.side,
            size: parseFloat(position.size).toFixed(3),
            entryPrice: parseFloat(position.avgPrice).toFixed(2),
            unrealizedPnl: parseFloat(position.unrealizedPnl).toFixed(2)
          } : 'None'
        };

        return `
          You are a sophisticated crypto trading AI. Analyze the provided market data and generate a trading signal.
          The signal should be a JSON object with the following structure:
          {
            "action": "BUY" | "SELL" | "HOLD",
            "quantity": number, // Suggested trade size in contracts. 0 for HOLD.
            "confidence": "LOW" | "MEDIUM" | "HIGH",
            "reason": string, // Detailed explanation for the decision.
            "targetPrice": number | null, // Optional target price for TP
            "stopLossPrice": number | null // Optional stop loss price
          }

          **Current Market Context:**
          Symbol: ${document.getElementById('symbolSelect').value}
          Timeframe: ${document.getElementById('timeframe').value}
          Trading Strategy: ${tradingMode}
          Market Data: ${JSON.stringify(marketData, null, 2)}

          ${customPrompt ? `**Additional Instructions from User:**\n${customPrompt}\n` : ''}

          Provide only the JSON object. Do not include any other text or formatting.
        `;
      }

      _parseAIOutput(text) {
        try {
          const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/);
          if (jsonMatch && jsonMatch[1]) {
            return JSON.parse(jsonMatch[1]);
          }
          return JSON.parse(text); // Try parsing directly if no code block
        } catch (e) {
          this.logger(`Failed to parse AI response as JSON: ${e.message}. Raw text: ${text}`, 'error');
          throw new Error('AI response could not be parsed. Check raw output.');
        }
      }
    }

    class TradingApp {
      constructor() {
        this.config = CONFIG;
        this.dom = this._getDomElements();
        this.ui = new UIManager(this.dom);
        this.bybitClient = new BybitClient(this.config, this.ui.log.bind(this.ui));
        this.bybitWs = new BybitWebSocket(this.config, this.ui.log.bind(this.ui));
        this.chartManager = new ChartManager(this.dom, this.ui.log.bind(this.ui));
        this.aiManager = new AIManager(this.config, this.ui.log.bind(this.ui));
        
        this.state = this._getInitialState();
        
        this._bindEventListeners();
        this._initialize();
      }

      _getDomElements() {
        const ids = [
          'loadingOverlay', 'totalPnL', 'winRate', 'sharpeRatio', 'maxDrawdown', 'activeTrades', 'volume24h',
          'toggleAdvancedBtn', 'geminiApiKey', 'bybitApiKey', 'bybitApiSecret', 'advancedSettings', 'maxPosition',
          'riskPerTrade', 'leverage', 'orderType', 'tpPercent', 'slPercent', 'trailingStop', 'enableTpSl',
          'enableTrailing', 'enableKelly', 'tradingMode', 'saveConfigBtn', 'loadConfigBtn', 'clearConfigBtn',
          'configStatus', 'wsStatus', 'wsStatusText', 'symbolSelect', 'timeframe', 'connectBtn', 'disconnectBtn',
          'orderBookChart', 'bidBookDisplay', 'askBookDisplay', 'priceChart', 'rsiValue', 'macdValue', 'bbValue',
          'volumeValue', 'indicatorChart', 'customPromptBtn', 'customPromptSection', 'customPrompt', 'analysisMode',
          'analyzeBtn', 'aiOutput', 'executeBuyBtn', 'executeSellBtn', 'executeHoldBtn', 'refreshPositionsBtn',
          'positionSize', 'entryPrice', 'unrealizedPnL', 'marginUsed', 'positionsDisplay', 'ordersDisplay',
          'historyDisplay', 'portfolioRisk', 'varValue', 'kellyPercent', 'riskScore', 'riskChart', 'activityLog',
          'clearLogsBtn'
        ];
        const elements = {};
        ids.forEach(id => elements[id] = document.getElementById(id));
        return elements;
      }

      _getInitialState() {
        return {
          currentSymbol: 'BTCUSDT',
          currentTimeframe: '5m',
          orderBook: { bids: [], asks: [] },
          klines: [],
          indicators: {},
          accountBalance: null,
          positions: [],
          openOrders: [],
          tradeHistory: [],
          lastSignal: null,
        };
      }

      _bindEventListeners() {
        this.dom.saveConfigBtn.addEventListener('click', () => this.saveConfiguration());
        this.dom.loadConfigBtn.addEventListener('click', () => this.loadConfiguration());
        this.dom.clearConfigBtn.addEventListener('click', () => this.clearConfiguration());
        this.dom.toggleAdvancedBtn.addEventListener('click', () => this.dom.advancedSettings.classList.toggle('hidden'));
        this.dom.clearLogsBtn.addEventListener('click', () => this.dom.activityLog.innerHTML = '<div class="text-text-secondary">Logs cleared...</div>');

        this.dom.connectBtn.addEventListener('click', () => this.connect());
        this.dom.disconnectBtn.addEventListener('click', () => this.disconnect());
        this.dom.symbolSelect.addEventListener('change', (e) => this.handleSymbolChange(e.target.value));
        this.dom.timeframe.addEventListener('change', (e) => this.handleTimeframeChange(e.target.value));

        document.querySelectorAll('.tab-nav .tab-btn').forEach(btn => {
          btn.addEventListener('click', (e) => this.handleTabSwitch(e));
        });
        
        this.dom.analyzeBtn.addEventListener('click', () => this.runAnalysis());
        this.dom.customPromptBtn.addEventListener('click', () => this.dom.customPromptSection.classList.toggle('hidden'));
        this.dom.executeBuyBtn.addEventListener('click', () => this.executeSignal('BUY'));
        this.dom.executeSellBtn.addEventListener('click', () => this.executeSignal('SELL'));
        this.dom.executeHoldBtn.addEventListener('click', () => this.ui.showToast('AI recommends HOLD. No action taken.', 'info'));
        this.dom.refreshPositionsBtn.addEventListener('click', () => this.fetchAccountInfo());

        this.bybitWs.on('status', (status) => this.ui.updateWsStatus(status));
        this.bybitWs.on('message', (data) => this._handleWsMessage(data));

        this.bybitClient.on('error', (msg) => this.ui.showToast(msg, 'error'));
      }

      async _initialize() {
        this.ui.log('System Initializing...', 'info');
        this.ui.showLoading();
        this.chartManager.initCharts();
        this.loadConfiguration();
        await this.populateSymbols();
        this.ui.hideLoading();
        this.ui.log('Initialization Complete. Ready to connect.', 'success');
      }

      saveConfiguration() {
        try {
          const config = {
            geminiApiKey: this.dom.geminiApiKey.value,
            bybitApiKey: this.dom.bybitApiKey.value,
            bybitApiSecret: this.dom.bybitApiSecret.value,
            tradingMode: this.dom.tradingMode.value,
            maxPosition: this.dom.maxPosition.value,
            riskPerTrade: this.dom.riskPerTrade.value,
            leverage: this.dom.leverage.value,
            orderType: this.dom.orderType.value,
            tpPercent: this.dom.tpPercent.value,
            slPercent: this.dom.slPercent.value,
            trailingStop: this.dom.trailingStop.value,
            enableTpSl: this.dom.enableTpSl.checked,
            enableTrailing: this.dom.enableTrailing.checked,
            enableKelly: this.dom.enableKelly.checked,
            currentSymbol: this.state.currentSymbol,
            currentTimeframe: this.state.currentTimeframe
          };
          const encryptedConfig = Utils.encrypt(JSON.stringify(config), CONFIG.ENCRYPTION_KEY);
          localStorage.setItem('tradingBotConfig', encryptedConfig);
          this.ui.log('Configuration saved and encrypted.', 'success');
          this.ui.showToast('Configuration saved!', 'success');
        } catch (e) {
          this.ui.log('Failed to save configuration.', 'error');
          this.ui.showToast('Failed to save configuration.', 'error');
        }
      }

      loadConfiguration() {
        const encryptedConfig = localStorage.getItem('tradingBotConfig');
        if (encryptedConfig) {
          try {
            const config = JSON.parse(Utils.decrypt(encryptedConfig, CONFIG.ENCRYPTION_KEY));
            this.dom.geminiApiKey.value = config.geminiApiKey || '';
            this.dom.bybitApiKey.value = config.bybitApiKey || '';
            this.dom.bybitApiSecret.value = config.bybitApiSecret || '';
            this.dom.tradingMode.value = config.tradingMode || 'testnet';
            this.dom.maxPosition.value = config.maxPosition || '0.01';
            this.dom.riskPerTrade.value = config.riskPerTrade || '1';
            this.dom.leverage.value = config.leverage || '10';
            this.dom.orderType.value = config.orderType || 'Market';
            this.dom.tpPercent.value = config.tpPercent || '2';
            this.dom.slPercent.value = config.slPercent || '1';
            this.dom.trailingStop.value = config.trailingStop || '0.5';
            this.dom.enableTpSl.checked = config.enableTpSl !== undefined ? config.enableTpSl : true;
            this.dom.enableTrailing.checked = config.enableTrailing || false;
            this.dom.enableKelly.checked = config.enableKelly || false;
            this.state.currentSymbol = config.currentSymbol || 'BTCUSDT';
            this.state.currentTimeframe = config.currentTimeframe || '5m';

            this.bybitClient.setCredentials(config.bybitApiKey, config.bybitApiSecret);
            this.aiManager.init(config.geminiApiKey);
            this.ui.log('Configuration loaded and decrypted.', 'info');
            this.ui.showToast('Configuration loaded!', 'info');
          } catch (e) {
            this.ui.log('Failed to load or decrypt configuration. It may be corrupted.', 'error');
            this.ui.showToast('Failed to load config. It might be corrupted.', 'error');
            localStorage.removeItem('tradingBotConfig');
          }
        }
      }
      
      clearConfiguration() {
        localStorage.removeItem('tradingBotConfig');
        this.dom.geminiApiKey.value = '';
        this.dom.bybitApiKey.value = '';
        this.dom.bybitApiSecret.value = '';
        this.bybitClient.setCredentials('', '');
        this.aiManager.init('');
        this.ui.log('Configuration cleared.', 'warning');
        this.ui.showToast('Configuration cleared!', 'warning');
      }

      async connect() {
        if (this.bybitWs.isConnected) return;
        this.ui.showLoading();
        try {
          await this.fetchInitialData();
          await this.fetchAccountInfo();
          this.bybitWs.connect(this.dom.tradingMode.value);
          this.subscribeToTopics();
        } catch (error) {
          this.ui.log(`Connection failed: ${error.message}`, 'error');
          this.ui.showToast(`Connection failed: ${error.message}`, 'error');
          this.disconnect();
        } finally {
          this.ui.hideLoading();
        }
      }
      
      disconnect() {
        this.bybitWs.disconnect();
        this.ui.log('Disconnected from Bybit.', 'info');
        this.ui.showToast('Disconnected from Bybit.', 'info');
      }

      async populateSymbols() {
        try {
          const symbols = await this.bybitClient.getValidSymbols();
          this.dom.symbolSelect.innerHTML = symbols.map(s => `<option value="${s}">${s}</option>`).join('');
          this.dom.symbolSelect.value = this.state.currentSymbol;
          this.ui.log(`Loaded ${symbols.length} valid trading symbols.`, 'info');
        } catch (error) {
          this.ui.log('Failed to load symbols.', 'error');
          this.dom.symbolSelect.innerHTML = '<option>Error loading</option>';
          this.ui.showToast('Failed to load symbols.', 'error');
        }
      }
      
      async handleSymbolChange(newSymbol) {
        this.ui.log(`Symbol changed to ${newSymbol}`, 'info');
        if (this.bybitWs.isConnected) {
          this.unsubscribeFromTopics();
          this.state.currentSymbol = newSymbol;
          await this.fetchInitialData();
          await this.fetchAccountInfo();
          this.subscribeToTopics();
        } else {
          this.state.currentSymbol = newSymbol;
          await this.fetchInitialData();
        }
      }
      
      async handleTimeframeChange(newTimeframe) {
        this.ui.log(`Timeframe changed to ${newTimeframe}`, 'info');
        if (this.bybitWs.isConnected) {
          this.unsubscribeFromTopics();
          this.state.currentTimeframe = newTimeframe;
          await this.fetchInitialData();
          this.subscribeToTopics();
        } else {
          this.state.currentTimeframe = newTimeframe;
          await this.fetchInitialData();
        }
      }

      async fetchInitialData() {
        this.ui.showLoading();
        try {
          const klinesResult = await this.bybitClient.getKlines(this.state.currentSymbol, this.state.currentTimeframe);
          this.state.klines = klinesResult.list.map(k => ({
            time: parseInt(k[0]) / 1000,
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5]),
          })).reverse();
          this._updateChartsAndIndicators();
          this.ui.log('Fetched historical klines.', 'info');
        } catch (error) {
          this.ui.log(`Failed to fetch initial data: ${error.message}`, 'error');
          this.ui.showToast('Failed to fetch initial market data.', 'error');
        } finally {
          this.ui.hideLoading();
        }
      }

      async fetchAccountInfo() {
        try {
          const [balance, positions, openOrders, tradeHistory] = await Promise.all([
            this.bybitClient.getWalletBalance(),
            this.bybitClient.getPositions(this.state.currentSymbol),
            this.bybitClient.getOpenOrders(this.state.currentSymbol),
            this.bybitClient.getTradeHistory(this.state.currentSymbol)
          ]);
          this.state.accountBalance = balance;
          this.state.positions = positions;
          this.state.openOrders = openOrders;
          this.state.tradeHistory = tradeHistory;

          this.ui.updatePositionInfo(positions[0]); // Assuming only one position per symbol
          this.ui.renderPositions(positions);
          this.ui.renderOpenOrders(openOrders);
          this.ui.renderTradeHistory(tradeHistory);
          this.ui.log('Account info, positions, orders, and history refreshed.', 'info');
        } catch (error) {
          this.ui.log(`Failed to fetch account info: ${error.message}`, 'error');
          this.ui.showToast('Failed to fetch account info.', 'error');
        }
      }

      subscribeToTopics() {
        const topics = [
          `orderbook.50.${this.state.currentSymbol}`,
          `kline.${this.state.currentTimeframe}.${this.state.currentSymbol}`,
          `position.linear`, // For all linear positions
          `order.linear`,    // For all linear orders
          `execution.linear` // For all linear executions
        ];
        this.bybitWs.subscribe(topics);
      }
      
      unsubscribeFromTopics() {
         const topics = [
          `orderbook.50.${this.state.currentSymbol}`,
          `kline.${this.state.currentTimeframe}.${this.state.currentSymbol}`,
        ];
        this.bybitWs.unsubscribe(topics);
      }

      _handleWsMessage(data) {
        if (data.topic?.startsWith('orderbook')) {
          this._updateOrderBook(data.data);
        } else if (data.topic?.startsWith('kline')) {
          this._updateKlines(data.data[0]);
        } else if (data.topic === 'position.linear' || data.topic === 'order.linear' || data.topic === 'execution.linear') {
          // Debounce fetching account info to avoid API rate limits from frequent WS updates
          Utils.debounce(() => this.fetchAccountInfo(), 1000)();
        }
      }
      
      _updateOrderBook(data) {
        this.state.orderBook.bids = data.b.map(d => ({ price: parseFloat(d[0]), size: parseFloat(d[1]) }));
        this.state.orderBook.asks = data.a.map(d => ({ price: parseFloat(d[0]), size: parseFloat(d[1]) }));
        this.chartManager.updateOrderBook(this.state.orderBook.bids, this.state.orderBook.asks);
      }
      
      _updateKlines(kline) {
        const newKline = {
            time: parseInt(kline.start) / 1000,
            open: parseFloat(kline.open),
            high: parseFloat(kline.high),
            low: parseFloat(kline.low),
            close: parseFloat(kline.close),
            volume: parseFloat(kline.volume),
        };
        
        const lastKline = this.state.klines[this.state.klines.length - 1];
        if (lastKline && newKline.time === lastKline.time) {
            this.state.klines[this.state.klines.length - 1] = newKline;
        } else {
            this.state.klines.push(newKline);
            if (this.state.klines.length > CONFIG.MAX_KLINES_DISPLAY) {
              this.state.klines.shift();
            }
        }
        this._updateChartsAndIndicators();
      }

      _updateChartsAndIndicators() {
        this.chartManager.updatePriceChart(this.state.klines);
        this._calculateAndDisplayIndicators();
      }
      
      _calculateAndDisplayIndicators() {
        if (this.state.klines.length === 0) return;

        const closes = this.state.klines.map(k => k.close);
        const volumes = this.state.klines.map(k => k.volume);
        
        const rsi = Utils.calculateRSI(closes);
        const macd = Utils.calculateMACD(closes);
        const bb = Utils.calculateBollingerBands(closes);
        const currentVolume = volumes[volumes.length - 1];

        // Store history for indicator chart
        const rsiHistory = []; // TODO: Implement full history calculation
        const macdHistory = []; // TODO: Implement full history calculation

        this.state.indicators = { rsi, macd, bb, volume: currentVolume, rsiHistory, macdHistory };
        this.ui.updateIndicatorValues(this.state.indicators);
        this.chartManager.updateIndicatorChart(this.state.klines, this.state.indicators);
      }

      handleTabSwitch(event) {
        const tabName = event.target.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
        document.getElementById(`tab-${tabName}`).classList.remove('hidden');
        document.querySelectorAll('.tab-nav .tab-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
      }

      async runAnalysis() {
        this.ui.log('Running AI analysis...', 'info');
        this.dom.aiOutput.innerHTML = '<div class="text-text-secondary">Analyzing...</div>';
        this.ui.showLoading();
        
        try {
            const customPrompt = this.dom.customPromptBtn.classList.contains('active') ? this.dom.customPrompt.value : '';
            const tradingMode = this.dom.analysisMode.value;
            const currentPosition = this.state.positions[0] || null;

            const aiResponse = await this.aiManager.analyze(
              customPrompt,
              this.state.klines,
              this.state.orderBook,
              currentPosition,
              tradingMode
            );

            this.ui.log('AI Analysis Complete.', 'success');
            this.dom.aiOutput.textContent = JSON.stringify(aiResponse, null, 2);
            this.state.lastSignal = aiResponse;
            this.ui.showToast(`AI Signal: ${aiResponse.action} (${aiResponse.confidence})`, 'info');

        } catch (error) {
            this.ui.log(`AI Analysis Error: ${error.message}`, 'error');
            this.dom.aiOutput.textContent = `Error: ${error.message}`;
            this.ui.showToast(`AI Analysis Failed: ${error.message}`, 'error');
        } finally {
            this.ui.hideLoading();
        }
      }
      
      async executeSignal(action) {
        if (!this.state.lastSignal || this.state.lastSignal.action !== action) {
          this.ui.log(`No valid ${action} signal to execute.`, 'warning');
          this.ui.showToast(`No valid ${action} signal from AI.`, 'warning');
          return;
        }
        
        this.ui.log(`Executing ${action} signal for ${this.state.lastSignal.quantity} contracts.`, 'info');
        this.ui.showLoading();

        try {
          const latestPrice = this.state.klines[this.state.klines.length - 1]?.close;
          if (!latestPrice) {
            throw new Error('Could not get latest price for order placement.');
          }

          let qty = this.state.lastSignal.quantity;
          if (this.dom.enableKelly.checked && this.state.accountBalance) {
            // Placeholder for Kelly Criterion calculation
            // Requires win rate, average win/loss ratio, and bankroll
            // For now, it's just a placeholder
            // const kellyFraction = this._calculateKellyCriterion();
            // qty = this.state.accountBalance.availableBalance * kellyFraction / latestPrice / parseFloat(this.dom.leverage.value);
            this.ui.log('Kelly Criterion is enabled but not fully implemented for dynamic sizing.', 'warning');
          } else if (parseFloat(this.dom.riskPerTrade.value) > 0 && this.state.accountBalance) {
            // Simple risk-based sizing
            const riskAmount = (parseFloat(this.dom.riskPerTrade.value) / 100) * parseFloat(this.state.accountBalance.availableBalance);
            // This is a simplified calculation. A proper SL-based sizing needs more context.
            qty = Math.min(qty, riskAmount / (latestPrice * (parseFloat(this.dom.slPercent.value) / 100)));
          }

          qty = Math.min(qty, parseFloat(this.dom.maxPosition.value));
          if (qty <= 0) {
            throw new Error('Calculated quantity is zero or negative. Cannot place order.');
          }

          const orderParams = {
            symbol: this.state.currentSymbol,
            side: action === 'BUY' ? 'Buy' : 'Sell',
            orderType: this.dom.orderType.value,
            qty: qty.toFixed(3),
            leverage: this.dom.leverage.value,
            price: this.dom.orderType.value === 'Limit' ? (action === 'BUY' ? (latestPrice * 0.99).toFixed(1) : (latestPrice * 1.01).toFixed(1)) : undefined, // Example limit price
          };
          
          if (this.dom.enableTpSl.checked) {
            const tpPct = parseFloat(this.dom.tpPercent.value) / 100;
            const slPct = parseFloat(this.dom.slPercent.value) / 100;
            if (action === 'BUY') {
              orderParams.takeProfit = (latestPrice * (1 + tpPct)).toFixed(1);
              orderParams.stopLoss = (latestPrice * (1 - slPct)).toFixed(1);
            } else { // SELL
              orderParams.takeProfit = (latestPrice * (1 - tpPct)).toFixed(1);
              orderParams.stopLoss = (latestPrice * (1 + slPct)).toFixed(1);
            }
          }

          if (this.dom.enableTrailing.checked && parseFloat(this.dom.trailingStop.value) > 0) {
            orderParams.trailingStop = parseFloat(this.dom.trailingStop.value) * 10000; // Bybit uses basis points
          }

          const result = await this.bybitClient.placeOrder(orderParams);
          this.ui.log(`Order placed successfully! Order ID: ${result.orderId}`, 'success');
          this.ui.showToast(`Order placed: ${action} ${qty.toFixed(3)} ${this.state.currentSymbol}`, 'success');
          this.fetchAccountInfo(); // Refresh account data
        } catch (error) {
          this.ui.log(`Order execution failed: ${error.message}`, 'error');
          this.ui.showToast(`Order failed: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading();
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      window.app = new TradingApp();
    });

  </script>
</body>
</html>
