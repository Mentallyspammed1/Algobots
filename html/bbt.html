<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bybit V5 Advanced Trading Terminal - AI Enhanced</title>

  <!-- Core Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  
  <!-- Additional Libraries for Enhanced Features -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <!-- Chart.js Financial plugin requires explicit registration -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

  <!-- Google Gemini AI Import Map -->
  <script type="importmap">
  {
    "imports": {
      "@google/generative-ai": "https://esm.sh/@google/generative-ai"
    }
  }
  </script>

  <!-- Main Stylesheet -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600;700&display=swap');
    
    :root {
      --bg-primary: #0a0a1e;
      --bg-secondary: #12122e;
      --bg-tertiary: #1a1a3a;
      --text-primary: #e8e8ff;
      --text-secondary: #a8a8c8;
      --neon-green: #00ff41;
      --neon-orange: #ff9f1c;
      --neon-red: #ff1744;
      --neon-cyan: #00e5ff;
      --neon-purple: #d500f9;
      --neon-yellow: #ffea00;
      --chart-bg: #0f0f2a;
      --shadow-neon: 0 0 20px rgba(0, 229, 255, 0.5);
      --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(0, 229, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(213, 0, 249, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 1;
    }
    
    .container {
      position: relative;
      z-index: 2;
    }
    
    .card {
      background: var(--bg-tertiary);
      border: 1px solid rgba(0, 229, 255, 0.2);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-neon);
      backdrop-filter: blur(10px);
      transition: var(--transition-smooth);
    }
    
    .card:hover {
      box-shadow: 0 0 30px rgba(0, 229, 255, 0.6);
      transform: translateY(-2px);
    }
    
    .card-header {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(0, 229, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .btn {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      color: var(--bg-primary);
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition-smooth);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 229, 255, 0.4);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    
    .btn-secondary {
      background: transparent;
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, var(--neon-red), var(--neon-orange));
    }
    
    .btn-success {
      background: linear-gradient(135deg, var(--neon-green), var(--neon-cyan));
    }

    .btn-sm {
      padding: 6px 12px;
      font-size: 0.75rem;
    }
    
    input, textarea, select {
      background: var(--bg-primary);
      border: 2px solid rgba(0, 229, 255, 0.3);
      color: var(--text-primary);
      padding: 10px 14px;
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      transition: var(--transition-smooth);
      width: 100%;
    }
    
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--neon-cyan);
      box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
    }
    
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }
    
    .status-connected {
      background: var(--neon-green);
      box-shadow: 0 0 10px var(--neon-green);
    }
    
    .status-disconnected {
      background: var(--neon-red);
      box-shadow: 0 0 10px var(--neon-red);
    }
    
    .status-connecting {
      background: var(--neon-orange);
      box-shadow: 0 0 10px var(--neon-orange);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .metric-card {
      background: linear-gradient(135deg, rgba(0, 229, 255, 0.1), rgba(213, 0, 249, 0.1));
      border: 1px solid rgba(0, 229, 255, 0.3);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }
    
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      margin-top: 8px;
    }
    
    .metric-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .chart-container {
      position: relative;
      height: 400px;
      background: var(--chart-bg);
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }
    
    .tab-nav {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      border-bottom: 2px solid rgba(0, 229, 255, 0.2);
      padding-bottom: 8px;
    }
    
    .tab-btn {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      padding: 8px 16px;
      cursor: pointer;
      transition: var(--transition-smooth);
      font-weight: 500;
      position: relative;
    }
    
    .tab-btn.active {
      color: var(--neon-cyan);
    }
    
    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--neon-cyan);
      box-shadow: 0 0 10px var(--neon-cyan);
    }
    
    .log-container {
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
    }
    
    .log-entry {
      margin-bottom: 8px;
      padding: 4px 8px;
      border-left: 3px solid;
      background: rgba(255, 255, 255, 0.02);
    }
    
    .log-info { border-color: var(--neon-cyan); }
    .log-success { border-color: var(--neon-green); }
    .log-warning { border-color: var(--neon-orange); }
    .log-error { border-color: var(--neon-red); }
    
    .grid-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 30, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: var(--transition-smooth);
    }
    
    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(0, 229, 255, 0.2);
      border-top: 4px solid var(--neon-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 250px;
      background: var(--bg-primary);
      color: var(--text-primary);
      text-align: center;
      border-radius: 8px;
      padding: 8px;
      position: absolute;
      z-index: 10; /* Increased z-index to ensure visibility */
      bottom: 125%;
      left: 50%;
      margin-left: -125px;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid var(--neon-cyan);
      font-size: 0.75rem;
      pointer-events: none; /* Allows clicks to pass through tooltip to elements below */
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
    }

    .data-table th, .data-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0, 229, 255, 0.1);
      text-align: left;
    }

    .data-table th {
      background-color: rgba(0, 229, 255, 0.1);
      font-weight: 600;
      color: var(--neon-cyan);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .data-table tbody tr:hover {
      background-color: rgba(0, 229, 255, 0.05);
    }
    
    @media (max-width: 768px) {
      .grid-metrics {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .card {
        padding: 16px;
      }
      
      .tab-nav {
        flex-wrap: wrap;
      }
    }
    
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, var(--neon-purple), var(--neon-cyan));
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <div class="container mx-auto p-6 max-w-7xl">
    <!-- Header -->
    <div class="text-center mb-8">
      <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-cyan-400 to-purple-500 bg-clip-text text-transparent mb-2">
        Advanced AI Trading Terminal
      </h1>
      <p class="text-text-secondary">Powered by Bybit V5 API & Google Gemini AI</p>
      <p class="text-sm text-neon-red mt-2 p-2 bg-red-900 bg-opacity-30 border border-red-700 rounded-md">
        ⚠️ **SECURITY WARNING:** This is a demonstration for educational purposes. Storing API keys in client-side localStorage (even encrypted) is NOT secure for real trading. Use with extreme caution and on a testnet only. For production, API keys should be managed server-side.
      </p>
    </div>

    <!-- Performance Metrics Dashboard -->
    <div class="grid-metrics">
      <div class="metric-card">
        <div class="metric-label">Total P&L</div>
        <div class="metric-value" id="totalPnL">$0.00</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Win Rate</div>
        <div class="metric-value" id="winRate">0%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Sharpe Ratio</div>
        <div class="metric-value" id="sharpeRatio">0.00</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Max Drawdown</div>
        <div class="metric-value" id="maxDrawdown">0%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Active Trades</div>
        <div class="metric-value" id="activeTrades">0</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Account Equity</div>
        <div class="metric-value" id="accountEquity">$0</div>
      </div>
    </div>

    <!-- Configuration Section -->
    <div class="card">
      <div class="card-header">
        <span>⚙️ Configuration & API Settings</span>
        <button class="btn btn-secondary btn-sm" id="toggleAdvancedBtn">Advanced Settings</button>
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label for="geminiApiKey">
            Google Gemini API Key
            <span class="tooltip">ⓘ
              <span class="tooltip-text">Your Google AI Studio API key for Gemini analysis. Stored encrypted in your browser.</span>
            </span>
          </label>
          <input type="password" id="geminiApiKey" placeholder="Enter Gemini API Key" />
        </div>
        <div>
          <label for="bybitApiKey">
            Bybit API Key
            <span class="tooltip">ⓘ
              <span class="tooltip-text">Your Bybit API key with trading permissions. Stored encrypted in your browser.</span>
            </span>
          </label>
          <input type="password" id="bybitApiKey" placeholder="Enter Bybit API Key" />
        </div>
        <div>
          <label for="bybitApiSecret">
            Bybit API Secret
            <span class="tooltip">ⓘ
              <span class="tooltip-text">Your Bybit API secret for authentication. Stored encrypted in your browser.</span>
            </span>
          </label>
          <input type="password" id="bybitApiSecret" placeholder="Enter Bybit API Secret" />
        </div>
      </div>

      <div id="advancedSettings" class="hidden">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
          <div>
            <label for="maxPosition">Max Position Size (Contracts)</label>
            <input type="number" id="maxPosition" value="0.01" step="0.001" min="0.001" />
          </div>
          <div>
            <label for="riskPerTrade">Risk Per Trade (%)</label>
            <input type="number" id="riskPerTrade" value="1" step="0.1" min="0.1" max="5" />
          </div>
          <div>
            <label for="leverage">Leverage</label>
            <select id="leverage">
              <option value="1">1x</option>
              <option value="2">2x</option>
              <option value="5">5x</option>
              <option value="10" selected>10x</option>
              <option value="20">20x</option>
              <option value="50">50x</option>
            </select>
          </div>
          <div>
            <label for="orderType">Default Order Type</label>
            <select id="orderType">
              <option value="Market" selected>Market</option>
              <option value="Limit">Limit</option>
            </select>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div>
            <label for="tpPercent">Take Profit (%)</label>
            <input type="number" id="tpPercent" value="2" step="0.1" min="0.1" />
          </div>
          <div>
            <label for="slPercent">Stop Loss (%)</label>
            <input type="number" id="slPercent" value="1" step="0.1" min="0.1" />
          </div>
          <div>
            <label for="trailingStop">Trailing Stop (Delta %)</label>
            <span class="tooltip ml-1">ⓘ
              <span class="tooltip-text">The percentage move from entry at which to activate the trailing stop. e.g., 0.5 means if profit reaches 0.5%, trailing stop activates.</span>
            </span>
            <input type="number" id="trailingStop" value="0.5" step="0.1" min="0" />
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div class="flex items-center gap-4">
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableTpSl" checked class="w-5 h-5" />
              <span>Auto TP/SL</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableTrailing" class="w-5 h-5" />
              <span>Trailing Stop</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableKelly" class="w-5 h-5" />
              <span>Kelly Criterion</span>
              <span class="tooltip ml-1">ⓘ
                <span class="tooltip-text">Experimental: Applies Kelly Criterion for optimal position sizing based on estimated win rate and risk/reward.</span>
              </span>
            </label>
          </div>
          <div>
            <label for="tradingMode">Trading Mode</label>
            <select id="tradingMode">
              <option value="testnet" selected>Testnet</option>
              <option value="mainnet">Mainnet</option>
            </select>
          </div>
        </div>
      </div>

      <div class="flex gap-4 mt-4 flex-wrap">
        <button class="btn btn-success" id="saveConfigBtn">Save Configuration</button>
        <button class="btn btn-secondary" id="loadConfigBtn">Load Saved Config</button>
        <button class="btn btn-danger" id="clearConfigBtn">Clear All</button>
        <span id="configStatus" class="flex items-center text-sm"></span>
      </div>
    </div>

    <!-- Market Data Section -->
    <div class="card">
      <div class="card-header">
        <span>📊 Market Data & Analysis</span>
        <div class="flex gap-2">
          <span class="status-indicator" id="wsStatus"></span>
          <span id="wsStatusText">Disconnected</span>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label for="symbolSelect">Trading Symbol</label>
          <select id="symbolSelect">
            <option value="">Loading symbols...</option>
          </select>
        </div>
        <div>
          <label for="timeframe">Analysis Timeframe</label>
          <select id="timeframe">
            <option value="1">1 Minute</option>
            <option value="5" selected>5 Minutes</option>
            <option value="15">15 Minutes</option>
            <option value="30">30 Minutes</option>
            <option value="60">1 Hour</option>
            <option value="240">4 Hours</option>
            <option value="D">1 Day</option>
          </select>
        </div>
        <div class="flex items-end gap-2">
          <button class="btn flex-1" id="connectBtn">Connect</button>
          <button class="btn btn-secondary flex-1" id="disconnectBtn">Disconnect</button>
        </div>
      </div>

      <!-- Tab Navigation -->
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="orderbook">Order Book</button>
        <button class="tab-btn" data-tab="chart">Price Chart</button>
        <button class="tab-btn" data-tab="indicators">Technical Indicators</button>
      </div>

      <!-- Tab Contents -->
      <div id="tab-orderbook" class="tab-content">
        <div class="chart-container">
          <canvas id="orderBookChart"></canvas>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
          <div class="log-container" id="bidBookDisplay">
            <div class="text-green-400 font-semibold mb-2">Bid Book</div>
            <div>Loading...</div>
          </div>
          <div class="log-container" id="askBookDisplay">
            <div class="text-red-400 font-semibold mb-2">Ask Book</div>
            <div>Loading...</div>
          </div>
        </div>
      </div>

      <div id="tab-chart" class="tab-content hidden">
        <div class="chart-container">
          <canvas id="priceChart"></canvas>
        </div>
      </div>

      <div id="tab-indicators" class="tab-content hidden">
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div class="metric-card">
            <div class="metric-label">RSI</div>
            <div class="metric-value" id="rsiValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">MACD</div>
            <div class="metric-value" id="macdValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">BB Width</div>
            <div class="metric-value" id="bbValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Volume</div>
            <div class="metric-value" id="volumeValue">--</div>
          </div>
        </div>
        <div class="chart-container mt-4">
          <canvas id="indicatorChart"></canvas>
        </div>
      </div>
    </div>

    <!-- AI Analysis Section -->
    <div class="card">
      <div class="card-header">
        <span>🤖 AI Analysis & Trading Signals</span>
        <button class="btn btn-secondary btn-sm" id="customPromptBtn">Custom Prompt</button>
      </div>

      <div id="customPromptSection" class="hidden mb-4">
        <label for="customPrompt">Custom Analysis Prompt</label>
        <textarea id="customPrompt" rows="3" placeholder="Enter custom instructions for Gemini AI..."></textarea>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div>
          <label for="analysisMode">Analysis Mode</label>
          <select id="analysisMode">
            <option value="conservative">Conservative</option>
            <option value="balanced" selected>Balanced</option>
            <option value="aggressive">Aggressive</option>
            <option value="scalping">Scalping</option>
            <option value="swing">Swing Trading</option>
          </select>
        </div>
        <div class="flex items-end">
          <button class="btn w-full" id="analyzeBtn">🔍 Analyze Market</button>
        </div>
      </div>

      <div class="log-container" id="aiOutput" style="max-height: 250px;">
        <div class="text-text-secondary">No analysis performed yet...</div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
        <button class="btn btn-success" id="executeBuyBtn" disabled>Execute Buy Signal</button>
        <button class="btn btn-danger" id="executeSellBtn" disabled>Execute Sell Signal</button>
        <button class="btn btn-secondary" id="executeHoldBtn" disabled>Hold Position</button>
      </div>
    </div>

    <!-- Position & Orders Section -->
    <div class="card">
      <div class="card-header">
        <span>💼 Positions & Orders</span>
        <button class="btn btn-secondary btn-sm" id="refreshPositionsBtn">Refresh</button>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        <div class="metric-card">
          <div class="metric-label">Position Size</div>
          <div class="metric-value" id="positionSize">0.000</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Entry Price</div>
          <div class="metric-value" id="entryPrice">--</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Unrealized P&L</div>
          <div class="metric-value" id="unrealizedPnL">$0.00</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Margin Used</div>
          <div class="metric-value" id="marginUsed">$0.00</div>
        </div>
      </div>

      <div class="tab-nav">
        <button class="tab-btn active" data-tab="positions">Active Positions</button>
        <button class="tab-btn" data-tab="openOrders">Open Orders</button>
        <button class="tab-btn" data-tab="history">Trade History</button>
      </div>

      <div id="tab-positions" class="tab-content">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Side</th>
                <th>Size</th>
                <th>Entry Price</th>
                <th>Liq. Price</th>
                <th>P&L</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="positionsDisplay">
              <tr><td colspan="7" class="text-text-secondary text-center">No active positions</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="tab-openOrders" class="tab-content hidden">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Order ID</th>
                <th>Symbol</th>
                <th>Side</th>
                <th>Type</th>
                <th>Price</th>
                <th>Qty</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="ordersDisplay">
              <tr><td colspan="8" class="text-text-secondary text-center">No open orders</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="tab-history" class="tab-content hidden">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Symbol</th>
                <th>Side</th>
                <th>Qty</th>
                <th>Price</th>
                <th>Fee</th>
                <th>P&L</th>
              </tr>
            </thead>
            <tbody id="historyDisplay">
              <tr><td colspan="7" class="text-text-secondary text-center">No trade history</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Risk Management Section -->
    <div class="card">
      <div class="card-header">
        <span>⚠️ Risk Management</span>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div class="metric-card">
          <div class="metric-label">Portfolio Risk</div>
          <div class="metric-value" id="portfolioRisk">Low</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">VaR (95%)</div>
          <div class="metric-value" id="varValue">$0.00</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Kelly %</div>
          <div class="metric-value" id="kellyPercent">0%</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Risk Score</div>
          <div class="metric-value" id="riskScore">0/100</div>
        </div>
      </div>

      <div class="chart-container mt-4">
        <canvas id="riskChart"></canvas>
      </div>
    </div>

    <!-- Activity Log Section -->
    <div class="card">
      <div class="card-header">
        <span>📜 Activity Log</span>
        <button class="btn btn-secondary btn-sm" id="clearLogsBtn">Clear Logs</button>
      </div>
      
      <div class="log-container" id="activityLog" style="height: 200px;">
        <div class="text-text-secondary">System initialized...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { GoogleGenerativeAI } from "@google/generative-ai";

    /**
     * @file bybit_ai_trader.html
     * @description Advanced AI-enhanced crypto trading terminal for Bybit V5 API.
     * Combines real-time market data via WebSockets, AI analysis with Google Gemini,
     * and a comprehensive UI for configuration, trading, and risk management.
     *
     * IMPORTANT SECURITY NOTE: This is for educational and demonstration purposes ONLY.
     * Storing API keys directly in client-side localStorage (even encrypted) is NOT secure
     * for production use with real funds. Always use server-side secure key management
     * and environment variables for any production application.
     */

    // --- CONFIGURATION ---
    const CONSTANTS = {
      BYBIT_WS_URL: {
        testnet: 'wss://stream-testnet.bybit.com/v5/public/linear',
        mainnet: 'wss://stream.bybit.com/v5/public/linear'
      },
      BYBIT_API_URL: {
        testnet: 'https://api-testnet.bybit.com',
        mainnet: 'https://api.bybit.com'
      },
      GEMINI_MODEL: 'gemini-1.5-flash',
      WS_PING_INTERVAL: 20000,
      WS_RECONNECT_DELAY: 5000,
      MAX_KLINES_DISPLAY: 200,
      ENCRYPTION_KEY: 'super-secret-key-for-demo-only-do-not-use-in-production-seriously', // WARNING: For demonstration only. NOT secure for production.
      KLINES_FETCH_LIMIT: 200, // Number of historical klines to fetch initially
      ORDER_BOOK_DEPTH: 50, // Number of levels for order book
      METRIC_CALC_PERIODS: { // Periods for various metric calculations
        SHARPE_RATIO_TRADES: 50,
        RSI_PERIOD: 14,
        MACD_FAST: 12,
        MACD_SLOW: 26,
        MACD_SIGNAL: 9,
        BB_PERIOD: 20,
        BB_STD_DEV: 2
      }
    };

    // --- UTILITIES & HELPERS ---
    class Utils {
      /**
       * Encrypts a string using a key.
       * @param {string} text - The text to encrypt.
       * @param {string} key - The encryption key.
       * @returns {string} The encrypted text.
       */
      static encrypt(text, key) {
        return CryptoJS.AES.encrypt(text, key).toString();
      }

      /**
       * Decrypts an encrypted string.
       * @param {string} encryptedText - The text to decrypt.
       * @param {string} key - The decryption key.
       * @returns {string} The original text, or an empty string on failure.
       */
      static decrypt(encryptedText, key) {
        try {
          const bytes = CryptoJS.AES.decrypt(encryptedText, key);
          const originalText = bytes.toString(CryptoJS.enc.Utf8);
          return originalText;
        } catch (e) {
          console.error("Decryption failed:", e);
          return '';
        }
      }

      /**
       * Debounces a function call.
       * @param {Function} func - The function to debounce.
       * @param {number} wait - The delay in milliseconds.
       * @returns {Function} The debounced function.
       */
      static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      /**
       * Formats a number as a currency string.
       * @param {number} amount - The amount to format.
       * @param {string} [symbol='$'] - The currency symbol.
       * @param {number} [fractionDigits=2] - Number of fraction digits.
       * @returns {string} The formatted string.
       */
      static formatCurrency(amount, symbol = '$', fractionDigits = 2) {
        return `${symbol}${new Intl.NumberFormat('en-US', { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits }).format(amount)}`;
      }

      /**
       * Formats a number as a percentage string.
       * @param {number} value - The value to format (e.g., 0.5 for 50%).
       * @returns {string} The formatted string.
       */
      static formatPercentage(value) {
        return `${(value * 100).toFixed(2)}%`;
      }

      /**
       * Calculates the Exponential Moving Average (EMA).
       * @param {number[]} data - An array of numerical data.
       * @param {number} period - The look-back period.
       * @returns {number[]} An array of EMA values.
       */
      static calculateEMA(data, period) {
          const k = 2 / (period + 1);
          let emas = [];
          if (data.length < period) return [];

          // Calculate initial SMA for the first EMA
          let currentEma = ss.mean(data.slice(0, period));
          emas.push(currentEma);

          // Calculate subsequent EMAs
          for (let i = period; i < data.length; i++) {
              currentEma = (data[i] - currentEma) * k + currentEma;
              emas.push(currentEma);
          }
          return emas;
      }

      /**
       * Calculates the Relative Strength Index (RSI).
       * @param {number[]} closes - An array of closing prices.
       * @param {number} [period=14] - The look-back period.
       * @returns {number|null} The RSI value, or null if insufficient data.
       */
      static calculateRSI(closes, period = CONSTANTS.METRIC_CALC_PERIODS.RSI_PERIOD) {
        if (closes.length < period + 1) return null;
        
        const changes = closes.slice(1).map((close, i) => close - closes[i]);
        const gains = changes.map(d => Math.max(0, d));
        const losses = changes.map(d => Math.max(0, -d));
        
        let avgGain = ss.mean(gains.slice(0, period));
        let avgLoss = ss.mean(losses.slice(0, period));

        for (let i = period; i < changes.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        }

        if (avgLoss === 0) return 100;
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
      }

      /**
       * Calculates the Moving Average Convergence Divergence (MACD).
       * @param {number[]} closes - An array of closing prices.
       * @param {number} [fastPeriod=12] - The fast EMA period.
       * @param {number} [slowPeriod=26] - The slow EMA period.
       * @param {number} [signalPeriod=9] - The signal EMA period.
       * @returns {{macd: number|null, signal: number|null, histogram: number|null}} The MACD values.
       */
      static calculateMACD(closes, fastPeriod = CONSTANTS.METRIC_CALC_PERIODS.MACD_FAST, slowPeriod = CONSTANTS.METRIC_CALC_PERIODS.MACD_SLOW, signalPeriod = CONSTANTS.METRIC_CALC_PERIODS.MACD_SIGNAL) {
        if (closes.length < slowPeriod + signalPeriod) return { macd: null, signal: null, histogram: null };

        const fastEma = Utils.calculateEMA(closes, fastPeriod);
        const slowEma = Utils.calculateEMA(closes, slowPeriod);

        // MACD line is difference between last parts of EMAs
        const macdLine = fastEma.slice(fastEma.length - slowEma.length).map((f, i) => f - slowEma[i]);
        if (macdLine.length < signalPeriod) return { macd: null, signal: null, histogram: null };

        const signalLine = Utils.calculateEMA(macdLine, signalPeriod);
        const histogram = signalLine.map((s, i) => macdLine[i + (macdLine.length - signalLine.length)] - s);

        return {
          macd: macdLine[macdLine.length - 1],
          signal: signalLine[signalLine.length - 1],
          histogram: histogram[histogram.length - 1]
        };
      }

      /**
       * Calculates Bollinger Bands.
       * @param {number[]} closes - An array of closing prices.
       * @param {number} [period=20] - The look-back period.
       * @param {number} [stdDev=2] - The number of standard deviations.
       * @returns {{upper: number|null, middle: number|null, lower: number|null, width: number|null}} The Bollinger Band values.
       */
      static calculateBollingerBands(closes, period = CONSTANTS.METRIC_CALC_PERIODS.BB_PERIOD, stdDev = CONSTANTS.METRIC_CALC_PERIODS.BB_STD_DEV) {
        if (closes.length < period) return { upper: null, middle: null, lower: null, width: null };
        
        const lastPeriodCloses = closes.slice(-period);
        const middle = ss.mean(lastPeriodCloses);
        const std = ss.standardDeviation(lastPeriodCloses);
        const upper = middle + std * stdDev;
        const lower = middle - std * stdDev;
        const width = (upper - lower) / middle * 100;

        return { upper, middle, lower, width };
      }

      /**
       * Calculates the Sharpe Ratio.
       * @param {number[]} returns - An array of periodic returns.
       * @param {number} [riskFreeRate=0] - The risk-free rate.
       * @param {number} [periodsPerYear=252] - The number of periods per year (e.g., 252 for daily, 12 for monthly).
       * @returns {number|null} The Sharpe Ratio.
       */
      static calculateSharpeRatio(returns, riskFreeRate = 0, periodsPerYear = CONSTANTS.METRIC_CALC_PERIODS.SHARPE_RATIO_TRADES) {
          if (returns.length < 2) return null;
          const excessReturns = returns.map(r => r - riskFreeRate);
          const meanExcessReturn = ss.mean(excessReturns);
          const stdDev = ss.standardDeviation(excessReturns);
          if (stdDev === 0) return null;
          return (meanExcessReturn / stdDev) * Math.sqrt(periodsPerYear);
      }
    }

    // --- EVENT EMITTER CLASS ---
    class EventEmitter {
      constructor() { this.events = {}; }
      on(event, listener) {
        if (!this.events[event]) this.events[event] = [];
        this.events[event].push(listener);
      }
      emit(event, ...args) {
        if (this.events[event]) this.events[event].forEach(listener => listener(...args));
      }
    }

    // --- BYBIT API CLIENT ---
    class BybitClient extends EventEmitter {
      constructor(logger) {
        super();
        this.logger = logger;
        this.apiKey = '';
        this.apiSecret = '';
        this.tradingMode = 'testnet';
        this.axiosInstance = axios.create();
        this.setupRateLimiting();
      }

      setCredentials(apiKey, apiSecret, tradingMode) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.tradingMode = tradingMode;
      }

      setupRateLimiting() {
        this.axiosInstance.interceptors.response.use(response => {
          return response;
        }, error => {
          if (error.response && error.response.status === 429) {
            this.emit('rateLimitExceeded');
            this.logger('Bybit API rate limit exceeded.', 'warning');
          }
          return Promise.reject(error);
        });
      }

      /**
       * Makes a signed or unsigned request to the Bybit V5 API.
       * @param {'GET'|'POST'} method - HTTP method.
       * @param {string} endpoint - The API endpoint.
       * @param {Object} [params={}] - Request parameters.
       * @param {boolean} [isPrivate=false] - Whether the request needs to be signed.
       * @returns {Promise<Object>} The API response result.
       */
      async request(method, endpoint, params = {}, isPrivate = false) {
        const baseURL = CONSTANTS.BYBIT_API_URL[this.tradingMode];
        
        const headers = { 'Content-Type': 'application/json' };
        const timestamp = Date.now().toString();
        const recvWindow = '10000'; // Recommended recvWindow for Bybit

        if (isPrivate) {
          if (!this.apiKey || !this.apiSecret) {
            const errorMsg = "API credentials not set for private request.";
            this.logger(errorMsg, 'error');
            throw new Error(errorMsg);
          }
          
          headers['X-BAPI-API-KEY'] = this.apiKey;
          headers['X-BAPI-TIMESTAMP'] = timestamp;
          headers['X-BAPI-RECV-WINDOW'] = recvWindow;

          let signaturePayload;
          if (method === 'GET') {
            const query = new URLSearchParams(params).toString();
            signaturePayload = timestamp + this.apiKey + recvWindow + query;
          } else if (method === 'POST') {
            const body = JSON.stringify(params);
            signaturePayload = timestamp + this.apiKey + recvWindow + body;
          }
          
          headers['X-BAPI-SIGN'] = CryptoJS.HmacSHA256(signaturePayload, this.apiSecret).toString();
        }

        try {
          const response = await this.axiosInstance({
            method,
            url: `${baseURL}${endpoint}`,
            headers,
            params: method === 'GET' ? params : undefined,
            data: method === 'POST' ? params : undefined
          });
          if (response.data.retCode !== 0) {
            throw new Error(`Bybit API Error: ${response.data.retMsg} (Code: ${response.data.retCode})`);
          }
          return response.data.result;
        } catch (error) {
          const errorMessage = error.response?.data?.retMsg || error.message;
          this.emit('error', errorMessage);
          this.logger(`Bybit API Request Failed: ${errorMessage}`, 'error');
          throw error;
        }
      }

      async getValidSymbols() {
        const result = await this.request('GET', '/v5/market/instruments-info', { category: 'linear' });
        return result.list
          .filter(s => s.status === 'Trading' && s.quoteCoin === 'USDT')
          .map(s => s.symbol)
          .sort();
      }
      
      async getKlines(symbol, interval, limit = CONSTANTS.KLINES_FETCH_LIMIT) {
        return this.request('GET', '/v5/market/kline', { category: 'linear', symbol, interval, limit });
      }

      async placeOrder(orderParams) {
        return this.request('POST', '/v5/order/create', { category: 'linear', ...orderParams }, true);
      }
      
      async getPositions(symbol = undefined) {
        const params = { category: 'linear' };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/position/list', params, true);
        return result.list;
      }

      async getOpenOrders(symbol = undefined) {
        const params = { category: 'linear' };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/order/realtime', params, true);
        return result.list;
      }

      async getTradeHistory(symbol = undefined, limit = 50) {
        const params = { category: 'linear', limit };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/trade/history', params, true);
        return result.list;
      }

      async getWalletBalance(coin = 'USDT') {
        const result = await this.request('GET', '/v5/account/wallet-balance', { accountType: 'UNIFIED', coin }, true);
        return result.list[0]?.coin[0] || null;
      }

      async cancelOrder(symbol, orderId) {
        return this.request('POST', '/v5/order/cancel', { category: 'linear', symbol, orderId }, true);
      }

      async closePosition(symbol, side) {
        // Closing a position is essentially placing a market order opposite to the current position.
        const position = (await this.getPositions(symbol)).find(p => p.symbol === symbol && p.size > 0);
        if (!position) {
          throw new Error(`No active position for ${symbol} to close.`);
        }
        const closeSide = side === 'Buy' ? 'Sell' : 'Buy'; // If current pos is Buy, close with Sell.
        return this.request('POST', '/v5/order/create', {
          category: 'linear',
          symbol: symbol,
          side: closeSide,
          orderType: 'Market',
          qty: position.size,
          reduceOnly: true, // Important to ensure it only closes existing position
        }, true);
      }
    }

    // --- BYBIT WEBSOCKET CLIENT ---
    class BybitWebSocket extends EventEmitter {
      constructor(logger) {
        super();
        this.logger = logger;
        this.ws = null;
        this.isConnected = false;
        this.pingInterval = null;
        this.reconnectTimeout = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.currentTopics = new Set();
        this.tradingMode = 'testnet';
      }

      setTradingMode(mode) {
        this.tradingMode = mode;
      }

      connect() {
        if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
          this.logger('WebSocket is already connected or connecting.', 'warning');
          return;
        }

        this.logger('Connecting to WebSocket...', 'info');
        this.emit('status', 'connecting');
        
        this.ws = new WebSocket(CONSTANTS.BYBIT_WS_URL[this.tradingMode]);

        this.ws.onopen = () => {
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.logger('WebSocket Connected.', 'success');
          this.emit('status', 'connected');
          this.startPing();
          this.resubscribeToTopics();
        };

        this.ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.op === 'pong') return;
          this.emit('message', data);
        };

        this.ws.onclose = () => {
          this.isConnected = false;
          this.stopPing();
          this.logger('WebSocket Disconnected.', 'warning');
          this.emit('status', 'disconnected');
          this.attemptReconnect();
        };

        this.ws.onerror = (err) => {
          this.logger(`WebSocket Error: ${err.message}`, 'error');
          this.ws.close();
        };
      }
      
      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.stopPing();
          clearTimeout(this.reconnectTimeout);
          this.isConnected = false;
          this.logger('Manually disconnected WebSocket.', 'info');
          this.emit('status', 'disconnected');
        }
      }

      subscribe(topics) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          const newTopics = topics.filter(topic => !this.currentTopics.has(topic));
          if (newTopics.length > 0) {
            this.ws.send(JSON.stringify({ op: 'subscribe', args: newTopics }));
            newTopics.forEach(topic => this.currentTopics.add(topic));
            this.logger(`Subscribed to: ${newTopics.join(', ')}`, 'info');
          }
        } else {
          // If not connected, add to pending topics to subscribe on connect
          topics.forEach(topic => this.currentTopics.add(topic));
        }
      }
      
      unsubscribe(topics) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          const topicsToUnsubscribe = topics.filter(topic => this.currentTopics.has(topic));
          if (topicsToUnsubscribe.length > 0) {
            this.ws.send(JSON.stringify({ op: 'unsubscribe', args: topicsToUnsubscribe }));
            topicsToUnsubscribe.forEach(topic => this.currentTopics.delete(topic));
            this.logger(`Unsubscribed from: ${topicsToUnsubscribe.join(', ')}`, 'info');
          }
        } else {
          topics.forEach(topic => this.currentTopics.delete(topic)); // Still remove from internal list
        }
      }

      resubscribeToTopics() {
        if (this.currentTopics.size > 0) {
          this.subscribe([...this.currentTopics]);
        }
      }

      startPing() {
        this.stopPing();
        this.pingInterval = setInterval(() => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ op: 'ping' }));
          }
        }, CONSTANTS.WS_PING_INTERVAL);
      }

      stopPing() {
        if (this.pingInterval) {
          clearInterval(this.pingInterval);
          this.pingInterval = null;
        }
      }

      attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
          this.reconnectAttempts++;
          const delay = CONSTANTS.WS_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts - 1);
          this.logger(`Attempting to reconnect in ${delay / 1000}s (Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`, 'warning');
          this.reconnectTimeout = setTimeout(() => this.connect(), delay);
        } else {
          this.logger('Max reconnection attempts reached. Please connect manually.', 'error');
          this.emit('status', 'disconnected');
        }
      }
    }

    // --- CHART MANAGER ---
    class ChartManager {
      constructor(dom, logger) {
        this.dom = dom;
        this.logger = logger;
        this.charts = {};
        this.lastKlineTimestamp = 0; // To track last kline time for indicator chart updates
        
        // Register financial chart plugin and annotation plugin
        if (window.Chart) {
          if (window.Chart.FinancialController && window.Chart.FinancialElement && window.Chart.Financial) {
            Chart.register(window.Chart.FinancialController, window.Chart.FinancialElement, window.Chart.Financial);
            this.logger("chartjs-chart-financial loaded.", "info");
          } else {
            this.logger("Warning: chartjs-chart-financial components not fully loaded. Candlestick chart may not display correctly.", "warning");
          }
          if (window.ChartjsPluginAnnotation) {
            Chart.register(window.ChartjsPluginAnnotation);
            this.logger("chartjs-plugin-annotation loaded.", "info");
          } else {
            this.logger("Warning: chartjs-plugin-annotation not loaded.", "warning");
          }
        }
      }

      initCharts() {
        this.charts.orderBook = new Chart(this.dom.orderBookChart, this._getOrderBookChartConfig());
        this.charts.price = new Chart(this.dom.priceChart, this._getPriceChartConfig());
        this.charts.indicator = new Chart(this.dom.indicatorChart, this._getIndicatorChartConfig());
        this.charts.risk = new Chart(this.dom.riskChart, this._getRiskChartConfig());
      }

      _getOrderBookChartConfig() {
        return {
          type: 'bar',
          data: { labels: [], datasets: [
            { label: 'Bids', data: [], backgroundColor: 'rgba(0, 255, 65, 0.5)', order: 2 },
            { label: 'Asks', data: [], backgroundColor: 'rgba(255, 23, 68, 0.5)', order: 1 }
          ]},
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 }, // Disable animation for real-time updates
            parsing: false, // Use pre-parsed data
            scales: { 
              x: { 
                stacked: true, 
                grid: { color: 'rgba(255,255,255,0.1)' }, 
                ticks: { color: 'var(--text-secondary)' },
                title: { display: true, text: 'Price (USDT)', color: 'var(--text-secondary)'}
              }, 
              y: { 
                beginAtZero: true, 
                grid: { color: 'rgba(255,255,255,0.1)' }, 
                ticks: { color: 'var(--text-secondary)' },
                title: { display: true, text: 'Cumulative Quantity', color: 'var(--text-secondary)'}
              } 
            },
            plugins: { 
              legend: { display: false },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) label += ': ';
                    if (context.parsed.y !== null) label += `${context.parsed.y.toFixed(3)} @ ${Utils.formatCurrency(context.parsed.x)}`;
                    return label;
                  }
                }
              }
            }
          }
        };
      }
      
      _getPriceChartConfig() {
        return {
          type: 'candlestick',
          data: { datasets: [{
            label: 'Candlestick',
            data: [],
            borderColor: 'rgba(0, 229, 255, 1)',
            borderWidth: 1,
            candlestick: {
              up: { backgroundColor: 'var(--neon-green)', borderColor: 'var(--neon-green)' },
              down: { backgroundColor: 'var(--neon-red)', borderColor: 'var(--neon-red)' },
              hover: { backgroundColor: 'var(--neon-cyan)', borderColor: 'var(--neon-cyan)' }
            }
          },
          {
            label: 'SMA20', // Example Moving Average
            type: 'line',
            data: [],
            borderColor: 'var(--neon-yellow)',
            borderWidth: 1,
            pointRadius: 0,
            yAxisID: 'y',
            parsing: false,
          }
          ]},
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 },
            parsing: false,
            scales: {
              x: { 
                type: 'time', 
                time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'HH:mm', day: 'MMM D' } },
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y: { 
                position: 'right', 
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    if (context.dataset.type === 'candlestick') {
                      const data = context.parsed._custom;
                      return [
                        `Open: ${data.o.toFixed(2)}`,
                        `High: ${data.h.toFixed(2)}`,
                        `Low: ${data.l.toFixed(2)}`,
                        `Close: ${data.c.toFixed(2)}`
                      ];
                    } else {
                      return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                    }
                  }
                }
              }
            }
          }
        };
      }

      _getIndicatorChartConfig() {
        return {
          type: 'line',
          data: {
            datasets: [
              { label: 'RSI', data: [], borderColor: 'var(--neon-cyan)', borderWidth: 1, pointRadius: 0, yAxisID: 'y', parsing: false },
              { label: 'MACD', data: [], borderColor: 'var(--neon-green)', borderWidth: 1, pointRadius: 0, yAxisID: 'y1', parsing: false },
              { label: 'Signal', data: [], borderColor: 'var(--neon-orange)', borderWidth: 1, pointRadius: 0, yAxisID: 'y1', parsing: false },
              { label: 'Histogram', data: [], backgroundColor: 'rgba(255,255,255,0.2)', borderWidth: 0, yAxisID: 'y1', type: 'bar', parsing: false }
            ]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 },
            scales: {
              x: {
                type: 'time',
                time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'HH:mm' } },
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y: {
                position: 'left',
                title: { display: true, text: 'RSI', color: 'var(--neon-cyan)' },
                grid: { color: 'rgba(255,255,255,0.05)' },
                ticks: { color: 'var(--text-secondary)' },
                min: 0, max: 100 // RSI specific scale
              },
              y1: {
                position: 'right',
                title: { display: true, text: 'MACD', color: 'var(--neon-green)' },
                grid: { color: 'rgba(255,255,255,0.05)' },
                ticks: { color: 'var(--text-secondary)' }
              }
            },
            plugins: {
              legend: { labels: { color: 'var(--text-primary)' } }
            }
          }
        };
      }

      _getRiskChartConfig() {
        return {
          type: 'doughnut',
          data: {
            labels: ['Current Risk (PnL vs Equity)', 'Remaining'],
            datasets: [{
              data: [0, 100],
              backgroundColor: ['var(--neon-red)', 'rgba(0, 229, 255, 0.2)'],
              borderColor: 'transparent',
              hoverOffset: 4
            }]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 },
            plugins: {
              legend: {
                position: 'bottom',
                labels: { color: 'var(--text-primary)' }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.label || '';
                    if (label) label += ': ';
                    if (context.parsed !== null) label += Utils.formatPercentage(context.parsed / 100);
                    return label;
                  }
                }
              }
            }
          }
        };
      }

      updateOrderBook(bids, asks) {
        const processedBids = bids
          .map(b => ({ price: parseFloat(b.price), size: parseFloat(b.size) }))
          .sort((a, b) => b.price - a.price) // Sort by price descending
          .slice(0, CONSTANTS.ORDER_BOOK_DEPTH);

        const processedAsks = asks
          .map(a => ({ price: parseFloat(a.price), size: parseFloat(a.size) }))
          .sort((a, b) => a.price - b.price) // Sort by price ascending
          .slice(0, CONSTANTS.ORDER_BOOK_DEPTH);

        // Calculate cumulative sizes
        let cumulativeBidSize = 0;
        const bidData = processedBids.map(b => {
          cumulativeBidSize += b.size;
          return { x: b.price, y: cumulativeBidSize };
        }).reverse(); // Reverse for charting from lowest bid price up

        let cumulativeAskSize = 0;
        const askData = processedAsks.map(a => {
          cumulativeAskSize += a.size;
          return { x: a.price, y: cumulativeAskSize };
        });

        // Combine all prices for x-axis labels to ensure correct scale
        const allPrices = [...processedBids.map(b => b.price), ...processedAsks.map(a => a.price)]
          .sort((a, b) => a - b);

        this.charts.orderBook.data.labels = allPrices;
        this.charts.orderBook.data.datasets[0].data = bidData; // Bids
        this.charts.orderBook.data.datasets[1].data = askData; // Asks
        this.charts.orderBook.update('none');

        this.dom.bidBookDisplay.innerHTML = '<div class="text-green-400 font-semibold mb-2">Bid Book</div>' + 
          processedBids.map(b => `<div>${b.size.toFixed(3)} @ ${Utils.formatCurrency(b.price, '$', 2)}</div>`).join('');
        this.dom.askBookDisplay.innerHTML = '<div class="text-red-400 font-semibold mb-2">Ask Book</div>' + 
          processedAsks.map(a => `<div>${a.size.toFixed(3)} @ ${Utils.formatCurrency(a.price, '$', 2)}</div>`).join('');
      }
      
      updatePriceChart(klines) {
        if (!klines || klines.length === 0) {
          this.charts.price.data.datasets[0].data = [];
          this.charts.price.data.datasets[1].data = [];
          this.charts.price.update('none');
          return;
        }

        this.charts.price.data.datasets[0].data = klines.map(k => ({
          x: k.time, o: k.open, h: k.high, l: k.low, c: k.close
        }));

        // Calculate and add a simple moving average (e.g., SMA20)
        const closes = klines.map(k => k.close);
        const smaPeriod = 20;
        if (closes.length >= smaPeriod) {
            const sma = ss.slidingWindow(closes, smaPeriod, ss.mean);
            this.charts.price.data.datasets[1].data = klines.slice(smaPeriod - 1).map((k, i) => ({
                x: k.time,
                y: sma[i]
            }));
        } else {
            this.charts.price.data.datasets[1].data = [];
        }
        
        this.charts.price.update('none');
      }

      updateIndicatorChart(klines, indicators) {
        if (!klines || klines.length === 0) {
          this.charts.indicator.data.datasets[0].data = [];
          this.charts.indicator.data.datasets[1].data = [];
          this.charts.indicator.data.datasets[2].data = [];
          this.charts.indicator.data.datasets[3].data = [];
          this.charts.indicator.update('none');
          return;
        }

        const times = klines.map(k => k.time);
        const closes = klines.map(k => k.close);
        
        const rsiData = [];
        const macdData = [];
        const signalData = [];
        const histogramData = [];

        // Calculate historical indicators for the chart. This is computationally intensive
        // if done for every update with a large `klines` array.
        // Optimization: only recalculate if `klines` has genuinely new data.
        if (klines[klines.length - 1].time !== this.lastKlineTimestamp) {
            for (let i = 0; i < closes.length; i++) {
                const subCloses = closes.slice(0, i + 1);
                
                // RSI
                const rsi = Utils.calculateRSI(subCloses);
                if (rsi !== null) rsiData.push({ x: times[i], y: rsi });

                // MACD
                const macdResult = Utils.calculateMACD(subCloses);
                if (macdResult.macd !== null && macdResult.signal !== null && macdResult.histogram !== null) {
                    // Align MACD data to the corresponding kline time
                    macdData.push({ x: times[i], y: macdResult.macd });
                    signalData.push({ x: times[i], y: macdResult.signal });
                    histogramData.push({ x: times[i], y: macdResult.histogram });
                }
            }
            this.lastKlineTimestamp = klines[klines.length - 1].time;
        }


        this.charts.indicator.data.datasets[0].data = rsiData;
        this.charts.indicator.data.datasets[1].data = macdData;
        this.charts.indicator.data.datasets[2].data = signalData;
        this.charts.indicator.data.datasets[3].data = histogramData;
        this.charts.indicator.update('none');
      }

      updateRiskChart(currentRiskPercent) {
        this.charts.risk.data.datasets[0].data = [currentRiskPercent, Math.max(0, 100 - currentRiskPercent)];
        this.charts.risk.update('none');
      }
    }

    // --- UI MANAGER ---
    class UIManager {
      constructor(dom) {
        this.dom = dom;
        this.toastContainer = this._createToastContainer();
      }

      _createToastContainer() {
        const container = document.createElement('div');
        container.className = 'fixed bottom-4 right-4 z-[10000] flex flex-col gap-2';
        document.body.appendChild(container);
        return container;
      }

      log(message, type = 'info') {
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
        this.dom.activityLog.prepend(entry);
        if (this.dom.activityLog.children.length > 100) {
          this.dom.activityLog.lastChild.remove();
        }
      }

      showLoading(sectionId = 'loadingOverlay') {
        if (sectionId === 'loadingOverlay') {
          this.dom.loadingOverlay.classList.add('active');
        } else {
          // Add specific loading states for sections if needed
          const section = document.getElementById(sectionId);
          if (section) {
            section.innerHTML = `<div class="text-text-secondary text-center py-4">Loading...</div>`;
          }
        }
      }

      hideLoading(sectionId = 'loadingOverlay') {
        if (sectionId === 'loadingOverlay') {
          this.dom.loadingOverlay.classList.remove('active');
        }
        // Specific section loading indicators would be removed here
      }

      updateWsStatus(status) {
        this.dom.wsStatus.className = `status-indicator status-${status}`;
        this.dom.wsStatusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        if (status === 'connected') {
          this.dom.connectBtn.disabled = true;
          this.dom.disconnectBtn.disabled = false;
        } else {
          this.dom.connectBtn.disabled = false;
          this.dom.disconnectBtn.disabled = true;
        }
      }

      updateMetrics(metrics) {
        this.dom.totalPnL.textContent = Utils.formatCurrency(metrics.totalPnL || 0);
        this.dom.winRate.textContent = Utils.formatPercentage(metrics.winRate || 0);
        this.dom.sharpeRatio.textContent = (metrics.sharpeRatio || 0).toFixed(2);
        this.dom.maxDrawdown.textContent = Utils.formatPercentage(metrics.maxDrawdown || 0);
        this.dom.activeTrades.textContent = metrics.activeTrades || 0;
        this.dom.accountEquity.textContent = Utils.formatCurrency(metrics.accountEquity || 0);
      }

      updateIndicatorValues(indicators) {
        this.dom.rsiValue.textContent = indicators.rsi ? indicators.rsi.toFixed(2) : '--';
        this.dom.macdValue.textContent = indicators.macd?.macd ? indicators.macd.macd.toFixed(2) : '--';
        this.dom.bbValue.textContent = indicators.bb?.width ? indicators.bb.width.toFixed(2) : '--';
        this.dom.volumeValue.textContent = indicators.volume ? Utils.formatCurrency(indicators.volume, '', 2) : '--';
      }

      updatePositionInfo(position) {
        if (position) {
          this.dom.positionSize.textContent = parseFloat(position.size).toFixed(3);
          this.dom.entryPrice.textContent = Utils.formatCurrency(parseFloat(position.avgPrice));
          this.dom.unrealizedPnL.textContent = Utils.formatCurrency(parseFloat(position.unrealizedPnl));
          this.dom.marginUsed.textContent = Utils.formatCurrency(parseFloat(position.liabFee || position.occHoldingCost || 0)); // Approx margin used
        } else {
          this.dom.positionSize.textContent = '0.000';
          this.dom.entryPrice.textContent = '--';
          this.dom.unrealizedPnL.textContent = '$0.00';
          this.dom.marginUsed.textContent = '$0.00';
        }
      }

      renderPositions(positions) {
        const tbody = this.dom.positionsDisplay;
        tbody.innerHTML = '';
        if (positions && positions.length > 0) {
          positions.forEach(p => {
            if (parseFloat(p.size) === 0) return; // Only show active positions
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${p.symbol}</td>
              <td class="${p.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${p.side}</td>
              <td>${parseFloat(p.size).toFixed(3)}</td>
              <td>${Utils.formatCurrency(parseFloat(p.avgPrice))}</td>
              <td>${Utils.formatCurrency(parseFloat(p.liqPrice))}</td>
              <td class="${parseFloat(p.unrealizedPnl) >= 0 ? 'text-green-400' : 'text-red-400'}">${Utils.formatCurrency(parseFloat(p.unrealizedPnl))}</td>
              <td><button class="btn btn-danger btn-sm close-position-btn" data-symbol="${p.symbol}" data-side="${p.side}">Close</button></td>
            `;
            tbody.appendChild(tr);
          });
        }
        if (tbody.children.length === 0) {
          tbody.innerHTML = `<tr><td colspan="7" class="text-text-secondary text-center">No active positions</td></tr>`;
        }
      }

      renderOpenOrders(orders) {
        const tbody = this.dom.ordersDisplay;
        tbody.innerHTML = '';
        if (orders && orders.length > 0) {
          orders.forEach(o => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${o.orderId.substring(0, 8)}...</td>
              <td>${o.symbol}</td>
              <td class="${o.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${o.side}</td>
              <td>${o.orderType}</td>
              <td>${Utils.formatCurrency(parseFloat(o.price))}</td>
              <td>${parseFloat(o.qty).toFixed(3)}</td>
              <td>${o.orderStatus}</td>
              <td><button class="btn btn-danger btn-sm cancel-order-btn" data-order-id="${o.orderId}" data-symbol="${o.symbol}">Cancel</button></td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          tbody.innerHTML = `<tr><td colspan="8" class="text-text-secondary text-center">No open orders</td></tr>`;
        }
      }

      renderTradeHistory(history) {
        const tbody = this.dom.historyDisplay;
        tbody.innerHTML = '';
        if (history && history.length > 0) {
          history.forEach(t => {
            const tr = document.createElement('tr');
            const pnl = parseFloat(t.execPnl);
            tr.innerHTML = `
              <td>${new Date(parseInt(t.execTime)).toLocaleString()}</td>
              <td>${t.symbol}</td>
              <td class="${t.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${t.side}</td>
              <td>${parseFloat(t.execQty).toFixed(3)}</td>
              <td>${Utils.formatCurrency(parseFloat(t.execPrice))}</td>
              <td>${parseFloat(t.execFee).toFixed(4)}</td>
              <td class="${pnl >= 0 ? 'text-green-400' : 'text-red-400'}">${Utils.formatCurrency(pnl)}</td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          tbody.innerHTML = `<tr><td colspan="7" class="text-text-secondary text-center">No trade history</td></tr>`;
        }
      }

      /**
       * Creates and displays a toast notification.
       * @param {string} message - The message to display.
       * @param {'info'|'success'|'warning'|'error'} [type='info'] - The type of toast.
       * @param {number} [duration=3000] - The display duration in milliseconds.
       */
      showToast(message, type = 'info', duration = 3000) {
        const toast = document.createElement('div');
        toast.className = `p-3 rounded-lg shadow-lg text-white text-sm flex items-center gap-2
                           ${type === 'success' ? 'bg-green-600' : ''}
                           ${type === 'error' ? 'bg-red-600' : ''}
                           ${type === 'warning' ? 'bg-orange-500' : ''}
                           ${type === 'info' ? 'bg-blue-500' : ''}`;
        toast.innerHTML = `
          <span>${message}</span>
          <button class="ml-auto text-white opacity-75 hover:opacity-100" onclick="this.parentElement.remove()">
            &times;
          </button>
        `;
        this.toastContainer.appendChild(toast);
        setTimeout(() => toast.remove(), duration);
      }

      // Enable/Disable AI signal buttons
      setAISignalButtons(enable) {
        this.dom.executeBuyBtn.disabled = !enable;
        this.dom.executeSellBtn.disabled = !enable;
        this.dom.executeHoldBtn.disabled = !enable;
      }
    }

    // --- AI MANAGER ---
    class AIManager {
      constructor(logger) {
        this.logger = logger;
        this.genAI = null;
      }

      init(apiKey) {
        if (apiKey) {
          this.genAI = new GoogleGenerativeAI(apiKey);
        } else {
          this.logger('Gemini API Key not set. AI features disabled.', 'warning');
          this.genAI = null;
        }
      }

      /**
       * Analyzes market data using Google Gemini AI.
       * @param {string} customPrompt - A custom user prompt.
       * @param {Object} data - Market and position data.
       * @returns {Promise<Object>} The parsed AI signal object.
       */
      async analyze(customPrompt, data) {
        if (!this.genAI) {
          throw new Error('Gemini AI not initialized. Please provide an API key.');
        }

        const model = this.genAI.getGenerativeModel({ model: CONSTANTS.GEMINI_MODEL });
        const analysisPrompt = this._buildAIPrompt(customPrompt, data);

        try {
          const result = await model.generateContent(analysisPrompt);
          const response = await result.response;
          const text = response.text();
          return this._parseAIOutput(text);
        } catch (error) {
          this.logger(`Gemini AI Generation Error: ${error.message}`, 'error');
          throw error;
        }
      }
      
      _buildAIPrompt(customPrompt, data) {
        const { klines, orderBook, position, analysisMode, symbol, timeframe, accountBalance } = data;
        const latestKline = klines[klines.length - 1];
        const closes = klines.map(k => k.close);
        const rsi = Utils.calculateRSI(closes);
        const macd = Utils.calculateMACD(closes);
        const bb = Utils.calculateBollingerBands(closes);

        const marketData = {
          latestPrice: latestKline?.close,
          volume: latestKline?.volume,
          orderBook: {
            bids: orderBook.bids.slice(0, 5).map(b => ({ price: b.price.toFixed(2), size: b.size.toFixed(3) })),
            asks: orderBook.asks.slice(0, 5).map(a => ({ price: a.price.toFixed(2), size: a.size.toFixed(3) }))
          },
          technicalIndicators: {
            rsi: rsi ? rsi.toFixed(2) : 'N/A',
            macd: macd.macd ? macd.macd.toFixed(2) : 'N/A',
            signal: macd.signal ? macd.signal.toFixed(2) : 'N/A',
            histogram: macd.histogram ? macd.histogram.toFixed(2) : 'N/A',
            bollingerBands: {
              upper: bb.upper ? bb.upper.toFixed(2) : 'N/A',
              middle: bb.middle ? bb.middle.toFixed(2) : 'N/A',
              lower: bb.lower ? bb.lower.toFixed(2) : 'N/A',
              width: bb.width ? bb.width.toFixed(2) : 'N/A'
            }
          },
          currentPosition: position ? {
            symbol: position.symbol,
            side: position.side,
            size: parseFloat(position.size).toFixed(3),
            entryPrice: parseFloat(position.avgPrice).toFixed(2),
            unrealizedPnl: parseFloat(position.unrealizedPnl).toFixed(2)
          } : 'None',
          accountEquity: accountBalance ? parseFloat(accountBalance.equity).toFixed(2) : 'N/A'
        };

        const promptTemplate = `
          You are a sophisticated crypto trading AI. Analyze the provided market data and generate a trading signal.
          The signal should be a JSON object with the following structure:
          {
            "action": "BUY" | "SELL" | "HOLD",
            "quantity": number, // Suggested trade size in contracts. 0 for HOLD.
            "confidence": "LOW" | "MEDIUM" | "HIGH",
            "reason": string, // Detailed explanation for the decision.
            "targetPrice": number | null, // Optional target price for TP
            "stopLossPrice": number | null // Optional stop loss price
          }

          **Current Market Context:**
          Symbol: ${symbol}
          Timeframe: ${timeframe}
          Trading Strategy: ${analysisMode}
          Market Data: ${JSON.stringify(marketData, null, 2)}

          ${customPrompt ? `**Additional Instructions from User:**\n${customPrompt}\n` : ''}

          Consider risk management and current account equity when determining quantity.
          Provide only the JSON object. Do not include any other text or formatting.
        `;

        return promptTemplate;
      }

      _parseAIOutput(text) {
        try {
          // Robust parsing to handle potential markdown code blocks
          const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/);
          if (jsonMatch && jsonMatch[1]) {
            return JSON.parse(jsonMatch[1]);
          }
          return JSON.parse(text); // Fallback to direct parse
        } catch (e) {
          this.logger(`Failed to parse AI response as JSON: ${e.message}. Raw text: ${text}`, 'error');
          throw new Error('AI response could not be parsed. Check raw output.');
        }
      }
    }

    // --- MAIN TRADING APPLICATION CLASS ---
    class TradingApp {
      constructor() {
        this.dom = this._getDomElements();
        this.ui = new UIManager(this.dom);
        this.bybitClient = new BybitClient(this.ui.log.bind(this.ui));
        this.bybitWs = new BybitWebSocket(this.ui.log.bind(this.ui));
        this.chartManager = new ChartManager(this.dom, this.ui.log.bind(this.ui));
        this.aiManager = new AIManager(this.ui.log.bind(this.ui));
        
        this.state = this._getInitialState();
        
        this._bindEventListeners();
        this._initialize();
      }

      _getDomElements() {
        // Collects all necessary DOM elements for easy access.
        const ids = [
          'loadingOverlay', 'totalPnL', 'winRate', 'sharpeRatio', 'maxDrawdown', 'activeTrades', 'accountEquity',
          'toggleAdvancedBtn', 'geminiApiKey', 'bybitApiKey', 'bybitApiSecret', 'advancedSettings', 'maxPosition',
          'riskPerTrade', 'leverage', 'orderType', 'tpPercent', 'slPercent', 'trailingStop', 'enableTpSl',
          'enableTrailing', 'enableKelly', 'tradingMode', 'saveConfigBtn', 'loadConfigBtn', 'clearConfigBtn',
          'configStatus', 'wsStatus', 'wsStatusText', 'symbolSelect', 'timeframe', 'connectBtn', 'disconnectBtn',
          'orderBookChart', 'bidBookDisplay', 'askBookDisplay', 'priceChart', 'rsiValue', 'macdValue', 'bbValue',
          'volumeValue', 'indicatorChart', 'customPromptBtn', 'customPromptSection', 'customPrompt', 'analysisMode',
          'analyzeBtn', 'aiOutput', 'executeBuyBtn', 'executeSellBtn', 'executeHoldBtn', 'refreshPositionsBtn',
          'positionSize', 'entryPrice', 'unrealizedPnL', 'marginUsed', 'positionsDisplay', 'ordersDisplay',
          'historyDisplay', 'portfolioRisk', 'varValue', 'kellyPercent', 'riskScore', 'riskChart', 'activityLog',
          'clearLogsBtn'
        ];
        const elements = {};
        ids.forEach(id => elements[id] = document.getElementById(id));
        return elements;
      }

      _getInitialState() {
        return {
          currentSymbol: 'BTCUSDT',
          currentTimeframe: '5', // Bybit uses string for interval e.g. '1', '5', '60', 'D'
          orderBook: { bids: [], asks: [] },
          klines: [], // Array of {time: ms, open, high, low, close, volume}
          indicators: {},
          accountBalance: null, // Full balance object from Bybit
          positions: [],
          openOrders: [],
          tradeHistory: [],
          lastSignal: null,
          pnlHistory: [], // For Sharpe ratio, Max Drawdown
          equityCurve: [], // For Max Drawdown
        };
      }

      _bindEventListeners() {
        this.dom.saveConfigBtn.addEventListener('click', () => this.saveConfiguration());
        this.dom.loadConfigBtn.addEventListener('click', () => this.loadConfiguration());
        this.dom.clearConfigBtn.addEventListener('click', () => this.clearConfiguration());
        this.dom.toggleAdvancedBtn.addEventListener('click', () => this.dom.advancedSettings.classList.toggle('hidden'));
        this.dom.clearLogsBtn.addEventListener('click', () => this.dom.activityLog.innerHTML = '<div class="text-text-secondary">Logs cleared...</div>');

        this.dom.connectBtn.addEventListener('click', () => this.connect());
        this.dom.disconnectBtn.addEventListener('click', () => this.disconnect());
        this.dom.symbolSelect.addEventListener('change', (e) => this.handleSymbolChange(e.target.value));
        this.dom.timeframe.addEventListener('change', (e) => this.handleTimeframeChange(e.target.value));

        document.querySelectorAll('.tab-nav .tab-btn').forEach(btn => {
          btn.addEventListener('click', (e) => this.handleTabSwitch(e));
        });
        
        this.dom.analyzeBtn.addEventListener('click', () => this.runAnalysis());
        this.dom.customPromptBtn.addEventListener('click', () => this.dom.customPromptSection.classList.toggle('hidden'));
        this.dom.executeBuyBtn.addEventListener('click', () => this.executeSignal('BUY'));
        this.dom.executeSellBtn.addEventListener('click', () => this.executeSignal('SELL'));
        this.dom.executeHoldBtn.addEventListener('click', () => this.ui.showToast('AI recommends HOLD. No action taken.', 'info'));
        this.dom.refreshPositionsBtn.addEventListener('click', () => this.fetchAccountInfo());

        // Event delegation for position and order actions
        this.dom.positionsDisplay.addEventListener('click', (e) => {
          if (e.target.classList.contains('close-position-btn')) {
            this.closePosition(e.target.dataset.symbol, e.target.dataset.side);
          }
        });
        this.dom.ordersDisplay.addEventListener('click', (e) => {
          if (e.target.classList.contains('cancel-order-btn')) {
            this.cancelOrder(e.target.dataset.symbol, e.target.dataset.orderId);
          }
        });

        this.bybitWs.on('status', (status) => this.ui.updateWsStatus(status));
        this.bybitWs.on('message', (data) => this._handleWsMessage(data));

        this.bybitClient.on('error', (msg) => this.ui.showToast(msg, 'error'));
      }

      async _initialize() {
        this.ui.log('System Initializing...', 'info');
        this.ui.showLoading();
        this.chartManager.initCharts();
        this.loadConfiguration(); // Loads saved config, populates API keys, sets trading mode
        await this.populateSymbols();
        await this.fetchInitialData(); // Fetch klines and init orderbook display
        this.ui.hideLoading();
        this.ui.log('Initialization Complete. Ready to connect.', 'success');
      }

      saveConfiguration() {
        try {
          const config = {
            geminiApiKey: this.dom.geminiApiKey.value,
            bybitApiKey: this.dom.bybitApiKey.value,
            bybitApiSecret: this.dom.bybitApiSecret.value,
            tradingMode: this.dom.tradingMode.value,
            maxPosition: this.dom.maxPosition.value,
            riskPerTrade: this.dom.riskPerTrade.value,
            leverage: this.dom.leverage.value,
            orderType: this.dom.orderType.value,
            tpPercent: this.dom.tpPercent.value,
            slPercent: this.dom.slPercent.value,
            trailingStop: this.dom.trailingStop.value,
            enableTpSl: this.dom.enableTpSl.checked,
            enableTrailing: this.dom.enableTrailing.checked,
            enableKelly: this.dom.enableKelly.checked,
            currentSymbol: this.state.currentSymbol,
            currentTimeframe: this.state.currentTimeframe
          };
          const encryptedConfig = Utils.encrypt(JSON.stringify(config), CONSTANTS.ENCRYPTION_KEY);
          localStorage.setItem('tradingBotConfig', encryptedConfig);
          this.ui.log('Configuration saved and encrypted.', 'success');
          this.ui.showToast('Configuration saved!', 'success');
        } catch (e) {
          this.ui.log('Failed to save configuration: ' + e.message, 'error');
          this.ui.showToast('Failed to save configuration.', 'error');
        }
      }

      loadConfiguration() {
        const encryptedConfig = localStorage.getItem('tradingBotConfig');
        if (encryptedConfig) {
          try {
            const config = JSON.parse(Utils.decrypt(encryptedConfig, CONSTANTS.ENCRYPTION_KEY));
            this.dom.geminiApiKey.value = config.geminiApiKey || '';
            this.dom.bybitApiKey.value = config.bybitApiKey || '';
            this.dom.bybitApiSecret.value = config.bybitApiSecret || '';
            this.dom.tradingMode.value = config.tradingMode || 'testnet';
            this.dom.maxPosition.value = config.maxPosition || '0.01';
            this.dom.riskPerTrade.value = config.riskPerTrade || '1';
            this.dom.leverage.value = config.leverage || '10';
            this.dom.orderType.value = config.orderType || 'Market';
            this.dom.tpPercent.value = config.tpPercent || '2';
            this.dom.slPercent.value = config.slPercent || '1';
            this.dom.trailingStop.value = config.trailingStop || '0.5';
            this.dom.enableTpSl.checked = config.enableTpSl !== undefined ? config.enableTpSl : true;
            this.dom.enableTrailing.checked = config.enableTrailing || false;
            this.dom.enableKelly.checked = config.enableKelly || false;
            this.state.currentSymbol = config.currentSymbol || 'BTCUSDT';
            this.state.currentTimeframe = config.currentTimeframe || '5';

            // Ensure dropdowns are updated after setting value
            this.dom.symbolSelect.value = this.state.currentSymbol;
            this.dom.timeframe.value = this.state.currentTimeframe;

            this.bybitClient.setCredentials(config.bybitApiKey, config.bybitApiSecret, this.dom.tradingMode.value);
            this.bybitWs.setTradingMode(this.dom.tradingMode.value);
            this.aiManager.init(config.geminiApiKey);
            this.ui.log('Configuration loaded and decrypted.', 'info');
            this.ui.showToast('Configuration loaded!', 'info');
          } catch (e) {
            this.ui.log('Failed to load or decrypt configuration. It may be corrupted: ' + e.message, 'error');
            this.ui.showToast('Failed to load config. It might be corrupted.', 'error');
            localStorage.removeItem('tradingBotConfig');
          }
        }
      }
      
      clearConfiguration() {
        localStorage.removeItem('tradingBotConfig');
        this.dom.geminiApiKey.value = '';
        this.dom.bybitApiKey.value = '';
        this.dom.bybitApiSecret.value = '';
        this.bybitClient.setCredentials('', '', 'testnet');
        this.bybitWs.setTradingMode('testnet');
        this.aiManager.init('');
        this.ui.log('Configuration cleared.', 'warning');
        this.ui.showToast('Configuration cleared!', 'warning');
      }

      async connect() {
        if (this.bybitWs.isConnected) return;
        this.ui.showLoading();
        this.bybitClient.setCredentials(this.dom.bybitApiKey.value, this.dom.bybitApiSecret.value, this.dom.tradingMode.value);
        this.bybitWs.setTradingMode(this.dom.tradingMode.value);
        this.aiManager.init(this.dom.geminiApiKey.value);

        if (!this.dom.bybitApiKey.value || !this.dom.bybitApiSecret.value) {
          this.ui.log('Bybit API Key and Secret are required to connect.', 'error');
          this.ui.showToast('Please enter Bybit API credentials.', 'error');
          this.ui.hideLoading();
          return;
        }

        try {
          // Pre-fetch account info before connecting WS to ensure API keys are valid
          await this.bybitClient.getWalletBalance(); // Test API key validity
          await this.fetchAccountInfo(); // Fetch initial positions/orders

          this.bybitWs.connect(); // Connect WebSocket
          this.subscribeToTopics(); // Subscribe to relevant topics
        } catch (error) {
          this.ui.log(`Connection failed: ${error.message}`, 'error');
          this.ui.showToast(`Connection failed: ${error.message}`, 'error');
          this.disconnect();
        } finally {
          this.ui.hideLoading();
        }
      }
      
      disconnect() {
        this.bybitWs.disconnect();
        this.ui.log('Disconnected from Bybit.', 'info');
        this.ui.showToast('Disconnected from Bybit.', 'info');
      }

      async populateSymbols() {
        try {
          const symbols = await this.bybitClient.getValidSymbols();
          this.dom.symbolSelect.innerHTML = symbols.map(s => `<option value="${s}">${s}</option>`).join('');
          this.dom.symbolSelect.value = this.state.currentSymbol; // Set to saved or default symbol
          this.ui.log(`Loaded ${symbols.length} valid trading symbols.`, 'info');
        } catch (error) {
          this.ui.log('Failed to load symbols.', 'error');
          this.dom.symbolSelect.innerHTML = '<option>Error loading</option>';
          this.ui.showToast('Failed to load symbols.', 'error');
        }
      }
      
      async handleSymbolChange(newSymbol) {
        this.ui.log(`Symbol changed to ${newSymbol}`, 'info');
        if (this.bybitWs.isConnected) {
          this.unsubscribeFromTopics();
          this.state.currentSymbol = newSymbol;
          await this.fetchInitialData();
          await this.fetchAccountInfo();
          this.subscribeToTopics();
        } else {
          this.state.currentSymbol = newSymbol;
          await this.fetchInitialData(); // Update charts with new symbol's historical data
        }
      }
      
      async handleTimeframeChange(newTimeframe) {
        this.ui.log(`Timeframe changed to ${newTimeframe}`, 'info');
        if (this.bybitWs.isConnected) {
          this.unsubscribeFromTopics();
          this.state.currentTimeframe = newTimeframe;
          await this.fetchInitialData();
          this.subscribeToTopics();
        } else {
          this.state.currentTimeframe = newTimeframe;
          await this.fetchInitialData();
        }
      }

      async fetchInitialData() {
        this.ui.showLoading();
        try {
          const klinesResult = await this.bybitClient.getKlines(this.state.currentSymbol, this.state.currentTimeframe);
          this.state.klines = klinesResult.list.map(k => ({
            time: parseInt(k[0]), // Timestamp in milliseconds
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5]),
          })).reverse(); // Bybit usually returns klines in descending order of time, reverse for chronological

          this._updateChartsAndIndicators();
          this.ui.log(`Fetched ${this.state.klines.length} historical klines for ${this.state.currentSymbol}.`, 'info');
        } catch (error) {
          this.ui.log(`Failed to fetch initial market data: ${error.message}`, 'error');
          this.ui.showToast('Failed to fetch initial market data.', 'error');
        } finally {
          this.ui.hideLoading();
        }
      }

      // Debounced version of fetchAccountInfo to prevent excessive API calls
      debouncedFetchAccountInfo = Utils.debounce(async () => {
        try {
          const [balance, positions, openOrders, tradeHistory] = await Promise.all([
            this.bybitClient.getWalletBalance(),
            this.bybitClient.getPositions(this.state.currentSymbol),
            this.bybitClient.getOpenOrders(this.state.currentSymbol),
            this.bybitClient.getTradeHistory(this.state.currentSymbol)
          ]);
          this.state.accountBalance = balance;
          this.state.positions = positions.filter(p => parseFloat(p.size) > 0); // Filter out zero positions
          this.state.openOrders = openOrders;
          this.state.tradeHistory = tradeHistory;

          const currentPosition = this.state.positions.find(p => p.symbol === this.state.currentSymbol);
          this.ui.updatePositionInfo(currentPosition);
          this.ui.renderPositions(this.state.positions);
          this.ui.renderOpenOrders(this.state.openOrders);
          this.ui.renderTradeHistory(this.state.tradeHistory);
          this.ui.log('Account info, positions, orders, and history refreshed.', 'info');
          this._calculateMetrics();
        } catch (error) {
          this.ui.log(`Failed to fetch account info: ${error.message}`, 'error');
          this.ui.showToast('Failed to fetch account info.', 'error');
        }
      }, 1000); // 1-second debounce

      async fetchAccountInfo() {
        this.debouncedFetchAccountInfo();
      }

      _calculateMetrics() {
        const totalPnL = this.state.tradeHistory.reduce((sum, t) => sum + parseFloat(t.execPnl), 0);
        const winningTrades = this.state.tradeHistory.filter(t => parseFloat(t.execPnl) > 0).length;
        const totalTrades = this.state.tradeHistory.length;
        const winRate = totalTrades > 0 ? winningTrades / totalTrades : 0;
        
        // Sharpe Ratio calculation
        const returns = this.state.tradeHistory.map(t => parseFloat(t.execPnl));
        const sharpeRatio = Utils.calculateSharpeRatio(returns);

        // Max Drawdown calculation - needs actual equity curve over time for accuracy
        let maxDrawdown = 0;
        if (this.state.equityCurve.length > 0) {
          let peak = this.state.equityCurve[0];
          for (let i = 1; i < this.state.equityCurve.length; i++) {
            if (this.state.equityCurve[i] > peak) {
              peak = this.state.equityCurve[i];
            }
            const drawdown = (peak - this.state.equityCurve[i]) / peak;
            if (drawdown > maxDrawdown) {
              maxDrawdown = drawdown;
            }
          }
        }

        const accountEquity = this.state.accountBalance ? parseFloat(this.state.accountBalance.equity) : 0;
        
        const metrics = {
          totalPnL: totalPnL,
          winRate: winRate,
          sharpeRatio: sharpeRatio || 0,
          maxDrawdown: maxDrawdown,
          activeTrades: this.state.positions.length,
          accountEquity: accountEquity
        };
        this.ui.updateMetrics(metrics);

        // Update risk chart
        const unrealizedPnl = this.state.positions.reduce((sum, p) => sum + parseFloat(p.unrealizedPnl), 0);
        let currentRiskPercent = 0;
        if (accountEquity > 0) {
          currentRiskPercent = (unrealizedPnl / accountEquity) * 100;
        }
        this.ui.updateRiskChart(Math.max(0, Math.min(100, currentRiskPercent)));
        this.dom.portfolioRisk.textContent = currentRiskPercent >= 10 ? 'High' : (currentRiskPercent >= 2 ? 'Medium' : 'Low');
        this.dom.riskScore.textContent = `${currentRiskPercent.toFixed(0)}/100`;

        // Update Kelly Criterion display (placeholder logic)
        if (this.dom.enableKelly.checked) {
          const winProbability = metrics.winRate; // From actual trades or estimated
          const riskRewardRatio = 2; // Example: assuming 1:2 risk/reward for Kelly formula
          // f = W - (1-W)/R  where W=win probability, R=win/loss ratio
          const kellyFraction = winProbability - (1 - winProbability) / riskRewardRatio;
          this.dom.kellyPercent.textContent = kellyFraction > 0 ? Utils.formatPercentage(kellyFraction) : '0%';
        } else {
          this.dom.kellyPercent.textContent = 'Disabled';
        }

        // VaR (Value at Risk) - requires historical volatility and position sizing. Placeholder.
        const var95 = accountEquity * 0.05; // Very simplified: 5% of equity at risk
        this.dom.varValue.textContent = Utils.formatCurrency(var95);
      }

      subscribeToTopics() {
        const topics = [
          `orderbook.${CONSTANTS.ORDER_BOOK_DEPTH}.${this.state.currentSymbol}`,
          `kline.${this.state.currentTimeframe}.${this.state.currentSymbol}`,
          `position.linear`, // For all linear positions
          `order.linear`,    // For all linear orders
          `execution.linear` // For all linear executions
        ];
        this.bybitWs.subscribe(topics);
      }
      
      unsubscribeFromTopics() {
         const topics = [
          `orderbook.${CONSTANTS.ORDER_BOOK_DEPTH}.${this.state.currentSymbol}`,
          `kline.${this.state.currentTimeframe}.${this.state.currentSymbol}`,
        ];
        this.bybitWs.unsubscribe(topics);
      }

      _handleWsMessage(data) {
        if (data.topic?.startsWith('orderbook')) {
          this._updateOrderBook(data.data);
        } else if (data.topic?.startsWith('kline')) {
          this._updateKlines(data.data[0]);
        } else if (data.topic === 'position.linear' || data.topic === 'order.linear' || data.topic === 'execution.linear') {
          // Debounce fetching account info to avoid API rate limits from frequent WS updates
          this.fetchAccountInfo();
        }
      }
      
      _updateOrderBook(data) {
        this.state.orderBook.bids = data.b.map(d => ({ price: parseFloat(d[0]), size: parseFloat(d[1]) }));
        this.state.orderBook.asks = data.a.map(d => ({ price: parseFloat(d[0]), size: parseFloat(d[1]) }));
        this.chartManager.updateOrderBook(this.state.orderBook.bids, this.state.orderBook.asks);
      }
      
      _updateKlines(kline) {
        const newKline = {
            time: parseInt(kline.start), // Timestamp in milliseconds
            open: parseFloat(kline.open),
            high: parseFloat(kline.high),
            low: parseFloat(kline.low),
            close: parseFloat(kline.close),
            volume: parseFloat(kline.volume),
        };
        
        const lastKline = this.state.klines[this.state.klines.length - 1];
        if (lastKline && newKline.time === lastKline.time) {
            // Update last kline if it's still forming
            this.state.klines[this.state.klines.length - 1] = newKline;
        } else {
            // Add new kline
            this.state.klines.push(newKline);
            if (this.state.klines.length > CONSTANTS.MAX_KLINES_DISPLAY) {
              this.state.klines.shift(); // Keep array size limited
            }
        }
        this._updateChartsAndIndicators();
      }

      _updateChartsAndIndicators() {
        this.chartManager.updatePriceChart(this.state.klines);
        this._calculateAndDisplayIndicators();
      }
      
      _calculateAndDisplayIndicators() {
        if (this.state.klines.length === 0) return;

        const closes = this.state.klines.map(k => k.close);
        const volumes = this.state.klines.map(k => k.volume);
        
        const rsi = Utils.calculateRSI(closes);
        const macd = Utils.calculateMACD(closes);
        const bb = Utils.calculateBollingerBands(closes);
        const currentVolume = volumes[volumes.length - 1];

        this.state.indicators = { rsi, macd, bb, volume: currentVolume };
        this.ui.updateIndicatorValues(this.state.indicators);
        this.chartManager.updateIndicatorChart(this.state.klines, this.state.indicators);
      }

      handleTabSwitch(event) {
        const tabName = event.target.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
        document.getElementById(`tab-${tabName}`).classList.remove('hidden');
        document.querySelectorAll('.tab-nav .tab-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
        // Re-render charts on tab switch to ensure they are properly sized
        const chartElementId = `${tabName}Chart`; // e.g., 'orderBookChart', 'priceChart'
        if (this.dom[chartElementId] && this.chartManager.charts[tabName]) {
            this.chartManager.charts[tabName].resize();
        }
      }

      async runAnalysis() {
        this.ui.log('Running AI analysis...', 'info');
        this.dom.aiOutput.innerHTML = '<div class="text-text-secondary">Analyzing...</div>';
        this.ui.showLoading();
        this.ui.setAISignalButtons(false); // Disable buttons during analysis
        
        try {
            const customPrompt = this.dom.customPrompt.value.trim();
            const tradingMode = this.dom.analysisMode.value;
            const currentPosition = this.state.positions.find(p => p.symbol === this.state.currentSymbol) || null;

            if (this.state.klines.length < CONSTANTS.METRIC_CALC_PERIODS.BB_PERIOD) {
              throw new Error('Insufficient historical data for a thorough AI analysis.');
            }

            const aiResponse = await this.aiManager.analyze(
              customPrompt,
              {
                klines: this.state.klines,
                orderBook: this.state.orderBook,
                position: currentPosition,
                analysisMode: tradingMode,
                symbol: this.state.currentSymbol,
                timeframe: this.state.currentTimeframe,
                accountBalance: this.state.accountBalance // Pass full balance for AI context
              }
            );

            this.ui.log('AI Analysis Complete.', 'success');
            this.dom.aiOutput.textContent = JSON.stringify(aiResponse, null, 2);
            this.state.lastSignal = aiResponse;
            this.ui.showToast(`AI Signal: ${aiResponse.action} (${aiResponse.confidence})`, 'info');

            // Enable relevant action buttons based on AI signal
            if (aiResponse.action === 'BUY') this.dom.executeBuyBtn.disabled = false;
            if (aiResponse.action === 'SELL') this.dom.executeSellBtn.disabled = false;
            if (aiResponse.action === 'HOLD') this.dom.executeHoldBtn.disabled = false;

        } catch (error) {
            this.ui.log(`AI Analysis Error: ${error.message}`, 'error');
            this.dom.aiOutput.textContent = `Error: ${error.message}`;
            this.ui.showToast(`AI Analysis Failed: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading();
        }
      }
      
      async executeSignal(action) {
        if (!this.state.lastSignal || this.state.lastSignal.action !== action) {
          this.ui.log(`No valid ${action} signal to execute or signal doesn't match.`, 'warning');
          this.ui.showToast(`No valid ${action} signal from AI.`, 'warning');
          return;
        }
        
        this.ui.log(`Executing ${action} signal for ${this.state.lastSignal.quantity} contracts.`, 'info');
        this.ui.showLoading();
        this.ui.setAISignalButtons(false);

        try {
          const latestPrice = this.state.klines[this.state.klines.length - 1]?.close;
          if (!latestPrice) {
            throw new Error('Could not get latest price for order placement.');
          }

          let qty = parseFloat(this.state.lastSignal.quantity);
          const maxPosition = parseFloat(this.dom.maxPosition.value);
          const leverage = parseFloat(this.dom.leverage.value);
          const riskPerTrade = parseFloat(this.dom.riskPerTrade.value) / 100;
          const slPercent = parseFloat(this.dom.slPercent.value) / 100;
          const accountEquity = this.state.accountBalance ? parseFloat(this.state.accountBalance.equity) : 0;
          
          if (accountEquity <= 0) {
            throw new Error('Account equity is zero or negative. Cannot place order.');
          }

          if (this.dom.enableKelly.checked && this.dom.kellyPercent.textContent !== '0%') {
            const kellyFraction = parseFloat(this.dom.kellyPercent.textContent) / 100;
            const kellyQty = (accountEquity * kellyFraction * leverage) / latestPrice;
            qty = Math.min(qty, kellyQty);
            this.ui.log(`Kelly Criterion suggested quantity: ${kellyQty.toFixed(3)}. Using min with AI suggested.`, 'info');
          } else if (riskPerTrade > 0 && slPercent > 0) {
            // Risk-based position sizing: (Equity * Risk%) / (Price * SL%)
            const riskedAmount = accountEquity * riskPerTrade;
            const calculatedQty = riskedAmount / (latestPrice * slPercent / leverage);
            qty = Math.min(qty, calculatedQty);
            this.ui.log(`Risk-based suggested quantity: ${calculatedQty.toFixed(3)}. Using min with AI suggested.`, 'info');
          }

          qty = Math.min(qty, maxPosition); // Ensure not exceeding max position from config
          if (qty <= 0.001) { // Minimum quantity threshold
            throw new Error('Calculated quantity is too small (or zero). Cannot place order.');
          }

          const orderParams = {
            symbol: this.state.currentSymbol,
            side: action === 'BUY' ? 'Buy' : 'Sell',
            orderType: this.dom.orderType.value,
            qty: qty.toFixed(3), // Bybit requires qty to be fixed to precision
            leverage: leverage.toString(),
          };
          
          if (orderParams.orderType === 'Limit') {
            // Simple limit price slightly away from current market. Could be improved.
            orderParams.price = (action === 'BUY' ? (latestPrice * 0.999) : (latestPrice * 1.001)).toFixed(2);
          }

          // TP/SL and Trailing Stop
          if (this.dom.enableTpSl.checked) {
            const tpPct = parseFloat(this.dom.tpPercent.value) / 100;
            const slPct = parseFloat(this.dom.slPercent.value) / 100;
            
            // Override with AI suggested if available and 'safe'
            const targetPrice = this.state.lastSignal.targetPrice || (action === 'BUY' ? (latestPrice * (1 + tpPct)) : (latestPrice * (1 - tpPct)));
            const stopLossPrice = this.state.lastSignal.stopLossPrice || (action === 'BUY' ? (latestPrice * (1 - slPct)) : (latestPrice * (1 + slPct)));

            orderParams.takeProfit = targetPrice.toFixed(2);
            orderParams.stopLoss = stopLossPrice.toFixed(2);
          }

          if (this.dom.enableTrailing.checked && parseFloat(this.dom.trailingStop.value) > 0) {
            // Bybit trailingStop is in points, not percentage, so convert.
            // A 0.5% trailing stop for BTCUSD might be 0.005 * Price.
            // Example: BTC at $30,000, 0.5% trailing delta is $150.
            orderParams.trailingStop = (parseFloat(this.dom.trailingStop.value) / 100 * latestPrice).toFixed(0); 
          }

          const result = await this.bybitClient.placeOrder(orderParams);
          this.ui.log(`Order placed successfully! Order ID: ${result.orderId}`, 'success');
          this.ui.showToast(`Order placed: ${action} ${qty.toFixed(3)} ${this.state.currentSymbol}`, 'success');
          this.fetchAccountInfo(); // Refresh account data
        } catch (error) {
          this.ui.log(`Order execution failed: ${error.message}`, 'error');
          this.ui.showToast(`Order failed: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading();
        }
      }

      async closePosition(symbol, side) {
        this.ui.log(`Attempting to close ${symbol} position (${side})...`, 'info');
        this.ui.showLoading();
        try {
          await this.bybitClient.closePosition(symbol, side);
          this.ui.log(`Position for ${symbol} successfully closed.`, 'success');
          this.ui.showToast(`Closed ${symbol} position.`, 'success');
          this.fetchAccountInfo();
        } catch (error) {
          this.ui.log(`Failed to close position for ${symbol}: ${error.message}`, 'error');
          this.ui.showToast(`Failed to close position: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading();
        }
      }

      async cancelOrder(symbol, orderId) {
        this.ui.log(`Attempting to cancel order ${orderId} for ${symbol}...`, 'info');
        this.ui.showLoading();
        try {
          await this.bybitClient.cancelOrder(symbol, orderId);
          this.ui.log(`Order ${orderId} for ${symbol} successfully cancelled.`, 'success');
          this.ui.showToast(`Cancelled order ${orderId}.`, 'success');
          this.fetchAccountInfo();
        } catch (error) {
          this.ui.log(`Failed to cancel order ${orderId} for ${symbol}: ${error.message}`, 'error');
          this.ui.showToast(`Failed to cancel order: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading();
        }
      }
    }

    // Initialize the App when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.app = new TradingApp();
    });

  </script>
</body>
</html>
