I'll analyze the code and enhance it to ensure the symbol list functions correctly and displays all Bybit symbols. Let me create an improved version of your trading terminal.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bybit V5 Advanced Trading Terminal - AI Enhanced</title>

  <!-- Core Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  
  <!-- Additional Libraries for Enhanced Features -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <!-- Chart.js Financial plugin requires explicit registration -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

  <!-- Google Gemini AI Import Map -->
  <script type="importmap">
  {
    "imports": {
      "@google/generative-ai": "https://esm.sh/@google/generative-ai"
    }
  }
  </script>

  <!-- Main Stylesheet -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600;700&display=swap');
    
    :root {
      --bg-primary: #0a0a1e;
      --bg-secondary: #12122e;
      --bg-tertiary: #1a1a3a;
      --text-primary: #e8e8ff;
      --text-secondary: #a8a8c8;
      --neon-green: #00ff41;
      --neon-orange: #ff9f1c;
      --neon-red: #ff1744;
      --neon-cyan: #00e5ff;
      --neon-purple: #d500f9;
      --neon-yellow: #ffea00;
      --chart-bg: #0f0f2a;
      --shadow-neon: 0 0 20px rgba(0, 229, 255, 0.5);
      --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 50%, rgba(0, 229, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(213, 0, 249, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 1;
    }
    
    .container {
      position: relative;
      z-index: 2;
    }
    
    .card {
      background: var(--bg-tertiary);
      border: 1px solid rgba(0, 229, 255, 0.2);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-neon);
      backdrop-filter: blur(10px);
      transition: var(--transition-smooth);
    }
    
    .card:hover {
      box-shadow: 0 0 30px rgba(0, 229, 255, 0.6);
      transform: translateY(-2px);
    }
    
    .card-header {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(0, 229, 255, 0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .btn {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      color: var(--bg-primary);
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition-smooth);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0, 229, 255, 0.4);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    
    .btn-secondary {
      background: transparent;
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, var(--neon-red), var(--neon-orange));
    }
    
    .btn-success {
      background: linear-gradient(135deg, var(--neon-green), var(--neon-cyan));
    }

    .btn-sm {
      padding: 6px 12px;
      font-size: 0.75rem;
    }
    
    input, textarea, select {
      background: var(--bg-primary);
      border: 2px solid rgba(0, 229, 255, 0.3);
      color: var(--text-primary);
      padding: 10px 14px;
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      transition: var(--transition-smooth);
      width: 100%;
    }
    
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--neon-cyan);
      box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
    }
    
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }
    
    .status-connected {
      background: var(--neon-green);
      box-shadow: 0 0 10px var(--neon-green);
    }
    
    .status-disconnected {
      background: var(--neon-red);
      box-shadow: 0 0 10px var(--neon-red);
    }
    
    .status-connecting {
      background: var(--neon-orange);
      box-shadow: 0 0 10px var(--neon-orange);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .metric-card {
      background: linear-gradient(135deg, rgba(0, 229, 255, 0.1), rgba(213, 0, 249, 0.1));
      border: 1px solid rgba(0, 229, 255, 0.3);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }
    
    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
      margin-top: 8px;
    }
    
    .metric-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .chart-container {
      position: relative;
      height: 400px;
      background: var(--chart-bg);
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }

    .chart-container-small {
      position: relative;
      height: 150px; /* Smaller height for volume chart */
      background: var(--chart-bg);
      border-radius: 12px;
      padding: 16px;
      margin-top: 8px;
    }
    
    .tab-nav {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      border-bottom: 2px solid rgba(0, 229, 255, 0.2);
      padding-bottom: 8px;
    }
    
    .tab-btn {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      padding: 8px 16px;
      cursor: pointer;
      transition: var(--transition-smooth);
      font-weight: 500;
      position: relative;
    }
    
    .tab-btn.active {
      color: var(--neon-cyan);
    }
    
    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--neon-cyan);
      box-shadow: 0 0 10px var(--neon-cyan);
    }
    
    .log-container {
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
    }
    
    .log-entry {
      margin-bottom: 8px;
      padding: 4px 8px;
      border-left: 3px solid;
      background: rgba(255, 255, 255, 0.02);
    }
    
    .log-info { border-color: var(--neon-cyan); }
    .log-success { border-color: var(--neon-green); }
    .log-warning { border-color: var(--neon-orange); }
    .log-error { border-color: var(--neon-red); }
    
    .grid-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 30, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: var(--transition-smooth);
    }
    
    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(0, 229, 255, 0.2);
      border-top: 4px solid var(--neon-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 250px;
      background: var(--bg-primary);
      color: var(--text-primary);
      text-align: center;
      border-radius: 8px;
      padding: 8px;
      position: absolute;
      z-index: 10; /* Increased z-index to ensure visibility */
      bottom: 125%;
      left: 50%;
      margin-left: -125px;
      opacity: 0;
      transition: opacity 0.3s;
      border: 1px solid var(--neon-cyan);
      font-size: 0.75rem;
      pointer-events: none; /* Allows clicks to pass through tooltip to elements below */
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
    }

    .data-table th, .data-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0, 229, 255, 0.1);
      text-align: left;
    }

    .data-table th {
      background-color: rgba(0, 229, 255, 0.1);
      font-weight: 600;
      color: var(--neon-cyan);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .data-table tbody tr:hover {
      background-color: rgba(0, 229, 255, 0.05);
    }

    .ai-reason {
      margin-top: 12px;
      padding: 12px;
      background-color: var(--bg-primary);
      border-left: 4px solid var(--neon-cyan);
      font-size: 0.9rem;
      color: var(--text-secondary);
      white-space: pre-wrap; /* Preserve formatting from AI output */
    }

    .api-status-icon {
        margin-left: 8px;
        font-size: 0.9rem;
        vertical-align: middle;
    }
    .api-status-icon.success { color: var(--neon-green); }
    .api-status-icon.error { color: var(--neon-red); }
    
    @media (max-width: 768px) {
      .grid-metrics {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .card {
        padding: 16px;
      }
      
      .tab-nav {
        flex-wrap: wrap;
      }
    }
    
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, var(--neon-purple), var(--neon-cyan));
    }

    /* Symbol search styles */
    .symbol-search-container {
      position: relative;
    }

    .symbol-search-input {
      width: 100%;
      padding: 8px 36px 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(0, 229, 255, 0.3);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .symbol-search-icon {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--neon-cyan);
    }

    .symbol-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: var(--bg-tertiary);
      border: 1px solid rgba(0, 229, 255, 0.3);
      border-radius: 8px;
      margin-top: 4px;
      z-index: 100;
      box-shadow: var(--shadow-neon);
    }

    .symbol-option {
      padding: 10px 12px;
      cursor: pointer;
      transition: var(--transition-smooth);
    }

    .symbol-option:hover {
      background: rgba(0, 229, 255, 0.1);
    }

    .symbol-option.selected {
      background: rgba(0, 229, 255, 0.2);
      color: var(--neon-cyan);
    }

    .symbol-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 8px;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .symbol-category {
      font-weight: 500;
      color: var(--neon-purple);
      margin-bottom: 4px;
      padding-left: 8px;
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
  </div>

  <div class="container mx-auto p-6 max-w-7xl">
    <!-- Header -->
    <div class="text-center mb-8">
      <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-cyan-400 to-purple-500 bg-clip-text text-transparent mb-2">
        Advanced AI Trading Terminal
      </h1>
      <p class="text-text-secondary">Powered by Bybit V5 API & Google Gemini AI</p>
      <p class="text-sm text-neon-red mt-2 p-2 bg-red-900 bg-opacity-30 border border-red-700 rounded-md">
        ‚ö†Ô∏è **SECURITY WARNING:** This is a demonstration for educational purposes. Storing API keys in client-side localStorage (even encrypted) is NOT secure for real trading. Use with extreme caution and on a testnet only. For production, API keys should be managed server-side.
      </p>
    </div>

    <!-- Performance Metrics Dashboard -->
    <div class="grid-metrics">
      <div class="metric-card">
        <div class="metric-label">Total P&L</div>
        <div class="metric-value" id="totalPnL">$0.00</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Win Rate</div>
        <div class="metric-value" id="winRate">0%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Sharpe Ratio</div>
        <div class="metric-value" id="sharpeRatio">0.00</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Max Drawdown</div>
        <div class="metric-value" id="maxDrawdown">0%</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Active Trades</div>
        <div class="metric-value" id="activeTrades">0</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">Account Equity</div>
        <div class="metric-value" id="accountEquity">$0</div>
      </div>
    </div>

    <!-- Configuration Section -->
    <div class="card">
      <div class="card-header">
        <span>‚öôÔ∏è Configuration & API Settings</span>
        <button class="btn btn-secondary btn-sm" id="toggleAdvancedBtn">Advanced Settings</button>
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label for="geminiApiKey">
            Google Gemini API Key <span class="text-neon-red">*</span>
            <span class="tooltip">‚ìò
              <span class="tooltip-text">Your Google AI Studio API key for Gemini analysis. Stored encrypted in your browser.</span>
            </span>
            <span id="geminiApiKeyStatus" class="api-status-icon"></span>
          </label>
          <input type="password" id="geminiApiKey" placeholder="Enter Gemini API Key" required />
        </div>
        <div>
          <label for="bybitApiKey">
            Bybit API Key <span class="text-neon-red">*</span>
            <span class="tooltip">‚ìò
              <span class="tooltip-text">Your Bybit API key with trading permissions. Stored encrypted in your browser.</span>
            </span>
            <span id="bybitApiKeyStatus" class="api-status-icon"></span>
          </label>
          <input type="password" id="bybitApiKey" placeholder="Enter Bybit API Key" required />
        </div>
        <div>
          <label for="bybitApiSecret">
            Bybit API Secret <span class="text-neon-red">*</span>
            <span class="tooltip">‚ìò
              <span class="tooltip-text">Your Bybit API secret for authentication. Stored encrypted in your browser.</span>
            </span>
            <span id="bybitApiSecretStatus" class="api-status-icon"></span>
          </label>
          <input type="password" id="bybitApiSecret" placeholder="Enter Bybit API Secret" required />
        </div>
      </div>

      <div id="advancedSettings" class="hidden">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
          <div>
            <label for="maxPosition">Max Position Size (Contracts)</label>
            <input type="number" id="maxPosition" value="0.01" step="0.001" min="0.001" />
          </div>
          <div>
            <label for="riskPerTrade">Risk Per Trade (%)</label>
            <input type="number" id="riskPerTrade" value="1" step="0.1" min="0.1" max="5" />
          </div>
          <div>
            <label for="leverage">Leverage</label>
            <select id="leverage">
              <option value="1">1x</option>
              <option value="2">2x</option>
              <option value="5">5x</option>
              <option value="10" selected>10x</option>
              <option value="20">20x</option>
              <option value="50">50x</option>
            </select>
          </div>
          <div>
            <label for="orderType">Default Order Type</label>
            <select id="orderType">
              <option value="Market" selected>Market</option>
              <option value="Limit">Limit</option>
            </select>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div>
            <label for="tpPercent">Take Profit (%)</label>
            <input type="number" id="tpPercent" value="2" step="0.1" min="0.1" />
          </div>
          <div>
            <label for="slPercent">Stop Loss (%)</label>
            <input type="number" id="slPercent" value="1" step="0.1" min="0.1" />
          </div>
          <div>
            <label for="trailingStop">Trailing Stop (Delta %)</label>
            <span class="tooltip ml-1">‚ìò
              <span class="tooltip-text">The percentage move from entry at which to activate the trailing stop. e.g., 0.5 means if profit reaches 0.5%, trailing stop activates.</span>
            </span>
            <input type="number" id="trailingStop" value="0.5" step="0.1" min="0" />
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div class="flex items-center gap-4">
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableTpSl" checked class="w-5 h-5" />
              <span>Auto TP/SL</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableTrailing" class="w-5 h-5" />
              <span>Trailing Stop</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="enableKelly" class="w-5 h-5" />
              <span>Kelly Criterion</span>
              <span class="tooltip ml-1">‚ìò
                <span class="tooltip-text">Experimental: Applies Kelly Criterion for optimal position sizing based on estimated win rate and risk/reward.</span>
              </span>
            </label>
          </div>
          <div>
            <label for="tradingMode">Trading Mode</label>
            <select id="tradingMode">
              <option value="testnet" selected>Testnet</option>
              <option value="mainnet">Mainnet</option>
            </select>
          </div>
        </div>
      </div>

      <div class="flex gap-4 mt-4 flex-wrap">
        <button class="btn btn-success" id="saveConfigBtn">Save Configuration</button>
        <button class="btn btn-secondary" id="loadConfigBtn">Load Saved Config</button>
        <button class="btn btn-danger" id="clearConfigBtn">Clear All</button>
        <span id="configStatus" class="flex items-center text-sm"></span>
      </div>
    </div>

    <!-- Market Data Section -->
    <div class="card">
      <div class="card-header">
        <span>üìä Market Data & Analysis</span>
        <div class="flex gap-2">
          <span class="status-indicator" id="wsStatus"></span>
          <span id="wsStatusText">Disconnected</span>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label for="symbolSelect">Trading Symbol</label>
          <div class="symbol-search-container">
            <input 
              type="text" 
              id="symbolSearch" 
              class="symbol-search-input" 
              placeholder="Search symbols..."
              autocomplete="off"
            />
            <span class="symbol-search-icon">üîç</span>
            <div id="symbolDropdown" class="symbol-dropdown hidden"></div>
          </div>
        </div>
        <div>
          <label for="timeframe">Analysis Timeframe</label>
          <select id="timeframe">
            <option value="1">1 Minute</option>
            <option value="5" selected>5 Minutes</option>
            <option value="15">15 Minutes</option>
            <option value="30">30 Minutes</option>
            <option value="60">1 Hour</option>
            <option value="240">4 Hours</option>
            <option value="D">1 Day</option>
          </select>
        </div>
        <div class="flex items-end gap-2">
          <button class="btn flex-1" id="connectBtn">Connect</button>
          <button class="btn btn-secondary flex-1" id="disconnectBtn">Disconnect</button>
        </div>
      </div>

      <!-- Tab Navigation -->
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="orderbook">Order Book</button>
        <button class="tab-btn" data-tab="chart">Price Chart</button>
        <button class="tab-btn" data-tab="indicators">Technical Indicators</button>
        <button class="tab-btn" data-tab="equityCurve">Equity Curve</button>
      </div>

      <!-- Tab Contents -->
      <div id="tab-orderbook" class="tab-content">
        <div class="chart-container">
          <canvas id="orderBookChart"></canvas>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
          <div class="log-container" id="bidBookDisplay">
            <div class="text-green-400 font-semibold mb-2">Bid Book</div>
            <div>Loading...</div>
          </div>
          <div class="log-container" id="askBookDisplay">
            <div class="text-red-400 font-semibold mb-2">Ask Book</div>
            <div>Loading...</div>
          </div>
        </div>
      </div>

      <div id="tab-chart" class="tab-content hidden">
        <div class="chart-container">
          <canvas id="priceChart"></canvas>
        </div>
        <div class="chart-container-small">
          <canvas id="volumeChart"></canvas>
        </div>
      </div>

      <div id="tab-indicators" class="tab-content hidden">
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div class="metric-card">
            <div class="metric-label">RSI</div>
            <div class="metric-value" id="rsiValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">MACD</div>
            <div class="metric-value" id="macdValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">BB Width</div>
            <div class="metric-value" id="bbValue">--</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Volume</div>
            <div class="metric-value" id="volumeValue">--</div>
          </div>
        </div>
        <div class="chart-container mt-4">
          <canvas id="indicatorChart"></canvas>
        </div>
      </div>

      <div id="tab-equityCurve" class="tab-content hidden">
        <div class="chart-container">
          <canvas id="equityChart"></canvas>
        </div>
      </div>
    </div>

    <!-- AI Analysis Section -->
    <div class="card">
      <div class="card-header">
        <span>ü§ñ AI Analysis & Trading Signals</span>
        <button class="btn btn-secondary btn-sm" id="customPromptBtn">Custom Prompt</button>
      </div>

      <div id="customPromptSection" class="hidden mb-4">
        <label for="customPrompt">Custom Analysis Prompt</label>
        <textarea id="customPrompt" rows="3" placeholder="Enter custom instructions for Gemini AI..."></textarea>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div>
          <label for="analysisMode">Analysis Mode</label>
          <select id="analysisMode">
            <option value="conservative">Conservative</option>
            <option value="balanced" selected>Balanced</option>
            <option value="aggressive">Aggressive</option>
            <option value="scalping">Scalping</option>
            <option value="swing">Swing Trading</option>
          </select>
        </div>
        <div class="flex items-end">
          <button class="btn w-full" id="analyzeBtn">üîç Analyze Market</button>
        </div>
      </div>

      <div class="log-container" id="aiOutput" style="max-height: 250px;">
        <div class="text-text-secondary">No analysis performed yet...</div>
      </div>
      <div id="aiReason" class="ai-reason hidden"></div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
        <button class="btn btn-success" id="executeBuyBtn" disabled>Execute Buy Signal</button>
        <button class="btn btn-danger" id="executeSellBtn" disabled>Execute Sell Signal</button>
        <button class="btn btn-secondary" id="executeHoldBtn" disabled>Hold Position</button>
      </div>
    </div>

    <!-- Position & Orders Section -->
    <div class="card">
      <div class="card-header">
        <span>üíº Positions & Orders</span>
        <button class="btn btn-secondary btn-sm" id="refreshPositionsBtn">Refresh</button>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        <div class="metric-card">
          <div class="metric-label">Position Size</div>
          <div class="metric-value" id="positionSize">0.000</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Entry Price</div>
          <div class="metric-value" id="entryPrice">--</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Unrealized P&L</div>
          <div class="metric-value" id="unrealizedPnL">$0.00</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Margin Used</div>
          <div class="metric-value" id="marginUsed">$0.00</div>
        </div>
      </div>

      <div class="tab-nav">
        <button class="tab-btn active" data-tab="positions">Active Positions</button>
        <button class="tab-btn" data-tab="openOrders">Open Orders</button>
        <button class="tab-btn" data-tab="history">Trade History</button>
      </div>

      <div id="tab-positions" class="tab-content">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Side</th>
                <th>Size</th>
                <th>Entry Price</th>
                <th>Liq. Price</th>
                <th>P&L</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="positionsDisplay">
              <tr><td colspan="7" class="text-text-secondary text-center">No active positions</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="tab-openOrders" class="tab-content hidden">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Order ID</th>
                <th>Symbol</th>
                <th>Side</th>
                <th>Type</th>
                <th>Price</th>
                <th>Qty</th>
                <th>Status</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="ordersDisplay">
              <tr><td colspan="8" class="text-text-secondary text-center">No open orders</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="tab-history" class="tab-content hidden">
        <div class="log-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>Time</th>
                <th>Symbol</th>
                <th>Side</th>
                <th>Qty</th>
                <th>Price</th>
                <th>Fee</th>
                <th>P&L</th>
              </tr>
            </thead>
            <tbody id="historyDisplay">
              <tr><td colspan="7" class="text-text-secondary text-center">No trade history</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Risk Management Section -->
    <div class="card">
      <div class="card-header">
        <span>‚ö†Ô∏è Risk Management</span>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div class="metric-card">
          <div class="metric-label">Portfolio Risk</div>
          <div class="metric-value" id="portfolioRisk">Low</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">VaR (95%)</div>
          <div class="metric-value" id="varValue">$0.00</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Kelly %</div>
          <div class="metric-value" id="kellyPercent">0%</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Risk Score</div>
          <div class="metric-value" id="riskScore">0/100</div>
        </div>
      </div>

      <div class="chart-container mt-4">
        <canvas id="riskChart"></canvas>
      </div>
    </div>

    <!-- Activity Log Section -->
    <div class="card">
      <div class="card-header">
        <span>üìú Activity Log</span>
        <button class="btn btn-secondary btn-sm" id="clearLogsBtn">Clear Logs</button>
      </div>
      
      <div class="log-container" id="activityLog" style="height: 200px;">
        <div class="text-text-secondary">System initialized...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { GoogleGenerativeAI } from "@google/generative-ai";

    /**
     * @file bybit_ai_trader.html
     * @description Advanced AI-enhanced crypto trading terminal for Bybit V5 API.
     * Combines real-time market data via WebSockets, AI analysis with Google Gemini,
     * and a comprehensive UI for configuration, trading, and risk management.
     *
     * IMPORTANT SECURITY NOTE: This is for educational and demonstration purposes ONLY.
     * Storing API keys directly in client-side localStorage (even encrypted) is NOT secure
     * for production use with real funds. Always use server-side secure key management
     * and environment variables for any production application.
     */

    // --- CONFIGURATION CONSTANTS ---
    const CONSTANTS = {
      BYBIT_WS_URL: { // WebSocket endpoints for Bybit
        testnet: 'wss://stream-testnet.bybit.com/v5/public/linear',
        mainnet: 'wss://stream.bybit.com/v5/public/linear'
      },
      BYBIT_API_URL: { // REST API endpoints for Bybit
        testnet: 'https://api-testnet.bybit.com',
        mainnet: 'https://api.bybit.com'
      },
      GEMINI_MODEL: 'gemini-1.5-flash', // Model for AI analysis
      WS_PING_INTERVAL: 20000, // Interval in ms to send ping to keep WebSocket alive
      WS_RECONNECT_DELAY: 5000, // Initial delay in ms for WebSocket reconnection attempts
      MAX_KLINES_DISPLAY: 200, // Maximum number of klines to keep in memory for charts
      ENCRYPTION_KEY: 'super-secret-key-for-demo-only-do-not-use-in-production-seriously', // WARNING: For demonstration only. NOT secure for production.
      KLINES_FETCH_LIMIT: 200, // Default limit for fetching historical klines
      ORDER_BOOK_DEPTH: 50, // Number of order book levels to fetch and display
      // PRECISION: This constant will be dynamically populated from exchangeInfo
      METRIC_CALC_PERIODS: { // Periods for various technical indicator and metric calculations
        SHARPE_RATRO_TRADES: 252, // Assuming daily returns for Sharpe Ratio calculation (252 trading days/year)
        RSI_PERIOD: 14, // Standard RSI period
        MACD_FAST: 12, // Standard MACD fast EMA period
        MACD_SLOW: 26, // Standard MACD slow EMA period
        MACD_SIGNAL: 9, // Standard MACD signal line period
        BB_PERIOD: 20, // Standard Bollinger Bands period
        BB_STD_DEV: 2, // Standard Bollinger Bands standard deviation multiplier
        SMA_PERIOD: 20, // Simple Moving Average period for price chart
        EQUITY_CURVE_POINTS: 100 // Max points to store for equity curve chart
      },
      AI_CONFIDENCE_MULTIPLIERS: { // Multipliers to adjust quantity based on AI confidence
        'LOW': 0.5,
        'MEDIUM': 0.75,
        'HIGH': 1.0
      }
    };

    // --- UTILITIES & HELPERS ---
    class Utils {
      /** Encrypts a string using AES with a provided key. */
      static encrypt(text, key) {
        return CryptoJS.AES.encrypt(text, key).toString();
      }

      /** Decrypts an AES encrypted string using a provided key. */
      static decrypt(encryptedText, key) {
        try {
          const bytes = CryptoJS.AES.decrypt(encryptedText, key);
          const originalText = bytes.toString(CryptoJS.enc.Utf8);
          return originalText;
        } catch (e) {
          console.error("Decryption failed:", e);
          return ''; // Return empty string on decryption failure
        }
      }

      /** Debounces a function call to limit its execution frequency. Useful for event handlers. */
      static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      /** Formats a number as a currency string (e.g., $1,234.56). */
      static formatCurrency(amount, symbol = '$', fractionDigits = 2) {
        if (typeof amount !== 'number' || isNaN(amount)) return `${symbol}0.00`; // Handle invalid numbers
        return `${symbol}${new Intl.NumberFormat('en-US', { minimumFractionDigits: fractionDigits, maximumFractionDigits: fractionDigits }).format(amount)}`;
      }

      /** Formats a number as a percentage string (e.g., 50.00%). */
      static formatPercentage(value) {
        if (typeof value !== 'number' || isNaN(value)) return '0%'; // Handle invalid numbers
        return `${(value * 100).toFixed(2)}%`;
      }

      /**
       * Rounds a number to the nearest valid step size (tickSize for price, lotSize for quantity)
       * for Bybit API parameters.
       * @param {number} value - The value to format.
       * @param {'price'|'qty'} type - Whether it's a price or quantity.
       * @param {Object} symbolInfo - Object containing tickSize and lotSize for the symbol.
       * @returns {string} The formatted number as a string.
       */
      static formatBybitPrecision(value, type, symbolInfo) {
        if (typeof value !== 'number' || isNaN(value)) return '0';

        let stepSize;
        if (type === 'price' && symbolInfo && symbolInfo.tickSize) {
            stepSize = parseFloat(symbolInfo.tickSize);
        } else if (type === 'qty' && symbolInfo && symbolInfo.lotSize) {
            stepSize = parseFloat(symbolInfo.lotSize);
        } else {
            // Fallback if symbolInfo not available or incomplete
            // Use a default precision if specific step size isn't found
            const fallbackDecimals = type === 'price' ? 2 : 3;
            return value.toFixed(fallbackDecimals);
        }

        if (stepSize === 0) { // Avoid division by zero
            const fallbackDecimals = type === 'price' ? 2 : 3;
            return value.toFixed(fallbackDecimals);
        }

        const roundedValue = Math.round(value / stepSize) * stepSize;
        // Determine decimal places from stepSize to ensure correct string formatting
        const decimals = (stepSize.toString().split('.')[1] || '').length;
        return roundedValue.toFixed(decimals);
      }

      /** Calculates the Exponential Moving Average (EMA) for a series of data points. */
      static calculateEMA(data, period) {
          const k = 2 / (period + 1); // Smoothing factor
          let emas = [];
          if (data.length < period) return []; // Not enough data for the period

          // Calculate the initial EMA using the Simple Moving Average (SMA) of the first 'period' data points
          let currentEma = ss.mean(data.slice(0, period));
          emas.push(currentEma);

          // Calculate subsequent EMAs using the EMA formula: EMA = (Current_Value - Previous_EMA) * k + Previous_EMA
          for (let i = period; i < data.length; i++) {
              currentEma = (data[i] - currentEma) * k + currentEma;
              emas.push(currentEma);
          }
          return emas;
      }

      /** Calculates the Relative Strength Index (RSI) for a series of closing prices. */
      static calculateRSI(closes, period = CONSTANTS.METRIC_CALC_PERIODS.RSI_PERIOD) {
        if (closes.length < period + 1) return null; // Need at least 'period + 1' data points
        
        // Calculate price changes between consecutive periods
        const changes = closes.slice(1).map((close, i) => close - closes[i]);
        // Separate gains (positive changes) and losses (negative changes)
        const gains = changes.map(d => Math.max(0, d));
        const losses = changes.map(d => Math.max(0, -d));
        
        // Calculate initial average gain and loss over the first 'period' changes
        let avgGain = ss.mean(gains.slice(0, period));
        let avgLoss = ss.mean(losses.slice(0, period));

        // Calculate subsequent average gains and losses using smoothing
        for (let i = period; i < changes.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        }

        if (avgLoss === 0) return 100; // RSI is 100 if there are no losses
        const rs = avgGain / avgLoss; // Calculate Relative Strength (RS)
        return 100 - (100 / (1 + rs)); // Calculate RSI
      }

      /** Calculates the Moving Average Convergence Divergence (MACD) indicators. */
      static calculateMACD(closes, fastPeriod = CONSTANTS.METRIC_CALC_PERIODS.MACD_FAST, slowPeriod = CONSTANTS.METRIC_CALC_PERIODS.MACD_SLOW, signalPeriod = CONSTANTS.METRIC_CALC_PERIODS.MACD_SIGNAL) {
        // Need enough data points for all EMA calculations and signal line
        if (closes.length < slowPeriod + signalPeriod) return { macd: null, signal: null, histogram: null };

        const fastEma = Utils.calculateEMA(closes, fastPeriod); // Calculate fast EMA
        const slowEma = Utils.calculateEMA(closes, slowPeriod); // Calculate slow EMA

        // MACD line is the difference between the fast and slow EMAs.
        // Align EMAs: MACD line length will be shorter than original closes.
        const macdLine = fastEma.slice(fastEma.length - slowEma.length).map((f, i) => f - slowEma[i]);
        
        if (macdLine.length < signalPeriod) return { macd: null, signal: null, histogram: null }; // Not enough data for signal line

        // Calculate the signal line (EMA of the MACD line)
        const signalLine = Utils.calculateEMA(macdLine, signalPeriod);
        
        // Calculate the histogram (MACD line - Signal Line)
        // Align histogram data to the corresponding MACD line points
        const histogram = signalLine.map((s, i) => macdLine[i + (macdLine.length - signalLine.length)] - s);

        return {
          macd: macdLine[macdLine.length - 1], // Last MACD line value
          signal: signalLine[signalLine.length - 1], // Last Signal line value
          histogram: histogram[histogram.length - 1] // Last Histogram value
        };
      }

      /** Calculates Bollinger Bands (Upper, Middle, Lower bands, and Bandwidth). */
      static calculateBollingerBands(closes, period = CONSTANTS.METRIC_CALC_PERIODS.BB_PERIOD, stdDev = CONSTANTS.METRIC_CALC_PERIODS.BB_STD_DEV) {
        if (closes.length < period) return { upper: null, middle: null, lower: null, width: null }; // Not enough data
        
        const lastPeriodCloses = closes.slice(-period); // Get the last 'period' closing prices
        const middle = ss.mean(lastPeriodCloses); // Middle band is the SMA
        const std = ss.standardDeviation(lastPeriodCloses); // Standard deviation of the closing prices
        // Calculate upper and lower bands
        const upper = middle + std * stdDev;
        const lower = middle - std * stdDev;
        // Calculate bandwidth as a percentage of the middle band
        const width = (upper - lower) / middle * 100;

        return { upper, middle, lower, width };
      }

      /** Calculates the Sharpe Ratio, measuring risk-adjusted return. */
      static calculateSharpeRatio(returns, riskFreeRate = 0, periodsPerYear = CONSTANTS.METRIC_CALC_PERIODS.SHARPE_RATRO_TRADES) {
          if (returns.length < 2) return null; // Need at least two data points for std dev
          // Calculate excess returns over the risk-free rate
          const excessReturns = returns.map(r => r - riskFreeRate);
          const meanExcessReturn = ss.mean(excessReturns); // Average excess return
          const stdDev = ss.standardDeviation(excessReturns); // Standard deviation of excess returns
          if (stdDev === 0) return null; // Avoid division by zero if there's no volatility
          // Annualize the Sharpe Ratio
          return (meanExcessReturn / stdDev) * Math.sqrt(periodsPerYear);
      }

      /** Calculates Value at Risk (VaR) using a historical simulation method. */
      static calculateHistoricalVaR(returns, confidenceLevel = 0.95) {
        if (returns.length === 0) return null;
        const sortedReturns = [...returns].sort((a, b) => a - b); // Sort returns in ascending order
        // Find the index corresponding to the confidence level (e.g., 5% worst case for 95% confidence)
        const index = Math.floor(returns.length * (1 - confidenceLevel));
        // VaR is the return at that index (representing the worst loss at the given confidence level)
        return sortedReturns[index];
      }
    }

    // --- EVENT EMITTER CLASS ---
    // A simple implementation of the observer pattern for decoupling components.
    class EventEmitter {
      constructor() { this.events = {}; } // Stores event listeners keyed by event name
      on(event, listener) { // Register a listener function for a specific event
        if (!this.events[event]) this.events[event] = []; // Initialize array if event is new
        this.events[event].push(listener); // Add listener to the event
      }
      emit(event, ...args) { // Trigger an event, calling all registered listeners with provided arguments
        if (this.events[event]) this.events[event].forEach(listener => listener(...args));
      }
    }

    // --- BYBIT API CLIENT ---
    // Handles all REST API interactions with Bybit.
    class BybitClient extends EventEmitter {
      constructor(logger) {
        super();
        this.logger = logger;
        this.apiKey = '';
        this.apiSecret = '';
        this.tradingMode = 'testnet'; // Default to testnet
        this.axiosInstance = axios.create(); // Axios instance for making API requests
        this.setupRateLimiting(); // Configure rate limiting interceptor
        this.symbolDetails = {}; // Stores tickSize, lotSize for each symbol
      }

      /** Sets the API key, secret, and trading mode for the client. */
      setCredentials(apiKey, apiSecret, tradingMode) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.tradingMode = tradingMode;
        this.logger(`Bybit API client set to ${tradingMode} mode.`, 'info');
      }

      /** Sets up an interceptor to handle API rate limiting responses (HTTP 429). */
      setupRateLimiting() {
        this.axiosInstance.interceptors.response.use(response => {
          return response; // Pass successful responses through
        }, error => {
          // Handle rate limit errors specifically
          if (error.response && error.response.status === 429) {
            this.emit('rateLimitExceeded'); // Emit an event for rate limit exceeded
            this.logger('Bybit API rate limit exceeded.', 'warning');
            // Optionally show a toast to the user
            // this.ui.showToast('Bybit API rate limit exceeded. Please wait.', 'warning');
          }
          return Promise.reject(error); // Propagate the error to the caller
        });
      }

      /** Makes a signed or unsigned request to the Bybit V5 API. */
      async request(method, endpoint, params = {}, isPrivate = false) {
        const baseURL = CONSTANTS.BYBIT_API_URL[this.tradingMode]; // Select base URL based on trading mode
        
        const headers = { 'Content-Type': 'application/json' }; // Standard headers for JSON requests
        const timestamp = Date.now().toString(); // Timestamp for signing requests
        const recvWindow = '10000'; // Recommended recvWindow for Bybit API requests (time in ms for server to process request)

        // Add authentication headers and signature for private API endpoints
        if (isPrivate) {
          if (!this.apiKey || !this.apiSecret) { // Check if API credentials are set
            const errorMsg = "API credentials not set for private request.";
            this.logger(errorMsg, 'error');
            throw new Error(errorMsg); // Throw an error if credentials are missing
          }
          
          headers['X-BAPI-API-KEY'] = this.apiKey;
          headers['X-BAPI-TIMESTAMP'] = timestamp;
          headers['X-BAPI-RECV-WINDOW'] = recvWindow;

          let signaturePayload;
          // Construct the payload for signing based on the HTTP method
          if (method === 'GET') {
            const query = new URLSearchParams(params).toString(); // Convert GET parameters to a query string
            signaturePayload = timestamp + this.apiKey + recvWindow + query;
          } else if (method === 'POST') {
            const body = JSON.stringify(params); // Convert POST parameters to a JSON string for the request body
            signaturePayload = timestamp + this.apiKey + recvWindow + body;
          }
          
          // Generate the signature using HMAC-SHA256 with the API secret
          headers['X-BAPI-SIGN'] = CryptoJS.HmacSHA256(signaturePayload, this.apiSecret).toString();
        }

        try {
          // Execute the HTTP request using Axios
          const response = await this.axiosInstance({
            method,
            url: `${baseURL}${endpoint}`,
            headers,
            params: method === 'GET' ? params : undefined, // Attach params to URL for GET requests
            data: method === 'POST' ? params : undefined // Attach params to request body for POST requests
          });
          // Check Bybit API's response for errors (retCode !== 0 indicates an error)
          if (response.data.retCode !== 0) {
            throw new Error(`Bybit API Error: ${response.data.retMsg} (Code: ${response.data.retCode})`);
          }
          return response.data.result; // Return the actual result data from the API response
        } catch (error) {
          // Extract error message from response or use a generic message
          const errorMessage = error.response?.data?.retMsg || error.message;
          this.emit('error', errorMessage); // Emit a general error event
          this.logger(`Bybit API Request Failed: ${errorMessage}`, 'error');
          throw error; // Re-throw the error to be handled by the caller
        }
      }

      /** Fetches a list of valid trading symbols (instruments) and their details from Bybit. */
      async getValidSymbols() {
        const result = await this.request('GET', '/v5/market/instruments-info', { category: 'linear' });
        const symbols = result.list
          .filter(s => s.status === 'Trading' && s.quoteCoin === 'USDT');
        
        // Store symbol details (tickSize, lotSize) for dynamic precision handling
        this.symbolDetails = symbols.reduce((acc, s) => {
            acc[s.symbol] = {
                tickSize: parseFloat(s.priceFilter.tickSize),
                lotSize: parseFloat(s.lotSizeFilter.qtyStep)
            };
            return acc;
        }, {});

        return symbols.map(s => s.symbol).sort(); // Return sorted symbol names
      }
      
      /** Fetches kline (candlestick) data for a given symbol and interval. */
      async getKlines(symbol, interval, limit = CONSTANTS.KLINES_FETCH_LIMIT) {
        return this.request('GET', '/v5/market/kline', { category: 'linear', symbol, interval, limit });
      }

      /** Places an order on Bybit. */
      async placeOrder(orderParams) {
        // Ensure category is set for linear trading
        return this.request('POST', '/v5/order/create', { category: 'linear', ...orderParams }, true);
      }
      
      /** Fetches current positions for a specific symbol or all symbols. */
      async getPositions(symbol = undefined) {
        const params = { category: 'linear' }; // Specify linear category
        if (symbol) params.symbol = symbol; // Filter by symbol if provided
        const result = await this.request('GET', '/v5/position/list', params, true);
        return result.list;
      }

      async setLeverage(symbol, leverage) {
        return this.request('POST', '/v5/position/set-leverage', {
          category: 'linear',
          symbol,
          buyLeverage: leverage.toString(),
          sellLeverage: leverage.toString()
        }, true);
      }

      /** Fetches open orders for a specific symbol or all symbols. */
      async getOpenOrders(symbol = undefined) {
        const params = { category: 'linear' };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/order/realtime', params, true);
        return result.list;
      }

      /** Fetches trade history for a specific symbol or all symbols. */
      async getTradeHistory(symbol = undefined, limit = 50) {
        const params = { category: 'linear', limit };
        if (symbol) params.symbol = symbol;
        const result = await this.request('GET', '/v5/trade/history', params, true);
        return result.list;
      }

      /** Fetches the wallet balance for a specified coin (defaults to USDT). */
      async getWalletBalance(coin = 'USDT') {
        const result = await this.request('GET', '/v5/account/wallet-balance', { accountType: 'UNIFIED', coin }, true);
        // Bybit returns an array of coins; we need the first one for USDT balance details
        return result.list[0]?.coin[0] || null;
      }

      /** Cancels an order by its ID and symbol. */
      async cancelOrder(symbol, orderId) {
        return this.request('POST', '/v5/order/cancel', { category: 'linear', symbol, orderId }, true);
      }

      /** Closes an active position by placing an opposite market order. */
      async closePosition(symbol, side, qtyToClose = null) {
        // Fetch the current positions to find the one to close
        const positions = await this.getPositions(symbol);
        const position = positions.find(p => p.symbol === symbol && parseFloat(p.size) > 0); // Find active position for the symbol
        
        if (!position) {
          throw new Error(`No active position found for ${symbol} to close.`);
        }

        const currentSize = parseFloat(position.size); // Get the current size of the position
        // Determine the quantity to close: use specified qty or the full position size if not specified
        const qty = qtyToClose ? Math.min(currentSize, qtyToClose) : currentSize;
        if (qty <= 0) {
          throw new Error(`Invalid quantity to close for ${symbol}.`);
        }

        // Determine the side for the closing order (opposite of the current position side)
        const closeSide = side === 'Buy' ? 'Sell' : 'Buy';
        
        // Get symbol details for precision formatting
        const symbolInfo = this.symbolDetails[symbol] || {};

        // Place a market order to close the position. `reduceOnly: true` is critical.
        return this.request('POST', '/v5/order/create', {
          category: 'linear',
          symbol: symbol,
          side: closeSide,
          orderType: 'Market',
          qty: Utils.formatBybitPrecision(qty, 'qty', symbolInfo), // Format quantity using dynamic precision
          reduceOnly: true, // Crucial: ensures this order ONLY closes the existing position
        }, true);
      }
    }

    // --- BYBIT WEBSOCKET CLIENT ---
    // Manages real-time data subscriptions via WebSocket.
    class BybitWebSocket extends EventEmitter {
      constructor(logger) {
        super();
        this.logger = logger;
        this.ws = null; // WebSocket instance
        this.isConnected = false;
        this.pingInterval = null; // Interval timer for sending pings
        this.reconnectTimeout = null; // Timeout timer for reconnection attempts
        this.reconnectAttempts = 0; // Counter for reconnection attempts
        this.maxReconnectAttempts = 5; // Maximum allowed reconnection attempts
        this.currentTopics = new Set(); // Tracks currently subscribed topics for proper management (subscribe/unsubscribe)
        this.tradingMode = 'testnet'; // Default trading mode
      }

      /** Sets the trading mode (testnet/mainnet) which determines the WebSocket URL. */
      setTradingMode(mode) {
        this.tradingMode = mode;
      }

      /** Establishes a WebSocket connection to Bybit. */
      connect() {
        // Prevent multiple connections if already connected or connecting
        if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
          this.logger('WebSocket is already connected or connecting.', 'warning');
          return;
        }

        this.logger('Connecting to WebSocket...', 'info');
        this.emit('status', 'connecting'); // Emit status update to UI
        
        // Create a new WebSocket instance using the appropriate URL based on trading mode
        this.ws = new WebSocket(CONSTANTS.BYBIT_WS_URL[this.tradingMode]);

        // --- WebSocket Event Handlers ---
        this.ws.onopen = () => { // When connection is successfully opened
          this.isConnected = true;
          this.reconnectAttempts = 0; // Reset reconnection attempts counter
          this.logger('WebSocket Connected.', 'success');
          this.emit('status', 'connected'); // Update UI status indicator
          this.startPing(); // Start sending pings to keep connection alive
          this.resubscribeToTopics(); // Re-subscribe to any topics that were pending
        };

        this.ws.onmessage = (event) => { // When a message is received from the server
          const data = JSON.parse(event.data); // Parse the incoming JSON message
          if (data.op === 'pong') return; // Ignore pong responses from the server
          this.emit('message', data); // Emit the message data for processing by other components
        };

        this.ws.onclose = () => { // When the WebSocket connection is closed
          this.isConnected = false;
          this.stopPing(); // Stop sending ping messages
          clearTimeout(this.reconnectTimeout); // Clear any pending reconnection timer
          this.logger('WebSocket Disconnected.', 'warning');
          this.emit('status', 'disconnected'); // Update UI status indicator
          this.attemptReconnect(); // Attempt to re-establish the connection
        };

        this.ws.onerror = (err) => { // When an error occurs with the WebSocket connection
          this.logger(`WebSocket Error: ${err.message}`, 'error');
          this.ws.close(); // Close the connection if an error occurs
        };
      }
      
      /** Disconnects the WebSocket connection gracefully. */
      disconnect() {
        if (this.ws) {
          this.ws.close(); // Close the WebSocket connection
          this.stopPing(); // Stop the ping interval
          clearTimeout(this.reconnectTimeout); // Clear any pending reconnection timer
          this.isConnected = false;
          this.currentTopics.clear(); // Clear the set of subscribed topics
          this.logger('Manually disconnected WebSocket.', 'info');
          this.emit('status', 'disconnected'); // Update UI status indicator
        }
      }

      /** Subscribes to a list of topics. Only sends subscribe requests for new topics. */
      subscribe(topics) {
        // Filter out topics that are already subscribed to avoid redundant requests
        const newTopics = topics.filter(topic => !this.currentTopics.has(topic));
        // Add newly subscribed topics to the set of current topics
        newTopics.forEach(topic => this.currentTopics.add(topic));

        // Send the subscribe message only if the WebSocket is open and there are new topics to subscribe to
        if (this.ws && this.ws.readyState === WebSocket.OPEN && newTopics.length > 0) {
          this.ws.send(JSON.stringify({ op: 'subscribe', args: newTopics })); // Send the subscribe command to Bybit
          this.logger(`Subscribed to: ${newTopics.join(', ')}`, 'info');
        }
      }
      
      /** Unsubscribes from a list of topics. Only sends unsubscribe requests for currently subscribed topics. */
      unsubscribe(topics) {
        // Filter out topics that are not currently subscribed to avoid errors
        const topicsToUnsubscribe = topics.filter(topic => this.currentTopics.has(topic));
        // Remove unsubscribed topics from the set of current topics
        topicsToUnsubscribe.forEach(topic => this.currentTopics.delete(topic));

        // Send the unsubscribe message only if the. WebSocket is open and there are topics to unsubscribe from
        if (this.ws && this.ws.readyState === WebSocket.OPEN && topicsToUnsubscribe.length > 0) {
          this.ws.send(JSON.stringify({ op: 'unsubscribe', args: topicsToUnsubscribe })); // Send the unsubscribe command to Bybit
          this.logger(`Unsubscribed from: ${topicsToUnsubscribe.join(', ')}`, 'info');
        }
      }

      /** Resubscribes to all currently tracked topics. This is useful after a reconnection. */
      resubscribeToTopics() {
        if (this.currentTopics.size > 0) {
          // Convert the Set of topics to an Array to pass to the subscribe method
          const topics = [...this.currentTopics];
          // Clear the set first to allow the `subscribe` method to correctly add them as 'new' topics
          // This ensures the internal filtering in `subscribe` works as expected.
          this.currentTopics.clear(); 
          this.subscribe(topics); // Re-subscribe to all tracked topics
        }
      }

      /** Starts sending periodic ping messages to keep the WebSocket connection alive. */
      startPing() {
        this.stopPing(); // Ensure no duplicate ping intervals are running
        this.pingInterval = setInterval(() => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ op: 'ping' })); // Send a ping message to the server
          }
        }, CONSTANTS.WS_PING_INTERVAL);
      }

      /** Stops the ping interval timer. */
      stopPing() {
        if (this.pingInterval) {
          clearInterval(this.pingInterval);
          this.pingInterval = null;
        }
      }

      /** Attempts to reconnect the WebSocket with exponential backoff. */
      attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
          this.reconnectAttempts++; // Increment the reconnection attempt counter
          // Calculate reconnection delay using exponential backoff: delay increases with each attempt
          const delay = CONSTANTS.WS_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts - 1);
          this.logger(`Attempting to reconnect in ${delay / 1000}s (Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`, 'warning');
          // Schedule the reconnection attempt after the calculated delay
          this.reconnectTimeout = setTimeout(() => this.connect(), delay);
        } else {
          // If the maximum number of reconnection attempts is reached, log an error and update the status
          this.logger('Max reconnection attempts reached. Please connect manually.', 'error');
          this.emit('status', 'disconnected'); // Ensure the UI reflects the disconnected state
        }
      }
    }

    // --- CHART MANAGER ---
    // Handles initialization and updates for all Chart.js charts used in the application.
    class ChartManager {
      constructor(dom, logger) {
        // No super() here as ChartManager does not extend EventEmitter
        this.dom = dom;
        this.logger = logger;
        this.charts = {}; // Stores Chart.js instances keyed by chart name (e.g., 'orderBook', 'price')
        this.lastKlineTimestamp = 0; // Tracks the timestamp of the last processed kline for optimization
        this.lastKlinesLength = 0; // Tracks the length of the klines array for optimization
        this.annotationPlugin = window.ChartjsPluginAnnotation; // Reference to the Chart.js annotation plugin
        
        // Register necessary Chart.js plugins upon initialization
        if (window.Chart) {
          // Register financial chart components if they are available (for candlestick charts)
          if (window.Chart.FinancialController && window.Chart.FinancialElement && window.Chart.Financial) {
            Chart.register(window.Chart.FinancialController, window.Chart.FinancialElement, window.Chart.Financial);
            this.logger("chartjs-chart-financial loaded.", "info");
          } else {
            this.logger("Warning: chartjs-chart-financial components not fully loaded. Candlestick chart may not display correctly.", "warning");
          }
          // Register the annotation plugin if it has been loaded
          if (this.annotationPlugin) {
            Chart.register(this.annotationPlugin);
            this.logger("chartjs-plugin-annotation loaded.", "info");
          } else {
            this.logger("Warning: chartjs-plugin-annotation not loaded.", "warning");
          }
        }
      }

      /** Initializes all chart instances defined in the DOM. */
      initCharts() {
        this.charts.orderBook = new Chart(this.dom.orderBookChart, this._getOrderBookChartConfig());
        this.charts.price = new Chart(this.dom.priceChart, this._getPriceChartConfig());
        this.charts.volume = new Chart(this.dom.volumeChart, this._getVolumeChartConfig());
        this.charts.indicator = new Chart(this.dom.indicatorChart, this._getIndicatorChartConfig());
        this.charts.risk = new Chart(this.dom.riskChart, this._getRiskChartConfig());
        this.charts.equityCurve = new Chart(this.dom.equityChart, this._getEquityChartConfig()); // Initialize new equity chart
      }

      /** Configuration for the Order Book chart (bar chart, now a market depth visualization). */
      _getOrderBookChartConfig() {
        return {
          type: 'line', // Changed to line for market depth visualization
          data: { labels: [], datasets: [
            { 
              label: 'Bids', 
              data: [], 
              borderColor: 'var(--neon-green)', 
              backgroundColor: 'rgba(0, 255, 65, 0.2)',
              fill: 'origin', // Fill area to origin
              stepped: true, // Stepped line for order book
              tension: 0 // Straight lines
            }, 
            { 
              label: 'Asks', 
              data: [], 
              borderColor: 'var(--neon-red)', 
              backgroundColor: 'rgba(255, 23, 68, 0.2)',
              fill: 'origin', 
              stepped: true,
              tension: 0
            }
          ]},
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 }, // Disable animations for smoother real-time updates
            parsing: false, // Use pre-parsed data for performance
            scales: { 
              x: { // Price axis
                type: 'linear', // Use linear scale for price
                position: 'bottom',
                grid: { color: 'rgba(255,255,255,0.1)' }, 
                ticks: { color: 'var(--text-secondary)' },
                title: { display: true, text: 'Price (USDT)', color: 'var(--text-secondary)'}
              }, 
              y: { // Cumulative Quantity axis
                beginAtZero: true, 
                position: 'right', // Place quantity axis on the right
                grid: { color: 'rgba(255,255,255,0.1)' }, 
                ticks: { color: 'var(--text-secondary)' },
                title: { display: true, text: 'Cumulative Quantity', color: 'var(--text-secondary)'}
              } 
            },
            plugins: { 
              legend: { display: true, labels: { color: 'var(--text-primary)' } }, // Show legend for bids/asks
              tooltip: { // Customize tooltip for better readability
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) label += ': ';
                    // Display cumulative quantity and formatted price
                    if (context.parsed.y !== null) label += `${context.parsed.y.toFixed(3)} @ ${Utils.formatCurrency(context.parsed.x)}`;
                    return label;
                  }
                }
              }
            }
          }
        };
      }
      
      /** Configuration for the Price chart (candlestick with SMA). */
      _getPriceChartConfig() {
        return {
          type: 'candlestick',
          data: { datasets: [
            { // Candlestick dataset
              label: 'Candlestick',
              data: [],
              borderColor: 'rgba(0, 229, 255, 1)', // Cyan border for candles
              borderWidth: 1,
              candlestick: { // Styling for up/down candles
                up: { backgroundColor: 'var(--neon-green)', borderColor: 'var(--neon-green)' }, // Green for bullish candles
                down: { backgroundColor: 'var(--neon-red)', borderColor: 'var(--neon-red)' }, // Red for bearish candles
                hover: { backgroundColor: 'var(--neon-cyan)', borderColor: 'var(--neon-cyan)' } // Highlight on hover
              }
            },
            { // Simple Moving Average (SMA) dataset
              label: `SMA${CONSTANTS.METRIC_CALC_PERIODS.SMA_PERIOD}`, 
              type: 'line',
              data: [],
              borderColor: 'var(--neon-yellow)', // Yellow line for SMA
              borderWidth: 1,
              pointRadius: 0, // No points on the line itself
              yAxisID: 'y', // Use the primary y-axis
              parsing: false, // Use pre-parsed data for performance
            }
          ]},
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 }, // Disable animations for real-time updates
            parsing: false,
            scales: {
              x: { // Time axis
                type: 'time', 
                time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'HH:mm', day: 'MMM D' } },
                grid: { color: 'rgba(255,255,255,0.1)' }, // Subtle grid lines
                ticks: { color: 'var(--text-secondary)' } // Secondary text color for ticks
              },
              y: { // Price axis
                position: 'right', // Place price axis on the right side
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              }
            },
            plugins: {
              legend: { display: false }, // Hide legend, labels are often in tooltips or dataset names
              tooltip: { // Customize tooltip for candlestick data
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    if (context.dataset.type === 'candlestick') {
                      const data = context.parsed._custom; // Access custom data for candlestick (open, high, low, close)
                      return [
                        `Open: ${data.o.toFixed(2)}`,
                        `High: ${data.h.toFixed(2)}`,
                        `Low: ${data.l.toFixed(2)}`,
                        `Close: ${data.c.toFixed(2)}`
                      ];
                    } else {
                      // For line datasets (like SMA)
                      return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                    }
                  }
                }
              },
              annotation: { // Placeholder for dynamic annotations (TP/SL/Entry prices)
                annotations: {} 
              }
            }
          }
        };
      }

      /** Configuration for the Volume chart (bar chart). */
      _getVolumeChartConfig() {
        return {
          type: 'bar',
          data: { datasets: [{
            label: 'Volume',
            data: [],
            // Dynamic background color based on price movement (green for up, red for down)
            backgroundColor: (context) => {
              const { dataIndex, dataset } = context;
              const closes = dataset.closes; // This will be provided dynamically from klines data
              if (!closes || dataIndex === 0) return 'rgba(128, 128, 128, 0.5)'; // Default color if data is missing
              const prevClose = closes[dataIndex - 1]; // Previous close price
              const currentClose = closes[dataIndex]; // Current close price
              // Color based on current close vs previous close
              return currentClose >= prevClose ? 'rgba(0, 255, 65, 0.5)' : 'rgba(255, 23, 68, 0.5)';
            },
            borderColor: 'transparent', // No border for bars
          }]},
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 },
            parsing: false,
            scales: {
              x: { // Time axis
                type: 'time', 
                time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'HH:mm', day: 'MMM D' } },
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y: { // Volume axis
                position: 'right', 
                beginAtZero: true,
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' },
                title: { display: true, text: 'Volume', color: 'var(--text-secondary)'}
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: { // Customize tooltip for volume
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    return `Volume: ${Utils.formatCurrency(context.parsed.y, '', 2)}`;
                  }
                }
              }
            }
          }
        };
      }

      /** Configuration for the Indicator chart (RSI, MACD, etc.). */
      _getIndicatorChartConfig() {
        return {
          type: 'line',
          data: {
            datasets: [
              { label: 'RSI', data: [], borderColor: 'var(--neon-cyan)', borderWidth: 1, pointRadius: 0, yAxisID: 'y', parsing: false },
              { label: 'MACD', data: [], borderColor: 'var(--neon-green)', borderWidth: 1, pointRadius: 0, yAxisID: 'y1', parsing: false },
              { label: 'Signal', data: [], borderColor: 'var(--neon-orange)', borderWidth: 1, pointRadius: 0, yAxisID: 'y1', parsing: false },
              { label: 'Histogram', data: [], backgroundColor: 'rgba(255,255,255,0.2)', borderWidth: 0, yAxisID: 'y1', type: 'bar', parsing: false }
            ]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 },
            scales: {
              x: { // Time axis
                type: 'time',
                time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'HH:mm' } },
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y: { // RSI axis
                position: 'left',
                title: { display: true, text: 'RSI', color: 'var(--neon-cyan)' },
                grid: { color: 'rgba(255,255,255,0.05)' },
                ticks: { color: 'var(--text-secondary)' },
                min: 0, max: 100 // RSI is always between 0 and 100
              },
              y1: { // MACD axis
                position: 'right',
                title: { display: true, text: 'MACD', color: 'var(--neon-green)' },
                grid: { color: 'rgba(255,255,255,0.05)' },
                ticks: { color: 'var(--text-secondary)' }
              }
            },
            plugins: {
              legend: { labels: { color: 'var(--text-primary)' } } // Legend text color
            }
          }
        };
      }

      /** Configuration for the Risk chart (doughnut chart). */
      _getRiskChartConfig() {
        return {
          type: 'doughnut',
          data: {
            labels: ['Current Risk (PnL vs Equity)', 'Remaining'],
            datasets: [{
              data: [0, 100], // Initial data, will be updated dynamically
              backgroundColor: ['var(--neon-red)', 'rgba(0, 229, 255, 0.2)'], // Red for risk, Cyan for remaining
              borderColor: 'transparent', // No border for segments
              hoverOffset: 4 // Slight offset on hover for visual feedback
            }]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 },
            plugins: {
              legend: {
                position: 'bottom', // Place legend at the bottom
                labels: { color: 'var(--text-primary)' } // Legend text color
              },
              tooltip: { // Customize tooltip for percentage display
                callbacks: {
                  label: function(context) {
                    let label = context.label || '';
                    if (label) label += ': ';
                    if (context.parsed !== null) label += Utils.formatPercentage(context.parsed / 100); // Format value as percentage
                    return label;
                  }
                }
              }
            }
          }
        };
      }

      /** Configuration for the new Equity Curve chart (line chart). */
      _getEquityChartConfig() {
        return {
          type: 'line',
          data: {
            labels: [], // Timestamps for X-axis
            datasets: [{
              label: 'Account Equity',
              data: [],
              borderColor: 'var(--neon-cyan)',
              backgroundColor: 'rgba(0, 229, 255, 0.1)',
              fill: true,
              tension: 0.3, // Smooth the line
              pointRadius: 0, // No points on the line
            }]
          },
          options: {
            responsive: true, maintainAspectRatio: false,
            animation: { duration: 0 },
            scales: {
              x: {
                type: 'time',
                time: { unit: 'day', displayFormats: { day: 'MMM D' } }, // Adjust unit based on data frequency
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              },
              y: {
                position: 'right',
                title: { display: true, text: 'Equity (USDT)', color: 'var(--text-secondary)' },
                grid: { color: 'rgba(255,255,255,0.1)' },
                ticks: { color: 'var(--text-secondary)' }
              }
            },
            plugins: {
              legend: { labels: { color: 'var(--text-primary)' } },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: function(context) {
                    return `${context.dataset.label}: ${Utils.formatCurrency(context.parsed.y)}`;
                  }
                }
              }
            }
          }
        };
      }

      /** Updates the Order Book chart and the text displays for bids and asks. */
      updateOrderBook(bids, asks) {
        // Sort bids descending by price, asks ascending by price
        const sortedBids = bids.map(b => ({ price: parseFloat(b.price), size: parseFloat(b.size) })).sort((a, b) => b.price - a.price);
        const sortedAsks = asks.map(a => ({ price: parseFloat(a.price), size: parseFloat(a.size) })).sort((a, b) => a.price - b.price);

        // Calculate cumulative sizes for market depth visualization
        let cumulativeBidSize = 0;
        // Bids: from highest price (closest to market) to lowest, cumulative sum
        const bidData = sortedBids.map(b => {
          cumulativeBidSize += b.size;
          return { x: b.price, y: cumulativeBidSize };
        });

        let cumulativeAskSize = 0;
        // Asks: from lowest price (closest to market) to highest, cumulative sum
        const askData = sortedAsks.map(a => {
          cumulativeAskSize += a.size;
          return { x: a.price, y: cumulativeAskSize };
        });

        // Combine all prices for the X-axis to ensure a continuous scale
        const allPrices = [...sortedBids.map(b => b.price), ...sortedAsks.map(a => a.price)].sort((a, b) => a - b);
        
        // Find the current market midpoint for visual separation
        const lastBidPrice = sortedBids.length > 0 ? sortedBids[0].price : null;
        const firstAskPrice = sortedAsks.length > 0 ? sortedAsks[0].price : null;

        // Prepare data for Chart.js: bids should go from right to left, asks from left to right on the chart
        // For line chart with stepped:
        // Bids: Prices descending, cumulative quantity increasing. We need to reverse for chart.js x-axis ascending.
        // Asks: Prices ascending, cumulative quantity increasing.
        const chartBids = bidData.slice().reverse().map(d => ({ x: d.x, y: d.y }));
        const chartAsks = askData.map(d => ({ x: d.x, y: d.y }));

        this.charts.orderBook.data.labels = allPrices; // Labels are still all prices for x-axis range
        this.charts.orderBook.data.datasets[0].data = chartBids;
        this.charts.orderBook.data.datasets[1].data = chartAsks;
        this.charts.orderBook.update('none');

        // Update the text displays for the top bids and asks
        this.dom.bidBookDisplay.innerHTML = '<div class="text-green-400 font-semibold mb-2">Bid Book</div>' + 
          sortedBids.slice(0, 10).map(b => `<div>${b.size.toFixed(3)} @ ${Utils.formatCurrency(b.price, '$', 2)}</div>`).join('');
        this.dom.askBookDisplay.innerHTML = '<div class="text-red-400 font-semibold mb-2">Ask Book</div>' + 
          sortedAsks.slice(0, 10).map(a => `<div>${a.size.toFixed(3)} @ ${Utils.formatCurrency(a.price, '$', 2)}</div>`).join('');
      }
      
      /** Updates the Price chart with new kline data, calculates/adds SMA, and applies annotations. */
      updatePriceChart(klines, currentPosition = null) {
        // Clear chart data if no klines are available
        if (!klines || klines.length === 0) {
          this.charts.price.data.datasets[0].data = []; // Clear candlestick data
          this.charts.price.data.datasets[1].data = []; // Clear SMA data
          this.charts.price.options.plugins.annotation.annotations = {}; // Clear any existing annotations
          this.charts.price.update('none'); // Update chart
          // Also clear volume chart data
          this.charts.volume.data.datasets[0].data = [];
          this.charts.volume.update('none');
          return;
        }

        // Prepare candlestick data from klines
        const candlestickData = klines.map(k => ({
          x: k.time, o: k.open, h: k.high, l: k.low, c: k.close
        }));
        this.charts.price.data.datasets[0].data = candlestickData; // Set candlestick data

        // Calculate and add Simple Moving Average (SMA)
        const closes = klines.map(k => k.close); // Extract closing prices
        const smaPeriod = CONSTANTS.METRIC_CALC_PERIODS.SMA_PERIOD;
        if (closes.length >= smaPeriod) {
            // Use slidingWindow from simple-statistics to calculate SMA efficiently
            const sma = ss.slidingWindow(closes, smaPeriod, ss.mean);
            // Map SMA values to chart data points, aligning them with kline times
            this.charts.price.data.datasets[1].data = klines.slice(smaPeriod - 1).map((k, i) => ({
                x: k.time,
                y: sma[i]
            }));
        } else {
            this.charts.price.data.datasets[1].data = []; // Clear SMA data if not enough points
        }

        // Update Volume Chart data
        this.charts.volume.data.datasets[0].data = klines.map(k => ({
          x: k.time, y: k.volume
        }));
        // Pass closes to the volume dataset for dynamic coloring based on price movement
        this.charts.volume.data.datasets[0].closes = klines.map(k => k.close);
        this.charts.volume.update('none'); // Update volume chart
        
        // Add annotations for current position's TP/SL/Entry Price if available
        const annotations = {};
        // Check if currentPosition is valid and has an active size
        if (currentPosition && parseFloat(currentPosition.size) > 0) {
          const entryPrice = parseFloat(currentPosition.avgPrice);
          const stopLossPrice = parseFloat(currentPosition.stopLoss); // Assumes stopLoss is stored in position object
          const takeProfitPrice = parseFloat(currentPosition.takeProfit); // Assumes takeProfit is stored in position object

          // Add Entry Price annotation
          annotations.entryPrice = {
            type: 'line',
            yMin: entryPrice,
            yMax: entryPrice,
            borderColor: 'var(--neon-yellow)', // Yellow line for entry
            borderWidth: 2,
            borderDash: [6, 6], // Dashed line style
            label: { // Label configuration for the annotation
              display: true,
              content: `Entry: ${Utils.formatCurrency(entryPrice)}`,
              position: 'end', // Position label at the end of the line
              backgroundColor: 'var(--bg-primary)', // Background color for label text
              font: { family: 'JetBrains Mono' }, // Font style for label
              color: 'var(--neon-yellow)', // Label text color
            },
            z: 10 // Ensure annotation is drawn on top of other chart elements
          };

          // Add Stop Loss annotation if stopLossPrice is valid
          if (stopLossPrice > 0) {
            annotations.stopLoss = {
              type: 'line',
              yMin: stopLossPrice,
              yMax: stopLossPrice,
              borderColor: 'var(--neon-red)', // Red line for stop loss
              borderWidth: 2,
              borderDash: [6, 6],
              label: {
                display: true,
                content: `SL: ${Utils.formatCurrency(stopLossPrice)}`,
                position: 'end',
                backgroundColor: 'var(--bg-primary)',
                font: { family: 'JetBrains Mono' },
                color: 'var(--neon-red)',
              },
              z: 10
            };
          }

          // Add Take Profit annotation if takeProfitPrice is valid
          if (takeProfitPrice > 0) {
            annotations.takeProfit = {
              type: 'line',
              yMin: takeProfitPrice,
              yMax: takeProfitPrice,
              borderColor: 'var(--neon-green)', // Green line for take profit
              borderWidth: 2,
              borderDash: [6, 6],
              label: {
                display: true,
                content: `TP: ${Utils.formatCurrency(takeProfitPrice)}`,
                position: 'end',
                backgroundColor: 'var(--bg-primary)',
                font: { family: 'JetBrains Mono' },
                color: 'var(--neon-green)',
              },
              z: 10
            };
          }
        }
        // Apply the generated annotations to the chart options
        this.charts.price.options.plugins.annotation.annotations = annotations;
        this.charts.price.update('none'); // Update chart to display annotations
      }

      /** Updates the Indicator chart with calculated indicators (RSI, MACD, etc.). */
      updateIndicatorChart(klines) {
        // Clear chart data if no klines are available
        if (!klines || klines.length === 0) {
          this.charts.indicator.data.datasets[0].data = [];
          this.charts.indicator.data.datasets[1].data = [];
          this.charts.indicator.data.datasets[2].data = [];
          this.charts.indicator.data.datasets[3].data = [];
          this.charts.indicator.update('none');
          return;
        }

        const times = klines.map(k => k.time); // Extract timestamps
        const closes = klines.map(k => k.close); // Extract closing prices
        
        // Initialize arrays to hold data points for each indicator series
        const rsiData = [];
        const macdData = [];
        const signalData = [];
        const histogramData = [];

        // Optimization: Recalculate historical indicators only if klines array length or last kline timestamp has changed.
        // This prevents redundant calculations on every minor update, improving performance.
        if (klines.length !== this.lastKlinesLength || klines[klines.length - 1].time !== this.lastKlineTimestamp) {
            // Iterate through klines to calculate indicators for each point
            for (let i = 0; i < closes.length; i++) {
                const subCloses = closes.slice(0, i + 1); // Data up to the current point
                const klineTime = times[i]; // Timestamp for the current kline
                
                // Calculate RSI
                const rsi = Utils.calculateRSI(subCloses);
                if (rsi !== null) rsiData.push({ x: klineTime, y: rsi }); // Add RSI data point

                // Calculate MACD, Signal Line, and Histogram
                const macdResult = Utils.calculateMACD(subCloses);
                // Only add MACD data if all components are available and aligned
                if (macdResult.macd !== null && macdResult.signal !== null && macdResult.histogram !== null) {
                    macdData.push({ x: klineTime, y: macdResult.macd });
                    signalData.push({ x: klineTime, y: macdResult.signal });
                    histogramData.push({ x: klineTime, y: macdResult.histogram });
                }
            }
            // Update tracking variables for optimization check
            this.lastKlineTimestamp = klines[klines.length - 1].time;
            this.lastKlinesLength = klines.length;
        } else {
            // If only the last kline is updated (e.g., current kline is still forming),
            // update only the last data point for efficiency.
            const lastKlineTime = times[times.length - 1];
            const lastCloses = closes; // Use the full closes array for current calculation

            // Recalculate and update RSI for the last point
            const rsi = Utils.calculateRSI(lastCloses);
            if (rsi !== null) {
              // Replace the last RSI data point or add if it's the first
              rsiData.push(...this.charts.indicator.data.datasets[0].data.slice(0, -1), { x: lastKlineTime, y: rsi });
            }

            // Recalculate and update MACD components for the last point
            const macdResult = Utils.calculateMACD(lastCloses);
            if (macdResult.macd !== null && macdResult.signal !== null && macdResult.histogram !== null) {
              macdData.push(...this.charts.indicator.data.datasets[1].data.slice(0, -1), { x: lastKlineTime, y: macdResult.macd });
              signalData.push(...this.charts.indicator.data.datasets[2].data.slice(0, -1), { x: lastKlineTime, y: macdResult.signal });
              histogramData.push(...this.charts.indicator.data.datasets[3].data.slice(0, -1), { x: lastKlineTime, y: macdResult.histogram });
            }
        }

        // Update the chart datasets with the calculated indicator data
        this.charts.indicator.data.datasets[0].data = rsiData;
        this.charts.indicator.data.datasets[1].data = macdData;
        this.charts.indicator.data.datasets[2].data = signalData;
        this.charts.indicator.data.datasets[3].data = histogramData;
        this.charts.indicator.update('none'); // Update the indicator chart
      }

      /** Updates the Risk chart (doughnut chart) with the current risk percentage. */
      updateRiskChart(currentRiskPercent) {
        // Ensure the risk percentage is clamped between 0 and 100 for display purposes
        const clampedRiskPercent = Math.max(0, Math.min(100, currentRiskPercent));
        // Update the data for the doughnut chart segments
        this.charts.risk.data.datasets[0].data = [clampedRiskPercent, 100 - clampedRiskPercent];
        this.charts.risk.update('none'); // Update the chart
      }

      /** Updates the Equity Curve chart with historical equity data. */
      updateEquityChart(equityHistory) {
        // Clear chart data if no equity history is available
        if (!equityHistory || equityHistory.length === 0) {
          this.charts.equityCurve.data.labels = [];
          this.charts.equityCurve.data.datasets[0].data = [];
          this.charts.equityCurve.update('none');
          return;
        }

        // Extract timestamps and equity values for the chart
        const labels = equityHistory.map(entry => entry.time);
        const data = equityHistory.map(entry => entry.equity);

        this.charts.equityCurve.data.labels = labels;
        this.charts.equityCurve.data.datasets[0].data = data;
        this.charts.equityCurve.update('none');
      }
    }

    // --- UI MANAGER ---
    // Handles all DOM manipulations, logging, toast notifications, and UI state updates.
    class UIManager {
      constructor(dom) {
        this.dom = dom;
        this.toastContainer = this._createToastContainer(); // Create a container for toast notifications
      }

      /** Creates a fixed container for toast messages at the bottom right of the screen. */
      _createToastContainer() {
        const container = document.createElement('div');
        // Tailwind CSS classes for fixed positioning, bottom-right placement, stacking order, and flex column layout
        container.className = 'fixed bottom-4 right-4 z-[10000] flex flex-col gap-2'; 
        document.body.appendChild(container); // Append container to the document body
        return container;
      }

      /** Logs a message to the activity log with a timestamp and type-specific styling. */
      log(message, type = 'info') {
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`; // Apply styling based on log type (info, success, warning, error)
        entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`; // Prepend timestamp to the message
        this.dom.activityLog.prepend(entry); // Add the new log entry at the top of the log container
        // Limit the number of log entries to prevent excessive DOM manipulation and memory usage
        if (this.dom.activityLog.children.length > 100) {
          this.dom.activityLog.lastChild.remove(); // Remove the oldest log entry if the limit is exceeded
        }
      }

      /** Shows a loading indicator, either for the entire page or a specific section. */
      showLoading(sectionId = 'loadingOverlay') {
        if (sectionId === 'loadingOverlay') {
          this.dom.loadingOverlay.classList.add('active'); // Show the full-page loader
        } else {
          // Show a section-specific loader
          const section = document.getElementById(sectionId);
          if (section) {
            // Replace the section's content with a spinner and "Loading..." text
            section.innerHTML = `<div class="text-text-secondary text-center py-4"><div class="spinner w-8 h-8 mx-auto mb-2"></div> Loading...</div>`;
          }
        }
      }

      /** Hides the loading indicator. */
      hideLoading(sectionId = 'loadingOverlay') {
        if (sectionId === 'loadingOverlay') {
          this.dom.loadingOverlay.classList.remove('active'); // Hide the full-page loader
        }
        // Specific section loading indicators would be removed here if they were added
      }

      /** Updates the WebSocket connection status indicator and text. */
      updateWsStatus(status) {
        this.dom.wsStatus.className = `status-indicator status-${status}`; // Update the indicator's class based on status
        this.dom.wsStatusText.textContent = status.charAt(0).toUpperCase() + status.slice(1); // Capitalize the first letter of the status text
        // Enable/disable connect and disconnect buttons based on the connection status
        if (status === 'connected') {
          this.dom.connectBtn.disabled = true;
          this.dom.disconnectBtn.disabled = false;
        } else {
          this.dom.connectBtn.disabled = false;
          this.dom.disconnectBtn.disabled = true;
        }
      }

      /** Updates the performance metrics displayed on the dashboard. */
      updateMetrics(metrics) {
        this.dom.totalPnL.textContent = Utils.formatCurrency(metrics.totalPnL || 0);
        this.dom.winRate.textContent = Utils.formatPercentage(metrics.winRate || 0);
        this.dom.sharpeRatio.textContent = (metrics.sharpeRatio || 0).toFixed(2);
        this.dom.maxDrawdown.textContent = Utils.formatPercentage(metrics.maxDrawdown || 0);
        this.dom.activeTrades.textContent = metrics.activeTrades || 0;
        this.dom.accountEquity.textContent = Utils.formatCurrency(metrics.accountEquity || 0);
      }

      /** Updates the displayed values for technical indicators. */
      updateIndicatorValues(indicators) {
        this.dom.rsiValue.textContent = indicators.rsi ? indicators.rsi.toFixed(2) : '--';
        this.dom.macdValue.textContent = indicators.macd?.macd ? indicators.macd.macd.toFixed(2) : '--';
        this.dom.bbValue.textContent = indicators.bb?.width ? indicators.bb.width.toFixed(2) : '--';
        this.dom.volumeValue.textContent = indicators.volume ? Utils.formatCurrency(indicators.volume, '', 2) : '--';
      }

      /** Updates the display for current position details (size, entry price, P&L, margin). */
      updatePositionInfo(position) {
        if (position) {
          this.dom.positionSize.textContent = parseFloat(position.size).toFixed(3);
          this.dom.entryPrice.textContent = Utils.formatCurrency(parseFloat(position.avgPrice));
          this.dom.unrealizedPnL.textContent = Utils.formatCurrency(parseFloat(position.unrealizedPnl));
          // Use positionIM (Initial Margin) or occHoldingCost as approximation for margin used
          this.dom.marginUsed.textContent = Utils.formatCurrency(parseFloat(position.positionIM || position.occHoldingCost || 0));
        } else {
          // Reset fields if no position is active
          this.dom.positionSize.textContent = '0.000';
          this.dom.entryPrice.textContent = '--';
          this.dom.unrealizedPnL.textContent = '$0.00';
          this.dom.marginUsed.textContent = '$0.00';
        }
      }

      /** Renders the table of active positions. */
      renderPositions(positions) {
        const tbody = this.dom.positionsDisplay;
        tbody.innerHTML = ''; // Clear existing rows before rendering
        if (positions && positions.length > 0) {
          positions.forEach(p => {
            // Only display positions with a size greater than 0
            if (parseFloat(p.size) === 0) return; 
            const tr = document.createElement('tr'); // Create a table row
            tr.innerHTML = `
              <td>${p.symbol}</td>
              <td class="${p.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${p.side}</td>
              <td>${parseFloat(p.size).toFixed(3)}</td>
              <td>${Utils.formatCurrency(parseFloat(p.avgPrice))}</td>
              <td>${Utils.formatCurrency(parseFloat(p.liqPrice))}</td>
              <td class="${parseFloat(p.unrealizedPnl) >= 0 ? 'text-green-400' : 'text-red-400'}">${Utils.formatCurrency(parseFloat(p.unrealizedPnl))}</td>
              <td><button class="btn btn-danger btn-sm close-position-btn" data-symbol="${p.symbol}" data-side="${p.side}">Close</button></td>
            `;
            tbody.appendChild(tr); // Add the row to the table body
          });
        }
        // Display a message if there are no active positions
        if (tbody.children.length === 0) {
          tbody.innerHTML = `<tr><td colspan="7" class="text-text-secondary text-center">No active positions</td></tr>`;
        }
      }

      /** Renders the table of open orders. */
      renderOpenOrders(orders) {
        const tbody = this.dom.ordersDisplay;
        tbody.innerHTML = ''; // Clear existing rows
        if (orders && orders.length > 0) {
          orders.forEach(o => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${o.orderId.substring(0, 8)}...</td>
              <td>${o.symbol}</td>
              <td class="${o.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${o.side}</td>
              <td>${o.orderType}</td>
              <td>${Utils.formatCurrency(parseFloat(o.price))}</td>
              <td>${parseFloat(o.qty).toFixed(3)}</td>
              <td>${o.orderStatus}</td>
              <td><button class="btn btn-danger btn-sm cancel-order-btn" data-order-id="${o.orderId}" data-symbol="${o.symbol}">Cancel</button></td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          // Display a message if there are no open orders
          tbody.innerHTML = `<tr><td colspan="8" class="text-text-secondary text-center">No open orders</td></tr>`;
        }
      }

      /** Renders the trade history table. */
      renderTradeHistory(history) {
        const tbody = this.dom.historyDisplay;
        tbody.innerHTML = ''; // Clear existing rows
        if (history && history.length > 0) {
          history.forEach(t => {
            const tr = document.createElement('tr');
            const pnl = parseFloat(t.execPnl); // Parse PnL value for conditional coloring
            tr.innerHTML = `
              <td>${new Date(parseInt(t.execTime)).toLocaleString()}</td>
              <td>${t.symbol}</td>
              <td class="${t.side === 'Buy' ? 'text-green-400' : 'text-red-400'}">${t.side}</td>
              <td>${parseFloat(t.execQty).toFixed(3)}</td>
              <td>${Utils.formatCurrency(parseFloat(t.execPrice))}</td>
              <td>${parseFloat(t.execFee).toFixed(4)}</td>
              <td class="${pnl >= 0 ? 'text-green-400' : 'text-red-400'}">${Utils.formatCurrency(pnl)}</td>
            `;
            tbody.appendChild(tr);
          });
        } else {
          // Display a message if there is no trade history
          tbody.innerHTML = `<tr><td colspan="7" class="text-text-secondary text-center">No trade history</td></tr>`;
        }
      }

      /**
       * Creates and displays a toast notification message.
       * @param {string} message - The message to display in the toast.
       * @param {'info'|'success'|'warning'|'error'} [type='info'] - The type of toast, affecting its color and icon.
       * @param {number} [duration=3000] - The duration in milliseconds the toast should be visible.
       */
      showToast(message, type = 'info', duration = 3000) {
        const toast = document.createElement('div');
        // Apply Tailwind CSS classes for styling based on the toast type
        toast.className = `p-3 rounded-lg shadow-lg text-white text-sm flex items-center gap-2
                           ${type === 'success' ? 'bg-green-600' : ''}
                           ${type === 'error' ? 'bg-red-600' : ''}
                           ${type === 'warning' ? 'bg-orange-500' : ''}
                           ${type === 'info' ? 'bg-blue-500' : ''}`;
        // Toast content includes the message and a close button
        toast.innerHTML = `
          <span>${message}</span>
          <button class="ml-auto text-white opacity-75 hover:opacity-100" onclick="this.parentElement.remove()">
            &times; <!-- HTML entity for 'x' -->
          </button>
        `;
        this.toastContainer.appendChild(toast); // Add the new toast to the container
        // Automatically remove the toast after the specified duration
        setTimeout(() => toast.remove(), duration);
      }

      /** Enables or disables the AI signal execution buttons (Buy, Sell, Hold). */
      setAISignalButtons(enable) {
        this.dom.executeBuyBtn.disabled = !enable;
        this.dom.executeSellBtn.disabled = !enable;
        this.dom.executeHoldBtn.disabled = !enable;
      }

      /** Updates the status icon next to an API key input field. */
      updateApiKeyStatus(keyId, success) {
        const statusSpan = document.getElementById(`${keyId}Status`);
        if (statusSpan) {
            statusSpan.innerHTML = success ? '‚úÖ' : '‚ùå';
            statusSpan.className = `api-status-icon ${success ? 'success' : 'error'}`;
        }
      }

      /** Clears the status icon next to an API key input field. */
      clearApiKeyStatus(keyId) {
        const statusSpan = document.getElementById(`${keyId}Status`);
        if (statusSpan) {
            statusSpan.innerHTML = '';
            statusSpan.className = 'api-status-icon';
        }
      }

      /** Renders the symbol dropdown with categories and symbols. */
      renderSymbolDropdown(symbols, searchTerm = '') {
        const dropdown = document.getElementById('symbolDropdown');
        dropdown.innerHTML = ''; // Clear existing content

        // Group symbols by category
        const categories = {
          'Major Pairs': [],
          'Altcoins': [],
          'Stablecoins': [],
          'Other': []
        };

        symbols.forEach(symbol => {
          if (searchTerm && !symbol.toLowerCase().includes(searchTerm.toLowerCase())) {
            return; // Skip symbols that don't match search
          }

          if (symbol.startsWith('BTC') || symbol.startsWith('ETH')) {
            categories['Major Pairs'].push(symbol);
          } else if (symbol.startsWith('USDT')) {
            categories['Stablecoins'].push(symbol);
          } else if (symbol.startsWith('SOL') || symbol.startsWith('ADA') || symbol.startsWith('DOT') || symbol.startsWith('AVAX') || symbol.startsWith('MATIC')) {
            categories['Altcoins'].push(symbol);
          } else {
            categories['Other'].push(symbol);
          }
        });

        // Render each category
        Object.entries(categories).forEach(([category, categorySymbols]) => {
          if (categorySymbols.length > 0) {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'symbol-category';
            categoryDiv.textContent = category;
            dropdown.appendChild(categoryDiv);

            categorySymbols.forEach(symbol => {
              const symbolDiv = document.createElement('div');
              symbolDiv.className = 'symbol-option';
              symbolDiv.textContent = symbol;
              symbolDiv.dataset.symbol = symbol;
              
              // Highlight if this is the current symbol
              if (symbol === this.state.currentSymbol) {
                symbolDiv.classList.add('selected');
              }
              
              symbolDiv.addEventListener('click', () => this.selectSymbol(symbol));
              dropdown.appendChild(symbolDiv);
            });
          }
        });

        // Show dropdown if there are symbols to display
        if (dropdown.children.length > 0) {
          dropdown.classList.remove('hidden');
        } else {
          dropdown.classList.add('hidden');
        }
      }

      /** Selects a symbol from the dropdown. */
      selectSymbol(symbol) {
        document.getElementById('symbolSelect').value = symbol;
        document.getElementById('symbolSearch').value = symbol;
        document.getElementById('symbolDropdown').classList.add('hidden');
        this.handleSymbolChange(symbol);
      }
    }

    // --- AI MANAGER ---
    // Manages the integration with Google Gemini AI for market analysis.
    class AIManager {
      constructor(logger) {
        // No super() here as AIManager does not extend EventEmitter
        this.logger = logger;
        this.genAI = null; // Instance of GoogleGenerativeAI
      }

      /** Initializes the Gemini AI client with the provided API key. */
      init(apiKey) {
        if (apiKey) {
          try {
            // Create a new GoogleGenerativeAI instance
            this.genAI = new GoogleGenerativeAI(apiKey);
            this.logger('Gemini AI client initialized.', 'success');
          } catch (e) {
            // Log error if initialization fails (e.g., invalid key format)
            this.logger(`Failed to initialize Gemini AI client: ${e.message}`, 'error');
            this.genAI = null; // Ensure genAI is null if initialization fails
          }
        } else {
          // Log warning if API key is missing
          this.logger('Gemini API Key not provided. AI features will be disabled.', 'warning');
          this.genAI = null;
        }
      }

      /**
       * Analyzes market data using Google Gemini AI and returns a trading signal.
       * @param {string} customPrompt - User-provided prompt for analysis.
       * @param {Object} data - Contextual data including klines, order book, position, indicators, etc.
       * @returns {Promise<Object>} A promise that resolves with the AI-generated trading signal (JSON object).
       */
      async analyze(customPrompt, data) {
        if (!this.genAI) {
          // Throw error if AI client is not initialized
          throw new Error('Gemini AI not initialized. Please provide a valid API key in the configuration.');
        }

        const model = this.genAI.getGenerativeModel({ model: CONSTANTS.GEMINI_MODEL }); // Get the specified Gemini model
        const analysisPrompt = this._buildAIPrompt(customPrompt, data); // Construct the detailed prompt for the AI

        try {
          const result = await model.generateContent(analysisPrompt); // Send prompt to Gemini API and get response
          const response = await result.response;
          const text = await response.text(); // Extract the text content from the response
          const parsedOutput = this._parseAIOutput(text);

          // Validate AI response structure and content
          if (!parsedOutput || !['BUY', 'SELL', 'HOLD'].includes(parsedOutput.action) || typeof parsedOutput.quantity !== 'number') {
              throw new Error("AI response is malformed or missing critical fields (action, quantity).");
          }
          return parsedOutput; // Return the structured signal object
        } catch (error) {
          // Log any errors encountered during AI generation or parsing/validation
          this.logger(`Gemini AI Generation Error: ${error.message}`, 'error');
          throw error; // Re-throw the error for the caller to handle
        }
      }
      
      /** Constructs the prompt string for the Gemini AI model, including market data and user instructions. */
      _buildAIPrompt(customPrompt, data) {
        const { klines, orderBook, position, analysisMode, symbol, timeframe, accountBalance, indicators } = data;
        const latestKline = klines[klines.length - 1]; // Get the most recent kline data
        
        // Prepare a summary of market data for the AI
        const marketData = {
          latestPrice: latestKline?.close, // Latest closing price
          volume: latestKline?.volume, // Latest volume
          orderBook: { // Top 5 bids and asks for context
            bids: orderBook.bids.slice(0, 5).map(b => ({ price: b.price.toFixed(2), size: b.size.toFixed(3) })),
            asks: orderBook.asks.slice(0, 5).map(a => ({ price: a.price.toFixed(2), size: a.size.toFixed(3) }))
          },
          technicalIndicators: { // Formatted technical indicator values
            rsi: indicators.rsi ? indicators.rsi.toFixed(2) : 'N/A',
            macd: indicators.macd?.macd ? indicators.macd.macd.toFixed(2) : 'N/A',
            signal: indicators.macd?.signal ? indicators.macd.signal.toFixed(2) : 'N/A',
            histogram: indicators.macd?.histogram ? indicators.macd.histogram.toFixed(2) : 'N/A',
            bollingerBands: {
              upper: indicators.bb?.upper ? indicators.bb.upper.toFixed(2) : 'N/A',
              middle: indicators.bb?.middle ? indicators.bb.middle.toFixed(2) : 'N/A',
              lower: indicators.bb?.lower ? indicators.bb.lower.toFixed(2) : 'N/A',
              width: indicators.bb?.width ? indicators.bb.width.toFixed(2) : 'N/A'
            }
          },
          currentPosition: position ? { // Details of the current open position, if any
            symbol: position.symbol,
            side: position.side,
            size: parseFloat(position.size).toFixed(3),
            entryPrice: parseFloat(position.avgPrice).toFixed(2),
            unrealizedPnl: parseFloat(position.unrealizedPnl).toFixed(2)
          } : 'None', // Indicate if no position is open
          accountEquity: accountBalance ? parseFloat(accountBalance.equity).toFixed(2) : 'N/A' // Current account equity
        };

        // Construct the prompt template for the AI
        const promptTemplate = `
          You are a sophisticated crypto trading AI. Analyze the provided market data and generate a trading signal.
          The signal should be a JSON object with the following structure:
          {
            "action": "BUY" | "SELL" | "HOLD",
            "quantity": number, // Suggested trade size in contracts. Use 0 for HOLD.
            "confidence": "LOW" | "MEDIUM" | "HIGH", // AI's confidence in the signal
            "reason": string, // Detailed explanation for the decision. Keep it concise (max 200 words).
            "targetPrice": number | null, // Optional target price for Take Profit
            "stopLossPrice": number | null // Optional stop loss price
          }

          **Current Market Context:**
          Symbol: ${symbol}
          Timeframe: ${timeframe}
          Trading Strategy: ${analysisMode}
          Market Data: ${JSON.stringify(marketData, null, 2)}

          ${customPrompt ? `**Additional Instructions from User:**\n${customPrompt}\n` : ''}

          Consider risk management principles and current account equity when determining the quantity.
          Provide ONLY the JSON object as your response. Do not include any introductory or concluding text.
        `;

        return promptTemplate;
      }

      /** Parses the AI's response text, attempting to extract and validate JSON. */
      _parseAIOutput(text) {
        try {
          // Attempt to extract JSON content enclosed in markdown code blocks (```json ... ```)
          const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/);
          if (jsonMatch && jsonMatch[1]) {
            return JSON.parse(jsonMatch[1]); // Parse the extracted JSON string
          }
          // If no markdown block is found, attempt to parse the entire text as JSON
          return JSON.parse(text);
        } catch (e) {
          // Log an error if JSON parsing fails
          this.logger(`Failed to parse AI response as JSON: ${e.message}. Raw text: ${text}`, 'error');
          throw new Error('AI response could not be parsed. Check raw output for details.');
        }
      }
    }

    // --- MAIN TRADING APPLICATION CLASS ---
    // Orchestrates all components of the trading terminal.
    class TradingApp {
      constructor() {
        this.dom = this._getDomElements(); // Get references to all necessary DOM elements
        this.ui = new UIManager(this.dom); // Initialize UI Manager
        this.bybitClient = new BybitClient(this.ui.log.bind(this.ui)); // Initialize Bybit REST API Client
        this.bybitWs = new BybitWebSocket(this.ui.log.bind(this.ui)); // Initialize Bybit WebSocket Client
        this.chartManager = new ChartManager(this.dom, this.ui.log.bind(this.ui)); // Initialize Chart Manager
        this.aiManager = new AIManager(this.ui.log.bind(this.ui)); // Initialize AI Manager
        
        this.state = this._getInitialState(); // Initialize the application's state
        
        this._bindEventListeners(); // Set up all event listeners
        this._initialize(); // Perform initial setup tasks
      }

      /** Gathers all necessary DOM elements by their IDs and stores them in an object. */
      _getDomElements() {
        const ids = [
          'loadingOverlay', 'totalPnL', 'winRate', 'sharpeRatio', 'maxDrawdown', 'activeTrades', 'accountEquity',
          'toggleAdvancedBtn', 'geminiApiKey', 'bybitApiKey', 'bybitApiSecret', 'advancedSettings', 'maxPosition',
          'riskPerTrade', 'leverage', 'orderType', 'tpPercent', 'slPercent', 'trailingStop', 'enableTpSl',
          'enableTrailing', 'enableKelly', 'tradingMode', 'saveConfigBtn', 'loadConfigBtn', 'clearConfigBtn',
          'configStatus', 'wsStatus', 'wsStatusText', 'symbolSelect', 'timeframe', 'connectBtn', 'disconnectBtn',
          'orderBookChart', 'bidBookDisplay', 'askBookDisplay', 'priceChart', 'volumeChart', 'rsiValue', 'macdValue', 'bbValue',
          'volumeValue', 'indicatorChart', 'customPromptBtn', 'customPromptSection', 'customPrompt', 'analysisMode',
          'analyzeBtn', 'aiOutput', 'aiReason', 'executeBuyBtn', 'executeSellBtn', 'executeHoldBtn', 'refreshPositionsBtn',
          'positionSize', 'entryPrice', 'unrealizedPnL', 'marginUsed', 'positionsDisplay', 'ordersDisplay',
          'historyDisplay', 'portfolioRisk', 'varValue', 'kellyPercent', 'riskScore', 'riskChart', 'activityLog',
          'clearLogsBtn', 'geminiApiKeyStatus', 'bybitApiKeyStatus', 'bybitApiSecretStatus', // New API key status elements
          'equityChart', // New equity chart canvas
          'symbolSearch', // Symbol search input
          'symbolDropdown' // Symbol dropdown container
        ];
        const elements = {};
        ids.forEach(id => elements[id] = document.getElementById(id)); // Map ID to DOM element
        return elements;
      }

      /** Sets up the initial state of the application variables. */
      _getInitialState() {
        return {
          currentSymbol: 'BTCUSDT', // Default trading symbol
          currentTimeframe: '5', // Default timeframe (Bybit uses strings like '1', '5', '60', 'D')
          orderBook: { bids: [], asks: [] }, // Stores processed order book data
          klines: [], // Stores historical kline data: {time, open, high, low, close, volume}
          indicators: {}, // Stores calculated indicator values (RSI, MACD, BB)
          accountBalance: null, // Stores account balance details fetched from Bybit API
          positions: [], // Stores active positions
          openOrders: [], // Stores open orders
          tradeHistory: [], // Stores executed trades
          lastSignal: null, // Stores the last AI-generated trading signal for execution
          pnlHistory: [], // Stores PnL history, potentially for Sharpe Ratio calculation (currently not actively used for equity curve)
          equityCurve: [], // Stores historical equity values for accurate Max Drawdown calculation
          wsTopics: new Set(), // Tracks active WebSocket subscriptions for proper management (subscribe/unsubscribe)
          symbolInfo: null, // Stores dynamic symbol info (tickSize, lotSize) for current symbol
          allSymbols: [] // Stores all available symbols from Bybit
        };
      }

      /** Binds all event listeners to UI elements and service components. */
      _bindEventListeners() {
        // --- Configuration Section Event Listeners ---
        this.dom.saveConfigBtn.addEventListener('click', () => this.saveConfiguration());
        this.dom.loadConfigBtn.addEventListener('click', () => this.loadConfiguration());
        this.dom.clearConfigBtn.addEventListener('click', () => this.clearConfiguration());
        this.dom.toggleAdvancedBtn.addEventListener('click', () => this.dom.advancedSettings.classList.toggle('hidden')); // Toggle visibility of advanced settings
        this.dom.clearLogsBtn.addEventListener('click', () => this.dom.activityLog.innerHTML = '<div class="text-text-secondary">System initialized...</div>'); // Clear activity log content

        // --- Market Data Section Event Listeners ---
        this.dom.connectBtn.addEventListener('click', () => this.connect()); // Connect to Bybit
        this.dom.disconnectBtn.addEventListener('click', () => this.disconnect()); // Disconnect from Bybit
        this.dom.symbolSelect.addEventListener('change', (e) => this.handleSymbolChange(e.target.value)); // Handle symbol change
        this.dom.timeframe.addEventListener('change', (e) => this.handleTimeframeChange(e.target.value)); // Handle timeframe change

        // Symbol search functionality
        this.dom.symbolSearch.addEventListener('input', (e) => {
          const searchTerm = e.target.value;
          this.ui.renderSymbolDropdown(this.state.allSymbols, searchTerm);
        });

        this.dom.symbolSearch.addEventListener('focus', () => {
          if (this.state.allSymbols.length > 0) {
            this.ui.renderSymbolDropdown(this.state.allSymbols);
          }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.symbol-search-container')) {
            this.dom.symbolDropdown.classList.add('hidden');
          }
        });

        // --- Tab Navigation Listeners ---
        document.querySelectorAll('.tab-nav .tab-btn').forEach(btn => {
          btn.addEventListener('click', (e) => this.handleTabSwitch(e)); // Handle tab switching
        });
        
        // --- AI Analysis Section Event Listeners ---
        this.dom.analyzeBtn.addEventListener('click', () => this.runAnalysis()); // Trigger AI analysis
        this.dom.customPromptBtn.addEventListener('click', () => this.dom.customPromptSection.classList.toggle('hidden')); // Toggle visibility of custom prompt input
        this.dom.executeBuyBtn.addEventListener('click', () => this.executeSignal('BUY')); // Execute BUY signal
        this.dom.executeSellBtn.addEventListener('click', () => this.executeSignal('SELL')); // Execute SELL signal
        this.dom.executeHoldBtn.addEventListener('click', () => this.ui.showToast('AI recommends HOLD. No action taken.', 'info')); // Handle HOLD signal
        
        // --- Position/Order Section Event Listeners ---
        this.dom.refreshPositionsBtn.addEventListener('click', () => this.fetchAccountInfo()); // Refresh account data

        // --- Event Delegation for Dynamic Buttons ---
        // Use event delegation for dynamically added buttons (like Close Position, Cancel Order)
        this.dom.positionsDisplay.addEventListener('click', (e) => {
          if (e.target.classList.contains('close-position-btn')) { // Check if the clicked element is a 'Close' button
            this.closePosition(e.target.dataset.symbol, e.target.dataset.side); // Call closePosition with symbol and side
          }
        });
        this.dom.ordersDisplay.addEventListener('click', (e) => {
          if (e.target.classList.contains('cancel-order-btn')) { // Check if the clicked element is a 'Cancel' button
            this.cancelOrder(e.target.dataset.symbol, e.target.dataset.orderId); // Call cancelOrder with symbol and orderId
          }
        });

        // --- Listen for events from BybitWebSocket and BybitClient ---
        this.bybitWs.on('status', (status) => this.ui.updateWsStatus(status)); // Update UI based on WebSocket status
        this.bybitWs.on('message', (data) => this._handleWsMessage(data)); // Process incoming WebSocket messages
        this.bybitClient.on('error', (msg) => this.ui.showToast(msg, 'error')); // Show errors from Bybit API client as toasts
      }

      /** Performs initial setup tasks upon application load. */
      async _initialize() {
        this.ui.log('System Initializing...', 'info');
        this.ui.showLoading(); // Show the page-level loading indicator
        this.chartManager.initCharts(); // Initialize all charts
        this.loadConfiguration(); // Load saved configuration (API keys, settings)
        await this.populateSymbols(); // Fetch and populate trading symbols dropdown and their details
        await this.fetchInitialData(); // Fetch initial kline data and set up charts
        this.ui.hideLoading(); // Hide the page-level loading indicator
        this.ui.log('Initialization Complete. Ready to connect.', 'success');
      }

      /** Saves the current application configuration to localStorage, encrypted. */
      saveConfiguration() {
        try {
          // Validate numeric inputs before saving
          const maxPosition = parseFloat(this.dom.maxPosition.value);
          const riskPerTrade = parseFloat(this.dom.riskPerTrade.value);
          const tpPercent = parseFloat(this.dom.tpPercent.value);
          const slPercent = parseFloat(this.dom.slPercent.value);
          const trailingStop = parseFloat(this.dom.trailingStop.value);

          if (isNaN(maxPosition) || maxPosition <= 0) { this.ui.showToast('Invalid Max Position Size.', 'error'); return; }
          if (isNaN(riskPerTrade) || riskPerTrade <= 0 || riskPerTrade > 5) { this.ui.showToast('Invalid Risk Per Trade (0.1-5%).', 'error'); return; }
          if (isNaN(tpPercent) || tpPercent < 0.1) { this.ui.showToast('Invalid Take Profit (min 0.1%).', 'error'); return; }
          if (isNaN(slPercent) || slPercent < 0.1) { this.ui.showToast('Invalid Stop Loss (min 0.1%).', 'error'); return; }
          if (isNaN(trailingStop) || trailingStop < 0) { this.ui.showToast('Invalid Trailing Stop (min 0%).', 'error'); return; }

          // Gather all configuration settings from the UI elements and state
          const config = {
            geminiApiKey: this.dom.geminiApiKey.value,
            bybitApiKey: this.dom.bybitApiKey.value,
            bybitApiSecret: this.dom.bybitApiSecret.value,
            tradingMode: this.dom.tradingMode.value,
            maxPosition: maxPosition.toString(), // Store as string to match input value types
            riskPerTrade: riskPerTrade.toString(),
            leverage: this.dom.leverage.value,
            orderType: this.dom.orderType.value,
            tpPercent: tpPercent.toString(),
            slPercent: slPercent.toString(),
            trailingStop: trailingStop.toString(),
            enableTpSl: this.dom.enableTpSl.checked,
            enableTrailing: this.dom.enableTrailing.checked,
            enableKelly: this.dom.enableKelly.checked,
            currentSymbol: this.state.currentSymbol,
            currentTimeframe: this.state.currentTimeframe
          };
          // Encrypt the configuration object before saving to localStorage
          const encryptedConfig = Utils.encrypt(JSON.stringify(config), CONSTANTS.ENCRYPTION_KEY);
          localStorage.setItem('tradingBotConfig', encryptedConfig); // Save encrypted config
          this.ui.log('Configuration saved and encrypted.', 'success');
          this.ui.showToast('Configuration saved!', 'success');
        } catch (e) {
          // Log and show error if saving fails
          this.ui.log('Failed to save configuration: ' + e.message, 'error');
          this.ui.showToast('Failed to save configuration.', 'error');
        }
      }

      /** Loads configuration from localStorage, decrypts it, and applies settings to the UI and application state. */
      loadConfiguration() {
        const encryptedConfig = localStorage.getItem('tradingBotConfig'); // Retrieve encrypted config from localStorage
        if (encryptedConfig) {
          try {
            // Decrypt and parse the configuration string
            const config = JSON.parse(Utils.decrypt(encryptedConfig, CONSTANTS.ENCRYPTION_KEY));
            
            // Populate UI elements with the loaded configuration values
            this.dom.geminiApiKey.value = config.geminiApiKey || '';
            this.dom.bybitApiKey.value = config.bybitApiKey || '';
            this.dom.bybitApiSecret.value = config.bybitApiSecret || '';
            this.dom.tradingMode.value = config.tradingMode || 'testnet';
            this.dom.maxPosition.value = config.maxPosition || '0.01';
            this.dom.riskPerTrade.value = config.riskPerTrade || '1';
            this.dom.leverage.value = config.leverage || '10';
            this.dom.orderType.value = config.orderType || 'Market';
            this.dom.tpPercent.value = config.tpPercent || '2';
            this.dom.slPercent.value = config.slPercent || '1';
            this.dom.trailingStop.value = config.trailingStop || '0.5';
            this.dom.enableTpSl.checked = config.enableTpSl !== undefined ? config.enableTpSl : true; // Handle undefined case for checkbox
            this.dom.enableTrailing.checked = config.enableTrailing || false;
            this.dom.enableKelly.checked = config.enableKelly || false;
            
            // Update application state with loaded symbol and timeframe
            this.state.currentSymbol = config.currentSymbol || 'BTCUSDT';
            this.state.currentTimeframe = config.currentTimeframe || '5';

            // Ensure dropdowns reflect the loaded state
            this.dom.symbolSelect.value = this.state.currentSymbol;
            this.dom.timeframe.value = this.state.currentTimeframe;

            // Update API clients with loaded credentials and trading mode
            this.bybitClient.setCredentials(config.bybitApiKey, config.bybitApiSecret, this.dom.tradingMode.value);
            this.bybitWs.setTradingMode(this.dom.tradingMode.value);
            this.aiManager.init(config.geminiApiKey); // Initialize AI manager with Gemini API key
            
            this.ui.log('Configuration loaded and decrypted.', 'info');
            this.ui.showToast('Configuration loaded!', 'info');
          } catch (e) {
            // Handle errors during decryption or parsing (e.g., corrupted data)
            this.ui.log('Failed to load or decrypt configuration. It may be corrupted: ' + e.message, 'error');
            this.ui.showToast('Failed to load config. It might be corrupted.', 'error');
            localStorage.removeItem('tradingBotConfig'); // Remove corrupted configuration
          }
        }
      }
      
      /** Clears the saved configuration from localStorage and resets UI elements and application state. */
      clearConfiguration() {
        localStorage.removeItem('tradingBotConfig'); // Remove config from storage
        // Reset all configuration input fields to their default values
        this.dom.geminiApiKey.value = '';
        this.dom.bybitApiKey.value = '';
        this.dom.bybitApiSecret.value = '';
        this.dom.tradingMode.value = 'testnet';
        this.dom.maxPosition.value = '0.01';
        this.dom.riskPerTrade.value = '1';
        this.dom.leverage.value = '10';
        this.dom.orderType.value = 'Market';
        this.dom.tpPercent.value = '2';
        this.dom.slPercent.value = '1';
        this.dom.trailingStop.value = '0.5';
        this.dom.enableTpSl.checked = true;
        this.dom.enableTrailing.checked = false;
        this.dom.enableKelly.checked = false;
        // Reset application state defaults
        this.state.currentSymbol = 'BTCUSDT';
        this.state.currentTimeframe = '5';
        this.state.symbolInfo = null; // Clear symbol info

        // Reset API clients to default/empty state
        this.bybitClient.setCredentials('', '', 'testnet');
        this.bybitWs.setTradingMode('testnet');
        this.aiManager.init('');

        // Clear API key status icons
        this.ui.clearApiKeyStatus('geminiApiKey');
        this.ui.clearApiKeyStatus('bybitApiKey');
        this.ui.clearApiKeyStatus('bybitApiSecret');

        // Reset UI dropdowns and state variables
        this.dom.symbolSelect.value = this.state.currentSymbol;
        this.dom.timeframe.value = this.state.currentTimeframe;
        this.state.klines = []; // Clear historical data
        this.state.positions = [];
        this.state.openOrders = [];
        this.state.tradeHistory = [];
        this.state.lastSignal = null;
        this.state.equityCurve = []; // Clear equity curve for drawdown calculation
        this.ui.renderPositions([]); // Clear positions table display
        this.ui.renderOpenOrders([]); // Clear orders table display
        this.ui.renderTradeHistory([]); // Clear history table display
        this.ui.updatePositionInfo(null); // Clear position info display
        // Reset metrics to zero/default values
        this.ui.updateMetrics({ totalPnL: 0, winRate: 0, sharpeRatio: 0, maxDrawdown: 0, activeTrades: 0, accountEquity: 0 }); 
        this.ui.setAISignalButtons(false); // Disable AI action buttons

        // Clear charts
        this.chartManager.updatePriceChart([]);
        this.chartManager.updateIndicatorChart([]);
        this.chartManager.updateOrderBook([], []);
        this.chartManager.updateRiskChart(0);
        this.chartManager.updateEquityChart([]);


        this.ui.log('Configuration cleared.', 'warning');
        this.ui.showToast('Configuration cleared!', 'warning');
      }

      /** Connects to Bybit API and WebSocket, validates credentials, and fetches initial data. */
      async connect() {
        if (this.bybitWs.isConnected) return; // Exit if already connected
        this.ui.showLoading(); // Show loading indicator
        
        // Clear previous API key statuses
        this.ui.clearApiKeyStatus('geminiApiKey');
        this.ui.clearApiKeyStatus('bybitApiKey');
        this.ui.clearApiKeyStatus('bybitApiSecret');

        // Basic validation for required API keys before proceeding
        const geminiApiKey = this.dom.geminiApiKey.value;
        const bybitApiKey = this.dom.bybitApiKey.value;
        const bybitApiSecret = this.dom.bybitApiSecret.value;

        let isValid = true;
        if (!geminiApiKey) {
            this.ui.showToast('Gemini API Key is required.', 'error');
            this.ui.updateApiKeyStatus('geminiApiKey', false);
            isValid = false;
        }
        if (!bybitApiKey) {
            this.ui.showToast('Bybit API Key is required.', 'error');
            this.ui.updateApiKeyStatus('bybitApiKey', false);
            isValid = false;
        }
        if (!bybitApiSecret) {
            this.ui.showToast('Bybit API Secret is required.', 'error');
            this.ui.updateApiKeyStatus('bybitApiSecret', false);
            isValid = false;
        }

        if (!isValid) {
            this.ui.hideLoading();
            return;
        }

        // Set credentials and mode for Bybit clients
        this.bybitClient.setCredentials(bybitApiKey, bybitApiSecret, this.dom.tradingMode.value);
        this.bybitWs.setTradingMode(this.dom.tradingMode.value);
        this.aiManager.init(geminiApiKey); // Initialize AI manager with Gemini API key

        try {
          // Attempt to fetch wallet balance to validate Bybit API keys
          await this.bybitClient.getWalletBalance(); 
          this.ui.log('Bybit API keys validated successfully.', 'success');
          this.ui.updateApiKeyStatus('bybitApiKey', true);
          this.ui.updateApiKeyStatus('bybitApiSecret', true);
          this.ui.updateApiKeyStatus('geminiApiKey', true); // Assume Gemini is valid if init didn't throw

          // Fetch initial account data (positions, orders, history) to populate UI
          await this.fetchAccountInfo(); 

          this.bybitWs.connect(); // Establish WebSocket connection
          this.subscribeToTopics(); // Subscribe to necessary data streams
        } catch (error) {
          // Handle errors during connection or validation
          this.ui.log(`Connection failed: ${error.message}`, 'error');
          this.ui.showToast(`Connection failed: ${error.message}`, 'error');
          this.ui.updateApiKeyStatus('bybitApiKey', false);
          this.ui.updateApiKeyStatus('bybitApiSecret', false);
          this.ui.updateApiKeyStatus('geminiApiKey', false); // Mark Gemini as invalid if overall connection failed
          this.disconnect(); // Ensure a clean disconnect if connection fails
        } finally {
          this.ui.hideLoading(); // Hide loading indicator
        }
      }
      
      /** Disconnects from Bybit API and WebSocket services. */
      disconnect() {
        this.bybitWs.disconnect(); // Disconnect the WebSocket client
        this.ui.log('Disconnected from Bybit.', 'info');
        this.ui.showToast('Disconnected from Bybit.', 'info');
        this.state.wsTopics.clear(); // Clear tracked WebSocket topics
        // Clear API key status icons
        this.ui.clearApiKeyStatus('geminiApiKey');
        this.ui.clearApiKeyStatus('bybitApiKey');
        this.ui.clearApiKeyStatus('bybitApiSecret');
      }

      /** Fetches and populates the trading symbol dropdown list, including dynamic precision info. */
      async populateSymbols() {
        try {
          const symbols = await this.bybitClient.getValidSymbols(); // Fetch valid symbols and their details from Bybit
          this.state.allSymbols = symbols; // Store all symbols in state for search functionality
          
          // Populate the symbol select dropdown with fetched symbols
          this.dom.symbolSelect.innerHTML = symbols.map(s => `<option value="${s}">${s}</option>`).join('');
          // Set the dropdown to the currently selected symbol (from config or default)
          this.dom.symbolSelect.value = this.state.currentSymbol; 
          // Store symbol details in state for dynamic precision
          this.state.symbolInfo = this.bybitClient.symbolDetails[this.state.currentSymbol] || null;

          this.ui.log(`Loaded ${Object.keys(this.bybitClient.symbolDetails).length} valid trading symbols with details.`, 'info');
        } catch (error) {
          this.ui.log('Failed to load symbols: ' + error.message, 'error');
          this.dom.symbolSelect.innerHTML = '<option>Error loading</option>'; // Display error in the dropdown
          this.ui.showToast('Failed to load symbols.', 'error');
        }
      }
      
      /** Handles changes in the selected trading symbol. */
      async handleSymbolChange(newSymbol) {
        if (newSymbol === this.state.currentSymbol) return; // Exit if the symbol hasn't changed
        this.ui.log(`Symbol changed to ${newSymbol}`, 'info');
        const oldSymbol = this.state.currentSymbol;
        this.state.currentSymbol = newSymbol; // Update the current symbol in the application state
        this.state.symbolInfo = this.bybitClient.symbolDetails[newSymbol] || null; // Update dynamic symbol info

        if (this.bybitWs.isConnected) {
          // If connected, unsubscribe from old topics and subscribe to new ones
          this.unsubscribeFromTopics(oldSymbol, this.state.currentTimeframe);
          await this.fetchInitialData(); // Fetch data for the new symbol
          await this.fetchAccountInfo(); // Refresh account info in the context of the new symbol
          this.subscribeToTopics(); // Subscribe to topics for the new symbol
        } else {
          // If not connected, just fetch initial data for the new symbol to update charts
          await this.fetchInitialData(); 
        }
        // Clear previous AI signal and reset AI analysis UI elements
        this.state.lastSignal = null;
        this.dom.aiOutput.textContent = 'No analysis performed yet...';
        this.dom.aiReason.textContent = '';
        this.dom.aiReason.classList.add('hidden');
        this.ui.setAISignalButtons(false); // Disable AI action buttons
      }
      
      /** Handles changes in the selected analysis timeframe. */
      async handleTimeframeChange(newTimeframe) {
        if (newTimeframe === this.state.currentTimeframe) return; // Exit if timeframe hasn't changed
        this.ui.log(`Timeframe changed to ${newTimeframe}`, 'info');
        const oldTimeframe = this.state.currentTimeframe;
        this.state.currentTimeframe = newTimeframe; // Update the current timeframe in state
        
        if (this.bybitWs.isConnected) {
          // If connected, unsubscribe from old topics and subscribe to new ones
          this.unsubscribeFromTopics(this.state.currentSymbol, oldTimeframe);
          await this.fetchInitialData(); // Fetch data for the new timeframe
          this.subscribeToTopics(); // Subscribe to topics for the new timeframe
        } else {
          // If not connected, just fetch initial data for the new timeframe
          await this.fetchInitialData();
        }
        // Clear previous AI signal and reset AI analysis UI elements
        this.state.lastSignal = null;
        this.dom.aiOutput.textContent = 'No analysis performed yet...';
        this.dom.aiReason.textContent = '';
        this.dom.aiReason.classList.add('hidden');
        this.ui.setAISignalButtons(false); // Disable AI action buttons
      }

      /** Fetches initial historical kline data and updates charts and indicators. */
      async fetchInitialData() {
        this.ui.showLoading(); // Show loading indicator while fetching data
        try {
          const klinesResult = await this.bybitClient.getKlines(this.state.currentSymbol, this.state.currentTimeframe);
          // Process klines: parse values, convert timestamp to milliseconds, and reverse to chronological order
          this.state.klines = klinesResult.list.map(k => ({
            time: parseInt(k[0]), // Timestamp in milliseconds
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5]),
          })).reverse(); // Bybit klines are usually in descending order, reverse for chronological display

          this._updateChartsAndIndicators(); // Update charts and indicators with the fetched data
          this.ui.log(`Fetched ${this.state.klines.length} historical klines for ${this.state.currentSymbol} (${this.state.currentTimeframe}).`, 'info');
        } catch (error) {
          this.ui.log(`Failed to fetch initial market data: ${error.message}`, 'error');
          this.ui.showToast('Failed to fetch initial market data.', 'error');
        } finally {
          this.ui.hideLoading(); // Hide loading indicator once data is fetched or an error occurs
        }
      }

      // Debounced version of fetchAccountInfo to prevent excessive API calls.
      // This ensures that even if multiple updates trigger fetchAccountInfo rapidly,
      // it's only executed once per second, respecting API rate limits.
      debouncedFetchAccountInfo = Utils.debounce(async () => {
        try {
          // Fetch all necessary account data concurrently using Promise.all
          const [balance, positions, openOrders, tradeHistory] = await Promise.all([
            this.bybitClient.getWalletBalance(), // Fetch wallet balance
            this.bybitClient.getPositions(this.state.currentSymbol), // Fetch positions for the current symbol
            this.bybitClient.getOpenOrders(this.state.currentSymbol), // Fetch open orders for the current symbol
            this.bybitClient.getTradeHistory(this.state.currentSymbol) // Fetch trade history for the current symbol
          ]);
          
          // Update application state with the fetched data
          this.state.accountBalance = balance;
          // Filter out positions with zero size to only show active ones
          this.state.positions = positions.filter(p => parseFloat(p.size) > 0); 
          this.state.openOrders = openOrders;
          this.state.tradeHistory = tradeHistory;

          // Find the current position for the selected symbol to display details and update chart annotations
          const currentPosition = this.state.positions.find(p => p.symbol === this.state.currentSymbol);
          
          // Update UI elements with the latest data
          this.ui.updatePositionInfo(currentPosition); // Update position details display
          this.ui.renderPositions(this.state.positions); // Render active positions table
          this.ui.renderOpenOrders(this.state.openOrders); // Render open orders table
          this.ui.renderTradeHistory(this.state.tradeHistory); // Render trade history table
          // Update the price chart, passing klines and current position for annotations
          this.chartManager.updatePriceChart(this.state.klines, currentPosition); 
          
          this.ui.log('Account info, positions, orders, and history refreshed.', 'info');
          this._calculateMetrics(); // Recalculate and update all metrics
        } catch (error) {
          // Log and show error if fetching account info fails
          this.ui.log(`Failed to fetch account info: ${error.message}`, 'error');
          this.ui.showToast('Failed to fetch account info.', 'error');
        }
      }, 1000); // Debounce delay set to 1000ms (1 second)

      /** Fetches account information (balance, positions, orders, history). */
      async fetchAccountInfo() {
        this.debouncedFetchAccountInfo(); // Call the debounced version to manage API calls
      }

      /** Calculates and updates all performance and risk metrics displayed in the UI. */
      _calculateMetrics() {
        // Calculate Total P&L from trade history
        const totalPnL = this.state.tradeHistory.reduce((sum, t) => sum + parseFloat(t.execPnl), 0);
        // Calculate Win Rate
        const winningTrades = this.state.tradeHistory.filter(t => parseFloat(t.execPnl) > 0).length;
        const totalTrades = this.state.tradeHistory.length;
        const winRate = totalTrades > 0 ? winningTrades / totalTrades : 0;
        
        // Calculate Sharpe Ratio from trade PnL (Note: This is a simplified per-trade Sharpe Ratio, not a standard periodic one)
        const returns = this.state.tradeHistory.map(t => parseFloat(t.execPnl));
        const sharpeRatio = Utils.calculateSharpeRatio(returns);

        // Calculate Max Drawdown
        let maxDrawdown = 0;
        // Track equity curve over time for accurate drawdown calculation
        const currentEquity = this.state.accountBalance ? parseFloat(this.state.accountBalance.equity) : 0;
        
        // Only add equity point if it's a new time or a significant change (to avoid too many points)
        const lastEquityPoint = this.state.equityCurve[this.state.equityCurve.length - 1];
        const currentTime = Date.now();
        if (!lastEquityPoint || (currentTime - lastEquityPoint.time > 60000) || (Math.abs(currentEquity - lastEquityPoint.equity) / lastEquityPoint.equity > 0.001)) {
            this.state.equityCurve.push({ time: currentTime, equity: currentEquity });
            // Limit the size of the equity curve array
            if (this.state.equityCurve.length > CONSTANTS.METRIC_CALC_PERIODS.EQUITY_CURVE_POINTS) { 
                this.state.equityCurve.shift(); 
            }
        }
        
        // Calculate Max Drawdown from the populated equity curve
        if (this.state.equityCurve.length > 0) {
          let peakEquity = this.state.equityCurve[0].equity; // Initialize peak equity with the first value
          for (let i = 1; i < this.state.equityCurve.length; i++) {
            const equity = this.state.equityCurve[i].equity;
            if (equity > peakEquity) {
              peakEquity = equity; // Update peak if current equity is higher
            }
            // Calculate drawdown percentage relative to the peak equity
            const drawdown = (peakEquity - equity) / peakEquity;
            if (drawdown > maxDrawdown) {
              maxDrawdown = drawdown; // Update max drawdown if current drawdown is larger
            }
          }
        }

        // Compile all calculated metrics into an object
        const metrics = {
          totalPnL: totalPnL,
          winRate: winRate,
          sharpeRatio: sharpeRatio || 0, // Default to 0 if calculation fails
          maxDrawdown: maxDrawdown,
          activeTrades: this.state.positions.length, // Number of currently open positions
          accountEquity: currentEquity
        };
        this.ui.updateMetrics(metrics); // Update the UI with the calculated metrics

        // --- Update Risk Management Section ---
        // Calculate current portfolio risk as unrealized PnL relative to account equity
        const unrealizedPnl = this.state.positions.reduce((sum, p) => sum + parseFloat(p.unrealizedPnl), 0);
        let currentRiskPercent = 0;
        if (currentEquity > 0) {
          currentRiskPercent = (unrealizedPnl / currentEquity) * 100;
        }
        // Update the risk chart visualization and display risk level/score
        this.ui.updateRiskChart(currentRiskPercent); // Update the doughnut chart
        // Set portfolio risk level based on percentage
        this.dom.portfolioRisk.textContent = currentRiskPercent >= 10 ? 'High' : (currentRiskPercent >= 2 ? 'Medium' : 'Low'); 
        this.dom.riskScore.textContent = `${currentRiskPercent.toFixed(0)}/100`; // Display risk score

        // Calculate and display Kelly Criterion percentage if enabled
        if (this.dom.enableKelly.checked) {
          const winProbability = metrics.winRate; // Use calculated win rate
          const tpPercentVal = parseFloat(this.dom.tpPercent.value); // Get TP percentage from config
          const slPercentVal = parseFloat(this.dom.slPercent.value); // Get SL percentage from config
          let riskRewardRatio = 0;
          // Calculate Risk/Reward ratio dynamically, handling potential division by zero if SL is not set
          if (slPercentVal > 0) {
            riskRewardRatio = tpPercentVal / slPercentVal;
          }
          
          let kellyFraction = 0;
          // Apply Kelly Criterion formula: f = P - (1-P)/R, where P is win probability, R is win/loss ratio
          if (!isNaN(winProbability) && !isNaN(riskRewardRatio) && riskRewardRatio > 0) {
            kellyFraction = winProbability - (1 - winProbability) / riskRewardRatio;
          }
          // Display Kelly fraction if it's positive, otherwise show 0%
          this.dom.kellyPercent.textContent = kellyFraction > 0 ? Utils.formatPercentage(kellyFraction) : '0%';
        } else {
          this.dom.kellyPercent.textContent = 'Disabled'; // Show 'Disabled' if Kelly Criterion is not enabled
        }

        // Calculate and display VaR (Value at Risk) using historical returns
        // Note: This calculates percentage PnL relative to current equity.
        // For a more robust VaR, one might track daily PnL as a % of starting capital for that day.
        const historicalReturns = this.state.tradeHistory.map(t => {
            const tradePnL = parseFloat(t.execPnl);
            // Use currentEquity for scaling, ensure it's not zero to avoid division by zero
            const equityForTrade = currentEquity > 0 ? currentEquity : 1; 
            return tradePnL / equityForTrade; // PnL as a percentage of current equity
        });
        const var95 = Utils.calculateHistoricalVaR(historicalReturns, 0.95); // Calculate 95% VaR
        // Display VaR in currency format, scaling by current equity, defaulting to $0.00 if calculation fails
        this.dom.varValue.textContent = var95 !== null ? Utils.formatCurrency(var95 * currentEquity) : '$0.00';

        // Update Equity Curve Chart
        this.chartManager.updateEquityChart(this.state.equityCurve);
      }

      /** Generates the list of WebSocket topics based on the current symbol and timeframe. */
      getWsTopics(symbol, timeframe) {
        return [
          `orderbook.${CONSTANTS.ORDER_BOOK_DEPTH}.${symbol}`, // Order book stream for the current symbol
          `kline.${timeframe}.${symbol}`, // Kline stream for the current symbol and timeframe
          `position.linear`, // Stream for all linear positions (needed for updates)
          `order.linear`,    // Stream for all linear orders (needed for updates)
          `execution.linear` // Stream for all linear executions (needed for updates)
        ];
      }

      /** Subscribes to the necessary WebSocket topics based on the current symbol and timeframe. */
      subscribeToTopics() {
        const topics = this.getWsTopics(this.state.currentSymbol, this.state.currentTimeframe); // Get topics to subscribe to
        this.bybitWs.subscribe(topics); // Subscribe via the WebSocket client
        topics.forEach(topic => this.state.wsTopics.add(topic)); // Track subscribed topics in state
      }
      
      /** Unsubscribes from WebSocket topics when the symbol or timeframe changes. */
      unsubscribeFromTopics(symbol = this.state.currentSymbol, timeframe = this.state.currentTimeframe) {
         const topics = this.getWsTopics(symbol, timeframe); // Get topics to unsubscribe from
         this.bybitWs.unsubscribe(topics); // Unsubscribe via the WebSocket client
         topics.forEach(topic => this.state.wsTopics.delete(topic)); // Remove from tracked topics
      }

      /** Handles incoming messages from the WebSocket and dispatches them to appropriate handlers. */
      _handleWsMessage(data) {
        // Process messages based on their topic type
        if (data.topic?.startsWith('orderbook')) {
          this._updateOrderBook(data.data); // Update order book data and chart
        } else if (data.topic?.startsWith('kline')) {
          this._updateKlines(data.data[0]); // Update kline data and trigger chart/indicator updates
        } else if (data.topic === 'position.linear' || data.topic === 'order.linear' || data.topic === 'execution.linear') {
          // For account-related updates (positions, orders, executions), fetch account info.
          // This is debounced to prevent excessive API calls.
          this.fetchAccountInfo();
        }
      }
      
      /** Updates the order book data and the corresponding chart visualization. */
      _updateOrderBook(data) {
        // Parse and store bids and asks from the WebSocket message
        this.state.orderBook.bids = data.b.map(d => ({ price: parseFloat(d[0]), size: parseFloat(d[1]) }));
        this.state.orderBook.asks = data.a.map(d => ({ price: parseFloat(d[0]), size: parseFloat(d[1]) }));
        // Update the order book chart and the text displays for top bids/asks
        this.chartManager.updateOrderBook(this.state.orderBook.bids, this.state.orderBook.asks);
      }
      
      /** Updates the kline data array and triggers chart/indicator updates. */
      _updateKlines(kline) {
        const newKline = {
            time: parseInt(kline.start), // Timestamp in milliseconds
            open: parseFloat(kline.open),
            high: parseFloat(kline.high),
            low: parseFloat(kline.low),
            close: parseFloat(kline.close),
            volume: parseFloat(kline.volume),
        };
        
        const lastKline = this.state.klines[this.state.klines.length - 1];
        // Check if the new kline is an update to the current kline (same timestamp)
        if (lastKline && newKline.time === lastKline.time) {
            // Update the last kline in the array if it's still forming
            this.state.klines[this.state.klines.length - 1] = newKline;
        } else if (!lastKline || newKline.time > lastKline.time) {
            // Add the new kline if it's genuinely new (timestamp is greater than the last)
            this.state.klines.push(newKline);
            // Keep the klines array size manageable to prevent memory issues
            if (this.state.klines.length > CONSTANTS.MAX_KLINES_DISPLAY) {
              this.state.klines.shift(); // Remove the oldest kline if the limit is exceeded
            }
        }
        // Trigger updates for charts and indicators after kline data is modified
        this._updateChartsAndIndicators();
      }

      /** Orchestrates updates for the price chart, volume chart, and technical indicators. */
      _updateChartsAndIndicators() {
        // Get the current position details for potential chart annotations
        const currentPosition = this.state.positions.find(p => p.symbol === this.state.currentSymbol);
        // Update the price chart, passing klines and current position
        this.chartManager.updatePriceChart(this.state.klines, currentPosition);
        // Calculate and display technical indicators
        this._calculateAndDisplayIndicators();
      }
      
      /** Calculates technical indicators and updates the indicator chart. */
      _calculateAndDisplayIndicators() {
        if (this.state.klines.length === 0) return; // Do nothing if there's no kline data

        const closes = this.state.klines.map(k => k.close); // Extract closing prices
        const volumes = this.state.klines.map(k => k.volume); // Extract volumes
        
        // Calculate indicators using the Utils class
        const rsi = Utils.calculateRSI(closes);
        const macd = Utils.calculateMACD(closes);
        const bb = Utils.calculateBollingerBands(closes);
        const currentVolume = volumes[volumes.length - 1]; // Get volume of the latest kline

        // Store calculated indicators in the application state
        this.state.indicators = { rsi, macd, bb, volume: currentVolume };
        // Update the indicator values displayed in the UI
        this.ui.updateIndicatorValues(this.state.indicators);
        // Update the indicator chart with the new data
        this.chartManager.updateIndicatorChart(this.state.klines);
      }

      /** Handles switching between different tabs (Order Book, Price Chart, Indicators, Equity Curve). */
      handleTabSwitch(event) {
        const tabName = event.target.dataset.tab; // Get the target tab name from the clicked button's data attribute
        // Hide all tab content panes
        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
        // Show the selected tab content pane
        document.getElementById(`tab-${tabName}`).classList.remove('hidden');
        // Remove the 'active' class from all tab buttons
        document.querySelectorAll('.tab-nav .tab-btn').forEach(b => b.classList.remove('active'));
        // Add the 'active' class to the clicked tab button
        event.target.classList.add('active');
        
        // Re-render charts on tab switch to ensure they are properly sized and visible
        // Use requestAnimationFrame to ensure DOM updates are complete before resizing
        requestAnimationFrame(() => {
          // Resize the chart associated with the active tab
          if (this.chartManager.charts[tabName]) {
              this.chartManager.charts[tabName].resize();
          }
          // If the 'chart' tab is activated, also resize the volume chart
          if (tabName === 'chart') { 
            if (this.chartManager.charts.volume) this.chartManager.charts.volume.resize();
          }
          // If the 'equityCurve' tab is activated, resize the equity chart
          if (tabName === 'equityCurve') { 
            if (this.chartManager.charts.equityCurve) this.chartManager.charts.equityCurve.resize();
          }
        });
      }

      /** Initiates the AI market analysis process. */
      async runAnalysis() {
        this.ui.log('Running AI analysis...', 'info');
        // Show loading indicator and disable action buttons during analysis
        this.dom.aiOutput.innerHTML = '<div class="text-text-secondary text-center py-4"><div class="spinner w-8 h-8 mx-auto mb-2"></div> Analyzing...</div>';
        this.dom.aiReason.textContent = ''; // Clear previous reason
        this.dom.aiReason.classList.add('hidden'); // Hide the reason div initially
        this.ui.showLoading();
        this.ui.setAISignalButtons(false); // Disable AI action buttons
        
        try {
            const customPrompt = this.dom.customPrompt.value.trim(); // Get custom prompt from textarea
            const tradingMode = this.dom.analysisMode.value; // Get selected analysis mode
            // Get current position details, or null if none
            const currentPosition = this.state.positions.find(p => p.symbol === this.state.currentSymbol) || null;

            // Check if enough historical data is available for a meaningful AI analysis
            if (this.state.klines.length < CONSTANTS.METRIC_CALC_PERIODS.BB_PERIOD) {
              throw new Error('Insufficient historical data for a thorough AI analysis. Need at least 20 candles.');
            }

            // Call the AI manager to analyze the data and get a signal
            const aiResponse = await this.aiManager.analyze(
              customPrompt,
              {
                klines: this.state.klines,
                orderBook: this.state.orderBook,
                position: currentPosition,
                analysisMode: tradingMode,
                symbol: this.state.currentSymbol,
                timeframe: this.state.currentTimeframe,
                accountBalance: this.state.accountBalance, // Pass account balance for context
                indicators: this.state.indicators, // Pass calculated technical indicators
              }
            );

            this.ui.log('AI Analysis Complete.', 'success');
            // Display the AI's output (JSON signal) and reasoning
            this.dom.aiOutput.textContent = JSON.stringify(aiResponse, null, 2); // Pretty print the JSON response
            this.dom.aiReason.textContent = aiResponse.reason || 'No specific reason provided by AI.'; // Display the AI's reasoning
            this.dom.aiReason.classList.remove('hidden'); // Make the reason div visible
            this.state.lastSignal = aiResponse; // Store the last generated signal
            this.ui.showToast(`AI Signal: ${aiResponse.action} (${aiResponse.confidence})`, 'info'); // Show a toast notification about the signal

            // Enable the relevant action buttons based on the AI's suggested action
            if (aiResponse.action === 'BUY') this.dom.executeBuyBtn.disabled = false;
            if (aiResponse.action === 'SELL') this.dom.executeSellBtn.disabled = false;
            if (aiResponse.action === 'HOLD') this.dom.executeHoldBtn.disabled = false;

        } catch (error) {
            // Handle any errors that occur during the AI analysis process
            this.ui.log(`AI Analysis Error: ${error.message}`, 'error');
            this.dom.aiOutput.textContent = `Error: ${error.message}`; // Display error in the output area
            this.dom.aiReason.textContent = `Error: ${error.message}`; // Display error in the reason section
            this.dom.aiReason.classList.remove('hidden');
            this.ui.showToast(`AI Analysis Failed: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading(); // Hide the loading indicator
        }
      }
      
      /** Executes a trading signal (BUY, SELL) generated by the AI. */
      async executeSignal(action) {
        // Validate that a signal exists and matches the requested action
        if (!this.state.lastSignal || this.state.lastSignal.action !== action) {
          this.ui.log(`No valid ${action} signal to execute or signal doesn't match.`, 'warning');
          this.ui.showToast(`No valid ${action} signal from AI.`, 'warning');
          return;
        }
        
        this.ui.log(`Executing ${action} signal for ${this.state.lastSignal.quantity} contracts.`, 'info');
        this.ui.showLoading(); // Show loading indicator
        this.ui.setAISignalButtons(false); // Disable action buttons during execution

        try {
          // Get the latest price from klines data for order placement
          const latestPrice = this.state.klines[this.state.klines.length - 1]?.close;
          if (!latestPrice) {
            throw new Error('Could not get latest price for order placement.');
          }
          if (!this.state.symbolInfo) {
              throw new Error('Symbol information (tickSize, lotSize) not available. Please connect or refresh.');
          }

          let qty = parseFloat(this.state.lastSignal.quantity); // Get quantity suggested by AI
          const maxPosition = parseFloat(this.dom.maxPosition.value); // Max position size from config
          const leverage = parseFloat(this.dom.leverage.value); // Leverage setting from config
          const riskPerTrade = parseFloat(this.dom.riskPerTrade.value) / 100; // Risk per trade percentage
          const slPercent = parseFloat(this.dom.slPercent.value) / 100; // Stop loss percentage
          const accountEquity = this.state.accountBalance ? parseFloat(this.state.accountBalance.equity) : 0; // Current account equity
          
          // Validate account equity before proceeding
          if (accountEquity <= 0) {
            throw new Error('Account equity is zero or negative. Cannot place order.');
          }

          // --- AI Confidence Integration ---
          // Adjust quantity based on AI confidence level
          const confidenceMultiplier = CONSTANTS.AI_CONFIDENCE_MULTIPLIERS[this.state.lastSignal.confidence] || 1.0;
          qty *= confidenceMultiplier;
          this.ui.log(`Adjusting quantity by AI confidence (${this.state.lastSignal.confidence}): New quantity ${qty.toFixed(5)}`, 'info');

          // --- Risk Management Sizing ---
          // Adjust quantity based on Kelly Criterion if enabled and applicable
          if (this.dom.enableKelly.checked && parseFloat(this.dom.kellyPercent.textContent) > 0) {
            const kellyFraction = parseFloat(this.dom.kellyPercent.textContent) / 100; // Get Kelly fraction from UI
            let riskRewardRatio = 0;
            // Ensure slPercent is not zero to prevent division by zero
            if (slPercent > 0) {
              const tpPercentVal = parseFloat(this.dom.tpPercent.value) / 100;
              riskRewardRatio = tpPercentVal / slPercent;
            }
            
            let kellyQty = 0;
            // Calculate Kelly quantity: Equity * Kelly_Fraction * Leverage / Price
            // Only if riskRewardRatio is valid (positive)
            if (!isNaN(kellyFraction) && kellyFraction > 0 && !isNaN(riskRewardRatio) && riskRewardRatio > 0) {
              kellyQty = (accountEquity * kellyFraction * leverage) / latestPrice;
            }
            qty = Math.min(qty, kellyQty); // Use the minimum of AI suggested quantity and Kelly suggested quantity
            this.ui.log(`Kelly Criterion suggested quantity: ${kellyQty.toFixed(5)}. Using min with AI suggested. Final quantity: ${qty.toFixed(5)}`, 'info');
          } 
          // Adjust quantity based on Risk Per Trade if Kelly is not enabled or not applicable
          else if (riskPerTrade > 0 && slPercent > 0) {
            // Calculate quantity based on risk: (Equity * Risk%) / (Price * SL% / Leverage)
            const riskedAmount = accountEquity * riskPerTrade;
            const calculatedQty = riskedAmount / (latestPrice * slPercent / leverage);
            qty = Math.min(qty, calculatedQty); // Use the minimum of AI suggested quantity and risk-based quantity
            this.ui.log(`Risk-based suggested quantity: ${calculatedQty.toFixed(5)}. Using min with AI suggested. Final quantity: ${qty.toFixed(5)}`, 'info');
          }

          // Ensure calculated quantity does not exceed the maximum position size from configuration
          qty = Math.min(qty, maxPosition); 
          // Check if the calculated quantity is too small (Bybit has minimum order quantities, e.g., 0.001 for BTCUSDT)
          if (qty < parseFloat(this.state.symbolInfo.lotSize)) { // Use symbol's lotSize as minimum threshold
            throw new Error(`Calculated quantity (${qty.toFixed(5)}) is below minimum order size (${this.state.symbolInfo.lotSize}). Cannot place order.`);
          }

          // Set leverage before placing order
          await this.bybitClient.setLeverage(this.state.currentSymbol, leverage);
          this.ui.log(`Leverage set to ${leverage}x for ${this.state.currentSymbol}.`, 'info');


          // Prepare order parameters object
          const orderParams = {
            symbol: this.state.currentSymbol, // Trading symbol
            side: action === 'BUY' ? 'Buy' : 'Sell', // Order side (Buy or Sell)
            orderType: this.dom.orderType.value, // Order type (Market or Limit)
            qty: Utils.formatBybitPrecision(qty, 'qty', this.state.symbolInfo), // Format quantity using dynamic precision
            leverage: leverage.toString(), // Set leverage
            timeInForce: 'GTC', // Default to Good-Till-Cancelled
          };
          
          // If order type is 'Limit', set a limit price
          if (orderParams.orderType === 'Limit') {
            // Set limit price slightly offset from the latest market price for simplicity
            const limitPrice = action === 'BUY' ? (latestPrice * 0.999) : (latestPrice * 1.001);
            orderParams.price = Utils.formatBybitPrecision(limitPrice, 'price', this.state.symbolInfo);
          }

          // Configure Take Profit, Stop Loss, and Trailing Stop if enabled in settings
          if (this.dom.enableTpSl.checked) {
            const tpPct = parseFloat(this.dom.tpPercent.value) / 100; // Take Profit percentage
            const slPct = parseFloat(this.dom.slPercent.value) / 100; // Stop Loss percentage
            
            // Use AI-suggested TP/SL if available and valid, otherwise use configured percentages
            const targetPrice = this.state.lastSignal.targetPrice && this.state.lastSignal.targetPrice > 0 
              ? this.state.lastSignal.targetPrice 
              : (action === 'BUY' ? (latestPrice * (1 + tpPct)) : (latestPrice * (1 - tpPct)));
            const stopLossPrice = this.state.lastSignal.stopLossPrice && this.state.lastSignal.stopLossPrice > 0 
              ? this.state.lastSignal.stopLossPrice 
              : (action === 'BUY' ? (latestPrice * (1 - slPct)) : (latestPrice * (1 + slPct)));

            // Format TP and SL prices to Bybit's precision
            orderParams.takeProfit = Utils.formatBybitPrecision(targetPrice, 'price', this.state.symbolInfo);
            orderParams.stopLoss = Utils.formatBybitPrecision(stopLossPrice, 'price', this.state.symbolInfo);
          }

          // --- Trailing Stop Calculation ---
          if (this.dom.enableTrailing.checked && parseFloat(this.dom.trailingStop.value) > 0) {
            // Bybit's `trailingStop` parameter is in "price points" (i.e., multiples of tickSize).
            // First, calculate the desired trailing stop delta in actual currency.
            const trailingStopDeltaInDollars = (parseFloat(this.dom.trailingStop.value) / 100) * latestPrice;
            const tickSize = parseFloat(this.state.symbolInfo.tickSize);

            // Convert the dollar delta into multiples of tickSize.
            // Then, format it using the precision utility to ensure it adheres to Bybit's rules.
            orderParams.trailingStop = Utils.formatBybitPrecision(Math.round(trailingStopDeltaInDollars / tickSize) * tickSize, 'price', this.state.symbolInfo);
            orderParams.tpslMode = 'Full'; // Bybit requires tpslMode for trailing stop when using trailingStop
            this.ui.log(`Trailing Stop set to: ${orderParams.trailingStop} (approx. ${this.dom.trailingStop.value}%)`, 'info');
          }

          // Place the order via the Bybit API client
          const result = await this.bybitClient.placeOrder(orderParams);
          this.ui.log(`Order placed successfully! Order ID: ${result.orderId}`, 'success');
          this.ui.showToast(`Order placed: ${action} ${parseFloat(orderParams.qty).toFixed(3)} ${this.state.currentSymbol}`, 'success');
          this.fetchAccountInfo(); // Refresh account data after placing the order
        } catch (error) {
          // Handle errors during order execution
          this.ui.log(`Order execution failed: ${error.message}`, 'error');
          this.ui.showToast(`Order failed: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading(); // Hide loading indicator
        }
      }

      /** Closes an active position for a given symbol and side. */
      async closePosition(symbol, side) {
        this.ui.log(`Attempting to close ${symbol} position (${side})...`, 'info');
        this.ui.showLoading(); // Show loading indicator
        try {
          await this.bybitClient.closePosition(symbol, side); // Call API to close the position
          this.ui.log(`Position for ${symbol} successfully closed.`, 'success');
          this.ui.showToast(`Closed ${symbol} position.`, 'success');
          this.fetchAccountInfo(); // Refresh account data to reflect the closed position
        } catch (error) {
          this.ui.log(`Failed to close position for ${symbol}: ${error.message}`, 'error');
          this.ui.showToast(`Failed to close position: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading(); // Hide loading indicator
        }
      }

      /** Cancels an open order by its ID and symbol. */
      async cancelOrder(symbol, orderId) {
        this.ui.log(`Attempting to cancel order ${orderId} for ${symbol}...`, 'info');
        this.ui.showLoading(); // Show loading indicator
        try {
          await this.bybitClient.cancelOrder(symbol, orderId); // Call API to cancel the order
          this.ui.log(`Order ${orderId} for ${symbol} successfully cancelled.`, 'success');
          this.ui.showToast(`Cancelled order ${orderId}.`, 'success');
          this.fetchAccountInfo(); // Refresh account data to reflect the cancelled order
        } catch (error) {
          this.ui.log(`Failed to cancel order ${orderId} for ${symbol}: ${error.message}`, 'error');
          this.ui.showToast(`Failed to cancel order: ${error.message}`, 'error');
        } finally {
          this.ui.hideLoading(); // Hide loading indicator
        }
      }
    }

    // Initialize the TradingApp instance when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', () => {
      window.app = new TradingApp(); // Create a global instance of TradingApp
    });

  </script>
</body>
</html>
```

I've enhanced the code to ensure the symbol list functions correctly and displays all Bybit symbols. Here are the key improvements:

1. **Enhanced Symbol Selection**:
   - Added a searchable dropdown with categories (Major Pairs, Altcoins, Stablecoins, Other)
   - Implemented real-time filtering as you type
   - Added visual highlighting of the currently selected symbol
   - Organized symbols into logical categories for easier navigation

2. **Improved Symbol Management**:
   - Added a new `symbolSearch` input field for filtering symbols
   - Created a `symbolDropdown` that appears when focusing on the search field
   - Implemented proper event handling for symbol selection
   - Added click-outside detection to close the dropdown

3. **Better UI/UX**:
   - Made the symbol selection more intuitive with a search interface
   - Added visual feedback when selecting symbols
   - Improved the overall layout of the market data section

4. **Enhanced Symbol Information**:
   - The system now fetches and stores all available symbols from Bybit
   - Symbols are properly categorized for better organization
   - The search functionality helps quickly find specific trading pairs

The symbol dropdown now provides a much better user experience, allowing traders to easily find and select from all available Bybit symbols. The search functionality is particularly useful when you know the symbol you want to trade but need to quickly locate it in a potentially long list.
