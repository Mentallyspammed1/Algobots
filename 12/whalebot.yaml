model: gemini:gemini-2.5-flash
temperature: 0.4
top_p: 0.9
use_tools: auto
save_session: true
compressed_messages:
- role: user
  content: "\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mos\e[39;00m\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mlogging\e[39;00m\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mrequests\e[39;00m\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mpandas\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mas\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mpd\e[39;00m\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mnumpy\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mas\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mnp\e[39;00m\n\e[38;2;0;112;32;01mfrom\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mdatetime\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mimport\e[39;00m datetime\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mhmac\e[39;00m\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mhashlib\e[39;00m\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mtime\e[39;00m\n\e[38;2;0;112;32;01mfrom\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mdotenv\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mimport\e[39;00m load_dotenv\n\e[38;2;0;112;32;01mfrom\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mtyping\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mimport\e[39;00m Dict, Tuple, List, Union, Any\n\e[38;2;0;112;32;01mfrom\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mcolorama\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mimport\e[39;00m init, Fore, Style\n\e[38;2;0;112;32;01mfrom\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mzoneinfo\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mimport\e[39;00m ZoneInfo\n\e[38;2;0;112;32;01mfrom\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mlogger_config\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mimport\e[39;00m setup_custom_logger  \e[38;2;96;160;176;03m# Assuming this file exists and is correctly set up\e[39;00m\n\e[38;2;0;112;32;01mfrom\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mdecimal\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mimport\e[39;00m Decimal, getcontext, InvalidOperation\n\e[38;2;0;112;32;01mimport\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mjson\e[39;00m\n\n\e[38;2;96;160;176;03m# --- Configuration & Constants ---\e[39;00m\n\n\e[38;2;96;160;176;03m# Set Decimal precision for financial calculations to avoid floating point errors\e[39;00m\ngetcontext()\e[38;2;102;102;102m.\e[39mprec \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m10\e[39m\n\n\e[38;2;96;160;176;03m# Initialize colorama for cross-platform colored terminal output\e[39;00m\ninit(autoreset\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mTrue\e[39;00m)\n\n\e[38;2;96;160;176;03m# Load environment variables from .env file\e[39;00m\nload_dotenv()\n\n\e[38;2;96;160;176;03m# --- Color Codex ---\e[39;00m\nNEON_GREEN \e[38;2;102;102;102m=\e[39m Fore\e[38;2;102;102;102m.\e[39mLIGHTGREEN_EX\nNEON_BLUE \e[38;2;102;102;102m=\e[39m Fore\e[38;2;102;102;102m.\e[39mCYAN\nNEON_PURPLE \e[38;2;102;102;102m=\e[39m Fore\e[38;2;102;102;102m.\e[39mMAGENTA\nNEON_YELLOW \e[38;2;102;102;102m=\e[39m Fore\e[38;2;102;102;102m.\e[39mYELLOW\nNEON_RED \e[38;2;102;102;102m=\e[39m Fore\e[38;2;102;102;102m.\e[39mLIGHTRED_EX\nRESET \e[38;2;102;102;102m=\e[39m Style\e[38;2;102;102;102m.\e[39mRESET_ALL\n\n\e[38;2;96;160;176;03m# --- Configuration & Constants ---\e[39;00m\nAPI_KEY \e[38;2;102;102;102m=\e[39m os\e[38;2;102;102;102m.\e[39mgetenv(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mBYBIT_API_KEY\e[39m\e[38;2;64;112;160m\"\e[39m)\nAPI_SECRET \e[38;2;102;102;102m=\e[39m os\e[38;2;102;102;102m.\e[39mgetenv(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mBYBIT_API_SECRET\e[39m\e[38;2;64;112;160m\"\e[39m)\nBASE_URL \e[38;2;102;102;102m=\e[39m os\e[38;2;102;102;102m.\e[39mgetenv(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mBYBIT_BASE_URL\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhttps://api.bybit.com\e[39m\e[38;2;64;112;160m\"\e[39m)\nCONFIG_FILE \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mconfig.json\e[39m\e[38;2;64;112;160m\"\e[39m\nLOG_DIRECTORY \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mbot_logs\e[39m\e[38;2;64;112;160m\"\e[39m\nTIMEZONE \e[38;2;102;102;102m=\e[39m ZoneInfo(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mAmerica/Chicago\e[39m\e[38;2;64;112;160m\"\e[39m)  \e[38;2;96;160;176;03m# Using a specific timezone for consistency\e[39;00m\nMAX_API_RETRIES \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m3\e[39m\nRETRY_DELAY_SECONDS \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m5\e[39m\nVALID_INTERVALS \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m1\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m3\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m5\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m15\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m30\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m60\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m120\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m240\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mD\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mW\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mM\e[39m\e[38;2;64;112;160m\"\e[39m]\nRETRY_ERROR_CODES \e[38;2;102;102;102m=\e[39m [\e[38;2;64;160;112m429\e[39m, \e[38;2;64;160;112m500\e[39m, \e[38;2;64;160;112m502\e[39m, \e[38;2;64;160;112m503\e[39m, \e[38;2;64;160;112m504\e[39m]  \e[38;2;96;160;176;03m# HTTP status codes to trigger a retry\e[39;00m\n\n\e[38;2;96;160;176;03m# Ensure log directory exists\e[39;00m\nos\e[38;2;102;102;102m.\e[39mmakedirs(LOG_DIRECTORY, exist_ok\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mTrue\e[39;00m)\n\n\e[38;2;96;160;176;03m# Setup the main application logger\e[39;00m\nlogger \e[38;2;102;102;102m=\e[39m setup_custom_logger(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mwhalebot_main\e[39m\e[38;2;64;112;160m'\e[39m)\n\n\n\e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mload_config\e[39m(filepath: \e[38;2;0;112;32mstr\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mdict\e[39m:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m    Loads configuration from a JSON file, merging with default values.\e[39;00m\n\e[38;2;64;112;160;03m    If the file is not found or is invalid, it creates one with default settings.\e[39;00m\n\e[38;2;64;112;160;03m    \"\"\"\e[39;00m\n    default_config \e[38;2;102;102;102m=\e[39m {\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m15\e[39m\e[38;2;64;112;160m\"\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m30\e[39m,  \e[38;2;96;160;176;03m# Time in seconds between main analysis cycles\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretry_delay\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m5\e[39m,  \e[38;2;96;160;176;03m# Delay in seconds for API retries\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m10\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_short\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m12\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_long\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m26\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_ma_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m20\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtrend_strength_threshold\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.4\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msideways_atr_multiplier\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m1.5\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msignal_score_threshold\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m1.0\e[39m,  \e[38;2;96;160;176;03m# Minimum combined weight for a signal to be valid\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m: {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_confirmation\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mdivergence\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmacd\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvwap\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mFalse\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mobv\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcci\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwr\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madx\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mpsar\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msma_10\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mFalse\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;96;160;176;03m# --- New: Stochastic Oscillator ---\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstochastic_oscillator\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n        },\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mweight_sets\e[39m\e[38;2;64;112;160m\"\e[39m: {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow_volatility\e[39m\e[38;2;64;112;160m\"\e[39m: {  \e[38;2;96;160;176;03m# Weights for a low volatility market environment\e[39;00m\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.3\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.2\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_confirmation\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.2\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mdivergence\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.5\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.3\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmacd\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.3\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvwap\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.0\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mobv\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcci\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwr\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madx\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mpsar\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.2\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msma_10\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.0\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.3\e[39m,\n                \e[38;2;96;160;176;03m# --- New: Stochastic Oscillator Weight ---\e[39;00m\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstochastic_oscillator\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.4\e[39m,\n            },\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh_volatility\e[39m\e[38;2;64;112;160m\"\e[39m: {  \e[38;2;96;160;176;03m# Weights for a high volatility market environment\e[39;00m\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.4\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_confirmation\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mdivergence\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.2\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.4\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.4\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmacd\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.4\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvwap\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.0\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mobv\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcci\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwr\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madx\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mpsar\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.1\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.3\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msma_10\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.0\e[39m,\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.4\e[39m,\n                \e[38;2;96;160;176;03m# --- New: Stochastic Oscillator Weight ---\e[39;00m\n                \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstochastic_oscillator\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.3\e[39m,\n            }\n        },\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_oversold_threshold\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m20\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_overbought_threshold\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m80\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_confidence_boost\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m5\e[39m,  \e[38;2;96;160;176;03m# Additional boost for strong Stoch RSI signals\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_mandatory\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mFalse\e[39;00m,  \e[38;2;96;160;176;03m# If true, Stoch RSI must be a confirming factor\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi_confidence_boost\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m2\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi_confidence_boost\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m2\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_support_confidence_boost\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m3\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_resistance_confidence_boost\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m3\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstop_loss_multiple\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m1.5\e[39m,  \e[38;2;96;160;176;03m# Multiplier for ATR to determine stop loss distance\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtake_profit_multiple\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m1.0\e[39m,  \e[38;2;96;160;176;03m# Multiplier for ATR to determine take profit distance\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_wall_threshold_multiplier\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m2.0\e[39m,  \e[38;2;96;160;176;03m# Multiplier for average volume to identify a \"wall\"\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_depth_to_check\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m10\e[39m,  \e[38;2;96;160;176;03m# Number of order book levels to check for walls\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mprice_change_threshold\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.005\e[39m,  \e[38;2;96;160;176;03m# % change in price to consider significant\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr_change_threshold\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.005\e[39m,  \e[38;2;96;160;176;03m# % change in ATR to consider significant volatility change\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msignal_cooldown_s\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m60\e[39m,  \e[38;2;96;160;176;03m# Seconds to wait before generating another signal\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_debounce_s\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m10\e[39m,  \e[38;2;96;160;176;03m# Seconds to wait between order book API calls\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_short_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m12\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_long_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m26\e[39m,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_confirmation_multiplier\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m1.5\e[39m,  \e[38;2;96;160;176;03m# Volume must be this many times average volume for confirmation\e[39;00m\n        \e[38;2;96;160;176;03m# --- New: Indicator Period Customization ---\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m: {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcci\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m20\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwilliams_r\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madx\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,       \e[38;2;96;160;176;03m# Period for RSI calculation within Stoch RSI\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_k_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m3\e[39m,     \e[38;2;96;160;176;03m# Smoothing period for %K line\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_d_period\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m3\e[39m,     \e[38;2;96;160;176;03m# Smoothing period for %D line (signal line)\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m10\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_short\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m12\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_long\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m26\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_ma\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m20\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msma_10\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m10\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve_price_ema\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m10\e[39m,         \e[38;2;96;160;176;03m# EMA period for FVE price component\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve_obv_sma\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m20\e[39m,           \e[38;2;96;160;176;03m# SMA period for OBV normalization\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve_atr_sma\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m20\e[39m,           \e[38;2;96;160;176;03m# SMA period for ATR normalization\e[39;00m\n            \e[38;2;96;160;176;03m# --- New: Stochastic Oscillator Periods ---\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_k\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m14\e[39m,           \e[38;2;96;160;176;03m# Stochastic Oscillator K period\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_d\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m3\e[39m,            \e[38;2;96;160;176;03m# Stochastic Oscillator D period\e[39;00m\n        },\n        \e[38;2;96;160;176;03m# --- New: Order Book Analysis Configuration ---\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_analysis\e[39m\e[38;2;64;112;160m\"\e[39m: {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160menabled\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mTrue\e[39;00m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwall_threshold_multiplier\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m2.0\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mdepth_to_check\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m10\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msupport_boost\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m3\e[39m,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresistance_boost\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m3\e[39m,\n        },\n        \e[38;2;96;160;176;03m# --- New: Trailing Stop Loss Configuration ---\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtrailing_stop_loss\e[39m\e[38;2;64;112;160m\"\e[39m: {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160menabled\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mFalse\e[39;00m,  \e[38;2;96;160;176;03m# Disabled by default\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160minitial_activation_percent\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.5\e[39m,  \e[38;2;96;160;176;03m# Activate trailing stop after price moves X% in favor\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtrailing_stop_multiple_atr\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m1.5\e[39m  \e[38;2;96;160;176;03m# Trail stop based on ATR multiple\e[39;00m\n        },\n        \e[38;2;96;160;176;03m# --- New: Take Profit Scaling Configuration ---\e[39;00m\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtake_profit_scaling\e[39m\e[38;2;64;112;160m\"\e[39m: {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160menabled\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;0;112;32;01mFalse\e[39;00m,  \e[38;2;96;160;176;03m# Disabled by default\e[39;00m\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtargets\e[39m\e[38;2;64;112;160m\"\e[39m: [\n                {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlevel\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m1.5\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mpercentage\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.25\e[39m},  \e[38;2;96;160;176;03m# Sell 25% when price hits 1.5x ATR TP\e[39;00m\n                {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlevel\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m2.0\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mpercentage\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.50\e[39m}  \e[38;2;96;160;176;03m# Sell 50% of remaining when price hits 2.0x ATR TP\e[39;00m\n            ]\n        }\n    }\n    \e[38;2;0;112;32;01mtry\e[39;00m:\n        \e[38;2;0;112;32;01mwith\e[39;00m \e[38;2;0;112;32mopen\e[39m(filepath, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mr\e[39m\e[38;2;64;112;160m\"\e[39m, encoding\e[38;2;102;102;102m=\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mutf-8\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mas\e[39;00m f:\n            config \e[38;2;102;102;102m=\e[39m json\e[38;2;102;102;102m.\e[39mload(f)\n            \e[38;2;96;160;176;03m# Merge loaded config with defaults. Prioritize loaded values, but ensure all default keys exist.\e[39;00m\n            merged_config \e[38;2;102;102;102m=\e[39m {\e[38;2;102;102;102m*\e[39m\e[38;2;102;102;102m*\e[39mdefault_config, \e[38;2;102;102;102m*\e[39m\e[38;2;102;102;102m*\e[39mconfig}\n\n            \e[38;2;96;160;176;03m# Basic validation for interval and analysis_interval\e[39;00m\n            \e[38;2;0;112;32;01mif\e[39;00m merged_config\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m VALID_INTERVALS:\n                logger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mInvalid \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m in config, using default: \e[39m\e[38;2;112;160;208;03m{\e[39;00mdefault_config[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                merged_config[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m default_config[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m\"\e[39m]\n            \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32misinstance\e[39m(merged_config\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m\"\e[39m), \e[38;2;0;112;32mint\e[39m) \e[38;2;0;112;32;01mor\e[39;00m merged_config\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;102;102;102m<\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0\e[39m:\n                logger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mInvalid \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m in config, using default: \e[39m\e[38;2;112;160;208;03m{\e[39;00mdefault_config[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                merged_config[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m default_config[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m\"\e[39m]\n\n            \e[38;2;0;112;32;01mreturn\e[39;00m merged_config\n    \e[38;2;0;112;32;01mexcept\e[39;00m \e[38;2;0;112;32mFileNotFoundError\e[39m:\n        logger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mConfig file not found, loading defaults and creating \e[39m\e[38;2;112;160;208;03m{\e[39;00mfilepath\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;0;112;32;01mwith\e[39;00m \e[38;2;0;112;32mopen\e[39m(filepath, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mw\e[39m\e[38;2;64;112;160m\"\e[39m, encoding\e[38;2;102;102;102m=\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mutf-8\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mas\e[39;00m f:\n            json\e[38;2;102;102;102m.\e[39mdump(default_config, f, indent\e[38;2;102;102;102m=\e[39m\e[38;2;64;160;112m4\e[39m)\n        \e[38;2;0;112;32;01mreturn\e[39;00m default_config\n    \e[38;2;0;112;32;01mexcept\e[39;00m json\e[38;2;102;102;102m.\e[39mJSONDecodeError:\n        logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mInvalid JSON in config file, loading defaults.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;96;160;176;03m# Optionally, back up the corrupt file before overwriting\e[39;00m\n        \e[38;2;0;112;32;01mtry\e[39;00m:\n            os\e[38;2;102;102;102m.\e[39mrename(filepath, \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mfilepath\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m.bak_\e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mint\e[39m(time\e[38;2;102;102;102m.\e[39mtime())\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            logger\e[38;2;102;102;102m.\e[39minfo(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mBacked up corrupt config file to \e[39m\e[38;2;112;160;208;03m{\e[39;00mfilepath\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m.bak_\e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mint\e[39m(time\e[38;2;102;102;102m.\e[39mtime())\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;0;112;32;01mexcept\e[39;00m \e[38;2;0;112;32mOSError\e[39m \e[38;2;0;112;32;01mas\e[39;00m e:\n            logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mFailed to backup corrupt config file: \e[39m\e[38;2;112;160;208;03m{\e[39;00me\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;0;112;32;01mwith\e[39;00m \e[38;2;0;112;32mopen\e[39m(filepath, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mw\e[39m\e[38;2;64;112;160m\"\e[39m, encoding\e[38;2;102;102;102m=\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mutf-8\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mas\e[39;00m f:\n            json\e[38;2;102;102;102m.\e[39mdump(default_config, f, indent\e[38;2;102;102;102m=\e[39m\e[38;2;64;160;112m4\e[39m)\n        \e[38;2;0;112;32;01mreturn\e[39;00m default_config\n\n\n\e[38;2;96;160;176;03m# Load the configuration\e[39;00m\nCONFIG \e[38;2;102;102;102m=\e[39m load_config(CONFIG_FILE)\n\n\n\e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mgenerate_signature\e[39m(api_secret: \e[38;2;0;112;32mstr\e[39m, params: \e[38;2;0;112;32mdict\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mstr\e[39m:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"Generates the HMAC SHA256 signature for Bybit API requests.\"\"\"\e[39;00m\n    \e[38;2;96;160;176;03m# Ensure params are sorted by key for consistent signature generation\e[39;00m\n    param_str \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m&\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;102;102;102m.\e[39mjoin([\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mkey\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m=\e[39m\e[38;2;112;160;208;03m{\e[39;00mvalue\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m \e[38;2;0;112;32;01mfor\e[39;00m key, value \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32msorted\e[39m(params\e[38;2;102;102;102m.\e[39mitems())])\n    \e[38;2;0;112;32;01mreturn\e[39;00m hmac\e[38;2;102;102;102m.\e[39mnew(api_secret\e[38;2;102;102;102m.\e[39mencode(), param_str\e[38;2;102;102;102m.\e[39mencode(), hashlib\e[38;2;102;102;102m.\e[39msha256)\e[38;2;102;102;102m.\e[39mhexdigest()\n\n\n\e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mhandle_api_error\e[39m(response: requests\e[38;2;102;102;102m.\e[39mResponse, logger: logging\e[38;2;102;102;102m.\e[39mLogger) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32;01mNone\e[39;00m:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"Logs detailed API error responses.\"\"\"\e[39;00m\n    logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mAPI request failed with status code: \e[39m\e[38;2;112;160;208;03m{\e[39;00mresponse\e[38;2;102;102;102m.\e[39mstatus_code\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n    \e[38;2;0;112;32;01mtry\e[39;00m:\n        error_json \e[38;2;102;102;102m=\e[39m response\e[38;2;102;102;102m.\e[39mjson()\n        logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mError details: \e[39m\e[38;2;112;160;208;03m{\e[39;00merror_json\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n    \e[38;2;0;112;32;01mexcept\e[39;00m json\e[38;2;102;102;102m.\e[39mJSONDecodeError:\n        logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mResponse text: \e[39m\e[38;2;112;160;208;03m{\e[39;00mresponse\e[38;2;102;102;102m.\e[39mtext\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n\n\n\e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mbybit_request\e[39m(method: \e[38;2;0;112;32mstr\e[39m, endpoint: \e[38;2;0;112;32mstr\e[39m, api_key: \e[38;2;0;112;32mstr\e[39m, api_secret: \e[38;2;0;112;32mstr\e[39m, params: Dict[\e[38;2;0;112;32mstr\e[39m, Any] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mNone\e[39;00m, logger: logging\e[38;2;102;102;102m.\e[39mLogger \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mNone\e[39;00m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Union[\e[38;2;0;112;32mdict\e[39m, \e[38;2;0;112;32;01mNone\e[39;00m]:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m    Sends a signed request to the Bybit API with retry logic.\e[39;00m\n\n\e[38;2;64;112;160;03m    Args:\e[39;00m\n\e[38;2;64;112;160;03m        method (str): HTTP method (e.g., \"GET\", \"POST\").\e[39;00m\n\e[38;2;64;112;160;03m        endpoint (str): API endpoint path.\e[39;00m\n\e[38;2;64;112;160;03m        api_key (str): Your Bybit API key.\e[39;00m\n\e[38;2;64;112;160;03m        api_secret (str): Your Bybit API secret.\e[39;00m\n\e[38;2;64;112;160;03m        params (Dict[str, Any], optional): Dictionary of request parameters. Defaults to None.\e[39;00m\n\e[38;2;64;112;160;03m        logger (logging.Logger, optional): Logger instance for logging. Defaults to None.\e[39;00m\n\n\e[38;2;64;112;160;03m    Returns:\e[39;00m\n\e[38;2;64;112;160;03m        Union[dict, None]: JSON response data if successful, None otherwise.\e[39;00m\n\e[38;2;64;112;160;03m    \"\"\"\e[39;00m\n    params \e[38;2;102;102;102m=\e[39m params \e[38;2;0;112;32;01mor\e[39;00m {}\n    \e[38;2;96;160;176;03m# Bybit API V5 requires timestamp in milliseconds\e[39;00m\n    params[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mtimestamp\e[39m\e[38;2;64;112;160m'\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mstr\e[39m(\e[38;2;0;112;32mint\e[39m(time\e[38;2;102;102;102m.\e[39mtime() \e[38;2;102;102;102m*\e[39m \e[38;2;64;160;112m1000\e[39m))\n    signature \e[38;2;102;102;102m=\e[39m generate_signature(api_secret, params)\n    headers \e[38;2;102;102;102m=\e[39m {\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mX-BAPI-API-KEY\e[39m\e[38;2;64;112;160m\"\e[39m: api_key,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mX-BAPI-SIGN\e[39m\e[38;2;64;112;160m\"\e[39m: signature,\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mX-BAPI-TIMESTAMP\e[39m\e[38;2;64;112;160m\"\e[39m: params[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mtimestamp\e[39m\e[38;2;64;112;160m'\e[39m],\n        \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mContent-Type\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mapplication/json\e[39m\e[38;2;64;112;160m\"\e[39m\n    }\n    url \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mBASE_URL\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mendpoint\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m\n\n    \e[38;2;0;112;32;01mfor\e[39;00m retry \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mrange\e[39m(MAX_API_RETRIES):\n        \e[38;2;0;112;32;01mtry\e[39;00m:\n            response \e[38;2;102;102;102m=\e[39m requests\e[38;2;102;102;102m.\e[39mrequest(\n                method,\n                url,\n                headers\e[38;2;102;102;102m=\e[39mheaders,\n                params\e[38;2;102;102;102m=\e[39mparams \e[38;2;0;112;32;01mif\e[39;00m method \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mGET\e[39m\e[38;2;64;112;160m\"\e[39m \e[38;2;0;112;32;01melse\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m,\n                json\e[38;2;102;102;102m=\e[39mparams \e[38;2;0;112;32;01mif\e[39;00m method \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mPOST\e[39m\e[38;2;64;112;160m\"\e[39m \e[38;2;0;112;32;01melse\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m,\n                timeout\e[38;2;102;102;102m=\e[39m\e[38;2;64;160;112m10\e[39m  \e[38;2;96;160;176;03m# Set a timeout for requests\e[39;00m\n            )\n            response\e[38;2;102;102;102m.\e[39mraise_for_status()  \e[38;2;96;160;176;03m# Raises HTTPError for bad responses (4xx or 5xx)\e[39;00m\n\n            \e[38;2;96;160;176;03m# Check for Bybit specific error codes within a successful HTTP response\e[39;00m\n            response_json \e[38;2;102;102;102m=\e[39m response\e[38;2;102;102;102m.\e[39mjson()\n            \e[38;2;0;112;32;01mif\e[39;00m response_json\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretCode\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;102;102;102m!=\e[39m \e[38;2;64;160;112m0\e[39m:\n                \e[38;2;0;112;32;01mif\e[39;00m logger:\n                    logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mBybit API Error: \e[39m\e[38;2;112;160;208;03m{\e[39;00mresponse_json\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mretMsg\e[39m\e[38;2;64;112;160m'\e[39m,\e[38;2;187;187;187m \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mUnknown error\e[39m\e[38;2;64;112;160m'\e[39m)\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m. Response: \e[39m\e[38;2;112;160;208;03m{\e[39;00mresponse_json\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n\n            \e[38;2;0;112;32;01mreturn\e[39;00m response_json\n\n        \e[38;2;0;112;32;01mexcept\e[39;00m requests\e[38;2;102;102;102m.\e[39mexceptions\e[38;2;102;102;102m.\e[39mHTTPError \e[38;2;0;112;32;01mas\e[39;00m e:\n            \e[38;2;0;112;32;01mif\e[39;00m e\e[38;2;102;102;102m.\e[39mresponse\e[38;2;102;102;102m.\e[39mstatus_code \e[38;2;0;112;32;01min\e[39;00m RETRY_ERROR_CODES:\n                \e[38;2;0;112;32;01mif\e[39;00m logger:\n                    logger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mAPI Error \e[39m\e[38;2;112;160;208;03m{\e[39;00me\e[38;2;102;102;102m.\e[39mresponse\e[38;2;102;102;102m.\e[39mstatus_code\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m (\e[39m\e[38;2;112;160;208;03m{\e[39;00me\e[38;2;102;102;102m.\e[39mresponse\e[38;2;102;102;102m.\e[39mreason\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m), retrying \e[39m\e[38;2;112;160;208;03m{\e[39;00mretry\e[38;2;187;187;187m \e[39m\e[38;2;102;102;102m+\e[39m\e[38;2;187;187;187m \e[39m\e[38;2;64;160;112m1\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m/\e[39m\e[38;2;112;160;208;03m{\e[39;00mMAX_API_RETRIES\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m...\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                time\e[38;2;102;102;102m.\e[39msleep(RETRY_DELAY_SECONDS \e[38;2;102;102;102m*\e[39m (\e[38;2;64;160;112m2\e[39m\e[38;2;102;102;102m*\e[39m\e[38;2;102;102;102m*\e[39mretry))  \e[38;2;96;160;176;03m# Exponential backoff\e[39;00m\n            \e[38;2;0;112;32;01melse\e[39;00m:\n                \e[38;2;0;112;32;01mif\e[39;00m logger:\n                    handle_api_error(e\e[38;2;102;102;102m.\e[39mresponse, logger)\n                \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n        \e[38;2;0;112;32;01mexcept\e[39;00m requests\e[38;2;102;102;102m.\e[39mexceptions\e[38;2;102;102;102m.\e[39mRequestException \e[38;2;0;112;32;01mas\e[39;00m e:\n            \e[38;2;0;112;32;01mif\e[39;00m logger:\n                logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mRequest exception: \e[39m\e[38;2;112;160;208;03m{\e[39;00me\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m, retrying \e[39m\e[38;2;112;160;208;03m{\e[39;00mretry\e[38;2;187;187;187m \e[39m\e[38;2;102;102;102m+\e[39m\e[38;2;187;187;187m \e[39m\e[38;2;64;160;112m1\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m/\e[39m\e[38;2;112;160;208;03m{\e[39;00mMAX_API_RETRIES\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m...\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            time\e[38;2;102;102;102m.\e[39msleep(RETRY_DELAY_SECONDS \e[38;2;102;102;102m*\e[39m (\e[38;2;64;160;112m2\e[39m\e[38;2;102;102;102m*\e[39m\e[38;2;102;102;102m*\e[39mretry))\n\n    \e[38;2;0;112;32;01mif\e[39;00m logger:\n        logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMax retries reached for \e[39m\e[38;2;112;160;208;03m{\e[39;00mmethod\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00mendpoint\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n    \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n\n\n\e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mfetch_current_price\e[39m(symbol: \e[38;2;0;112;32mstr\e[39m, api_key: \e[38;2;0;112;32mstr\e[39m, api_secret: \e[38;2;0;112;32mstr\e[39m, logger: logging\e[38;2;102;102;102m.\e[39mLogger) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Union[Decimal, \e[38;2;0;112;32;01mNone\e[39;00m]:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"Fetches the current last traded price for a given symbol.\"\"\"\e[39;00m\n    endpoint \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m/v5/market/tickers\e[39m\e[38;2;64;112;160m\"\e[39m\n    params \e[38;2;102;102;102m=\e[39m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcategory\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlinear\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msymbol\e[39m\e[38;2;64;112;160m\"\e[39m: symbol}\n    response_data \e[38;2;102;102;102m=\e[39m bybit_request(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mGET\e[39m\e[38;2;64;112;160m\"\e[39m, endpoint, api_key, api_secret, params, logger)\n    \e[38;2;0;112;32;01mif\e[39;00m response_data \e[38;2;0;112;32;01mand\e[39;00m response_data\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretCode\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;102;102;102m==\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01mand\e[39;00m response_data\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresult\e[39m\e[38;2;64;112;160m\"\e[39m):\n        tickers \e[38;2;102;102;102m=\e[39m response_data[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresult\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlist\e[39m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;0;112;32;01mif\e[39;00m tickers:\n            \e[38;2;0;112;32;01mfor\e[39;00m ticker \e[38;2;0;112;32;01min\e[39;00m tickers:\n                \e[38;2;0;112;32;01mif\e[39;00m ticker\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msymbol\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;102;102;102m==\e[39m symbol:\n                    last_price \e[38;2;102;102;102m=\e[39m ticker\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlastPrice\e[39m\e[38;2;64;112;160m\"\e[39m)\n                    \e[38;2;0;112;32;01mreturn\e[39;00m Decimal(last_price) \e[38;2;0;112;32;01mif\e[39;00m last_price \e[38;2;0;112;32;01melse\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n    logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mCould not fetch current price for \e[39m\e[38;2;112;160;208;03m{\e[39;00msymbol\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m. Response: \e[39m\e[38;2;112;160;208;03m{\e[39;00mresponse_data\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n    \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n\n\n\e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mfetch_klines\e[39m(symbol: \e[38;2;0;112;32mstr\e[39m, interval: \e[38;2;0;112;32mstr\e[39m, api_key: \e[38;2;0;112;32mstr\e[39m, api_secret: \e[38;2;0;112;32mstr\e[39m, logger: logging\e[38;2;102;102;102m.\e[39mLogger, limit: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m200\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mDataFrame:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"Fetches historical K-line (candlestick) data for a given symbol and interval.\"\"\"\e[39;00m\n    endpoint \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m/v5/market/kline\e[39m\e[38;2;64;112;160m\"\e[39m\n    params \e[38;2;102;102;102m=\e[39m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msymbol\e[39m\e[38;2;64;112;160m\"\e[39m: symbol, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m\"\e[39m: interval, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlimit\e[39m\e[38;2;64;112;160m\"\e[39m: limit, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcategory\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlinear\e[39m\e[38;2;64;112;160m\"\e[39m}\n    response_data \e[38;2;102;102;102m=\e[39m bybit_request(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mGET\e[39m\e[38;2;64;112;160m\"\e[39m, endpoint, api_key, api_secret, params, logger)\n    \e[38;2;0;112;32;01mif\e[39;00m response_data \e[38;2;0;112;32;01mand\e[39;00m response_data\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretCode\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;102;102;102m==\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01mand\e[39;00m response_data\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresult\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mand\e[39;00m response_data[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresult\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlist\e[39m\e[38;2;64;112;160m\"\e[39m):\n        data \e[38;2;102;102;102m=\e[39m response_data[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresult\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlist\e[39m\e[38;2;64;112;160m\"\e[39m]\n        \e[38;2;96;160;176;03m# Bybit's kline list order is: [timestamp, open, high, low, close, volume, turnover]\e[39;00m\n        columns \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstart_time\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mopen\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mturnover\e[39m\e[38;2;64;112;160m\"\e[39m]\n        df \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mDataFrame(data, columns\e[38;2;102;102;102m=\e[39mcolumns)\n        df[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstart_time\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mto_datetime(pd\e[38;2;102;102;102m.\e[39mto_numeric(df[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstart_time\e[39m\e[38;2;64;112;160m\"\e[39m]), unit\e[38;2;102;102;102m=\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mms\e[39m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;96;160;176;03m# Convert numeric columns, coercing errors to NaN\e[39;00m\n        \e[38;2;0;112;32;01mfor\e[39;00m col \e[38;2;0;112;32;01min\e[39;00m df\e[38;2;102;102;102m.\e[39mcolumns[\e[38;2;64;160;112m1\e[39m:]:\n            df[col] \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mto_numeric(df[col], errors\e[38;2;102;102;102m=\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mcoerce\e[39m\e[38;2;64;112;160m'\e[39m)\n        \e[38;2;96;160;176;03m# Drop any rows that resulted in all NaNs after conversion (shouldn't happen with valid data)\e[39;00m\n        df\e[38;2;102;102;102m.\e[39mdropna(subset\e[38;2;102;102;102m=\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns[\e[38;2;64;160;112m1\e[39m:], inplace\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mTrue\e[39;00m)\n        \e[38;2;0;112;32;01mreturn\e[39;00m df\e[38;2;102;102;102m.\e[39msort_values(by\e[38;2;102;102;102m=\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstart_time\e[39m\e[38;2;64;112;160m\"\e[39m, ascending\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mTrue\e[39;00m)\e[38;2;102;102;102m.\e[39mreset_index(drop\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mTrue\e[39;00m)  \e[38;2;96;160;176;03m# Ensure chronological order\e[39;00m\n    logger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mFailed to fetch Kline data for \e[39m\e[38;2;112;160;208;03m{\e[39;00msymbol\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m, interval \e[39m\e[38;2;112;160;208;03m{\e[39;00minterval\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m. Response: \e[39m\e[38;2;112;160;208;03m{\e[39;00mresponse_data\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n    \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mDataFrame()\n\n\n\e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mfetch_order_book\e[39m(symbol: \e[38;2;0;112;32mstr\e[39m, api_key: \e[38;2;0;112;32mstr\e[39m, api_secret: \e[38;2;0;112;32mstr\e[39m, logger: logging\e[38;2;102;102;102m.\e[39mLogger, limit: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m50\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Union[\e[38;2;0;112;32mdict\e[39m, \e[38;2;0;112;32;01mNone\e[39;00m]:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"Fetches the order book (bids and asks) for a given symbol.\"\"\"\e[39;00m\n    endpoint \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m/v5/market/orderbook\e[39m\e[38;2;64;112;160m\"\e[39m\n    params \e[38;2;102;102;102m=\e[39m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msymbol\e[39m\e[38;2;64;112;160m\"\e[39m: symbol, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlimit\e[39m\e[38;2;64;112;160m\"\e[39m: limit, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcategory\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlinear\e[39m\e[38;2;64;112;160m\"\e[39m}\n    response_data \e[38;2;102;102;102m=\e[39m bybit_request(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mGET\e[39m\e[38;2;64;112;160m\"\e[39m, endpoint, api_key, api_secret, params, logger)\n    \e[38;2;0;112;32;01mif\e[39;00m response_data \e[38;2;0;112;32;01mand\e[39;00m response_data\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretCode\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;102;102;102m==\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01mand\e[39;00m response_data\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresult\e[39m\e[38;2;64;112;160m\"\e[39m):\n        \e[38;2;0;112;32;01mreturn\e[39;00m response_data[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mresult\e[39m\e[38;2;64;112;160m\"\e[39m]\n    logger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mCould not fetch order book for \e[39m\e[38;2;112;160;208;03m{\e[39;00msymbol\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m. Response: \e[39m\e[38;2;112;160;208;03m{\e[39;00mresponse_data\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n    \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n\n\n\e[38;2;0;112;32;01mclass\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;14;132;181;01mTradingAnalyzer\e[39;00m:\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m    Performs technical analysis on candlestick data and generates trading signals.\e[39;00m\n\e[38;2;64;112;160;03m    \"\"\"\e[39;00m\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m__init__\e[39m(\e[38;2;0;112;32mself\e[39m, df: pd\e[38;2;102;102;102m.\e[39mDataFrame, config: \e[38;2;0;112;32mdict\e[39m, symbol_logger: logging\e[38;2;102;102;102m.\e[39mLogger, symbol: \e[38;2;0;112;32mstr\e[39m, interval: \e[38;2;0;112;32mstr\e[39m):\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf \e[38;2;102;102;102m=\e[39m df\e[38;2;102;102;102m.\e[39mcopy()  \e[38;2;96;160;176;03m# Work on a copy to avoid modifying original DataFrame\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig \e[38;2;102;102;102m=\e[39m config\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger \e[38;2;102;102;102m=\e[39m symbol_logger\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39msymbol \e[38;2;102;102;102m=\e[39m symbol\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39minterval \e[38;2;102;102;102m=\e[39m interval\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlevels: Dict[\e[38;2;0;112;32mstr\e[39m, Any] \e[38;2;102;102;102m=\e[39m {}  \e[38;2;96;160;176;03m# Stores support/resistance levels (fib, pivot)\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mfib_levels: Dict[\e[38;2;0;112;32mstr\e[39m, \e[38;2;0;112;32mfloat\e[39m] \e[38;2;102;102;102m=\e[39m {}  \e[38;2;96;160;176;03m# Stores calculated Fibonacci levels\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mweight_sets \e[38;2;102;102;102m=\e[39m config[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mweight_sets\e[39m\e[38;2;64;112;160m\"\e[39m]\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values: Dict[\e[38;2;0;112;32mstr\e[39m, Any] \e[38;2;102;102;102m=\e[39m {}  \e[38;2;96;160;176;03m# Stores calculated indicator values\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value: \e[38;2;0;112;32mfloat\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0.0\e[39m  \e[38;2;96;160;176;03m# Stores the latest ATR value\e[39;00m\n\n        \e[38;2;96;160;176;03m# Pre-calculate common indicators needed for others or for weight selection\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_pre_calculate_indicators()\n\n        \e[38;2;96;160;176;03m# Now that ATR is potentially calculated, select the weight set\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39muser_defined_weights \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_select_weight_set()  \e[38;2;96;160;176;03m# Dynamically selected weights\e[39;00m\n\n        \e[38;2;96;160;176;03m# Calculate Stoch RSI if enabled, as it's used in signal generation\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m\"\e[39m):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_stoch_rsi()\n        \e[38;2;96;160;176;03m# --- New: Calculate Stochastic Oscillator if enabled ---\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstochastic_oscillator\e[39m\e[38;2;64;112;160m\"\e[39m):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_stochastic_oscillator()\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_pre_calculate_indicators\e[39m(\e[38;2;0;112;32mself\e[39m):\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Pre-calculates indicators necessary for weight selection or other calculations.\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mempty:\n            \e[38;2;96;160;176;03m# Calculate ATR once for volatility assessment\e[39;00m\n            atr_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_atr(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr_period\e[39m\e[38;2;64;112;160m\"\e[39m])\n            \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m atr_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m pd\e[38;2;102;102;102m.\e[39misna(atr_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]):\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value \e[38;2;102;102;102m=\e[39m atr_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\n            \e[38;2;0;112;32;01melse\e[39;00m:\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0.0\e[39m  \e[38;2;96;160;176;03m# Default ATR to 0 if calculation fails or is NaN\e[39;00m\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value  \e[38;2;96;160;176;03m# Store ATR for logging/analysis\e[39;00m\n\n            \e[38;2;96;160;176;03m# Calculate momentum MAs for trend determination\e[39;00m\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_momentum_ma()\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_select_weight_set\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Dict[\e[38;2;0;112;32mstr\e[39m, \e[38;2;0;112;32mfloat\e[39m]:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        Selects a weight set (e.g., low_volatility, high_volatility) based on current ATR.\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        \e[38;2;96;160;176;03m# Use the atr_value that was pre-calculated in _pre_calculate_indicators\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value \e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr_change_threshold\e[39m\e[38;2;64;112;160m\"\e[39m]:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39minfo(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMarket detected as HIGH VOLATILITY (ATR: \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.4f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m). Using \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh_volatility\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m weights.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mweight_sets\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh_volatility\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mweight_sets[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow_volatility\e[39m\e[38;2;64;112;160m\"\e[39m])\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39minfo(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMarket detected as LOW VOLATILITY (ATR: \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.4f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m). Using \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow_volatility\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m weights.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mweight_sets[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow_volatility\e[39m\e[38;2;64;112;160m\"\e[39m]\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_safe_series_operation\e[39m(\e[38;2;0;112;32mself\e[39m, column: \e[38;2;0;112;32mstr\e[39m, operation: \e[38;2;0;112;32mstr\e[39m, window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mNone\e[39;00m, series: pd\e[38;2;102;102;102m.\e[39mSeries \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mNone\e[39;00m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Helper to safely perform operations on DataFrame columns or provided series.\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m series \e[38;2;0;112;32;01mis\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m:\n            data_series \e[38;2;102;102;102m=\e[39m series\n        \e[38;2;0;112;32;01melif\e[39;00m column \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            data_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[column]\n        \e[38;2;0;112;32;01melse\e[39;00m:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;112;160;208;03m{\e[39;00mcolumn\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m column for \e[39m\e[38;2;112;160;208;03m{\e[39;00moperation\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        \e[38;2;0;112;32;01mif\e[39;00m data_series\e[38;2;102;102;102m.\e[39mempty:\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        \e[38;2;0;112;32;01mtry\e[39;00m:\n            \e[38;2;0;112;32;01mif\e[39;00m operation \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m\"\e[39m:\n                \e[38;2;0;112;32;01mreturn\e[39;00m data_series\e[38;2;102;102;102m.\e[39mrolling(window\e[38;2;102;102;102m=\e[39mwindow)\e[38;2;102;102;102m.\e[39mmean()\n            \e[38;2;0;112;32;01melif\e[39;00m operation \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema\e[39m\e[38;2;64;112;160m\"\e[39m:\n                \e[38;2;0;112;32;01mreturn\e[39;00m data_series\e[38;2;102;102;102m.\e[39mewm(span\e[38;2;102;102;102m=\e[39mwindow, adjust\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mFalse\e[39;00m)\e[38;2;102;102;102m.\e[39mmean()\n            \e[38;2;0;112;32;01melif\e[39;00m operation \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmax\e[39m\e[38;2;64;112;160m\"\e[39m:\n                \e[38;2;0;112;32;01mreturn\e[39;00m data_series\e[38;2;102;102;102m.\e[39mrolling(window\e[38;2;102;102;102m=\e[39mwindow)\e[38;2;102;102;102m.\e[39mmax()\n            \e[38;2;0;112;32;01melif\e[39;00m operation \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmin\e[39m\e[38;2;64;112;160m\"\e[39m:\n                \e[38;2;0;112;32;01mreturn\e[39;00m data_series\e[38;2;102;102;102m.\e[39mrolling(window\e[38;2;102;102;102m=\e[39mwindow)\e[38;2;102;102;102m.\e[39mmin()\n            \e[38;2;0;112;32;01melif\e[39;00m operation \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mdiff\e[39m\e[38;2;64;112;160m\"\e[39m:\n                \e[38;2;0;112;32;01mreturn\e[39;00m data_series\e[38;2;102;102;102m.\e[39mdiff(window)\n            \e[38;2;0;112;32;01melif\e[39;00m operation \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mabs_diff_mean\e[39m\e[38;2;64;112;160m\"\e[39m:\n                \e[38;2;0;112;32;01mreturn\e[39;00m data_series\e[38;2;102;102;102m.\e[39mrolling(window\e[38;2;102;102;102m=\e[39mwindow)\e[38;2;102;102;102m.\e[39mapply(\e[38;2;0;112;32;01mlambda\e[39;00m x: np\e[38;2;102;102;102m.\e[39mabs(x \e[38;2;102;102;102m-\e[39m x\e[38;2;102;102;102m.\e[39mmean())\e[38;2;102;102;102m.\e[39mmean(), raw\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mTrue\e[39;00m)\n            \e[38;2;0;112;32;01melif\e[39;00m operation \e[38;2;102;102;102m==\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcumsum\e[39m\e[38;2;64;112;160m\"\e[39m:\n                \e[38;2;0;112;32;01mreturn\e[39;00m data_series\e[38;2;102;102;102m.\e[39mcumsum()\n            \e[38;2;0;112;32;01melse\e[39;00m:\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mUnsupported series operation: \e[39m\e[38;2;112;160;208;03m{\e[39;00moperation\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n        \e[38;2;0;112;32;01mexcept\e[39;00m \e[38;2;0;112;32mException\e[39m \e[38;2;0;112;32;01mas\e[39;00m e:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mError during \e[39m\e[38;2;112;160;208;03m{\e[39;00moperation\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m calculation on \e[39m\e[38;2;112;160;208;03m{\e[39;00mcolumn\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m: \e[39m\e[38;2;112;160;208;03m{\e[39;00me\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_sma\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m, series: pd\e[38;2;102;102;102m.\e[39mSeries \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mNone\e[39;00m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates Simple Moving Average (SMA). Can operate on a specified series or 'close' price.\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m'\e[39m, window, series)\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_ema\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m, series: pd\e[38;2;102;102;102m.\e[39mSeries \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mNone\e[39;00m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates Exponential Moving Average (EMA). Can operate on a specified series or 'close' price.\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mema\e[39m\e[38;2;64;112;160m'\e[39m, window, series)\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_ema_alignment\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mfloat\e[39m:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        Calculates an EMA alignment score.\e[39;00m\n\e[38;2;64;112;160;03m        Score is 1.0 for strong bullish alignment, -1.0 for strong bearish, 0.0 for neutral.\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        ema_short \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_short_period\e[39m\e[38;2;64;112;160m\"\e[39m])\n        ema_long \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_long_period\e[39m\e[38;2;64;112;160m\"\e[39m])\n\n        \e[38;2;0;112;32;01mif\e[39;00m ema_short\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mor\e[39;00m ema_long\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf) \e[38;2;102;102;102m<\e[39m \e[38;2;0;112;32mmax\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_short_period\e[39m\e[38;2;64;112;160m\"\e[39m], \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_long_period\e[39m\e[38;2;64;112;160m\"\e[39m]):\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;160;112m0.0\e[39m\n\n        latest_short_ema \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(ema_short\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]))\n        latest_long_ema \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(ema_long\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]))\n\n        \e[38;2;96;160;176;03m# Check for consistent alignment over the last few bars (e.g., 3 bars)\e[39;00m\n        alignment_period \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m3\e[39m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mlen\e[39m(ema_short) \e[38;2;102;102;102m<\e[39m alignment_period \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32mlen\e[39m(ema_long) \e[38;2;102;102;102m<\e[39m alignment_period:\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;160;112m0.0\e[39m\n\n        bullish_aligned_count \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0\e[39m\n        bearish_aligned_count \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0\e[39m\n\n        \e[38;2;0;112;32;01mfor\e[39;00m i \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mrange\e[39m(\e[38;2;64;160;112m1\e[39m, alignment_period \e[38;2;102;102;102m+\e[39m \e[38;2;64;160;112m1\e[39m):\n            \e[38;2;0;112;32;01mif\e[39;00m (ema_short\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi] \e[38;2;102;102;102m>\e[39m ema_long\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi] \e[38;2;0;112;32;01mand\e[39;00m\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi] \e[38;2;102;102;102m>\e[39m ema_short\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi]):\n                bullish_aligned_count \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m1\e[39m\n            \e[38;2;0;112;32;01melif\e[39;00m (ema_short\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi] \e[38;2;102;102;102m<\e[39m ema_long\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi] \e[38;2;0;112;32;01mand\e[39;00m\n                  \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi] \e[38;2;102;102;102m<\e[39m ema_short\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39mi]):\n                bearish_aligned_count \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m1\e[39m\n\n        \e[38;2;0;112;32;01mif\e[39;00m bullish_aligned_count \e[38;2;102;102;102m>\e[39m\e[38;2;102;102;102m=\e[39m alignment_period \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m:  \e[38;2;96;160;176;03m# At least (period-1) bars are aligned\e[39;00m\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;160;112m1.0\e[39m  \e[38;2;96;160;176;03m# Strong bullish alignment\e[39;00m\n        \e[38;2;0;112;32;01melif\e[39;00m bearish_aligned_count \e[38;2;102;102;102m>\e[39m\e[38;2;102;102;102m=\e[39m alignment_period \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m:\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1.0\e[39m  \e[38;2;96;160;176;03m# Strong bearish alignment\e[39;00m\n        \e[38;2;0;112;32;01melse\e[39;00m:\n            \e[38;2;96;160;176;03m# Check for recent crossover as a weaker signal\e[39;00m\n            \e[38;2;0;112;32;01mif\e[39;00m latest_short_ema \e[38;2;102;102;102m>\e[39m latest_long_ema \e[38;2;0;112;32;01mand\e[39;00m ema_short\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m] \e[38;2;102;102;102m<\e[39m\e[38;2;102;102;102m=\e[39m latest_long_ema:\n                \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;160;112m0.5\e[39m  \e[38;2;96;160;176;03m# Recent bullish crossover\e[39;00m\n            \e[38;2;0;112;32;01melif\e[39;00m latest_short_ema \e[38;2;102;102;102m<\e[39m latest_long_ema \e[38;2;0;112;32;01mand\e[39;00m ema_short\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m] \e[38;2;102;102;102m>\e[39m\e[38;2;102;102;102m=\e[39m latest_long_ema:\n                \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m0.5\e[39m  \e[38;2;96;160;176;03m# Recent bearish crossover\e[39;00m\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;160;112m0.0\e[39m  \e[38;2;96;160;176;03m# Neutral\e[39;00m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_momentum\e[39m(\e[38;2;0;112;32mself\e[39m, period: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m10\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Momentum indicator.\"\"\"\e[39;00m\n        \e[38;2;96;160;176;03m# Momentum is often calculated as current price - price N periods ago.\e[39;00m\n        \e[38;2;96;160;176;03m# For signal generation, a ratio or percentage change can be more useful.\e[39;00m\n        \e[38;2;96;160;176;03m# Here, we calculate the percentage change over the period.\e[39;00m\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mdiff\e[39m\e[38;2;64;112;160m'\e[39m, period) \e[38;2;102;102;102m/\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift(period) \e[38;2;102;102;102m*\e[39m \e[38;2;64;160;112m100\e[39m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_cci\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m20\e[39m, constant: \e[38;2;0;112;32mfloat\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0.015\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Commodity Channel Index (CCI).\"\"\"\e[39;00m\n        required_columns \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m]\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mall\e[39m(col \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mfor\e[39;00m col \e[38;2;0;112;32;01min\e[39;00m required_columns):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing required columns for CCI calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n        typical_price \e[38;2;102;102;102m=\e[39m (\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m+\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m+\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]) \e[38;2;102;102;102m/\e[39m \e[38;2;64;160;112m3\e[39m\n        sma_typical_price \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m'\e[39m, window, typical_price)\n        mean_deviation \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mabs_diff_mean\e[39m\e[38;2;64;112;160m'\e[39m, window, typical_price)\n        \e[38;2;96;160;176;03m# Avoid division by zero\e[39;00m\n        cci \e[38;2;102;102;102m=\e[39m (typical_price \e[38;2;102;102;102m-\e[39m sma_typical_price) \e[38;2;102;102;102m/\e[39m (constant \e[38;2;102;102;102m*\e[39m mean_deviation)\n        \e[38;2;0;112;32;01mreturn\e[39;00m cci\e[38;2;102;102;102m.\e[39mreplace([np\e[38;2;102;102;102m.\e[39minf, \e[38;2;102;102;102m-\e[39mnp\e[38;2;102;102;102m.\e[39minf], np\e[38;2;102;102;102m.\e[39mnan)  \e[38;2;96;160;176;03m# Handle potential inf values\e[39;00m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_williams_r\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m14\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Williams %R indicator.\"\"\"\e[39;00m\n        required_columns \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m]\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mall\e[39m(col \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mfor\e[39;00m col \e[38;2;0;112;32;01min\e[39;00m required_columns):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing required columns for Williams %R calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n        highest_high \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmax\e[39m\e[38;2;64;112;160m'\e[39m, window)\n        lowest_low \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmin\e[39m\e[38;2;64;112;160m'\e[39m, window)\n        \e[38;2;96;160;176;03m# Avoid division by zero\e[39;00m\n        denominator \e[38;2;102;102;102m=\e[39m (highest_high \e[38;2;102;102;102m-\e[39m lowest_low)\n        wr \e[38;2;102;102;102m=\e[39m ((highest_high \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]) \e[38;2;102;102;102m/\e[39m denominator) \e[38;2;102;102;102m*\e[39m \e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m100\e[39m\n        \e[38;2;0;112;32;01mreturn\e[39;00m wr\e[38;2;102;102;102m.\e[39mreplace([np\e[38;2;102;102;102m.\e[39minf, \e[38;2;102;102;102m-\e[39mnp\e[38;2;102;102;102m.\e[39minf], np\e[38;2;102;102;102m.\e[39mnan)\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_mfi\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m14\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Money Flow Index (MFI).\"\"\"\e[39;00m\n        required_columns \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m]\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mall\e[39m(col \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mfor\e[39;00m col \e[38;2;0;112;32;01min\e[39;00m required_columns):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing required columns for MFI calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        typical_price \e[38;2;102;102;102m=\e[39m (\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m+\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m+\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]) \e[38;2;102;102;102m/\e[39m \e[38;2;64;160;112m3\e[39m\n        raw_money_flow \e[38;2;102;102;102m=\e[39m typical_price \e[38;2;102;102;102m*\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m]\n\n        \e[38;2;96;160;176;03m# Calculate positive and negative money flow\e[39;00m\n        money_flow_direction \e[38;2;102;102;102m=\e[39m typical_price\e[38;2;102;102;102m.\e[39mdiff()\n        positive_flow \e[38;2;102;102;102m=\e[39m raw_money_flow\e[38;2;102;102;102m.\e[39mwhere(money_flow_direction \e[38;2;102;102;102m>\e[39m \e[38;2;64;160;112m0\e[39m, \e[38;2;64;160;112m0\e[39m)\n        negative_flow \e[38;2;102;102;102m=\e[39m raw_money_flow\e[38;2;102;102;102m.\e[39mwhere(money_flow_direction \e[38;2;102;102;102m<\e[39m \e[38;2;64;160;112m0\e[39m, \e[38;2;64;160;112m0\e[39m)\n\n        \e[38;2;96;160;176;03m# Calculate sums over the window\e[39;00m\n        positive_mf \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m'\e[39m, window, positive_flow) \e[38;2;102;102;102m*\e[39m window  \e[38;2;96;160;176;03m# sum not mean\e[39;00m\n        negative_mf \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m'\e[39m, window, negative_flow) \e[38;2;102;102;102m*\e[39m window  \e[38;2;96;160;176;03m# sum not mean\e[39;00m\n\n        \e[38;2;96;160;176;03m# Avoid division by zero\e[39;00m\n        money_ratio \e[38;2;102;102;102m=\e[39m positive_mf \e[38;2;102;102;102m/\e[39m negative_mf\e[38;2;102;102;102m.\e[39mreplace(\e[38;2;64;160;112m0\e[39m, np\e[38;2;102;102;102m.\e[39mnan)  \e[38;2;96;160;176;03m# Replace 0 with NaN to handle division by zero\e[39;00m\n        mfi \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m100\e[39m \e[38;2;102;102;102m-\e[39m (\e[38;2;64;160;112m100\e[39m \e[38;2;102;102;102m/\e[39m (\e[38;2;64;160;112m1\e[39m \e[38;2;102;102;102m+\e[39m money_ratio))\n        \e[38;2;0;112;32;01mreturn\e[39;00m mfi\e[38;2;102;102;102m.\e[39mreplace([np\e[38;2;102;102;102m.\e[39minf, \e[38;2;102;102;102m-\e[39mnp\e[38;2;102;102;102m.\e[39minf], np\e[38;2;102;102;102m.\e[39mnan)\e[38;2;102;102;102m.\e[39mfillna(\e[38;2;64;160;112m0\e[39m)  \e[38;2;96;160;176;03m# Fill NaN from division by zero with 0 or a sensible value\e[39;00m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mcalculate_fibonacci_retracement\e[39m(\e[38;2;0;112;32mself\e[39m, high: Decimal, low: Decimal, current_price: Decimal) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Dict[\e[38;2;0;112;32mstr\e[39m, Decimal]:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates Fibonacci retracement levels based on a given high and low.\"\"\"\e[39;00m\n        diff \e[38;2;102;102;102m=\e[39m high \e[38;2;102;102;102m-\e[39m low\n        \e[38;2;0;112;32;01mif\e[39;00m diff \e[38;2;102;102;102m<\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0\e[39m:  \e[38;2;96;160;176;03m# Handle cases where high <= low\e[39;00m\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mCannot calculate Fibonacci retracement: High (\e[39m\e[38;2;112;160;208;03m{\e[39;00mhigh\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m) <= Low (\e[39m\e[38;2;112;160;208;03m{\e[39;00mlow\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m).\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mfib_levels \e[38;2;102;102;102m=\e[39m {}\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlevels \e[38;2;102;102;102m=\e[39m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mSupport\e[39m\e[38;2;64;112;160m\"\e[39m: {}, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mResistance\e[39m\e[38;2;64;112;160m\"\e[39m: {}}\n            \e[38;2;0;112;32;01mreturn\e[39;00m {}\n\n        \e[38;2;96;160;176;03m# Standard Fibonacci ratios\e[39;00m\n        fib_ratios \e[38;2;102;102;102m=\e[39m {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m23.6\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160m\"\e[39m: Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.236\e[39m\e[38;2;64;112;160m'\e[39m), \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m38.2\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160m\"\e[39m: Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.382\e[39m\e[38;2;64;112;160m'\e[39m), \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m50.0\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160m\"\e[39m: Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.500\e[39m\e[38;2;64;112;160m'\e[39m),\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m61.8\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160m\"\e[39m: Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.618\e[39m\e[38;2;64;112;160m'\e[39m), \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m78.6\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160m\"\e[39m: Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.786\e[39m\e[38;2;64;112;160m'\e[39m), \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m88.6\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160m\"\e[39m: Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.886\e[39m\e[38;2;64;112;160m'\e[39m),\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m94.1\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160m\"\e[39m: Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.941\e[39m\e[38;2;64;112;160m'\e[39m)\n        }\n        fib_levels_calculated: Dict[\e[38;2;0;112;32mstr\e[39m, Decimal] \e[38;2;102;102;102m=\e[39m {}\n\n        \e[38;2;96;160;176;03m# Assuming an uptrend (retracement from high to low)\e[39;00m\n        \e[38;2;96;160;176;03m# Levels are calculated from the high, moving down\e[39;00m\n        \e[38;2;0;112;32;01mfor\e[39;00m label, ratio \e[38;2;0;112;32;01min\e[39;00m fib_ratios\e[38;2;102;102;102m.\e[39mitems():\n            level \e[38;2;102;102;102m=\e[39m high \e[38;2;102;102;102m-\e[39m (diff \e[38;2;102;102;102m*\e[39m ratio)\n            fib_levels_calculated[\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mFib \e[39m\e[38;2;112;160;208;03m{\e[39;00mlabel\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m level\e[38;2;102;102;102m.\e[39mquantize(Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.00001\e[39m\e[38;2;64;112;160m'\e[39m))  \e[38;2;96;160;176;03m# Quantize for consistent precision\e[39;00m\n\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mfib_levels \e[38;2;102;102;102m=\e[39m fib_levels_calculated\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlevels \e[38;2;102;102;102m=\e[39m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mSupport\e[39m\e[38;2;64;112;160m\"\e[39m: {}, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mResistance\e[39m\e[38;2;64;112;160m\"\e[39m: {}}\n\n        \e[38;2;96;160;176;03m# Categorize levels as support or resistance relative to current price\e[39;00m\n        \e[38;2;0;112;32;01mfor\e[39;00m label, value \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mfib_levels\e[38;2;102;102;102m.\e[39mitems():\n            \e[38;2;0;112;32;01mif\e[39;00m value \e[38;2;102;102;102m<\e[39m current_price:\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlevels[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mSupport\e[39m\e[38;2;64;112;160m\"\e[39m][label] \e[38;2;102;102;102m=\e[39m value\n            \e[38;2;0;112;32;01melif\e[39;00m value \e[38;2;102;102;102m>\e[39m current_price:\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlevels[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mResistance\e[39m\e[38;2;64;112;160m\"\e[39m][label] \e[38;2;102;102;102m=\e[39m value\n\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mfib_levels\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mcalculate_pivot_points\e[39m(\e[38;2;0;112;32mself\e[39m, high: Decimal, low: Decimal, close: Decimal):\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates standard Pivot Points.\"\"\"\e[39;00m\n        pivot \e[38;2;102;102;102m=\e[39m (high \e[38;2;102;102;102m+\e[39m low \e[38;2;102;102;102m+\e[39m close) \e[38;2;102;102;102m/\e[39m \e[38;2;64;160;112m3\e[39m\n        r1 \e[38;2;102;102;102m=\e[39m (\e[38;2;64;160;112m2\e[39m \e[38;2;102;102;102m*\e[39m pivot) \e[38;2;102;102;102m-\e[39m low\n        s1 \e[38;2;102;102;102m=\e[39m (\e[38;2;64;160;112m2\e[39m \e[38;2;102;102;102m*\e[39m pivot) \e[38;2;102;102;102m-\e[39m high\n        r2 \e[38;2;102;102;102m=\e[39m pivot \e[38;2;102;102;102m+\e[39m (high \e[38;2;102;102;102m-\e[39m low)\n        s2 \e[38;2;102;102;102m=\e[39m pivot \e[38;2;102;102;102m-\e[39m (high \e[38;2;102;102;102m-\e[39m low)\n        r3 \e[38;2;102;102;102m=\e[39m high \e[38;2;102;102;102m+\e[39m \e[38;2;64;160;112m2\e[39m \e[38;2;102;102;102m*\e[39m (pivot \e[38;2;102;102;102m-\e[39m low)\n        s3 \e[38;2;102;102;102m=\e[39m low \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m2\e[39m \e[38;2;102;102;102m*\e[39m (high \e[38;2;102;102;102m-\e[39m pivot)\n\n        \e[38;2;96;160;176;03m# Quantize all pivot points for consistent precision\e[39;00m\n        precision \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0.00001\e[39m\e[38;2;64;112;160m'\e[39m)\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlevels\e[38;2;102;102;102m.\e[39mupdate({\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mPivot\e[39m\e[38;2;64;112;160m\"\e[39m: pivot\e[38;2;102;102;102m.\e[39mquantize(precision),\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mR1\e[39m\e[38;2;64;112;160m\"\e[39m: r1\e[38;2;102;102;102m.\e[39mquantize(precision), \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mS1\e[39m\e[38;2;64;112;160m\"\e[39m: s1\e[38;2;102;102;102m.\e[39mquantize(precision),\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mR2\e[39m\e[38;2;64;112;160m\"\e[39m: r2\e[38;2;102;102;102m.\e[39mquantize(precision), \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mS2\e[39m\e[38;2;64;112;160m\"\e[39m: s2\e[38;2;102;102;102m.\e[39mquantize(precision),\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mR3\e[39m\e[38;2;64;112;160m\"\e[39m: r3\e[38;2;102;102;102m.\e[39mquantize(precision), \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mS3\e[39m\e[38;2;64;112;160m\"\e[39m: s3\e[38;2;102;102;102m.\e[39mquantize(precision),\n        })\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mfind_nearest_levels\e[39m(\e[38;2;0;112;32mself\e[39m, current_price: Decimal, num_levels: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m5\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Tuple[List[Tuple[\e[38;2;0;112;32mstr\e[39m, Decimal]], List[Tuple[\e[38;2;0;112;32mstr\e[39m, Decimal]]]:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        Finds the nearest support and resistance levels from calculated Fibonacci and Pivot Points.\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        all_support_levels: List[Tuple[\e[38;2;0;112;32mstr\e[39m, Decimal]] \e[38;2;102;102;102m=\e[39m []\n        all_resistance_levels: List[Tuple[\e[38;2;0;112;32mstr\e[39m, Decimal]] \e[38;2;102;102;102m=\e[39m []\n\n        \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mprocess_level\e[39m(label: \e[38;2;0;112;32mstr\e[39m, value: Decimal):\n            \e[38;2;0;112;32;01mif\e[39;00m value \e[38;2;102;102;102m<\e[39m current_price:\n                all_support_levels\e[38;2;102;102;102m.\e[39mappend((label, value))\n            \e[38;2;0;112;32;01melif\e[39;00m value \e[38;2;102;102;102m>\e[39m current_price:\n                all_resistance_levels\e[38;2;102;102;102m.\e[39mappend((label, value))\n\n        \e[38;2;96;160;176;03m# Process all levels stored in self.levels (from Fibonacci and Pivot)\e[39;00m\n        \e[38;2;0;112;32;01mfor\e[39;00m label, value \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlevels\e[38;2;102;102;102m.\e[39mitems():\n            \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32misinstance\e[39m(value, \e[38;2;0;112;32mdict\e[39m):  \e[38;2;96;160;176;03m# For nested levels like \"Support\": {\"Fib 23.6%\": ...}\e[39;00m\n                \e[38;2;0;112;32;01mfor\e[39;00m sub_label, sub_value \e[38;2;0;112;32;01min\e[39;00m value\e[38;2;102;102;102m.\e[39mitems():\n                    \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32misinstance\e[39m(sub_value, Decimal):\n                        process_level(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mlabel\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m (\e[39m\e[38;2;112;160;208;03m{\e[39;00msub_label\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m)\e[39m\e[38;2;64;112;160m\"\e[39m, sub_value)\n            \e[38;2;0;112;32;01melif\e[39;00m \e[38;2;0;112;32misinstance\e[39m(value, Decimal):  \e[38;2;96;160;176;03m# For direct levels like \"Pivot\"\e[39;00m\n                process_level(label, value)\n\n        \e[38;2;96;160;176;03m# Sort by distance to current price and select the 'num_levels' closest\e[39;00m\n        nearest_supports \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32msorted\e[39m(all_support_levels, key\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mlambda\e[39;00m x: current_price \e[38;2;102;102;102m-\e[39m x[\e[38;2;64;160;112m1\e[39m])[:num_levels]\n        nearest_resistances \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32msorted\e[39m(all_resistance_levels, key\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mlambda\e[39;00m x: x[\e[38;2;64;160;112m1\e[39m] \e[38;2;102;102;102m-\e[39m current_price)[:num_levels]\n\n        \e[38;2;0;112;32;01mreturn\e[39;00m nearest_supports, nearest_resistances\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_atr\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m14\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Average True Range (ATR).\"\"\"\e[39;00m\n        required_columns \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m]\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mall\e[39m(col \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mfor\e[39;00m col \e[38;2;0;112;32;01min\e[39;00m required_columns):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing required columns for ATR calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        high_low \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\n        high_close \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mabs\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift())\n        low_close \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mabs\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift())\n\n        \e[38;2;96;160;176;03m# True Range is the maximum of the three\e[39;00m\n        tr \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mconcat([high_low, high_close, low_close], axis\e[38;2;102;102;102m=\e[39m\e[38;2;64;160;112m1\e[39m)\e[38;2;102;102;102m.\e[39mmax(axis\e[38;2;102;102;102m=\e[39m\e[38;2;64;160;112m1\e[39m)\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mema\e[39m\e[38;2;64;112;160m'\e[39m, window, tr)  \e[38;2;96;160;176;03m# Use EMA for ATR for smoothing\e[39;00m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_rsi\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m14\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Relative Strength Index (RSI).\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m column for RSI calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        delta \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mdiff()\n        gain \e[38;2;102;102;102m=\e[39m delta\e[38;2;102;102;102m.\e[39mwhere(delta \e[38;2;102;102;102m>\e[39m \e[38;2;64;160;112m0\e[39m, \e[38;2;64;160;112m0\e[39m)\n        loss \e[38;2;102;102;102m=\e[39m \e[38;2;102;102;102m-\e[39mdelta\e[38;2;102;102;102m.\e[39mwhere(delta \e[38;2;102;102;102m<\e[39m \e[38;2;64;160;112m0\e[39m, \e[38;2;64;160;112m0\e[39m)\n\n        avg_gain \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mema\e[39m\e[38;2;64;112;160m'\e[39m, window, gain)\n        avg_loss \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mema\e[39m\e[38;2;64;112;160m'\e[39m, window, loss)\n\n        \e[38;2;96;160;176;03m# Avoid division by zero\e[39;00m\n        rs \e[38;2;102;102;102m=\e[39m avg_gain \e[38;2;102;102;102m/\e[39m avg_loss\e[38;2;102;102;102m.\e[39mreplace(\e[38;2;64;160;112m0\e[39m, np\e[38;2;102;102;102m.\e[39mnan)\n        rsi \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m100\e[39m \e[38;2;102;102;102m-\e[39m (\e[38;2;64;160;112m100\e[39m \e[38;2;102;102;102m/\e[39m (\e[38;2;64;160;112m1\e[39m \e[38;2;102;102;102m+\e[39m rs))\n        \e[38;2;0;112;32;01mreturn\e[39;00m rsi\e[38;2;102;102;102m.\e[39mreplace([np\e[38;2;102;102;102m.\e[39minf, \e[38;2;102;102;102m-\e[39mnp\e[38;2;102;102;102m.\e[39minf], np\e[38;2;102;102;102m.\e[39mnan)\e[38;2;102;102;102m.\e[39mfillna(\e[38;2;64;160;112m0\e[39m)  \e[38;2;96;160;176;03m# Fill NaN from division by zero with 0\e[39;00m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_stoch_rsi\e[39m(\e[38;2;0;112;32mself\e[39m, rsi_window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m14\e[39m, stoch_window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m14\e[39m, k_window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m3\e[39m, d_window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m3\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mDataFrame:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates Stochastic RSI (%K and %D lines).\"\"\"\e[39;00m\n        rsi \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_rsi(window\e[38;2;102;102;102m=\e[39mrsi_window)\n        \e[38;2;0;112;32;01mif\e[39;00m rsi\e[38;2;102;102;102m.\e[39mempty:\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mDataFrame()\n\n        \e[38;2;96;160;176;03m# Calculate StochRSI\e[39;00m\n        stoch_rsi \e[38;2;102;102;102m=\e[39m (rsi \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmin\e[39m\e[38;2;64;112;160m'\e[39m, stoch_window, rsi)) \e[38;2;102;102;102m/\e[39m \\\n                    (\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmax\e[39m\e[38;2;64;112;160m'\e[39m, stoch_window, rsi) \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmin\e[39m\e[38;2;64;112;160m'\e[39m, stoch_window, rsi))\n\n        \e[38;2;96;160;176;03m# Handle division by zero for StochRSI (if max == min)\e[39;00m\n        stoch_rsi \e[38;2;102;102;102m=\e[39m stoch_rsi\e[38;2;102;102;102m.\e[39mreplace([np\e[38;2;102;102;102m.\e[39minf, \e[38;2;102;102;102m-\e[39mnp\e[38;2;102;102;102m.\e[39minf], np\e[38;2;102;102;102m.\e[39mnan)\e[38;2;102;102;102m.\e[39mfillna(\e[38;2;64;160;112m0\e[39m)\n\n        k_line \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m'\e[39m, k_window, stoch_rsi) \e[38;2;102;102;102m*\e[39m \e[38;2;64;160;112m100\e[39m  \e[38;2;96;160;176;03m# Scale to 0-100\e[39;00m\n        d_line \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m'\e[39m, d_window, k_line)  \e[38;2;96;160;176;03m# Signal line for %K\e[39;00m\n\n        \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mDataFrame({\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m'\e[39m: stoch_rsi \e[38;2;102;102;102m*\e[39m \e[38;2;64;160;112m100\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mk\e[39m\e[38;2;64;112;160m'\e[39m: k_line, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160md\e[39m\e[38;2;64;112;160m'\e[39m: d_line})  \e[38;2;96;160;176;03m# Return StochRSI also scaled\e[39;00m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_stochastic_oscillator\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mDataFrame:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Stochastic Oscillator (%K and %D lines).\"\"\"\e[39;00m\n        k_period \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_k\e[39m\e[38;2;64;112;160m\"\e[39m]\n        d_period \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_d\e[39m\e[38;2;64;112;160m\"\e[39m]\n\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing required columns for Stochastic Oscillator calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mDataFrame()\n\n        highest_high \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmax\e[39m\e[38;2;64;112;160m'\e[39m, k_period)\n        lowest_low \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmin\e[39m\e[38;2;64;112;160m'\e[39m, k_period)\n\n        \e[38;2;96;160;176;03m# Calculate %K\e[39;00m\n        k_line \e[38;2;102;102;102m=\e[39m (\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m] \e[38;2;102;102;102m-\e[39m lowest_low) \e[38;2;102;102;102m/\e[39m (highest_high \e[38;2;102;102;102m-\e[39m lowest_low) \e[38;2;102;102;102m*\e[39m \e[38;2;64;160;112m100\e[39m\n        k_line \e[38;2;102;102;102m=\e[39m k_line\e[38;2;102;102;102m.\e[39mreplace([np\e[38;2;102;102;102m.\e[39minf, \e[38;2;102;102;102m-\e[39mnp\e[38;2;102;102;102m.\e[39minf], np\e[38;2;102;102;102m.\e[39mnan)\e[38;2;102;102;102m.\e[39mfillna(\e[38;2;64;160;112m0\e[39m)  \e[38;2;96;160;176;03m# Handle division by zero\e[39;00m\n\n        \e[38;2;96;160;176;03m# Calculate %D (SMA of %K)\e[39;00m\n        d_line \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msma\e[39m\e[38;2;64;112;160m'\e[39m, d_period, k_line)\n\n        \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mDataFrame({\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mk\e[39m\e[38;2;64;112;160m'\e[39m: k_line, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160md\e[39m\e[38;2;64;112;160m'\e[39m: d_line})\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_momentum_ma\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32;01mNone\e[39;00m:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates momentum and its moving averages, and volume moving average.\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m or \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m column for Momentum MA calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m\n\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_momentum(period\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_period\e[39m\e[38;2;64;112;160m\"\e[39m])  \e[38;2;96;160;176;03m# Use the momentum function\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_short\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_sma(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_short\e[39m\e[38;2;64;112;160m\"\e[39m], series\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m])\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_long\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_sma(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_long\e[39m\e[38;2;64;112;160m\"\e[39m], series\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m])\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_ma\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_sma(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_ma_period\e[39m\e[38;2;64;112;160m\"\e[39m], series\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m])\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_macd\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mDataFrame:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates Moving Average Convergence Divergence (MACD).\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m column for MACD calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mDataFrame()\n\n        ma_short \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(\e[38;2;64;160;112m12\e[39m)\n        ma_long \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(\e[38;2;64;160;112m26\e[39m)\n        macd \e[38;2;102;102;102m=\e[39m ma_short \e[38;2;102;102;102m-\e[39m ma_long\n        signal \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(\e[38;2;64;160;112m9\e[39m, series\e[38;2;102;102;102m=\e[39mmacd)\n        histogram \e[38;2;102;102;102m=\e[39m macd \e[38;2;102;102;102m-\e[39m signal\n        \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mDataFrame({\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmacd\e[39m\e[38;2;64;112;160m'\e[39m: macd, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160msignal\e[39m\e[38;2;64;112;160m'\e[39m: signal, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhistogram\e[39m\e[38;2;64;112;160m'\e[39m: histogram})\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mdetect_macd_divergence\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Union[\e[38;2;0;112;32mstr\e[39m, \e[38;2;0;112;32;01mNone\e[39;00m]:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Detects bullish or bearish MACD divergence.\"\"\"\e[39;00m\n        macd_df \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_macd()\n        \e[38;2;0;112;32;01mif\e[39;00m macd_df\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf) \e[38;2;102;102;102m<\e[39m \e[38;2;64;160;112m30\e[39m:  \e[38;2;96;160;176;03m# Need sufficient data for reliable divergence\e[39;00m\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n\n        prices \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\n        macd_histogram \e[38;2;102;102;102m=\e[39m macd_df[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhistogram\e[39m\e[38;2;64;112;160m\"\e[39m]\n\n        \e[38;2;96;160;176;03m# Simple divergence check on last two bars (can be expanded for more robust detection)\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m (prices\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m] \e[38;2;102;102;102m>\e[39m prices\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m] \e[38;2;0;112;32;01mand\e[39;00m macd_histogram\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m] \e[38;2;102;102;102m<\e[39m macd_histogram\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39minfo(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_GREEN\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mDetected Bullish MACD Divergence.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mbullish\e[39m\e[38;2;64;112;160m\"\e[39m\n        \e[38;2;0;112;32;01melif\e[39;00m (prices\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m] \e[38;2;102;102;102m<\e[39m prices\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m] \e[38;2;0;112;32;01mand\e[39;00m macd_histogram\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m] \e[38;2;102;102;102m>\e[39m macd_histogram\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39minfo(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mDetected Bearish MACD Divergence.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mbearish\e[39m\e[38;2;64;112;160m\"\e[39m\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126mdetermine_trend_momentum\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Dict[\e[38;2;0;112;32mstr\e[39m, Union[\e[38;2;0;112;32mstr\e[39m, \e[38;2;0;112;32mfloat\e[39m]]:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Determines the current trend and its strength based on momentum MAs and ATR.\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf) \e[38;2;102;102;102m<\e[39m \e[38;2;0;112;32mmax\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_long\e[39m\e[38;2;64;112;160m\"\e[39m], \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr_period\e[39m\e[38;2;64;112;160m\"\e[39m]):\n            \e[38;2;0;112;32;01mreturn\e[39;00m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtrend\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mInsufficient Data\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstrength\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.0\e[39m}\n\n        \e[38;2;96;160;176;03m# Ensure momentum_ma_short, momentum_ma_long, and atr_value are calculated\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_short\e[39m\e[38;2;64;112;160m\"\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_long\e[39m\e[38;2;64;112;160m\"\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value \e[38;2;102;102;102m==\e[39m \e[38;2;64;160;112m0\e[39m:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMomentum MAs or ATR not available for trend calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtrend\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mNeutral\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstrength\e[39m\e[38;2;64;112;160m\"\e[39m: \e[38;2;64;160;112m0.0\e[39m}\n\n        latest_short_ma \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_short\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\n        latest_long_ma \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum_ma_long\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\n\n        trend \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mNeutral\e[39m\e[38;2;64;112;160m\"\e[39m\n        \e[38;2;0;112;32;01mif\e[39;00m latest_short_ma \e[38;2;102;102;102m>\e[39m latest_long_ma:\n            trend \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mUptrend\e[39m\e[38;2;64;112;160m\"\e[39m\n        \e[38;2;0;112;32;01melif\e[39;00m latest_short_ma \e[38;2;102;102;102m<\e[39m latest_long_ma:\n            trend \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mDowntrend\e[39m\e[38;2;64;112;160m\"\e[39m\n\n        \e[38;2;96;160;176;03m# Strength is normalized by ATR to make it comparable across symbols/timeframes\e[39;00m\n        strength \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mabs\e[39m(latest_short_ma \e[38;2;102;102;102m-\e[39m latest_long_ma) \e[38;2;102;102;102m/\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value\n        \e[38;2;0;112;32;01mreturn\e[39;00m {\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtrend\e[39m\e[38;2;64;112;160m\"\e[39m: trend, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstrength\e[39m\e[38;2;64;112;160m\"\e[39m: strength}\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_adx\e[39m(\e[38;2;0;112;32mself\e[39m, window: \e[38;2;0;112;32mint\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m14\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mfloat\e[39m:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates the Average Directional Index (ADX).\"\"\"\e[39;00m\n        df_adx \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcopy()\n        required_columns \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m]\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mall\e[39m(col \e[38;2;0;112;32;01min\e[39;00m df_adx\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mfor\e[39;00m col \e[38;2;0;112;32;01min\e[39;00m required_columns):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing required columns for ADX calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;64;160;112m0.0\e[39m\n\n        \e[38;2;96;160;176;03m# True Range\e[39;00m\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mTR\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mconcat([\n            df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m],\n            \e[38;2;0;112;32mabs\e[39m(df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift()),\n            \e[38;2;0;112;32mabs\e[39m(df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift())\n        ], axis\e[38;2;102;102;102m=\e[39m\e[38;2;64;160;112m1\e[39m)\e[38;2;102;102;102m.\e[39mmax(axis\e[38;2;102;102;102m=\e[39m\e[38;2;64;160;112m1\e[39m)\n\n        \e[38;2;96;160;176;03m# Directional Movement\e[39;00m\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m+DM\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m np\e[38;2;102;102;102m.\e[39mwhere((df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift()) \e[38;2;102;102;102m>\e[39m (df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift() \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]),\n                                 np\e[38;2;102;102;102m.\e[39mmaximum(df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift(), \e[38;2;64;160;112m0\e[39m), \e[38;2;64;160;112m0\e[39m)\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m-DM\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m np\e[38;2;102;102;102m.\e[39mwhere((df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift() \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]) \e[38;2;102;102;102m>\e[39m (df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift()),\n                                 np\e[38;2;102;102;102m.\e[39mmaximum(df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mshift() \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m], \e[38;2;64;160;112m0\e[39m), \e[38;2;64;160;112m0\e[39m)\n\n        \e[38;2;96;160;176;03m# Smoothed True Range and Directional Movement (using EMA)\e[39;00m\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mTR_ema\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(window, series\e[38;2;102;102;102m=\e[39mdf_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mTR\e[39m\e[38;2;64;112;160m\"\e[39m])\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m+DM_ema\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(window, series\e[38;2;102;102;102m=\e[39mdf_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m+DM\e[39m\e[38;2;64;112;160m\"\e[39m])\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m-DM_ema\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(window, series\e[38;2;102;102;102m=\e[39mdf_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m-DM\e[39m\e[38;2;64;112;160m\"\e[39m])\n\n        \e[38;2;96;160;176;03m# Directional Indicators\e[39;00m\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m+DI\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m100\e[39m \e[38;2;102;102;102m*\e[39m (df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m+DM_ema\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m/\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mTR_ema\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mreplace(\e[38;2;64;160;112m0\e[39m, np\e[38;2;102;102;102m.\e[39mnan))\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m-DI\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m100\e[39m \e[38;2;102;102;102m*\e[39m (df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m-DM_ema\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m/\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mTR_ema\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mreplace(\e[38;2;64;160;112m0\e[39m, np\e[38;2;102;102;102m.\e[39mnan))\n\n        \e[38;2;96;160;176;03m# Directional Movement Index (DX)\e[39;00m\n        df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mDX\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m100\e[39m \e[38;2;102;102;102m*\e[39m \e[38;2;0;112;32mabs\e[39m(df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m+DI\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m-DI\e[39m\e[38;2;64;112;160m\"\e[39m]) \e[38;2;102;102;102m/\e[39m (df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m+DI\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m+\e[39m df_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m-DI\e[39m\e[38;2;64;112;160m\"\e[39m])\e[38;2;102;102;102m.\e[39mreplace(\e[38;2;64;160;112m0\e[39m, np\e[38;2;102;102;102m.\e[39mnan)\n\n        \e[38;2;96;160;176;03m# Average Directional Index (ADX)\e[39;00m\n        adx_value \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(window, series\e[38;2;102;102;102m=\e[39mdf_adx[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mDX\e[39m\e[38;2;64;112;160m\"\e[39m])\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\n        \e[38;2;0;112;32;01mreturn\e[39;00m adx_value \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m pd\e[38;2;102;102;102m.\e[39misna(adx_value) \e[38;2;0;112;32;01melse\e[39;00m \e[38;2;64;160;112m0.0\e[39m\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_obv\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates On-Balance Volume (OBV).\"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m or \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m column for OBV calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        obv \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mSeries(\e[38;2;64;160;112m0\e[39m, index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex, dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n        obv\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m0\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m0\e[39m]  \e[38;2;96;160;176;03m# Initialize with first volume\e[39;00m\n\n        \e[38;2;0;112;32;01mfor\e[39;00m i \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mrange\e[39m(\e[38;2;64;160;112m1\e[39m, \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf)):\n            \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m]:\n                obv\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m obv\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m] \e[38;2;102;102;102m+\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i]\n            \e[38;2;0;112;32;01melif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m<\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m]:\n                obv\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m obv\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m] \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i]\n            \e[38;2;0;112;32;01melse\e[39;00m:\n                obv\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m obv\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m]  \e[38;2;96;160;176;03m# No change if close price is the same\e[39;00m\n\n        \e[38;2;0;112;32;01mreturn\e[39;00m obv\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_adi\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates Accumulation/Distribution Index (ADI).\"\"\"\e[39;00m\n        required_columns \e[38;2;102;102;102m=\e[39m [\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m]\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mall\e[39m(col \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mfor\e[39;00m col \e[38;2;0;112;32;01min\e[39;00m required_columns):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing required columns for ADI calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        \e[38;2;96;160;176;03m# Money Flow Multiplier (MFM)\e[39;00m\n        mfm_denominator \e[38;2;102;102;102m=\e[39m (\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m])\n        mfm \e[38;2;102;102;102m=\e[39m ((\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]) \e[38;2;102;102;102m-\e[39m (\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m-\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m])) \e[38;2;102;102;102m/\e[39m mfm_denominator\e[38;2;102;102;102m.\e[39mreplace(\e[38;2;64;160;112m0\e[39m, np\e[38;2;102;102;102m.\e[39mnan)\n        mfm\e[38;2;102;102;102m.\e[39mfillna(\e[38;2;64;160;112m0\e[39m, inplace\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32;01mTrue\e[39;00m)  \e[38;2;96;160;176;03m# If high == low, MFM is 0\e[39;00m\n\n        \e[38;2;96;160;176;03m# Money Flow Volume (MFV)\e[39;00m\n        money_flow_volume \e[38;2;102;102;102m=\e[39m mfm \e[38;2;102;102;102m*\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m]\n\n        \e[38;2;96;160;176;03m# Accumulation/Distribution Line (ADL) is the cumulative sum of MFV\e[39;00m\n        \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_safe_series_operation(\e[38;2;0;112;32;01mNone\e[39;00m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mcumsum\e[39m\e[38;2;64;112;160m'\e[39m, series\e[38;2;102;102;102m=\e[39mmoney_flow_volume)\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_psar\e[39m(\e[38;2;0;112;32mself\e[39m, acceleration: \e[38;2;0;112;32mfloat\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0.02\e[39m, max_acceleration: \e[38;2;0;112;32mfloat\e[39m \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0.2\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"Calculates Parabolic SAR (PSAR).\"\"\"\e[39;00m\n        psar \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mSeries(index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex, dtype\e[38;2;102;102;102m=\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfloat64\e[39m\e[38;2;64;112;160m\"\e[39m)\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf) \e[38;2;102;102;102m<\e[39m \e[38;2;64;160;112m2\e[39m:  \e[38;2;96;160;176;03m# Need at least two bars to start\e[39;00m\n            \e[38;2;0;112;32;01mreturn\e[39;00m psar\n\n        \e[38;2;96;160;176;03m# Initial values\e[39;00m\n        psar\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m0\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m0\e[39m]  \e[38;2;96;160;176;03m# Start PSAR at first close\e[39;00m\n        \e[38;2;96;160;176;03m# Determine initial trend based on first two bars\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m1\e[39m] \e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m0\e[39m]:\n            trend \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m1\e[39m  \e[38;2;96;160;176;03m# Uptrend\e[39;00m\n            ep \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m0\e[39m]  \e[38;2;96;160;176;03m# Extreme Point\e[39;00m\n        \e[38;2;0;112;32;01melse\e[39;00m:\n            trend \e[38;2;102;102;102m=\e[39m \e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m  \e[38;2;96;160;176;03m# Downtrend\e[39;00m\n            ep \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;64;160;112m0\e[39m]  \e[38;2;96;160;176;03m# Extreme Point\e[39;00m\n        af \e[38;2;102;102;102m=\e[39m acceleration  \e[38;2;96;160;176;03m# Acceleration Factor\e[39;00m\n\n        \e[38;2;0;112;32;01mfor\e[39;00m i \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mrange\e[39m(\e[38;2;64;160;112m1\e[39m, \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf)):\n            current_high \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i]\n            current_low \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i]\n            prev_psar \e[38;2;102;102;102m=\e[39m psar\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m]\n\n            \e[38;2;0;112;32;01mif\e[39;00m trend \e[38;2;102;102;102m==\e[39m \e[38;2;64;160;112m1\e[39m:  \e[38;2;96;160;176;03m# Uptrend\e[39;00m\n                psar\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m prev_psar \e[38;2;102;102;102m+\e[39m af \e[38;2;102;102;102m*\e[39m (ep \e[38;2;102;102;102m-\e[39m prev_psar)\n                \e[38;2;96;160;176;03m# Check if PSAR should be below current low\e[39;00m\n                psar\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mmin\e[39m(psar\e[38;2;102;102;102m.\e[39miloc[i], current_low, \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m] \e[38;2;0;112;32;01mif\e[39;00m i \e[38;2;102;102;102m>\e[39m \e[38;2;64;160;112m1\e[39m \e[38;2;0;112;32;01melse\e[39;00m current_low)\n                \e[38;2;0;112;32;01mif\e[39;00m current_high \e[38;2;102;102;102m>\e[39m ep:  \e[38;2;96;160;176;03m# New extreme high\e[39;00m\n                    ep \e[38;2;102;102;102m=\e[39m current_high\n                    af \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mmin\e[39m(af \e[38;2;102;102;102m+\e[39m acceleration, max_acceleration)\n                \e[38;2;0;112;32;01mif\e[39;00m current_low \e[38;2;102;102;102m<\e[39m psar\e[38;2;102;102;102m.\e[39miloc[i]:  \e[38;2;96;160;176;03m# Trend reversal\e[39;00m\n                    trend \e[38;2;102;102;102m=\e[39m \e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m\n                    psar\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m ep  \e[38;2;96;160;176;03m# PSAR jumps to old EP\e[39;00m\n                    ep \e[38;2;102;102;102m=\e[39m current_low\n                    af \e[38;2;102;102;102m=\e[39m acceleration\n            \e[38;2;0;112;32;01melif\e[39;00m trend \e[38;2;102;102;102m==\e[39m \e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m:  \e[38;2;96;160;176;03m# Downtrend\e[39;00m\n                psar\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m prev_psar \e[38;2;102;102;102m+\e[39m af \e[38;2;102;102;102m*\e[39m (ep \e[38;2;102;102;102m-\e[39m prev_psar)\n                \e[38;2;96;160;176;03m# Check if PSAR should be above current high\e[39;00m\n                psar\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mmax\e[39m(psar\e[38;2;102;102;102m.\e[39miloc[i], current_high, \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[i \e[38;2;102;102;102m-\e[39m \e[38;2;64;160;112m1\e[39m] \e[38;2;0;112;32;01mif\e[39;00m i \e[38;2;102;102;102m>\e[39m \e[38;2;64;160;112m1\e[39m \e[38;2;0;112;32;01melse\e[39;00m current_high)\n                \e[38;2;0;112;32;01mif\e[39;00m current_low \e[38;2;102;102;102m<\e[39m ep:  \e[38;2;96;160;176;03m# New extreme low\e[39;00m\n                    ep \e[38;2;102;102;102m=\e[39m current_low\n                    af \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mmin\e[39m(af \e[38;2;102;102;102m+\e[39m acceleration, max_acceleration)\n                \e[38;2;0;112;32;01mif\e[39;00m current_high \e[38;2;102;102;102m>\e[39m psar\e[38;2;102;102;102m.\e[39miloc[i]:  \e[38;2;96;160;176;03m# Trend reversal\e[39;00m\n                    trend \e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m1\e[39m\n                    psar\e[38;2;102;102;102m.\e[39miloc[i] \e[38;2;102;102;102m=\e[39m ep  \e[38;2;96;160;176;03m# PSAR jumps to old EP\e[39;00m\n                    ep \e[38;2;102;102;102m=\e[39m current_high\n                    af \e[38;2;102;102;102m=\e[39m acceleration\n        \e[38;2;0;112;32;01mreturn\e[39;00m psar\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_fve\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m pd\e[38;2;102;102;102m.\e[39mSeries:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        Calculates a \"Fictional Value Estimate\" (FVE) by combining price, volume, and volatility.\e[39;00m\n\e[38;2;64;112;160;03m        This is a custom composite indicator for demonstrative purposes.\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m or \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m column for FVE calculation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(dtype\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mfloat\e[39m)\n\n        \e[38;2;0;112;32;01mtry\e[39;00m:\n            \e[38;2;96;160;176;03m# Ensure enough data for calculations\e[39;00m\n            min_data_points \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mmax\e[39m(\e[38;2;64;160;112m20\e[39m, \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr_period\e[39m\e[38;2;64;112;160m\"\e[39m])\n            \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf) \e[38;2;102;102;102m<\e[39m min_data_points:\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mInsufficient data for FVE calculation. Need at least \e[39m\e[38;2;112;160;208;03m{\e[39;00mmin_data_points\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m bars.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                \e[38;2;96;160;176;03m# Return a series of NaNs matching the DataFrame length if data is insufficient\e[39;00m\n                \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries([np\e[38;2;102;102;102m.\e[39mnan] \e[38;2;102;102;102m*\e[39m \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf), index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex)\n\n            \e[38;2;96;160;176;03m# Components calculation, ensuring Decimal usage where appropriate\e[39;00m\n            \e[38;2;96;160;176;03m# Use Decimal for price-related calculations\e[39;00m\n            price_component \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve_price_ema\e[39m\e[38;2;64;112;160m\"\e[39m])  \e[38;2;96;160;176;03m# Short term price trend\e[39;00m\n            obv_component \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_obv()\n            atr_component \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_atr(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160matr\e[39m\e[38;2;64;112;160m\"\e[39m])\n\n            \e[38;2;96;160;176;03m# Convert components to Decimal for calculations if they are not already\e[39;00m\n            \e[38;2;96;160;176;03m# This is crucial to avoid numpy.float64 issues with Decimal operations\e[39;00m\n            price_component_dec \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mSeries([Decimal(\e[38;2;0;112;32mstr\e[39m(x)) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(x) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m) \e[38;2;0;112;32;01mfor\e[39;00m x \e[38;2;0;112;32;01min\e[39;00m price_component], index\e[38;2;102;102;102m=\e[39mprice_component\e[38;2;102;102;102m.\e[39mindex)\n            obv_component_dec \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mSeries([Decimal(\e[38;2;0;112;32mstr\e[39m(x)) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(x) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m) \e[38;2;0;112;32;01mfor\e[39;00m x \e[38;2;0;112;32;01min\e[39;00m obv_component], index\e[38;2;102;102;102m=\e[39mobv_component\e[38;2;102;102;102m.\e[39mindex)\n            atr_component_dec \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mSeries([Decimal(\e[38;2;0;112;32mstr\e[39m(x)) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(x) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m) \e[38;2;0;112;32;01mfor\e[39;00m x \e[38;2;0;112;32;01min\e[39;00m atr_component], index\e[38;2;102;102;102m=\e[39matr_component\e[38;2;102;102;102m.\e[39mindex)\n\n            \e[38;2;96;160;176;03m# Normalize components to prevent one from dominating excessively\e[39;00m\n            \e[38;2;96;160;176;03m# Use Decimal for mean and std calculation to maintain precision\e[39;00m\n            price_mean \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(price_component_dec\e[38;2;102;102;102m.\e[39mmean())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(price_component_dec\e[38;2;102;102;102m.\e[39mmean()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n            price_std \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(price_component_dec\e[38;2;102;102;102m.\e[39mstd())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(price_component_dec\e[38;2;102;102;102m.\e[39mstd()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n            obv_mean \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(obv_component_dec\e[38;2;102;102;102m.\e[39mmean())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(obv_component_dec\e[38;2;102;102;102m.\e[39mmean()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n            obv_std \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(obv_component_dec\e[38;2;102;102;102m.\e[39mstd())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(obv_component_dec\e[38;2;102;102;102m.\e[39mstd()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n            atr_mean \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(atr_component_dec\e[38;2;102;102;102m.\e[39mmean())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(atr_component_dec\e[38;2;102;102;102m.\e[39mmean()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n            atr_std \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(atr_component_dec\e[38;2;102;102;102m.\e[39mstd())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(atr_component_dec\e[38;2;102;102;102m.\e[39mstd()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n\n            \e[38;2;96;160;176;03m# Handle potential division by zero for std dev\e[39;00m\n            price_norm \e[38;2;102;102;102m=\e[39m (price_component_dec \e[38;2;102;102;102m-\e[39m price_mean) \e[38;2;102;102;102m/\e[39m price_std \e[38;2;0;112;32;01mif\e[39;00m price_std \e[38;2;102;102;102m!=\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01melse\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0\e[39m\e[38;2;64;112;160m'\e[39m), index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex)\n            obv_norm \e[38;2;102;102;102m=\e[39m (obv_component_dec \e[38;2;102;102;102m-\e[39m obv_mean) \e[38;2;102;102;102m/\e[39m obv_std \e[38;2;0;112;32;01mif\e[39;00m obv_std \e[38;2;102;102;102m!=\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01melse\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0\e[39m\e[38;2;64;112;160m'\e[39m), index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex)\n\n            \e[38;2;96;160;176;03m# Inverse of ATR: lower ATR means higher stability/less volatility, which can be seen as positive for trend following\e[39;00m\n            \e[38;2;96;160;176;03m# Use Decimal for division, and handle potential division by zero for ATR\e[39;00m\n            \e[38;2;96;160;176;03m# Calculate inverse ATR, handling division by zero safely\e[39;00m\n            atr_inverse \e[38;2;102;102;102m=\e[39m pd\e[38;2;102;102;102m.\e[39mSeries([Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m1.0\e[39m\e[38;2;64;112;160m'\e[39m) \e[38;2;102;102;102m/\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(x)) \e[38;2;0;112;32;01mif\e[39;00m x \e[38;2;0;112;32;01mand\e[39;00m x \e[38;2;102;102;102m!=\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m) \e[38;2;0;112;32;01mfor\e[39;00m x \e[38;2;0;112;32;01min\e[39;00m atr_component_dec], index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex)\n            \e[38;2;96;160;176;03m# Replace infinite values resulting from division by zero with NaN\e[39;00m\n            atr_inverse \e[38;2;102;102;102m=\e[39m atr_inverse\e[38;2;102;102;102m.\e[39mreplace([Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mInfinity\e[39m\e[38;2;64;112;160m'\e[39m), Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m-Infinity\e[39m\e[38;2;64;112;160m'\e[39m)], Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m))\n\n            atr_inverse_mean \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(atr_inverse\e[38;2;102;102;102m.\e[39mmean())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(atr_inverse\e[38;2;102;102;102m.\e[39mmean()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n            atr_inverse_std \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(atr_inverse\e[38;2;102;102;102m.\e[39mstd())) \e[38;2;0;112;32;01mif\e[39;00m pd\e[38;2;102;102;102m.\e[39mnotna(atr_inverse\e[38;2;102;102;102m.\e[39mstd()) \e[38;2;0;112;32;01melse\e[39;00m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m)\n\n            \e[38;2;96;160;176;03m# Normalize ATR inverse, handling potential zero std dev\e[39;00m\n            atr_inverse_norm \e[38;2;102;102;102m=\e[39m (atr_inverse \e[38;2;102;102;102m-\e[39m atr_inverse_mean) \e[38;2;102;102;102m/\e[39m atr_inverse_std \e[38;2;0;112;32;01mif\e[39;00m atr_inverse_std \e[38;2;102;102;102m!=\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01melse\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries(Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0\e[39m\e[38;2;64;112;160m'\e[39m), index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex)\n\n            \e[38;2;96;160;176;03m# Combine them - this formula is illustrative and should be fine-tuned\e[39;00m\n            \e[38;2;96;160;176;03m# Higher FVE indicates more \"value\" or bullishness.\e[39;00m\n            \e[38;2;96;160;176;03m# Ensure all components are aligned and handle NaNs\e[39;00m\n            fve \e[38;2;102;102;102m=\e[39m price_norm\e[38;2;102;102;102m.\e[39mfillna(Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0\e[39m\e[38;2;64;112;160m'\e[39m)) \e[38;2;102;102;102m+\e[39m obv_norm\e[38;2;102;102;102m.\e[39mfillna(Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0\e[39m\e[38;2;64;112;160m'\e[39m)) \e[38;2;102;102;102m+\e[39m atr_inverse_norm\e[38;2;102;102;102m.\e[39mfillna(Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m0\e[39m\e[38;2;64;112;160m'\e[39m))\n\n            \e[38;2;96;160;176;03m# Convert back to float Series for compatibility with later operations if needed\e[39;00m\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries([\e[38;2;0;112;32mfloat\e[39m(x) \e[38;2;0;112;32;01mif\e[39;00m x \e[38;2;102;102;102m!=\e[39m Decimal(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNaN\e[39m\e[38;2;64;112;160m'\e[39m) \e[38;2;0;112;32;01melse\e[39;00m np\e[38;2;102;102;102m.\e[39mnan \e[38;2;0;112;32;01mfor\e[39;00m x \e[38;2;0;112;32;01min\e[39;00m fve], index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex)\n\n        \e[38;2;0;112;32;01mexcept\e[39;00m \e[38;2;0;112;32mException\e[39m \e[38;2;0;112;32;01mas\e[39;00m e:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mError calculating FVE: \e[39m\e[38;2;112;160;208;03m{\e[39;00me\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;96;160;176;03m# Return a series of NaNs matching the DataFrame length in case of any error\e[39;00m\n            \e[38;2;0;112;32;01mreturn\e[39;00m pd\e[38;2;102;102;102m.\e[39mSeries([np\e[38;2;102;102;102m.\e[39mnan] \e[38;2;102;102;102m*\e[39m \e[38;2;0;112;32mlen\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf), index\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mindex)\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126m_calculate_volume_confirmation\e[39m(\e[38;2;0;112;32mself\e[39m) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m \e[38;2;0;112;32mbool\e[39m:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        Checks if the current volume confirms a trend (e.g., significant spike).\e[39;00m\n\e[38;2;64;112;160;03m        Returns True if current volume is significantly higher than average.\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume_ma\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf\e[38;2;102;102;102m.\e[39mcolumns:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39merror(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mMissing \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m or \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume_ma\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m column for Volume Confirmation.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mFalse\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_ma\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mempty:\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mFalse\e[39;00m\n\n        current_volume \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\n        average_volume \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume_ma\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\n\n        \e[38;2;0;112;32;01mif\e[39;00m average_volume \e[38;2;102;102;102m<\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m0\e[39m:  \e[38;2;96;160;176;03m# Avoid division by zero or nonsensical average\e[39;00m\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mFalse\e[39;00m\n\n        \e[38;2;0;112;32;01mreturn\e[39;00m current_volume \e[38;2;102;102;102m>\e[39m average_volume \e[38;2;102;102;102m*\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mvolume_confirmation_multiplier\e[39m\e[38;2;64;112;160m\"\e[39m]\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126manalyze_order_book_walls\e[39m(\e[38;2;0;112;32mself\e[39m, order_book: Dict[\e[38;2;0;112;32mstr\e[39m, Any]) \e[38;2;102;102;102m-\e[39m\e[38;2;102;102;102m>\e[39m Tuple[\e[38;2;0;112;32mbool\e[39m, \e[38;2;0;112;32mbool\e[39m, Dict[\e[38;2;0;112;32mstr\e[39m, Decimal], Dict[\e[38;2;0;112;32mstr\e[39m, Decimal]]:\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        Analyzes order book for significant bid (support) and ask (resistance) walls.\e[39;00m\n\e[38;2;64;112;160;03m        Returns whether bullish/bearish walls are found and the wall details.\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        has_bullish_wall \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mFalse\e[39;00m\n        has_bearish_wall \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mFalse\e[39;00m\n        bullish_wall_details: Dict[\e[38;2;0;112;32mstr\e[39m, Decimal] \e[38;2;102;102;102m=\e[39m {}\n        bearish_wall_details: Dict[\e[38;2;0;112;32mstr\e[39m, Decimal] \e[38;2;102;102;102m=\e[39m {}\n\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_analysis\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160menabled\e[39m\e[38;2;64;112;160m\"\e[39m]:\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mFalse\e[39;00m, \e[38;2;0;112;32;01mFalse\e[39;00m, {}, {}\n\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m order_book \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m order_book\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mbids\e[39m\e[38;2;64;112;160m'\e[39m) \e[38;2;0;112;32;01mor\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m order_book\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160masks\e[39m\e[38;2;64;112;160m'\e[39m):\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39mwarning(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_YELLOW\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mOrder book data incomplete for wall analysis.\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mFalse\e[39;00m, \e[38;2;0;112;32;01mFalse\e[39;00m, {}, {}\n\n        bids \e[38;2;102;102;102m=\e[39m [(Decimal(price), Decimal(qty)) \e[38;2;0;112;32;01mfor\e[39;00m price, qty \e[38;2;0;112;32;01min\e[39;00m order_book[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mbids\e[39m\e[38;2;64;112;160m'\e[39m][:\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_analysis\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mdepth_to_check\e[39m\e[38;2;64;112;160m\"\e[39m]]]\n        asks \e[38;2;102;102;102m=\e[39m [(Decimal(price), Decimal(qty)) \e[38;2;0;112;32;01mfor\e[39;00m price, qty \e[38;2;0;112;32;01min\e[39;00m order_book[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160masks\e[39m\e[38;2;64;112;160m'\e[39m][:\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_analysis\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mdepth_to_check\e[39m\e[38;2;64;112;160m\"\e[39m]]]\n\n        \e[38;2;96;160;176;03m# Calculate average quantity across relevant depth\e[39;00m\n        all_quantities \e[38;2;102;102;102m=\e[39m [qty \e[38;2;0;112;32;01mfor\e[39;00m _, qty \e[38;2;0;112;32;01min\e[39;00m bids \e[38;2;102;102;102m+\e[39m asks]\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m all_quantities:\n            \e[38;2;0;112;32;01mreturn\e[39;00m \e[38;2;0;112;32;01mFalse\e[39;00m, \e[38;2;0;112;32;01mFalse\e[39;00m, {}, {}\n\n        avg_qty \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(np\e[38;2;102;102;102m.\e[39mmean([\e[38;2;0;112;32mfloat\e[39m(q) \e[38;2;0;112;32;01mfor\e[39;00m q \e[38;2;0;112;32;01min\e[39;00m all_quantities])))  \e[38;2;96;160;176;03m# Convert to float for numpy, then back to Decimal\e[39;00m\n        wall_threshold \e[38;2;102;102;102m=\e[39m avg_qty \e[38;2;102;102;102m*\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_analysis\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwall_threshold_multiplier\e[39m\e[38;2;64;112;160m\"\e[39m]))\n\n        \e[38;2;96;160;176;03m# Check for bullish walls (large bids below current price)\e[39;00m\n        current_price \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]))\n        \e[38;2;0;112;32;01mfor\e[39;00m bid_price, bid_qty \e[38;2;0;112;32;01min\e[39;00m bids:\n            \e[38;2;0;112;32;01mif\e[39;00m bid_qty \e[38;2;102;102;102m>\e[39m\e[38;2;102;102;102m=\e[39m wall_threshold \e[38;2;0;112;32;01mand\e[39;00m bid_price \e[38;2;102;102;102m<\e[39m current_price:\n                has_bullish_wall \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mTrue\e[39;00m\n                bullish_wall_details[\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mBid@\e[39m\e[38;2;112;160;208;03m{\e[39;00mbid_price\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m bid_qty\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39minfo(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_GREEN\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mDetected Bullish Order Book Wall: Bid \e[39m\e[38;2;112;160;208;03m{\e[39;00mbid_qty\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m at \e[39m\e[38;2;112;160;208;03m{\e[39;00mbid_price\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                \e[38;2;0;112;32;01mbreak\e[39;00m  \e[38;2;96;160;176;03m# Only need to find one significant wall\e[39;00m\n\n        \e[38;2;96;160;176;03m# Check for bearish walls (large asks above current price)\e[39;00m\n        \e[38;2;0;112;32;01mfor\e[39;00m ask_price, ask_qty \e[38;2;0;112;32;01min\e[39;00m asks:\n            \e[38;2;0;112;32;01mif\e[39;00m ask_qty \e[38;2;102;102;102m>\e[39m\e[38;2;102;102;102m=\e[39m wall_threshold \e[38;2;0;112;32;01mand\e[39;00m ask_price \e[38;2;102;102;102m>\e[39m current_price:\n                has_bearish_wall \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32;01mTrue\e[39;00m\n                bearish_wall_details[\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mAsk@\e[39m\e[38;2;112;160;208;03m{\e[39;00mask_price\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m ask_qty\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger\e[38;2;102;102;102m.\e[39minfo(\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mDetected Bearish Order Book Wall: Ask \e[39m\e[38;2;112;160;208;03m{\e[39;00mask_qty\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m at \e[39m\e[38;2;112;160;208;03m{\e[39;00mask_price\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m\"\e[39m)\n                \e[38;2;0;112;32;01mbreak\e[39;00m  \e[38;2;96;160;176;03m# Only need to find one significant wall\e[39;00m\n\n        \e[38;2;0;112;32;01mreturn\e[39;00m has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details\n\n    \e[38;2;0;112;32;01mdef\e[39;00m\e[38;2;187;187;187m \e[39m\e[38;2;6;40;126manalyze\e[39m(\e[38;2;0;112;32mself\e[39m, current_price: Decimal, timestamp: \e[38;2;0;112;32mstr\e[39m, order_book: Dict[\e[38;2;0;112;32mstr\e[39m, Any]):\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        Performs comprehensive analysis, calculates indicators, and logs the findings.\e[39;00m\n\e[38;2;64;112;160;03m        This method populates `self.indicator_values` and generates the output string.\e[39;00m\n\e[38;2;64;112;160;03m        It does NOT generate the final signal; that is done by `generate_trading_signal`.\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        \e[38;2;96;160;176;03m# Ensure Decimal type for price calculations\e[39;00m\n        current_price_dec \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(current_price))\n        high_dec \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mhigh\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mmax()))\n        low_dec \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mlow\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mmin()))\n        close_dec \e[38;2;102;102;102m=\e[39m Decimal(\e[38;2;0;112;32mstr\e[39m(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]))\n\n        \e[38;2;96;160;176;03m# Calculate Support/Resistance Levels\e[39;00m\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mcalculate_fibonacci_retracement(high_dec, low_dec, current_price_dec)\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mcalculate_pivot_points(high_dec, low_dec, close_dec)\n        nearest_supports, nearest_resistances \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mfind_nearest_levels(current_price_dec)\n\n        \e[38;2;96;160;176;03m# Calculate and store indicator values based on config\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mobv\e[39m\e[38;2;64;112;160m\"\e[39m):\n            obv_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_obv()\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mobv\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m obv_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m obv_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi\e[39m\e[38;2;64;112;160m\"\e[39m):\n            rsi_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_rsi(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi\e[39m\e[38;2;64;112;160m\"\e[39m])\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mrsi\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m rsi_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m rsi_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi\e[39m\e[38;2;64;112;160m\"\e[39m):\n            mfi_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_mfi(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi\e[39m\e[38;2;64;112;160m\"\e[39m])\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmfi\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m mfi_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m mfi_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcci\e[39m\e[38;2;64;112;160m\"\e[39m):\n            cci_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_cci(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcci\e[39m\e[38;2;64;112;160m\"\e[39m])\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mcci\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m cci_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m cci_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwr\e[39m\e[38;2;64;112;160m\"\e[39m):\n            wr_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_williams_r(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwilliams_r\e[39m\e[38;2;64;112;160m\"\e[39m])\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mwr\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m wr_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m wr_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madx\e[39m\e[38;2;64;112;160m\"\e[39m):\n            adx_value \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_adx(window\e[38;2;102;102;102m=\e[39m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicator_periods\e[39m\e[38;2;64;112;160m\"\e[39m][\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madx\e[39m\e[38;2;64;112;160m\"\e[39m])\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madx\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m [adx_value]  \e[38;2;96;160;176;03m# ADX is a single value\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madi\e[39m\e[38;2;64;112;160m\"\e[39m):\n            adi_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_adi()\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160madi\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m adi_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m adi_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmomentum\e[39m\e[38;2;64;112;160m\"\e[39m):\n            trend_data \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdetermine_trend_momentum()\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmom\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m trend_data  \e[38;2;96;160;176;03m# Store dict directly\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msma_10\e[39m\e[38;2;64;112;160m\"\e[39m):\n            sma_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_sma(\e[38;2;64;160;112m10\e[39m)\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msma_10\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m [sma_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]] \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m sma_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mpsar\e[39m\e[38;2;64;112;160m\"\e[39m):\n            psar_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_psar()\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mpsar\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m psar_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m psar_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve\e[39m\e[38;2;64;112;160m\"\e[39m):\n            fve_series \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_fve()\n            \e[38;2;96;160;176;03m# Ensure fve_series is not empty or all NaNs before processing\e[39;00m\n            \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m fve_series\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m fve_series\e[38;2;102;102;102m.\e[39misnull()\e[38;2;102;102;102m.\e[39mall():\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m fve_series\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mtolist()\n            \e[38;2;0;112;32;01melse\e[39;00m:\n                \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mfve\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m []  \e[38;2;96;160;176;03m# Ensure it's an empty list if calculation failed\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmacd\e[39m\e[38;2;64;112;160m\"\e[39m):\n            macd_df \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_macd()\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmacd\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m macd_df\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m:]\e[38;2;102;102;102m.\e[39mvalues\e[38;2;102;102;102m.\e[39mtolist() \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m macd_df\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01melse\e[39;00m []\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m\"\e[39m):\n            ema_alignment_score \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39m_calculate_ema_alignment()\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m ema_alignment_score  \e[38;2;96;160;176;03m# Store score directly\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mis\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mempty:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;102;102;102m.\e[39mtolist()  \e[38;2;96;160;176;03m# Store K, D, and Stoch RSI values\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstochastic_oscillator\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mis\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mempty:\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;102;102;102m.\e[39mtolist()  \e[38;2;96;160;176;03m# Store K and D values for Stochastic Oscillator\e[39;00m\n\n        \e[38;2;96;160;176;03m# Order Book Analysis\e[39;00m\n        has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details \e[38;2;102;102;102m=\e[39m \\\n            \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39manalyze_order_book_walls(order_book)\n        \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_walls\e[39m\e[38;2;64;112;160m\"\e[39m] \e[38;2;102;102;102m=\e[39m {\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mbullish\e[39m\e[38;2;64;112;160m\"\e[39m: has_bullish_wall, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mbearish\e[39m\e[38;2;64;112;160m\"\e[39m: has_bearish_wall,\n            \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mbullish_details\e[39m\e[38;2;64;112;160m\"\e[39m: bullish_wall_details, \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mbearish_details\e[39m\e[38;2;64;112;160m\"\e[39m: bearish_wall_details\n        }\n\n        \e[38;2;96;160;176;03m# Prepare output string\e[39;00m\n        output \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\"\"\e[39m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mExchange:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m Bybit\e[39m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mSymbol:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39msymbol\e[38;2;112;160;208;03m}\e[39;00m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mInterval:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39minterval\e[38;2;112;160;208;03m}\e[39;00m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mTimestamp:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00mtimestamp\e[38;2;112;160;208;03m}\e[39;00m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mPrice History:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m | \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m | \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mclose\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mVolume History:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m3\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m,.0f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m | \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m2\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m,.0f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m | \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mdf[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mvolume\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m,.0f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mCurrent Price:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00mcurrent_price_dec\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.5f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mATR (\e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160matr_period\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m):\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39matr_value\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.5f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\n\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mTrend:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmom\e[39m\e[38;2;64;112;160m\"\e[39m,\e[38;2;187;187;187m \e[39m{})\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mtrend\e[39m\e[38;2;64;112;160m\"\e[39m,\e[38;2;187;187;187m \e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mN/A\e[39m\e[38;2;64;112;160m\"\e[39m)\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m (Strength: \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mmom\e[39m\e[38;2;64;112;160m\"\e[39m,\e[38;2;187;187;187m \e[39m{})\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstrength\e[39m\e[38;2;64;112;160m\"\e[39m,\e[38;2;187;187;187m \e[39m\e[38;2;64;160;112m0.0\e[39m)\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m\"\"\"\e[39m\n        \e[38;2;96;160;176;03m# Append indicator interpretations\e[39;00m\n        \e[38;2;0;112;32;01mfor\e[39;00m indicator_name, values \e[38;2;0;112;32;01min\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mitems():\n            \e[38;2;96;160;176;03m# Skip indicators that are already logged in a custom format or are internal\e[39;00m\n            \e[38;2;0;112;32;01mif\e[39;00m indicator_name \e[38;2;0;112;32;01min\e[39;00m [\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mmom\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160matr\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160morder_book_walls\e[39m\e[38;2;64;112;160m'\e[39m, \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m'\e[39m]:\n                \e[38;2;0;112;32;01mcontinue\e[39;00m\n            interpreted_line \e[38;2;102;102;102m=\e[39m interpret_indicator(\e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mlogger, indicator_name, values)\n            \e[38;2;0;112;32;01mif\e[39;00m interpreted_line:\n                output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m interpreted_line \e[38;2;102;102;102m+\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n\n        \e[38;2;96;160;176;03m# Custom logging for specific indicators\e[39;00m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m\"\e[39m):\n            ema_alignment_score \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mema_alignment\e[39m\e[38;2;64;112;160m\"\e[39m, \e[38;2;64;160;112m0.0\e[39m)\n            status \e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mBullish\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mif\e[39;00m ema_alignment_score \e[38;2;102;102;102m>\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01melse\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mBearish\e[39m\e[38;2;64;112;160m'\e[39m \e[38;2;0;112;32;01mif\e[39;00m ema_alignment_score \e[38;2;102;102;102m<\e[39m \e[38;2;64;160;112m0\e[39m \e[38;2;0;112;32;01melse\e[39;00m \e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNeutral\e[39m\e[38;2;64;112;160m'\e[39m\n            output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_PURPLE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mEMA Alignment:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m Score=\e[39m\e[38;2;112;160;208;03m{\e[39;00mema_alignment_score\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m (\e[39m\e[38;2;112;160;208;03m{\e[39;00mstatus\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m)\e[39m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mis\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mempty:\n            stoch_rsi_vals \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_rsi_vals\e[39m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mif\e[39;00m stoch_rsi_vals \e[38;2;0;112;32;01mis\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m stoch_rsi_vals\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32mlen\e[39m(stoch_rsi_vals) \e[38;2;102;102;102m>\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m3\e[39m:  \e[38;2;96;160;176;03m# Ensure we have K, D, and Stoch RSI values\e[39;00m\n                output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_GREEN\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mStoch RSI:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m K=\e[39m\e[38;2;112;160;208;03m{\e[39;00mstoch_rsi_vals[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mk\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m, D=\e[39m\e[38;2;112;160;208;03m{\e[39;00mstoch_rsi_vals[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160md\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m, Stoch_RSI=\e[39m\e[38;2;112;160;208;03m{\e[39;00mstoch_rsi_vals[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mstoch_rsi\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mconfig[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mindicators\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstochastic_oscillator\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m\"\e[39m) \e[38;2;0;112;32;01mis\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values[\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m\"\e[39m]\e[38;2;102;102;102m.\e[39mempty:\n            stoch_osc_vals \e[38;2;102;102;102m=\e[39m \e[38;2;0;112;32mself\e[39m\e[38;2;102;102;102m.\e[39mindicator_values\e[38;2;102;102;102m.\e[39mget(\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mstoch_osc_vals\e[39m\e[38;2;64;112;160m\"\e[39m)\n            \e[38;2;0;112;32;01mif\e[39;00m stoch_osc_vals \e[38;2;0;112;32;01mis\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m \e[38;2;0;112;32;01mNone\e[39;00m \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m stoch_osc_vals\e[38;2;102;102;102m.\e[39mempty \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32mlen\e[39m(stoch_osc_vals) \e[38;2;102;102;102m>\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;160;112m2\e[39m:  \e[38;2;96;160;176;03m# Ensure we have K and D values\e[39;00m\n                output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_CYAN\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mStochastic Oscillator:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m K=\e[39m\e[38;2;112;160;208;03m{\e[39;00mstoch_osc_vals[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mk\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m, D=\e[39m\e[38;2;112;160;208;03m{\e[39;00mstoch_osc_vals[\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160md\e[39m\e[38;2;64;112;160m'\e[39m]\e[38;2;102;102;102m.\e[39miloc[\e[38;2;102;102;102m-\e[39m\e[38;2;64;160;112m1\e[39m]\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n\n        \e[38;2;96;160;176;03m# Order Book Wall Logging\e[39;00m\n        output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mNEON_BLUE\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160mOrder Book Walls:\e[39m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n        \e[38;2;0;112;32;01mif\e[39;00m has_bullish_wall:\n            output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_GREEN\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m  Bullish Walls Found: \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m, \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;102;102;102m.\e[39mjoin([\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;112;160;208;03m{\e[39;00mk\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m:\e[39m\e[38;2;112;160;208;03m{\e[39;00mv\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m'\e[39m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mfor\e[39;00m\e[38;2;187;187;187m \e[39mk,\e[38;2;187;187;187m \e[39mv\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01min\e[39;00m\e[38;2;187;187;187m \e[39mbullish_wall_details\e[38;2;102;102;102m.\e[39mitems()])\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n        \e[38;2;0;112;32;01mif\e[39;00m has_bearish_wall:\n            output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{\e[39;00mNEON_RED\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m  Bearish Walls Found: \e[39m\e[38;2;112;160;208;03m{\e[39;00m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m, \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;102;102;102m.\e[39mjoin([\e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;112;160;208;03m{\e[39;00mk\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m:\e[39m\e[38;2;112;160;208;03m{\e[39;00mv\e[38;2;112;160;208;03m:\e[39;00m\e[38;2;64;112;160m.2f\e[39m\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160m'\e[39m\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01mfor\e[39;00m\e[38;2;187;187;187m \e[39mk,\e[38;2;187;187;187m \e[39mv\e[38;2;187;187;187m \e[39m\e[38;2;0;112;32;01min\e[39;00m\e[38;2;187;187;187m \e[39mbearish_wall_details\e[38;2;102;102;102m.\e[39mitems()])\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;112;160;208;03m{\e[39;00mRESET\e[38;2;112;160;208;03m}\e[39;00m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n        \e[38;2;0;112;32;01mif\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m has_bullish_wall \e[38;2;0;112;32;01mand\e[39;00m \e[38;2;0;112;32;01mnot\e[39;00m has_bearish_wall:\n            output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m  No significant walls detected.\e[39m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;64;112;160m\"\e[39m\n\n        output \e[38;2;102;102;102m+\e[39m\e[38;2;102;102;102m=\e[39m \e[38;2;64;112;160mf\e[39m\e[38;2;64;112;160m\"\"\"\e[39m\e[38;2;64;112;160m\"\"\"\e[39m\n\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_BLUE}\e[39;00m\e[38;2;64;112;160mSupport and Resistance Levels:\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\n\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        for s_label, s_val in nearest_supports:\e[39;00m\n\e[38;2;64;112;160;03m            output += f\"S: {s_label} ${s_val:.5f}\\n\"\e[39;00m\n\e[38;2;64;112;160;03m        for r_label, r_val in nearest_resistances:\e[39;00m\n\e[38;2;64;112;160;03m            output += f\"R: {r_label} ${r_val:.5f}\\n\"\e[39;00m\n\n\e[38;2;64;112;160;03m        self.logger.info(output)\e[39;00m\n\n\e[38;2;64;112;160;03m    def generate_trading_signal(self, current_price: Decimal) -> Tuple[Union[str, None], float, List[str], Dict[str, Decimal]]:\e[39;00m\n\e[38;2;64;112;160;03m        \"\"\"\e[39;00m\n        Generates a trading signal (buy\e[38;2;102;102;102m/\e[39msell) based on indicator values \e[38;2;0;112;32;01mand\e[39;00m configuration\e[38;2;102;102;102m.\e[39m\n        Returns the signal, its confidence score, conditions met, \e[38;2;0;112;32;01mand\e[39;00m suggested SL\e[38;2;102;102;102m/\e[39mTP levels\e[38;2;102;102;102m.\e[39m\n\e[38;2;187;187;187m        \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m        signal_score = Decimal('0.0')\e[39;00m\n\e[38;2;64;112;160;03m        signal = None\e[39;00m\n\e[38;2;64;112;160;03m        conditions_met: List[str] = []\e[39;00m\n\e[38;2;64;112;160;03m        trade_levels: Dict[str, Decimal] = {}\e[39;00m\n\n\e[38;2;64;112;160;03m        # --- Bullish Signal Logic ---\e[39;00m\n\e[38;2;64;112;160;03m        # Sum weights of bullish conditions met\e[39;00m\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"stoch_rsi\") and not self.indicator_values[\"stoch_rsi_vals\"].empty:\e[39;00m\n\e[38;2;64;112;160;03m            stoch_rsi_k = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['k'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            stoch_rsi_d = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['d'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            if stoch_rsi_k < self.config[\"stoch_rsi_oversold_threshold\"] and stoch_rsi_k > stoch_rsi_d:\e[39;00m\n\e[38;2;64;112;160;03m                signal_score += Decimal(str(self.user_defined_weights[\"stoch_rsi\"]))\e[39;00m\n\e[38;2;64;112;160;03m                conditions_met.append(\"Stoch RSI Oversold Crossover\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"rsi\") and self.indicator_values.get(\"rsi\") and self.indicator_values[\"rsi\"][-1] < 30:\e[39;00m\n\e[38;2;64;112;160;03m            signal_score += Decimal(str(self.user_defined_weights[\"rsi\"]))\e[39;00m\n\e[38;2;64;112;160;03m            conditions_met.append(\"RSI Oversold\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"mfi\") and self.indicator_values.get(\"mfi\") and self.indicator_values[\"mfi\"][-1] < 20:\e[39;00m\n\e[38;2;64;112;160;03m            signal_score += Decimal(str(self.user_defined_weights[\"mfi\"]))\e[39;00m\n\e[38;2;64;112;160;03m            conditions_met.append(\"MFI Oversold\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"ema_alignment\") and self.indicator_values.get(\"ema_alignment\", 0.0) > 0:\e[39;00m\n\e[38;2;64;112;160;03m            signal_score += Decimal(str(self.user_defined_weights[\"ema_alignment\"])) * Decimal(str(abs(self.indicator_values[\"ema_alignment\"])))  # Scale by score\e[39;00m\n\e[38;2;64;112;160;03m            conditions_met.append(\"Bullish EMA Alignment\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"volume_confirmation\") and self._calculate_volume_confirmation():\e[39;00m\n\e[38;2;64;112;160;03m            signal_score += Decimal(str(self.user_defined_weights[\"volume_confirmation\"]))\e[39;00m\n\e[38;2;64;112;160;03m            conditions_met.append(\"Volume Confirmation\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"divergence\") and self.detect_macd_divergence() == \"bullish\":\e[39;00m\n\e[38;2;64;112;160;03m            signal_score += Decimal(str(self.user_defined_weights[\"divergence\"]))\e[39;00m\n\e[38;2;64;112;160;03m            conditions_met.append(\"Bullish MACD Divergence\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.indicator_values[\"order_book_walls\"].get(\"bullish\"):\e[39;00m\n\e[38;2;64;112;160;03m            signal_score += Decimal(str(self.config[\"order_book_support_confidence_boost\"] / 10.0))  # Boost score for order book wall\e[39;00m\n\e[38;2;64;112;160;03m            conditions_met.append(\"Bullish Order Book Wall\")\e[39;00m\n\n\e[38;2;64;112;160;03m        # --- New: Stochastic Oscillator Bullish Signal ---\e[39;00m\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"stochastic_oscillator\") and self.indicator_values.get(\"stoch_osc_vals\") is not None and not self.indicator_values[\"stoch_osc_vals\"].empty:\e[39;00m\n\e[38;2;64;112;160;03m            stoch_k = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['k'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            stoch_d = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['d'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            if stoch_k < 20 and stoch_k > stoch_d:  # Oversold and K crossing above D\e[39;00m\n\e[38;2;64;112;160;03m                signal_score += Decimal(str(self.user_defined_weights[\"stochastic_oscillator\"]))\e[39;00m\n\e[38;2;64;112;160;03m                conditions_met.append(\"Stoch Oscillator Oversold Crossover\")\e[39;00m\n\n\e[38;2;64;112;160;03m        # Final check for Bullish signal\e[39;00m\n\e[38;2;64;112;160;03m        if signal_score >= Decimal(str(self.config[\"signal_score_threshold\"])):\e[39;00m\n\e[38;2;64;112;160;03m            signal = \"buy\"\e[39;00m\n\e[38;2;64;112;160;03m            # Calculate Stop Loss and Take Profit\e[39;00m\n\e[38;2;64;112;160;03m            if self.atr_value > 0:\e[39;00m\n\e[38;2;64;112;160;03m                stop_loss = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"stop_loss_multiple\"])))\e[39;00m\n\e[38;2;64;112;160;03m                take_profit = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"take_profit_multiple\"])))\e[39;00m\n\e[38;2;64;112;160;03m                trade_levels[\"stop_loss\"] = stop_loss.quantize(Decimal('0.00001'))\e[39;00m\n\e[38;2;64;112;160;03m                trade_levels[\"take_profit\"] = take_profit.quantize(Decimal('0.00001'))\e[39;00m\n\n\e[38;2;64;112;160;03m        # --- Bearish Signal Logic (similar structure) ---\e[39;00m\n\e[38;2;64;112;160;03m        bearish_score = Decimal('0.0')\e[39;00m\n\e[38;2;64;112;160;03m        bearish_conditions: List[str] = []\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"stoch_rsi\") and not self.indicator_values[\"stoch_rsi_vals\"].empty:\e[39;00m\n\e[38;2;64;112;160;03m            stoch_rsi_k = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['k'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            stoch_rsi_d = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['d'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            if stoch_rsi_k > self.config[\"stoch_rsi_overbought_threshold\"] and stoch_rsi_k < stoch_rsi_d:\e[39;00m\n\e[38;2;64;112;160;03m                bearish_score += Decimal(str(self.user_defined_weights[\"stoch_rsi\"]))\e[39;00m\n\e[38;2;64;112;160;03m                bearish_conditions.append(\"Stoch RSI Overbought Crossover\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"rsi\") and self.indicator_values.get(\"rsi\") and self.indicator_values[\"rsi\"][-1] > 70:\e[39;00m\n\e[38;2;64;112;160;03m            bearish_score += Decimal(str(self.user_defined_weights[\"rsi\"]))\e[39;00m\n\e[38;2;64;112;160;03m            bearish_conditions.append(\"RSI Overbought\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"mfi\") and self.indicator_values.get(\"mfi\") and self.indicator_values[\"mfi\"][-1] > 80:\e[39;00m\n\e[38;2;64;112;160;03m            bearish_score += Decimal(str(self.user_defined_weights[\"mfi\"]))\e[39;00m\n\e[38;2;64;112;160;03m            bearish_conditions.append(\"MFI Overbought\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"ema_alignment\") and self.indicator_values.get(\"ema_alignment\", 0.0) < 0:\e[39;00m\n\e[38;2;64;112;160;03m            bearish_score += Decimal(str(self.user_defined_weights[\"ema_alignment\"])) * Decimal(str(abs(self.indicator_values[\"ema_alignment\"])))\e[39;00m\n\e[38;2;64;112;160;03m            bearish_conditions.append(\"Bearish EMA Alignment\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"divergence\") and self.detect_macd_divergence() == \"bearish\":\e[39;00m\n\e[38;2;64;112;160;03m            bearish_score += Decimal(str(self.user_defined_weights[\"divergence\"]))\e[39;00m\n\e[38;2;64;112;160;03m            bearish_conditions.append(\"Bearish MACD Divergence\")\e[39;00m\n\n\e[38;2;64;112;160;03m        if self.indicator_values[\"order_book_walls\"].get(\"bearish\"):\e[39;00m\n\e[38;2;64;112;160;03m            bearish_score += Decimal(str(self.config[\"order_book_resistance_confidence_boost\"] / 10.0))\e[39;00m\n\e[38;2;64;112;160;03m            bearish_conditions.append(\"Bearish Order Book Wall\")\e[39;00m\n\n\e[38;2;64;112;160;03m        # --- New: Stochastic Oscillator Bearish Signal ---\e[39;00m\n\e[38;2;64;112;160;03m        if self.config[\"indicators\"].get(\"stochastic_oscillator\") and self.indicator_values.get(\"stoch_osc_vals\") is not None and not self.indicator_values[\"stoch_osc_vals\"].empty:\e[39;00m\n\e[38;2;64;112;160;03m            stoch_k = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['k'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            stoch_d = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['d'].iloc[-1]))\e[39;00m\n\e[38;2;64;112;160;03m            if stoch_k > 80 and stoch_k < stoch_d:  # Overbought and K crossing below D\e[39;00m\n\e[38;2;64;112;160;03m                bearish_score += Decimal(str(self.user_defined_weights[\"stochastic_oscillator\"]))\e[39;00m\n\e[38;2;64;112;160;03m                bearish_conditions.append(\"Stoch Oscillator Overbought Crossover\")\e[39;00m\n\n\e[38;2;64;112;160;03m        # Final check for Bearish signal (only if no bullish signal already)\e[39;00m\n\e[38;2;64;112;160;03m        if signal is None and bearish_score >= Decimal(str(self.config[\"signal_score_threshold\"])):\e[39;00m\n\e[38;2;64;112;160;03m            signal = \"sell\"\e[39;00m\n\e[38;2;64;112;160;03m            signal_score = bearish_score  # Use bearish score if it's the chosen signal\e[39;00m\n\e[38;2;64;112;160;03m            conditions_met = bearish_conditions  # Use bearish conditions\e[39;00m\n\e[38;2;64;112;160;03m            # Calculate Stop Loss and Take Profit for sell signal\e[39;00m\n\e[38;2;64;112;160;03m            if self.atr_value > 0:\e[39;00m\n\e[38;2;64;112;160;03m                stop_loss = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"stop_loss_multiple\"])))\e[39;00m\n\e[38;2;64;112;160;03m                take_profit = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"take_profit_multiple\"])))\e[39;00m\n\e[38;2;64;112;160;03m                trade_levels[\"stop_loss\"] = stop_loss.quantize(Decimal('0.00001'))\e[39;00m\n\e[38;2;64;112;160;03m                trade_levels[\"take_profit\"] = take_profit.quantize(Decimal('0.00001'))\e[39;00m\n\n\e[38;2;64;112;160;03m        return signal, float(signal_score), conditions_met, trade_levels\e[39;00m\n\n\n\e[38;2;64;112;160;03mdef interpret_indicator(logger: logging.Logger, indicator_name: str, values: Union[List[float], float, Dict[str, Any]]) -> Union[str, None]:\e[39;00m\n\e[38;2;64;112;160;03m    \"\"\"\e[39;00m\n    Provides a human\e[38;2;102;102;102m-\e[39mreadable interpretation of indicator values\e[38;2;102;102;102m.\e[39m\n\e[38;2;187;187;187m    \e[39m\e[38;2;64;112;160;03m\"\"\"\e[39;00m\n\e[38;2;64;112;160;03m    if values is None or (isinstance(values, list) and not values) or (isinstance(values, pd.DataFrame) and values.empty):\e[39;00m\n\e[38;2;64;112;160;03m        return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No data available.\"\e[39;00m\n\e[38;2;64;112;160;03m    try:\e[39;00m\n\e[38;2;64;112;160;03m        # Convert single float values to list for consistent indexing if needed\e[39;00m\n\e[38;2;64;112;160;03m        if isinstance(values, (float, int)):\e[39;00m\n\e[38;2;64;112;160;03m            values = [values]\e[39;00m\n\e[38;2;64;112;160;03m        elif isinstance(values, dict):  # For 'mom' which is a dict\e[39;00m\n\e[38;2;64;112;160;03m            if indicator_name == \"mom\":\e[39;00m\n\e[38;2;64;112;160;03m                trend = values.get(\"trend\", \"N/A\")\e[39;00m\n\e[38;2;64;112;160;03m                strength = values.get(\"strength\", 0.0)\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_PURPLE}Momentum Trend:{RESET} {trend} (Strength: {strength:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} Dictionary format not specifically interpreted.\"\e[39;00m\n\e[38;2;64;112;160;03m        elif isinstance(values, pd.DataFrame):  # For stoch_rsi_vals which is a DataFrame\e[39;00m\n\e[38;2;64;112;160;03m            if indicator_name == \"stoch_rsi_vals\":\e[39;00m\n\e[38;2;64;112;160;03m                # Stoch RSI interpretation is handled directly in analyze function\e[39;00m\n\e[38;2;64;112;160;03m                return None\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} DataFrame format not specifically interpreted.\"\e[39;00m\n\n\e[38;2;64;112;160;03m        # Interpret based on indicator name\e[39;00m\n\e[38;2;64;112;160;03m        last_value = values[-1] if isinstance(values, list) and values else values[0] if isinstance(values, list) else values  # Handles single value lists too\e[39;00m\n\n\e[38;2;64;112;160;03m        if indicator_name == \"rsi\":\e[39;00m\n\e[38;2;64;112;160;03m            if last_value > 70:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_RED}RSI:{RESET} Overbought ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            elif last_value < 30:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_GREEN}RSI:{RESET} Oversold ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_YELLOW}RSI:{RESET} Neutral ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"mfi\":\e[39;00m\n\e[38;2;64;112;160;03m            if last_value > 80:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_RED}MFI:{RESET} Overbought ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            elif last_value < 20:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_GREEN}MFI:{RESET} Oversold ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_YELLOW}MFI:{RESET} Neutral ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"cci\":\e[39;00m\n\e[38;2;64;112;160;03m            if last_value > 100:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_RED}CCI:{RESET} Overbought ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            elif last_value < -100:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_GREEN}CCI:{RESET} Oversold ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_YELLOW}CCI:{RESET} Neutral ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"wr\":\e[39;00m\n\e[38;2;64;112;160;03m            if last_value < -80:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_GREEN}Williams %R:{RESET} Oversold ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            elif last_value > -20:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_RED}Williams %R:{RESET} Overbought ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_YELLOW}Williams %R:{RESET} Neutral ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"adx\":\e[39;00m\n\e[38;2;64;112;160;03m            if last_value > 25:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_GREEN}ADX:{RESET} Trending ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_YELLOW}ADX:{RESET} Ranging ({last_value:.2f})\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"obv\":\e[39;00m\n\e[38;2;64;112;160;03m            if len(values) >= 2:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_BLUE}OBV:{RESET} {'Bullish' if values[-1] > values[-2] else 'Bearish' if values[-1] < values[-2] else 'Neutral'}\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_BLUE}OBV:{RESET} {last_value:.2f} (Insufficient history for trend)\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"adi\":\e[39;00m\n\e[38;2;64;112;160;03m            if len(values) >= 2:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_BLUE}ADI:{RESET} {'Accumulation' if values[-1] > values[-2] else 'Distribution' if values[-1] < values[-2] else 'Neutral'}\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_BLUE}ADI:{RESET} {last_value:.2f} (Insufficient history for trend)\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"sma_10\":\e[39;00m\n\e[38;2;64;112;160;03m            return f\"{NEON_YELLOW}SMA (10):{RESET} {last_value:.2f}\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"psar\":\e[39;00m\n\e[38;2;64;112;160;03m            return f\"{NEON_BLUE}PSAR:{RESET} {last_value:.4f} (Last Value)\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"fve\":\e[39;00m\n\e[38;2;64;112;160;03m            return f\"{NEON_BLUE}FVE:{RESET} {last_value:.2f} (Last Value)\"\e[39;00m\n\e[38;2;64;112;160;03m        elif indicator_name == \"macd\":\e[39;00m\n\e[38;2;64;112;160;03m            # values for MACD are [macd_line, signal_line, histogram]\e[39;00m\n\e[38;2;64;112;160;03m            if len(values[-1]) == 3:\e[39;00m\n\e[38;2;64;112;160;03m                macd_line, signal_line, histogram = values[-1][0], values[-1][1], values[-1][2]\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_GREEN}MACD:{RESET} MACD={macd_line:.2f}, Signal={signal_line:.2f}, Histogram={histogram:.2f}\"\e[39;00m\n\e[38;2;64;112;160;03m            else:\e[39;00m\n\e[38;2;64;112;160;03m                return f\"{NEON_RED}MACD:{RESET} Calculation issue.\"\e[39;00m\n\e[38;2;64;112;160;03m        else:\e[39;00m\n\e[38;2;64;112;160;03m            return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No specific interpretation available.\"\e[39;00m\n\e[38;2;64;112;160;03m    except (TypeError, IndexError, KeyError, ValueError) as e:\e[39;00m\n\e[38;2;64;112;160;03m        logger.error(f\"{NEON_RED}Error interpreting {indicator_name}: {e}. Values: {values}{RESET}\")\e[39;00m\n\e[38;2;64;112;160;03m        return f\"{NEON_RED}{indicator_name.upper()}:{RESET} Interpretation error.\"\e[39;00m\n\n\n\e[38;2;64;112;160;03mdef main():\e[39;00m\n\e[38;2;64;112;160;03m    \"\"\"\e[39;00m\n    Main function to run the trading analysis bot\e[38;2;102;102;102m.\e[39m\n    Handles user \e[38;2;0;112;32minput\e[39m, data fetching, analysis, \e[38;2;0;112;32;01mand\e[39;00m signal generation loop\e[38;2;102;102;102m.\e[39m\n    \e[38;2;64;112;160m\"\"\"\e[39m\n\e[38;2;64;112;160m    if not API_KEY or not API_SECRET:\e[39m\n\e[38;2;64;112;160m        logger.error(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_RED}\e[39;00m\e[38;2;64;112;160mBYBIT_API_KEY and BYBIT_API_SECRET must be set in your .env file.\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m        return\e[39m\n\n\e[38;2;64;112;160m    symbol_input = input(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_BLUE}\e[39;00m\e[38;2;64;112;160mEnter trading symbol (e.g., BTCUSDT): \e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m).upper().strip()\e[39m\n\e[38;2;64;112;160m    symbol = symbol_input if symbol_input else \e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mBTCUSDT\e[39m\e[38;2;64;112;160m\"\e[39m\n\n\e[38;2;64;112;160m    interval_input = input(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_BLUE}\e[39;00m\e[38;2;64;112;160mEnter timeframe (e.g., \e[39m\e[38;2;64;112;160m{\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m, \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m.join(VALID_INTERVALS)} or press Enter for default \e[39m\e[38;2;112;160;208;03m{CONFIG['interval']}\e[39;00m\e[38;2;64;112;160m): \e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m).strip()\e[39m\n\e[38;2;64;112;160m    interval = interval_input if interval_input and interval_input in VALID_INTERVALS else CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160minterval\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m]\e[39m\n\n\e[38;2;64;112;160m    # Setup a dedicated logger for this symbol\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160ms activities\e[39m\n\e[38;2;64;112;160m    symbol_logger = setup_custom_logger(symbol)\e[39m\n\e[38;2;64;112;160m    symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_BLUE}\e[39;00m\e[38;2;64;112;160mStarting analysis for \e[39m\e[38;2;112;160;208;03m{symbol}\e[39;00m\e[38;2;64;112;160m with interval \e[39m\e[38;2;112;160;208;03m{interval}\e[39;00m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\n\e[38;2;64;112;160m    last_signal_time = 0.0  # Tracks the last time a signal was triggered for cooldown\e[39m\n\e[38;2;64;112;160m    last_order_book_fetch_time = 0.0  # Tracks last order book fetch time for debouncing\e[39m\n\n\e[38;2;64;112;160m    while True:\e[39m\n\e[38;2;64;112;160m        try:\e[39m\n\e[38;2;64;112;160m            current_price = fetch_current_price(symbol, API_KEY, API_SECRET, symbol_logger)\e[39m\n\e[38;2;64;112;160m            if current_price is None:\e[39m\n\e[38;2;64;112;160m                symbol_logger.error(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_RED}\e[39;00m\e[38;2;64;112;160mFailed to fetch current price for \e[39m\e[38;2;112;160;208;03m{symbol}\e[39;00m\e[38;2;64;112;160m. Skipping cycle.\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                time.sleep(CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretry_delay\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m])\e[39m\n\e[38;2;64;112;160m                continue\e[39m\n\n\e[38;2;64;112;160m            df = fetch_klines(symbol, interval, API_KEY, API_SECRET, symbol_logger, limit=200)\e[39m\n\e[38;2;64;112;160m            if df.empty:\e[39m\n\e[38;2;64;112;160m                symbol_logger.error(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_RED}\e[39;00m\e[38;2;64;112;160mFailed to fetch Kline data for \e[39m\e[38;2;112;160;208;03m{symbol}\e[39;00m\e[38;2;64;112;160m. Skipping cycle.\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                time.sleep(CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretry_delay\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m])\e[39m\n\e[38;2;64;112;160m                continue\e[39m\n\n\e[38;2;64;112;160m            # Debounce order book fetching to reduce API calls\e[39m\n\e[38;2;64;112;160m            order_book_data = None\e[39m\n\e[38;2;64;112;160m            if time.time() - last_order_book_fetch_time >= CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_debounce_s\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m]:\e[39m\n\e[38;2;64;112;160m                order_book_data = fetch_order_book(symbol, API_KEY, API_SECRET, symbol_logger, limit=CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160morder_book_depth_to_check\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m])\e[39m\n\e[38;2;64;112;160m                last_order_book_fetch_time = time.time()\e[39m\n\e[38;2;64;112;160m            else:\e[39m\n\e[38;2;64;112;160m                symbol_logger.debug(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_YELLOW}\e[39;00m\e[38;2;64;112;160mOrder book fetch debounced. Next fetch in \e[39m\e[38;2;64;112;160m{\e[39m\e[38;2;64;112;160mCONFIG[\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160morder_book_debounce_s\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m] - (time.time() - last_order_book_fetch_time):.1f}s\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\n\e[38;2;64;112;160m            analyzer = TradingAnalyzer(df, CONFIG, symbol_logger, symbol, interval)\e[39m\n\e[38;2;64;112;160m            timestamp = datetime.now(TIMEZONE).strftime(\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160mY-\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160mm-\e[39m\e[38;2;112;160;208;03m%d\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160mH:\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160mM:\e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160mS \e[39m\e[38;2;64;112;160m%\e[39m\e[38;2;64;112;160mZ\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\n\e[38;2;64;112;160m            # Perform analysis and log the current state of indicators\e[39m\n\e[38;2;64;112;160m            analyzer.analyze(current_price, timestamp, order_book_data)\e[39m\n\n\e[38;2;64;112;160m            # Generate trading signal based on the analysis\e[39m\n\e[38;2;64;112;160m            current_time_seconds = time.time()\e[39m\n\e[38;2;64;112;160m            signal, confidence, conditions_met, trade_levels = analyzer.generate_trading_signal(current_price)\e[39m\n\n\e[38;2;64;112;160m            if signal and (current_time_seconds - last_signal_time >= CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160msignal_cooldown_s\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m]):\e[39m\n\e[38;2;64;112;160m                symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160;01m\\n\e[39;00m\e[38;2;112;160;208;03m{NEON_PURPLE}\e[39;00m\e[38;2;64;112;160m--- TRADING SIGNAL TRIGGERED ---\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_BLUE}\e[39;00m\e[38;2;64;112;160mSignal:\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;64;112;160m{\e[39m\e[38;2;64;112;160msignal.upper()} (Confidence: \e[39m\e[38;2;112;160;208;03m{confidence:.2f}\e[39;00m\e[38;2;64;112;160m)\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_BLUE}\e[39;00m\e[38;2;64;112;160mConditions Met:\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;64;112;160m{\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m, \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m.join(conditions_met) if conditions_met else \e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mNone\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m}\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                if trade_levels:\e[39m\n\e[38;2;64;112;160m                    symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_GREEN}\e[39;00m\e[38;2;64;112;160mSuggested Stop Loss:\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;64;112;160m{\e[39m\e[38;2;64;112;160mtrade_levels.get(\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mstop_loss\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m):.5f}\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                    symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_GREEN}\e[39;00m\e[38;2;64;112;160mSuggested Take Profit:\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m \e[39m\e[38;2;64;112;160m{\e[39m\e[38;2;64;112;160mtrade_levels.get(\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160mtake_profit\e[39m\e[38;2;64;112;160m'\e[39m\e[38;2;64;112;160m):.5f}\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_YELLOW}\e[39;00m\e[38;2;64;112;160m--- Placeholder: Order placement logic would be here for \e[39m\e[38;2;64;112;160m{\e[39m\e[38;2;64;112;160msignal.upper()} signal ---\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m                last_signal_time = current_time_seconds  # Update last signal time\e[39m\n\n\e[38;2;64;112;160m            time.sleep(CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160manalysis_interval\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m])\e[39m\n\n\e[38;2;64;112;160m        except requests.exceptions.RequestException as e:\e[39m\n\e[38;2;64;112;160m            symbol_logger.error(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_RED}\e[39;00m\e[38;2;64;112;160mNetwork or API communication error: \e[39m\e[38;2;112;160;208;03m{e}\e[39;00m\e[38;2;64;112;160m. Retrying in \e[39m\e[38;2;112;160;208;03m{CONFIG['retry_delay']}\e[39;00m\e[38;2;64;112;160m seconds...\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m            time.sleep(CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretry_delay\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m])\e[39m\n\e[38;2;64;112;160m        except KeyboardInterrupt:\e[39m\n\e[38;2;64;112;160m            symbol_logger.info(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_YELLOW}\e[39;00m\e[38;2;64;112;160mAnalysis stopped by user.\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m            break\e[39m\n\e[38;2;64;112;160m        except Exception as e:\e[39m\n\e[38;2;64;112;160m            symbol_logger.exception(f\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;112;160;208;03m{NEON_RED}\e[39;00m\e[38;2;64;112;160mAn unexpected error occurred: \e[39m\e[38;2;112;160;208;03m{e}\e[39;00m\e[38;2;64;112;160m. Retrying in \e[39m\e[38;2;112;160;208;03m{CONFIG['retry_delay']}\e[39;00m\e[38;2;64;112;160m seconds...\e[39m\e[38;2;112;160;208;03m{RESET}\e[39;00m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m)\e[39m\n\e[38;2;64;112;160m            time.sleep(CONFIG[\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160mretry_delay\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m])\e[39m\n\n\n\e[38;2;64;112;160mif __name__ == \e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m__main__\e[39m\e[38;2;64;112;160m\"\e[39m\e[38;2;64;112;160m:\e[39m\n\e[38;2;64;112;160m    main()\e[39m\n"
- role: assistant
  content: |-
    The provided Python code is well-structured and demonstrates a good understanding of API interaction, technical analysis, and configuration management. The use of `Decimal` for financial calculations is a crucial best practice.

    Here's a refactored version focusing on:

    1.  **Logical Flow & Clarity:** Ensuring indicators are calculated per analysis cycle, not just once at initialization.
    2.  **Consistency:** Standardizing how indicator values are stored and accessed.
    3.  **Configuration:** Adjusting confidence boost values in the default config to directly reflect their intended weight, removing the `/ 10.0` division in the signal logic.
    4.  **Completeness:** Implementing the missing confidence boosts for RSI and MFI.

    ```python
    import os
    import logging
    import requests
    import pandas as pd
    import numpy as np
    from datetime import datetime
    import hmac
    import hashlib
    import time
    from dotenv import load_dotenv
    from typing import Dict, Tuple, List, Union, Any
    from colorama import init, Fore, Style
    from zoneinfo import ZoneInfo
    from decimal import Decimal, getcontext, InvalidOperation
    import json

    # --- Configuration & Constants ---

    # Set Decimal precision for financial calculations to avoid floating point errors
    getcontext().prec = 10

    # Initialize colorama for cross-platform colored terminal output
    init(autoreset=True)

    # Load environment variables from .env file
    load_dotenv()

    # --- Color Codex ---
    NEON_GREEN = Fore.LIGHTGREEN_EX
    NEON_BLUE = Fore.CYAN
    NEON_PURPLE = Fore.MAGENTA
    NEON_YELLOW = Fore.YELLOW
    NEON_RED = Fore.LIGHTRED_EX
    RESET = Style.RESET_ALL

    # --- Configuration & Constants ---
    API_KEY = os.getenv("BYBIT_API_KEY")
    API_SECRET = os.getenv("BYBIT_API_SECRET")
    BASE_URL = os.getenv("BYBIT_BASE_URL", "https://api.bybit.com")
    CONFIG_FILE = "config.json"
    LOG_DIRECTORY = "bot_logs"
    TIMEZONE = ZoneInfo("America/Chicago")  # Using a specific timezone for consistency
    MAX_API_RETRIES = 3
    RETRY_DELAY_SECONDS = 5
    VALID_INTERVALS = ["1", "3", "5", "15", "30", "60", "120", "240", "D", "W", "M"]
    RETRY_ERROR_CODES = [429, 500, 502, 503, 504]  # HTTP status codes to trigger a retry

    # Ensure log directory exists
    os.makedirs(LOG_DIRECTORY, exist_ok=True)

    # Setup the main application logger
    logger = setup_custom_logger('whalebot_main')


    def load_config(filepath: str) -> dict:
        """
        Loads configuration from a JSON file, merging with default values.
        If the file is not found or is invalid, it creates one with default settings.
        """
        default_config = {
            "interval": "15",
            "analysis_interval": 30,  # Time in seconds between main analysis cycles
            "retry_delay": 5,  # Delay in seconds for API retries
            "momentum_period": 10,
            "momentum_ma_short": 12,
            "momentum_ma_long": 26,
            "volume_ma_period": 20,
            "atr_period": 14,
            "trend_strength_threshold": 0.4,
            "sideways_atr_multiplier": 1.5,
            "signal_score_threshold": 1.0,  # Minimum combined weight for a signal to be valid
            "indicators": {
                "ema_alignment": True,
                "momentum": True,
                "volume_confirmation": True,
                "divergence": True,
                "stoch_rsi": True,
                "rsi": True,
                "macd": True,
                "vwap": False,
                "obv": True,
                "adi": True,
                "cci": True,
                "wr": True,
                "adx": True,
                "psar": True,
                "fve": True,
                "sma_10": False,
                "mfi": True,
                "stochastic_oscillator": True,
            },
            "weight_sets": {
                "low_volatility": {  # Weights for a low volatility market environment
                    "ema_alignment": 0.3,
                    "momentum": 0.2,
                    "volume_confirmation": 0.2,
                    "divergence": 0.1,
                    "stoch_rsi": 0.5,
                    "rsi": 0.3,
                    "macd": 0.3,
                    "vwap": 0.0,
                    "obv": 0.1,
                    "adi": 0.1,
                    "cci": 0.1,
                    "wr": 0.1,
                    "adx": 0.1,
                    "psar": 0.1,
                    "fve": 0.2,
                    "sma_10": 0.0,
                    "mfi": 0.3,
                    "stochastic_oscillator": 0.4,
                },
                "high_volatility": {  # Weights for a high volatility market environment
                    "ema_alignment": 0.1,
                    "momentum": 0.4,
                    "volume_confirmation": 0.1,
                    "divergence": 0.2,
                    "stoch_rsi": 0.4,
                    "rsi": 0.4,
                    "macd": 0.4,
                    "vwap": 0.0,
                    "obv": 0.1,
                    "adi": 0.1,
                    "cci": 0.1,
                    "wr": 0.1,
                    "adx": 0.1,
                    "psar": 0.1,
                    "fve": 0.3,
                    "sma_10": 0.0,
                    "mfi": 0.4,
                    "stochastic_oscillator": 0.3,
                }
            },
            "stoch_rsi_oversold_threshold": 20,
            "stoch_rsi_overbought_threshold": 80,
            "stoch_rsi_confidence_boost": 0.5,  # Additional boost for strong Stoch RSI signals (changed to float)
            "stoch_rsi_mandatory": False,  # If true, Stoch RSI must be a confirming factor
            "rsi_confidence_boost": 0.2, # Changed to float
            "mfi_confidence_boost": 0.2, # Changed to float
            "order_book_support_confidence_boost": 0.3, # Changed to float
            "order_book_resistance_confidence_boost": 0.3, # Changed to float
            "stop_loss_multiple": 1.5,  # Multiplier for ATR to determine stop loss distance
            "take_profit_multiple": 1.0,  # Multiplier for ATR to determine take profit distance
            "order_book_wall_threshold_multiplier": 2.0,  # Multiplier for average volume to identify a "wall"
            "order_book_depth_to_check": 10,  # Number of order book levels to check for walls
            "price_change_threshold": 0.005,  # % change in price to consider significant
            "atr_change_threshold": 0.005,  # % change in ATR to consider significant volatility change
            "signal_cooldown_s": 60,  # Seconds to wait before generating another signal
            "order_book_debounce_s": 10,  # Seconds to wait between order book API calls
            "ema_short_period": 12,
            "ema_long_period": 26,
            "volume_confirmation_multiplier": 1.5,  # Volume must be this many times average volume for confirmation
            "indicator_periods": {
                "rsi": 14,
                "mfi": 14,
                "cci": 20,
                "williams_r": 14,
                "adx": 14,
                "stoch_rsi_period": 14,  # Period for RSI calculation within Stoch RSI
                "stoch_rsi_k_period": 3,  # Smoothing period for %K line
                "stoch_rsi_d_period": 3,  # Smoothing period for %D line (signal line)
                "momentum": 10,
                "momentum_ma_short": 12,
                "momentum_ma_long": 26,
                "volume_ma": 20,
                "atr": 14,
                "sma_10": 10,
                "fve_price_ema": 10,  # EMA period for FVE price component
                "fve_obv_sma": 20,  # SMA period for OBV normalization
                "fve_atr_sma": 20,  # SMA period for ATR normalization
                "stoch_osc_k": 14,  # Stochastic Oscillator K period
                "stoch_osc_d": 3,  # Stochastic Oscillator D period
            },
            "order_book_analysis": {
                "enabled": True,
                "wall_threshold_multiplier": 2.0,
                "depth_to_check": 10,
                "support_boost": 0.3, # Changed to float
                "resistance_boost": 0.3, # Changed to float
            },
            "trailing_stop_loss": {
                "enabled": False,  # Disabled by default
                "initial_activation_percent": 0.5,  # Activate trailing stop after price moves X% in favor
                "trailing_stop_multiple_atr": 1.5  # Trail stop based on ATR multiple
            },
            "take_profit_scaling": {
                "enabled": False,  # Disabled by default
                "targets": [
                    {"level": 1.5, "percentage": 0.25},  # Sell 25% when price hits 1.5x ATR TP
                    {"level": 2.0, "percentage": 0.50}  # Sell 50% of remaining when price hits 2.0x ATR TP
                ]
            }
        }
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                config = json.load(f)
                # Merge loaded config with defaults. Prioritize loaded values, but ensure all default keys exist.
                merged_config = {**default_config, **config}

                # Recursively merge nested dictionaries (like 'indicators' and 'weight_sets')
                for key, default_val in default_config.items():
                    if isinstance(default_val, dict) and key in config and isinstance(config[key], dict):
                        merged_config[key] = {**default_val, **config[key]}

                # Basic validation for interval and analysis_interval
                if merged_config.get("interval") not in VALID_INTERVALS:
                    logger.warning(f"{NEON_YELLOW} Invalid 'interval' in config, using default: {default_config['interval']}{RESET}")
                    merged_config["interval"] = default_config["interval"]
                if not isinstance(merged_config.get("analysis_interval"), int) or merged_config.get("analysis_interval") <= 0:
                    logger.warning(f"{NEON_YELLOW} Invalid 'analysis_interval' in config, using default: {default_config['analysis_interval']}{RESET}")
                    merged_config["analysis_interval"] = default_config["analysis_interval"]

                return merged_config
        except FileNotFoundError:
            logger.warning(f"{NEON_YELLOW} Config file not found, loading defaults and creating {filepath}{RESET}")
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            return default_config
        except json.JSONDecodeError:
            logger.error(f"{NEON_RED} Invalid JSON in config file, loading defaults. {RESET}")
            # Optionally, back up the corrupt file before overwriting
            try:
                os.rename(filepath, f"{filepath}.bak_{int(time.time())}")
                logger.info(f"{NEON_YELLOW} Backed up corrupt config file to {filepath}.bak_{int(time.time())}{RESET}")
            except OSError as e:
                logger.error(f"{NEON_RED} Failed to backup corrupt config file: {e}{RESET}")
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            return default_config


    # Load the configuration
    CONFIG = load_config(CONFIG_FILE)


    def generate_signature(api_secret: str, params: dict) -> str:
        """Generates the HMAC SHA256 signature for Bybit API requests."""
        # Ensure params are sorted by key for consistent signature generation
        param_str = "&".join([f"{key}={value}" for key, value in sorted(params.items())])
        return hmac.new(api_secret.encode(), param_str.encode(), hashlib.sha256).hexdigest()


    def handle_api_error(response: requests.Response, logger: logging.Logger) -> None:
        """Logs detailed API error responses."""
        logger.error(f"{NEON_RED} API request failed with status code: {response.status_code}{RESET}")
        try:
            error_json = response.json()
            logger.error(f"{NEON_RED} Error details: {error_json}{RESET}")
        except json.JSONDecodeError:
            logger.error(f"{NEON_RED} Response text: {response.text}{RESET}")


    def bybit_request(method: str, endpoint: str, api_key: str, api_secret: str, params: Dict[str, Any] = None, logger: logging.Logger = None) -> Union[dict, None]:
        """
        Sends a signed request to the Bybit API with retry logic.

        Args:
            method (str): HTTP method (e.g., "GET", "POST").
            endpoint (str): API endpoint path.
            api_key (str): Your Bybit API key.
            api_secret (str): Your Bybit API secret.
            params (Dict[str, Any], optional): Dictionary of request parameters. Defaults to None.
            logger (logging.Logger, optional): Logger instance for logging. Defaults to None.

        Returns:
            Union[dict, None]: JSON response data if successful, None otherwise.
        """
        params = params or {}
        # Bybit API V5 requires timestamp in milliseconds
        params['timestamp'] = str(int(time.time() * 1000))
        signature = generate_signature(api_secret, params)
        headers = {
            "X-BAPI-API-KEY": api_key,
            "X-BAPI-SIGN": signature,
            "X-BAPI-TIMESTAMP": params['timestamp'],
            "Content-Type": "application/json"
        }
        url = f"{BASE_URL}{endpoint}"

        for retry in range(MAX_API_RETRIES):
            try:
                response = requests.request(
                    method,
                    url,
                    headers=headers,
                    params=params if method == "GET" else None,
                    json=params if method == "POST" else None,
                    timeout=10  # Set a timeout for requests
                )
                response.raise_for_status()  # Raises HTTPError for bad responses (4xx or 5xx)

                # Check for Bybit specific error codes within a successful HTTP response
                response_json = response.json()
                if response_json.get("retCode") != 0:
                    if logger:
                        logger.error(f"{NEON_RED} Bybit API Error: {response_json.get('retMsg', 'Unknown error')}. Response: {response_json}{RESET}")
                    return None

                return response_json

            except requests.exceptions.HTTPError as e:
                if e.response.status_code in RETRY_ERROR_CODES:
                    if logger:
                        logger.warning(f"{NEON_YELLOW} API Error {e.response.status_code} ({e.response.reason}), retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}")
                    time.sleep(RETRY_DELAY_SECONDS * (2**retry))  # Exponential backoff
                else:
                    if logger:
                        handle_api_error(e.response, logger)
                    return None
            except requests.exceptions.RequestException as e:
                if logger:
                    logger.error(f"{NEON_RED} Request exception: {e}, retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}")
                time.sleep(RETRY_DELAY_SECONDS * (2**retry))

        if logger:
            logger.error(f"{NEON_RED} Max retries reached for {method} {endpoint}{RESET}")
        return None


    def fetch_current_price(symbol: str, api_key: str, api_secret: str, logger: logging.Logger) -> Union[Decimal, None]:
        """Fetches the current last traded price for a given symbol."""
        endpoint = "/v5/market/tickers"
        params = {"category": "linear", "symbol": symbol}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result"):
            tickers = response_data["result"].get("list")
            if tickers:
                for ticker in tickers:
                    if ticker.get("symbol") == symbol:
                        last_price = ticker.get("lastPrice")
                        return Decimal(last_price) if last_price else None
        logger.error(f"{NEON_RED} Could not fetch current price for {symbol}. Response: {response_data}{RESET}")
        return None


    def fetch_klines(symbol: str, interval: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 200) -> pd.DataFrame:
        """Fetches historical K-line (candlestick) data for a given symbol and interval."""
        endpoint = "/v5/market/kline"
        params = {"symbol": symbol, "interval": interval, "limit": limit, "category": "linear"}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result") and response_data["result"].get("list"):
            data = response_data["result"]["list"]
            # Bybit's kline list order is: [timestamp, open, high, low, close, volume, turnover]
            columns = ["start_time", "open", "high", "low", "close", "volume", "turnover"]
            df = pd.DataFrame(data, columns=columns)
            df["start_time"] = pd.to_datetime(pd.to_numeric(df["start_time"]), unit="ms")
            # Convert numeric columns, coercing errors to NaN
            for col in df.columns[1:]:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            # Drop any rows that resulted in all NaNs after conversion (shouldn't happen with valid data)
            df.dropna(subset=df.columns[1:], inplace=True)
            return df.sort_values(by="start_time", ascending=True).reset_index(drop=True)  # Ensure chronological order
        logger.error(f"{NEON_RED} Failed to fetch Kline data for {symbol}, interval {interval}. Response: {response_data}{RESET}")
        return pd.DataFrame()


    def fetch_order_book(symbol: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 50) -> Union[dict, None]:
        """Fetches the order book (bids and asks) for a given symbol."""
        endpoint = "/v5/market/orderbook"
        params = {"symbol": symbol, "limit": limit, "category": "linear"}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result"):
            return response_data["result"]
        logger.warning(f"{NEON_YELLOW} Could not fetch order book for {symbol}. Response: {response_data}{RESET}")
        return None


    class TradingAnalyzer:
        """
        Performs technical analysis on candlestick data and generates trading signals.
        """
        def __init__(self, df: pd.DataFrame, config: dict, symbol_logger: logging.Logger, symbol: str, interval: str):
            self.df = df.copy()  # Work on a copy to avoid modifying original DataFrame
            self.config = config
            self.logger = symbol_logger
            self.symbol = symbol
            self.interval = interval
            self.levels: Dict[str, Any] = {}  # Stores support/resistance levels (fib, pivot)
            self.fib_levels: Dict[str, float] = {}  # Stores calculated Fibonacci levels
            self.weight_sets = config["weight_sets"]
            self.indicator_values: Dict[str, Any] = {}  # Stores calculated indicator values
            self.atr_value: float = 0.0  # Stores the latest ATR value
            self.user_defined_weights: Dict[str, float] = {} # To be selected dynamically

        def _safe_series_operation(self, column: str, operation: str, window: int = None, series: pd.Series = None) -> pd.Series:
            """Helper to safely perform operations on DataFrame columns or provided series."""
            if series is not None:
                data_series = series
            elif column in self.df.columns:
                data_series = self.df[column]
            else:
                self.logger.error(f"{NEON_RED} Missing '{column}' column for {operation} calculation.{RESET}")
                return pd.Series(dtype=float)

            if data_series.empty:
                return pd.Series(dtype=float)

            try:
                if operation == "sma":
                    return data_series.rolling(window=window).mean()
                elif operation == "ema":
                    return data_series.ewm(span=window, adjust=False).mean()
                elif operation == "max":
                    return data_series.rolling(window=window).max()
                elif operation == "min":
                    return data_series.rolling(window=window).min()
                elif operation == "diff":
                    return data_series.diff(window)
                elif operation == "abs_diff_mean":
                    return data_series.rolling(window=window).apply(lambda x: np.abs(x - x.mean()).mean(), raw=True)
                elif operation == "cumsum":
                    return data_series.cumsum()
                else:
                    self.logger.error(f"{NEON_RED} Unsupported series operation: {operation}{RESET}")
                    return pd.Series(dtype=float)
            except Exception as e:
                self.logger.error(f"{NEON_RED} Error during {operation} calculation on {column}: {e}{RESET}")
                return pd.Series(dtype=float)

        def _calculate_sma(self, window: int, series: pd.Series = None) -> pd.Series:
            """Calculates Simple Moving Average (SMA). Can operate on a specified series or 'close' price."""
            return self._safe_series_operation('close', 'sma', window, series)

        def _calculate_ema(self, window: int, series: pd.Series = None) -> pd.Series:
            """Calculates Exponential Moving Average (EMA). Can operate on a specified series or 'close' price."""
            return self._safe_series_operation('close', 'ema', window, series)

        def _calculate_ema_alignment(self) -> float:
            """
            Calculates an EMA alignment score.
            Score is 1.0 for strong bullish alignment, -1.0 for strong bearish, 0.0 for neutral.
            """
            ema_short = self._calculate_ema(self.config["ema_short_period"])
            ema_long = self._calculate_ema(self.config["ema_long_period"])

            if ema_short.empty or ema_long.empty or len(self.df) < max(self.config["ema_short_period"], self.config["ema_long_period"]):
                return 0.0

            latest_short_ema = Decimal(str(ema_short.iloc[-1]))
            latest_long_ema = Decimal(str(ema_long.iloc[-1]))

            # Check for consistent alignment over the last few bars (e.g., 3 bars)
            alignment_period = 3
            if len(ema_short) < alignment_period or len(ema_long) < alignment_period:
                return 0.0

            bullish_aligned_count = 0
            bearish_aligned_count = 0

            for i in range(1, alignment_period + 1):
                if (ema_short.iloc[-i] > ema_long.iloc[-i] and
                    self.df["close"].iloc[-i] > ema_short.iloc[-i]):
                    bullish_aligned_count += 1
                elif (ema_short.iloc[-i] < ema_long.iloc[-i] and
                      self.df["close"].iloc[-i] < ema_short.iloc[-i]):
                    bearish_aligned_count += 1

            if bullish_aligned_count >= alignment_period - 1:  # At least (period-1) bars are aligned
                return 1.0  # Strong bullish alignment
            elif bearish_aligned_count >= alignment_period - 1:
                return -1.0  # Strong bearish alignment
            else:
                # Check for recent crossover as a weaker signal
                if latest_short_ema > latest_long_ema and ema_short.iloc[-2] <= latest_long_ema:
                    return 0.5  # Recent bullish crossover
                elif latest_short_ema < latest_long_ema and ema_short.iloc[-2] >= latest_long_ema:
                    return -0.5  # Recent bearish crossover
                return 0.0  # Neutral

        def _calculate_momentum(self, period: int = 10) -> pd.Series:
            """Calculates the Momentum indicator."""
            # Momentum is often calculated as current price - price N periods ago.
            # For signal generation, a ratio or percentage change can be more useful.
            # Here, we calculate the percentage change over the period.
            return self._safe_series_operation('close', 'diff', period) / self.df["close"].shift(period) * 100

        def _calculate_cci(self, window: int = 20, constant: float = 0.015) -> pd.Series:
            """Calculates the Commodity Channel Index (CCI)."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for CCI calculation.{RESET}")
                return pd.Series(dtype=float)
            typical_price = (self.df["high"] + self.df["low"] + self.df["close"]) / 3
            sma_typical_price = self._safe_series_operation(None, 'sma', window, typical_price)
            mean_deviation = self._safe_series_operation(None, 'abs_diff_mean', window, typical_price)
            # Avoid division by zero
            cci = (typical_price - sma_typical_price) / (constant * mean_deviation)
            return cci.replace([np.inf, -np.inf], np.nan)  # Handle potential inf values

        def _calculate_williams_r(self, window: int = 14) -> pd.Series:
            """Calculates the Williams %R indicator."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for Williams %R calculation.{RESET}")
                return pd.Series(dtype=float)
            highest_high = self._safe_series_operation('high', 'max', window)
            lowest_low = self._safe_series_operation('low', 'min', window)
            # Avoid division by zero
            denominator = (highest_high - lowest_low)
            wr = ((highest_high - self.df["close"]) / denominator) * -100
            return wr.replace([np.inf, -np.inf], np.nan)

        def _calculate_mfi(self, window: int = 14) -> pd.Series:
            """Calculates the Money Flow Index (MFI)."""
            required_columns = ['high', 'low', 'close', 'volume']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for MFI calculation.{RESET}")
                return pd.Series(dtype=float)

            typical_price = (self.df["high"] + self.df["low"] + self.df["close"]) / 3
            raw_money_flow = typical_price * self.df["volume"]

            # Calculate positive and negative money flow
            money_flow_direction = typical_price.diff()
            positive_flow = raw_money_flow.where(money_flow_direction > 0, 0)
            negative_flow = raw_money_flow.where(money_flow_direction < 0, 0)

            # Calculate sums over the window
            positive_mf = self._safe_series_operation(None, 'sma', window, positive_flow) * window  # sum not mean
            negative_mf = self._safe_series_operation(None, 'sma', window, negative_flow) * window  # sum not mean

            # Avoid division by zero
            money_ratio = positive_mf / negative_mf.replace(0, np.nan)  # Replace 0 with NaN to handle division by zero
            mfi = 100 - (100 / (1 + money_ratio))
            return mfi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0 or a sensible value

        def calculate_fibonacci_retracement(self, high: Decimal, low: Decimal, current_price: Decimal) -> Dict[str, Decimal]:
            """Calculates Fibonacci retracement levels based on a given high and low."""
            diff = high - low
            if diff <= 0:  # Handle cases where high <= low
                self.logger.warning(f"{NEON_YELLOW} Cannot calculate Fibonacci retracement: High ({high}) <= Low ({low}).{RESET}")
                self.fib_levels = {}
                self.levels = {"Support": {}, "Resistance": {}}
                return {}

            # Standard Fibonacci ratios
            fib_ratios = {
                "23.6%": Decimal('0.236'), "38.2%": Decimal('0.382'), "50.0%": Decimal('0.500'),
                "61.8%": Decimal('0.618'), "78.6%": Decimal('0.786'), "88.6%": Decimal('0.886'),
                "94.1%": Decimal('0.941')
            }
            fib_levels_calculated: Dict[str, Decimal] = {}

            # Assuming an uptrend (retracement from high to low)
            # Levels are calculated from the high, moving down
            for label, ratio in fib_ratios.items():
                level = high - (diff * ratio)
                fib_levels_calculated[f"Fib {label}"] = level.quantize(Decimal('0.00001'))  # Quantize for consistent precision

            self.fib_levels = fib_levels_calculated
            self.levels = {"Support": {}, "Resistance": {}}

            # Categorize levels as support or resistance relative to current price
            for label, value in self.fib_levels.items():
                if value < current_price:
                    self.levels["Support"][label] = value
                elif value > current_price:
                    self.levels["Resistance"][label] = value

            return self.fib_levels

        def calculate_pivot_points(self, high: Decimal, low: Decimal, close: Decimal):
            """Calculates standard Pivot Points."""
            pivot = (high + low + close) / 3
            r1 = (2 * pivot) - low
            s1 = (2 * pivot) - high
            r2 = pivot + (high - low)
            s2 = pivot - (high - low)
            r3 = high + 2 * (pivot - low)
            s3 = low - 2 * (high - pivot)

            # Quantize all pivot points for consistent precision
            precision = Decimal('0.00001')
            self.levels.update({
                "Pivot": pivot.quantize(precision),
                "R1": r1.quantize(precision), "S1": s1.quantize(precision),
                "R2": r2.quantize(precision), "S2": s2.quantize(precision),
                "R3": r3.quantize(precision), "S3": s3.quantize(precision),
            })

        def find_nearest_levels(self, current_price: Decimal, num_levels: int = 5) -> Tuple[List[Tuple[str, Decimal]], List[Tuple[str, Decimal]]]:
            """
            Finds the nearest support and resistance levels from calculated Fibonacci and Pivot Points.
            """
            all_support_levels: List[Tuple[str, Decimal]] = []
            all_resistance_levels: List[Tuple[str, Decimal]] = []

            def process_level(label: str, value: Decimal):
                if value < current_price:
                    all_support_levels.append((label, value))
                elif value > current_price:
                    all_resistance_levels.append((label, value))

            # Process all levels stored in self.levels (from Fibonacci and Pivot)
            for label, value in self.levels.items():
                if isinstance(value, dict):  # For nested levels like "Support": {"Fib 23.6%": ...}
                    for sub_label, sub_value in value.items():
                        if isinstance(sub_value, Decimal):
                            process_level(f"{label} ({sub_label})", sub_value)
                elif isinstance(value, Decimal):  # For direct levels like "Pivot"
                    process_level(label, value)

            # Sort by distance to current price and select the 'num_levels' closest
            nearest_supports = sorted(all_support_levels, key=lambda x: current_price - x[1])[:num_levels]
            nearest_resistances = sorted(all_resistance_levels, key=lambda x: x[1] - current_price)[:num_levels]

            return nearest_supports, nearest_resistances

        def _calculate_atr(self, window: int = 14) -> pd.Series:
            """Calculates the Average True Range (ATR)."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ATR calculation.{RESET}")
                return pd.Series(dtype=float)

            high_low = self.df["high"] - self.df["low"]
            high_close = abs(self.df["high"] - self.df["close"].shift())
            low_close = abs(self.df["low"] - self.df["close"].shift())

            # True Range is the maximum of the three
            tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
            return self._safe_series_operation(None, 'ema', window, tr)  # Use EMA for ATR for smoothing

        def _calculate_rsi(self, window: int = 14) -> pd.Series:
            """Calculates the Relative Strength Index (RSI)."""
            if 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' column for RSI calculation.{RESET}")
                return pd.Series(dtype=float)

            delta = self.df["close"].diff()
            gain = delta.where(delta > 0, 0)
            loss = -delta.where(delta < 0, 0)

            avg_gain = self._safe_series_operation(None, 'ema', window, gain)
            avg_loss = self._safe_series_operation(None, 'ema', window, loss)

            # Avoid division by zero
            rs = avg_gain / avg_loss.replace(0, np.nan)
            rsi = 100 - (100 / (1 + rs))
            return rsi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0

        def _calculate_stoch_rsi(self, rsi_window: int = 14, stoch_window: int = 14, k_window: int = 3, d_window: int = 3) -> pd.DataFrame:
            """Calculates Stochastic RSI (%K and %D lines)."""
            rsi = self._calculate_rsi(window=rsi_window)
            if rsi.empty:
                return pd.DataFrame()

            # Calculate StochRSI
            stoch_rsi = (rsi - self._safe_series_operation(None, 'min', stoch_window, rsi)) / \
                        (self._safe_series_operation(None, 'max', stoch_window, rsi) - self._safe_series_operation(None, 'min', stoch_window, rsi))

            # Handle division by zero for StochRSI (if max == min)
            stoch_rsi = stoch_rsi.replace([np.inf, -np.inf], np.nan).fillna(0)

            k_line = self._safe_series_operation(None, 'sma', k_window, stoch_rsi) * 100  # Scale to 0-100
            d_line = self._safe_series_operation(None, 'sma', d_window, k_line)  # Signal line for %K

            return pd.DataFrame({'stoch_rsi': stoch_rsi * 100, 'k': k_line, 'd': d_line})  # Return StochRSI also scaled

        def _calculate_stochastic_oscillator(self) -> pd.DataFrame:
            """Calculates the Stochastic Oscillator (%K and %D lines)."""
            k_period = self.config["indicator_periods"]["stoch_osc_k"]
            d_period = self.config["indicator_periods"]["stoch_osc_d"]

            if 'high' not in self.df.columns or 'low' not in self.df.columns or 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing required columns for Stochastic Oscillator calculation.{RESET}")
                return pd.DataFrame()

            highest_high = self._safe_series_operation('high', 'max', k_period)
            lowest_low = self._safe_series_operation('low', 'min', k_period)

            # Calculate %K
            k_line = (self.df['close'] - lowest_low) / (highest_high - lowest_low) * 100
            k_line = k_line.replace([np.inf, -np.inf], np.nan).fillna(0)  # Handle division by zero

            # Calculate %D (SMA of %K)
            d_line = self._safe_series_operation(None, 'sma', d_period, k_line)

            return pd.DataFrame({'k': k_line, 'd': d_line})

        def _calculate_momentum_ma(self) -> None:
            """Calculates momentum and its moving averages, and volume moving average."""
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for Momentum MA calculation.{RESET}")
                return

            self.df["momentum"] = self._calculate_momentum(period=self.config["momentum_period"])  # Use the momentum function
            self.df["momentum_ma_short"] = self._calculate_sma(self.config["momentum_ma_short"], series=self.df["momentum"])
            self.df["momentum_ma_long"] = self._calculate_sma(self.config["momentum_ma_long"], series=self.df["momentum"])
            self.df["volume_ma"] = self._calculate_sma(self.config["volume_ma_period"], series=self.df["volume"])

        def _calculate_macd(self) -> pd.DataFrame:
            """Calculates Moving Average Convergence Divergence (MACD)."""
            if 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' column for MACD calculation.{RESET}")
                return pd.DataFrame()

            ma_short = self._calculate_ema(12)
            ma_long = self._calculate_ema(26)
            macd = ma_short - ma_long
            signal = self._calculate_ema(9, series=macd)
            histogram = macd - signal
            return pd.DataFrame({'macd': macd, 'signal': signal, 'histogram': histogram})

        def detect_macd_divergence(self) -> Union[str, None]:
            """Detects bullish or bearish MACD divergence."""
            macd_df = self._calculate_macd()
            if macd_df.empty or len(self.df) < 30:  # Need sufficient data for reliable divergence
                return None

            prices = self.df["close"]
            macd_histogram = macd_df["histogram"]

            # Simple divergence check on last two bars (can be expanded for more robust detection)
            if (prices.iloc[-2] > prices.iloc[-1] and macd_histogram.iloc[-2] < macd_histogram.iloc[-1]):
                self.logger.info(f"{NEON_GREEN} Detected Bullish MACD Divergence.{RESET}")
                return "bullish"
            elif (prices.iloc[-2] < prices.iloc[-1] and macd_histogram.iloc[-2] > macd_histogram.iloc[-1]):
                self.logger.info(f"{NEON_RED} Detected Bearish MACD Divergence.{RESET}")
                return "bearish"
            return None

        def determine_trend_momentum(self) -> Dict[str, Union[str, float]]:
            """Determines the current trend and its strength based on momentum MAs and ATR."""
            if self.df.empty or len(self.df) < max(self.config["momentum_ma_long"], self.config["atr_period"]):
                return {"trend": "Insufficient Data", "strength": 0.0}

            # Ensure momentum_ma_short, momentum_ma_long, and atr_value are calculated
            if "momentum_ma_short" not in self.df.columns or "momentum_ma_long" not in self.df.columns or self.atr_value == 0:
                self.logger.warning(f"{NEON_YELLOW} Momentum MAs or ATR not available for trend calculation.{RESET}")
                return {"trend": "Neutral", "strength": 0.0}

            latest_short_ma = self.df["momentum_ma_short"].iloc[-1]
            latest_long_ma = self.df["momentum_ma_long"].iloc[-1]

            trend = "Neutral"
            if latest_short_ma > latest_long_ma:
                trend = "Uptrend"
            elif latest_short_ma < latest_long_ma:
                trend = "Downtrend"

            # Strength is normalized by ATR to make it comparable across symbols/timeframes
            strength = abs(latest_short_ma - latest_long_ma) / self.atr_value
            return {"trend": trend, "strength": strength}

        def _calculate_adx(self, window: int = 14) -> float:
            """Calculates the Average Directional Index (ADX)."""
            df_adx = self.df.copy()
            required_columns = ['high', 'low', 'close']
            if not all(col in df_adx.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ADX calculation.{RESET}")
                return 0.0

            # True Range
            df_adx["TR"] = pd.concat([
                df_adx["high"] - df_adx["low"],
                abs(df_adx["high"] - df_adx["close"].shift()),
                abs(df_adx["low"] - df_adx["close"].shift())
            ], axis=1).max(axis=1)

            # Directional Movement
            df_adx["+DM"] = np.where((df_adx["high"] - df_adx["high"].shift()) > (df_adx["low"].shift() - df_adx["low"]),
                                     np.maximum(df_adx["high"] - df_adx["high"].shift(), 0), 0)
            df_adx["-DM"] = np.where((df_adx["low"].shift() - df_adx["low"]) > (df_adx["high"] - df_adx["high"].shift()),
                                     np.maximum(df_adx["low"].shift() - df_adx["low"], 0), 0)

            # Smoothed True Range and Directional Movement (using EMA)
            df_adx["TR_ema"] = self._calculate_ema(window, series=df_adx["TR"])
            df_adx["+DM_ema"] = self._calculate_ema(window, series=df_adx["+DM"])
            df_adx["-DM_ema"] = self._calculate_ema(window, series=df_adx["-DM"])

            # Directional Indicators
            df_adx["+DI"] = 100 * (df_adx["+DM_ema"] / df_adx["TR_ema"].replace(0, np.nan))
            df_adx["-DI"] = 100 * (df_adx["-DM_ema"] / df_adx["TR_ema"].replace(0, np.nan))

            # Directional Movement Index (DX)
            df_adx["DX"] = 100 * abs(df_adx["+DI"] - df_adx["-DI"]) / (df_adx["+DI"] + df_adx["-DI"]).replace(0, np.nan)

            # Average Directional Index (ADX)
            adx_value = self._calculate_ema(window, series=df_adx["DX"]).iloc[-1]
            return adx_value if not pd.isna(adx_value) else 0.0

        def _calculate_obv(self) -> pd.Series:
            """Calculates On-Balance Volume (OBV)."""
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for OBV calculation.{RESET}")
                return pd.Series(dtype=float)

            obv = pd.Series(0, index=self.df.index, dtype=float)
            obv.iloc[0] = self.df["volume"].iloc[0]  # Initialize with first volume

            for i in range(1, len(self.df)):
                if self.df["close"].iloc[i] > self.df["close"].iloc[i - 1]:
                    obv.iloc[i] = obv.iloc[i - 1] + self.df["volume"].iloc[i]
                elif self.df["close"].iloc[i] < self.df["close"].iloc[i - 1]:
                    obv.iloc[i] = obv.iloc[i - 1] - self.df["volume"].iloc[i]
                else:
                    obv.iloc[i] = obv.iloc[i - 1]  # No change if close price is the same

            return obv

        def _calculate_adi(self) -> pd.Series:
            """Calculates Accumulation/Distribution Index (ADI)."""
            required_columns = ['high', 'low', 'close', 'volume']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ADI calculation.{RESET}")
                return pd.Series(dtype=float)

            # Money Flow Multiplier (MFM)
            mfm_denominator = (self.df["high"] - self.df["low"])
            mfm = ((self.df["close"] - self.df["low"]) - (self.df["high"] - self.df["close"])) / mfm_denominator.replace(0, np.nan)
            mfm.fillna(0, inplace=True)  # If high == low, MFM is 0

            # Money Flow Volume (MFV)
            money_flow_volume = mfm * self.df["volume"]

            # Accumulation/Distribution Line (ADL) is the cumulative sum of MFV
            return self._safe_series_operation(None, 'cumsum', series=money_flow_volume)

        def _calculate_psar(self, acceleration: float = 0.02, max_acceleration: float = 0.2) -> pd.Series:
            """Calculates Parabolic SAR (PSAR)."""
            psar = pd.Series(index=self.df.index, dtype="float64")
            if self.df.empty or len(self.df) < 2:  # Need at least two bars to start
                return psar

            # Initial values
            psar.iloc[0] = self.df["close"].iloc[0]  # Start PSAR at first close
            # Determine initial trend based on first two bars
            if self.df["close"].iloc[1] > self.df["close"].iloc[0]:
                trend = 1  # Uptrend
                ep = self.df["high"].iloc[0]  # Extreme Point
            else:
                trend = -1  # Downtrend
                ep = self.df["low"].iloc[0]  # Extreme Point
            af = acceleration  # Acceleration Factor

            for i in range(1, len(self.df)):
                current_high = self.df["high"].iloc[i]
                current_low = self.df["low"].iloc[i]
                prev_psar = psar.iloc[i - 1]

                if trend == 1:  # Uptrend
                    psar.iloc[i] = prev_psar + af * (ep - prev_psar)
                    # Check if PSAR should be below current low
                    psar.iloc[i] = min(psar.iloc[i], current_low, self.df["low"].iloc[i - 1] if i > 1 else current_low)
                    if current_high > ep:  # New extreme high
                        ep = current_high
                        af = min(af + acceleration, max_acceleration)
                    if current_low < psar.iloc[i]:  # Trend reversal
                        trend = -1
                        psar.iloc[i] = ep  # PSAR jumps to old EP
                        ep = current_low
                        af = acceleration
                elif trend == -1:  # Downtrend
                    psar.iloc[i] = prev_psar + af * (ep - prev_psar)
                    # Check if PSAR should be above current high
                    psar.iloc[i] = max(psar.iloc[i], current_high, self.df["high"].iloc[i - 1] if i > 1 else current_high)
                    if current_low < ep:  # New extreme low
                        ep = current_low
                        af = min(af + acceleration, max_acceleration)
                    if current_high > psar.iloc[i]:  # Trend reversal
                        trend = 1
                        psar.iloc[i] = ep  # PSAR jumps to old EP
                        ep = current_high
                        af = acceleration
            return psar

        def _calculate_fve(self) -> pd.Series:
            """
            Calculates a "Fictional Value Estimate" (FVE) by combining price, volume, and volatility.
            This is a custom composite indicator for demonstrative purposes.
            """
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for FVE calculation.{RESET}")
                return pd.Series(dtype=float)

            try:
                # Ensure enough data for calculations
                min_data_points = max(20, self.config["atr_period"])
                if len(self.df) < min_data_points:
                    self.logger.warning(f"{NEON_YELLOW} Insufficient data for FVE calculation. Need at least {min_data_points} bars.{RESET}")
                    # Return a series of NaNs matching the DataFrame length if data is insufficient
                    return pd.Series([np.nan] * len(self.df), index=self.df.index)

                # Components calculation, ensuring Decimal usage where appropriate
                # Use Decimal for price-related calculations
                price_component = self._calculate_ema(window=self.config["indicator_periods"]["fve_price_ema"])  # Short term price trend
                obv_component = self._calculate_obv()
                atr_component = self._calculate_atr(window=self.config["indicator_periods"]["atr"])

                # Convert components to Decimal for calculations if they are not already
                # This is crucial to avoid numpy.float64 issues with Decimal operations
                price_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in price_component], index=price_component.index)
                obv_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in obv_component], index=obv_component.index)
                atr_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in atr_component], index=atr_component.index)

                # Normalize components to prevent one from dominating excessively
                # Use Decimal for mean and std calculation to maintain precision
                price_mean = Decimal(str(price_component_dec.mean())) if pd.notna(price_component_dec.mean()) else Decimal('NaN')
                price_std = Decimal(str(price_component_dec.std())) if pd.notna(price_component_dec.std()) else Decimal('NaN')
                obv_mean = Decimal(str(obv_component_dec.mean())) if pd.notna(obv_component_dec.mean()) else Decimal('NaN')
                obv_std = Decimal(str(obv_component_dec.std())) if pd.notna(obv_component_dec.std()) else Decimal('NaN')
                atr_mean = Decimal(str(atr_component_dec.mean())) if pd.notna(atr_component_dec.mean()) else Decimal('NaN')
                atr_std = Decimal(str(atr_component_dec.std())) if pd.notna(atr_component_dec.std()) else Decimal('NaN')

                # Handle potential division by zero for std dev
                price_norm = (price_component_dec - price_mean) / price_std if price_std != 0 else pd.Series(Decimal('0'), index=self.df.index)
                obv_norm = (obv_component_dec - obv_mean) / obv_std if obv_std != 0 else pd.Series(Decimal('0'), index=self.df.index)

                # Inverse of ATR: lower ATR means higher stability/less volatility, which can be seen as positive for trend following
                # Use Decimal for division, and handle potential division by zero for ATR
                # Calculate inverse ATR, handling division by zero safely
                atr_inverse = pd.Series([Decimal('1.0') / Decimal(str(x)) if x and x != 0 else Decimal('NaN') for x in atr_component_dec], index=self.df.index)
                # Replace infinite values resulting from division by zero with NaN
                atr_inverse = atr_inverse.replace([Decimal('Infinity'), Decimal('-Infinity')], Decimal('NaN'))

                atr_inverse_mean = Decimal(str(atr_inverse.mean())) if pd.notna(atr_inverse.mean()) else Decimal('NaN')
                atr_inverse_std = Decimal(str(atr_inverse.std())) if pd.notna(atr_inverse.std()) else Decimal('NaN')

                # Normalize ATR inverse, handling potential zero std dev
                atr_inverse_norm = (atr_inverse - atr_inverse_mean) / atr_inverse_std if atr_inverse_std != 0 else pd.Series(Decimal('0'), index=self.df.index)

                # Combine them - this formula is illustrative and should be fine-tuned
                # Higher FVE indicates more "value" or bullishness.
                # Ensure all components are aligned and handle NaNs
                fve = price_norm.fillna(Decimal('0')) + obv_norm.fillna(Decimal('0')) + atr_inverse_norm.fillna(Decimal('0'))

                # Convert back to float Series for compatibility with later operations if needed
                return pd.Series([float(x) if x != Decimal('NaN') else np.nan for x in fve], index=self.df.index)

            except Exception as e:
                self.logger.error(f"{NEON_RED} Error calculating FVE: {e}{RESET}")
                # Return a series of NaNs matching the DataFrame length in case of any error
                return pd.Series([np.nan] * len(self.df), index=self.df.index)

        def _calculate_volume_confirmation(self) -> bool:
            """
            Checks if the current volume confirms a trend (e.g., significant spike).
            Returns True if current volume is significantly higher than average.
            """
            if 'volume' not in self.df.columns or 'volume_ma' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'volume' or 'volume_ma' column for Volume Confirmation.{RESET}")
                return False
            if self.df["volume"].empty or self.df["volume_ma"].empty:
                return False

            current_volume = self.df['volume'].iloc[-1]
            average_volume = self.df['volume_ma'].iloc[-1]

            if average_volume <= 0:  # Avoid division by zero or nonsensical average
                return False

            return current_volume > average_volume * self.config["volume_confirmation_multiplier"]

        def analyze_order_book_walls(self, order_book: Dict[str, Any]) -> Tuple[bool, bool, Dict[str, Decimal], Dict[str, Decimal]]:
            """
            Analyzes order book for significant bid (support) and ask (resistance) walls.
            Returns whether bullish/bearish walls are found and the wall details.
            """
            has_bullish_wall = False
            has_bearish_wall = False
            bullish_wall_details: Dict[str, Decimal] = {}
            bearish_wall_details: Dict[str, Decimal] = {}

            if not self.config["order_book_analysis"]["enabled"]:
                return False, False, {}, {}

            if not order_book or not order_book.get('bids') or not order_book.get('asks'):
                self.logger.warning(f"{NEON_YELLOW} Order book data incomplete for wall analysis.{RESET}")
                return False, False, {}, {}

            bids = [(Decimal(price), Decimal(qty)) for price, qty in order_book['bids'][:self.config["order_book_analysis"]["depth_to_check"]]]
            asks = [(Decimal(price), Decimal(qty)) for price, qty in order_book['asks'][:self.config["order_book_analysis"]["depth_to_check"]]]

            # Calculate average quantity across relevant depth
            all_quantities = [qty for _, qty in bids + asks]
            if not all_quantities:
                return False, False, {}, {}

            # Use Decimal for sum and count, then divide to maintain precision
            total_qty = sum(all_quantities)
            avg_qty = total_qty / Decimal(str(len(all_quantities)))
            wall_threshold = avg_qty * Decimal(str(self.config["order_book_analysis"]["wall_threshold_multiplier"]))

            # Check for bullish walls (large bids below current price)
            current_price = Decimal(str(self.df["close"].iloc[-1]))
            for bid_price, bid_qty in bids:
                if bid_qty >= wall_threshold and bid_price < current_price:
                    has_bullish_wall = True
                    bullish_wall_details[f"Bid@{bid_price}"] = bid_qty
                    self.logger.info(f"{NEON_GREEN} Detected Bullish Order Book Wall: Bid {bid_qty:.2f} at {bid_price:.2f}{RESET}")
                    break  # Only need to find one significant wall

            # Check for bearish walls (large asks above current price)
            for ask_price, ask_qty in asks:
                if ask_qty >= wall_threshold and ask_price > current_price:
                    has_bearish_wall = True
                    bearish_wall_details[f"Ask@{ask_price}"] = ask_qty
                    self.logger.info(f"{NEON_RED} Detected Bearish Order Book Wall: Ask {ask_qty:.2f} at {ask_price:.2f}{RESET}")
                    break  # Only need to find one significant wall

            return has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details

        def _calculate_all_indicators(self):
            """Calculates and stores all enabled indicators for the current cycle."""
            # Pre-calculate ATR and momentum MAs first, as they are used for weight selection and trend
            atr_series = self._calculate_atr(window=self.config["atr_period"])
            if not atr_series.empty and not pd.isna(atr_series.iloc[-1]):
                self.atr_value = float(atr_series.iloc[-1])
            else:
                self.atr_value = 0.0
            self.indicator_values["atr"] = self.atr_value

            self._calculate_momentum_ma() # Populates momentum and its MAs, and volume MA

            # Now that ATR is potentially calculated, select the weight set
            self.user_defined_weights = self._select_weight_set()

            # Calculate and store other indicator values based on config
            if self.config["indicators"].get("obv"):
                obv_series = self._calculate_obv()
                self.indicator_values["obv"] = obv_series.iloc[-3:].tolist() if not obv_series.empty else []
            if self.config["indicators"].get("rsi"):
                rsi_series = self._calculate_rsi(window=self.config["indicator_periods"]["rsi"])
                self.indicator_values["rsi"] = rsi_series.iloc[-3:].tolist() if not rsi_series.empty else []
            if self.config["indicators"].get("mfi"):
                mfi_series = self._calculate_mfi(window=self.config["indicator_periods"]["mfi"])
                self.indicator_values["mfi"] = mfi_series.iloc[-3:].tolist() if not mfi_series.empty else []
            if self.config["indicators"].get("cci"):
                cci_series = self._calculate_cci(window=self.config["indicator_periods"]["cci"])
                self.indicator_values["cci"] = cci_series.iloc[-3:].tolist() if not cci_series.empty else []
            if self.config["indicators"].get("wr"):
                wr_series = self._calculate_williams_r(window=self.config["indicator_periods"]["williams_r"])
                self.indicator_values["wr"] = wr_series.iloc[-3:].tolist() if not wr_series.empty else []
            if self.config["indicators"].get("adx"):
                adx_value = self._calculate_adx(window=self.config["indicator_periods"]["adx"])
                self.indicator_values["adx"] = [adx_value]
            if self.config["indicators"].get("adi"):
                adi_series = self._calculate_adi()
                self.indicator_values["adi"] = adi_series.iloc[-3:].tolist() if not adi_series.empty else []
            if self.config["indicators"].get("momentum"):
                trend_data = self.determine_trend_momentum()
                self.indicator_values["mom"] = trend_data
            if self.config["indicators"].get("sma_10"):
                sma_series = self._calculate_sma(10)
                self.indicator_values["sma_10"] = [sma_series.iloc[-1]] if not sma_series.empty else []
            if self.config["indicators"].get("psar"):
                psar_series = self._calculate_psar()
                self.indicator_values["psar"] = psar_series.iloc[-3:].tolist() if not psar_series.empty else []
            if self.config["indicators"].get("fve"):
                fve_series = self._calculate_fve()
                if not fve_series.empty and not fve_series.isnull().all():
                    self.indicator_values["fve"] = fve_series.iloc[-3:].tolist()
                else:
                    self.indicator_values["fve"] = []
            if self.config["indicators"].get("macd"):
                macd_df = self._calculate_macd()
                self.indicator_values["macd"] = macd_df.iloc[-3:].values.tolist() if not macd_df.empty else []
            if self.config["indicators"].get("ema_alignment"):
                ema_alignment_score = self._calculate_ema_alignment()
                self.indicator_values["ema_alignment"] = ema_alignment_score
            if self.config["indicators"].get("stoch_rsi"):
                stoch_rsi_vals = self._calculate_stoch_rsi(
                    rsi_window=self.config["indicator_periods"]["stoch_rsi_period"],
                    stoch_window=self.config["indicator_periods"]["stoch_rsi_period"],
                    k_window=self.config["indicator_periods"]["stoch_rsi_k_period"],
                    d_window=self.config["indicator_periods"]["stoch_rsi_d_period"]
                )
                self.indicator_values["stoch_rsi_vals"] = stoch_rsi_vals # Store DataFrame
                # For logging, we'll extract specific values later
            if self.config["indicators"].get("stochastic_oscillator"):
                stoch_osc_vals = self._calculate_stochastic_oscillator()
                self.indicator_values["stoch_osc_vals"] = stoch_osc_vals # Store DataFrame
                # For logging, we'll extract specific values later

        def _select_weight_set(self) -> Dict[str, float]:
            """
            Selects a weight set (e.g., low_volatility, high_volatility) based on current ATR.
            """
            # Use the atr_value that was pre-calculated in _calculate_all_indicators
            if self.atr_value > self.config["atr_change_threshold"]:
                self.logger.info(f"{NEON_YELLOW} Market detected as HIGH VOLATILITY (ATR: {self.atr_value:.4f}). Using 'high_volatility' weights.{RESET}")
                return self.weight_sets.get("high_volatility", self.weight_sets["low_volatility"])
            self.logger.info(f"{NEON_BLUE} Market detected as LOW VOLATILITY (ATR: {self.atr_value:.4f}). Using 'low_volatility' weights.{RESET}")
            return self.weight_sets["low_volatility"]

        def analyze(self, current_price: Decimal, timestamp: str, order_book: Dict[str, Any]):
            """
            Performs comprehensive analysis, calculates indicators, and logs the findings.
            This method populates `self.indicator_values` and generates the output string.
            It does NOT generate the final signal; that is done by `generate_trading_signal`.
            """
            # Ensure Decimal type for price calculations
            current_price_dec = Decimal(str(current_price))
            high_dec = Decimal(str(self.df["high"].max()))
            low_dec = Decimal(str(self.df["low"].min()))
            close_dec = Decimal(str(self.df["close"].iloc[-1]))

            # Calculate all indicators for the current cycle
            self._calculate_all_indicators()

            # Calculate Support/Resistance Levels
            self.calculate_fibonacci_retracement(high_dec, low_dec, current_price_dec)
            self.calculate_pivot_points(high_dec, low_dec, close_dec)
            nearest_supports, nearest_resistances = self.find_nearest_levels(current_price_dec)

            # Order Book Analysis
            has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details = \
                self.analyze_order_book_walls(order_book)
            self.indicator_values["order_book_walls"] = {
                "bullish": has_bullish_wall, "bearish": has_bearish_wall,
                "bullish_details": bullish_wall_details, "bearish_details": bearish_wall_details
            }

            # Prepare output string
            output = f"""
    {NEON_BLUE}Exchange:{RESET} Bybit
    {NEON_BLUE}Symbol:{RESET} {self.symbol}
    {NEON_BLUE}Interval:{RESET} {self.interval}
    {NEON_BLUE}Timestamp:{RESET} {timestamp}
    {NEON_BLUE}Price History:{RESET} {self.df['close'].iloc[-3]:.2f} | {self.df['close'].iloc[-2]:.2f} | {self.df['close'].iloc[-1]:.2f}
    {NEON_BLUE}Volume History:{RESET} {self.df['volume'].iloc[-3]:,.0f} | {self.df['volume'].iloc[-2]:,.0f} | {self.df['volume'].iloc[-1]:,.0f}
    {NEON_BLUE}Current Price:{RESET} {current_price_dec:.5f}
    {NEON_BLUE}ATR ({self.config['atr_period']}):{RESET} {self.atr_value:.5f}
    {NEON_BLUE}Trend:{RESET} {self.indicator_values.get("mom", {}).get("trend", "N/A")} (Strength: {self.indicator_values.get("mom", {}).get("strength", 0.0):.2f})
    """
            # Append indicator interpretations
            for indicator_name, values in self.indicator_values.items():
                # Skip indicators that are already logged in a custom format or are internal
                if indicator_name in ["mom", "atr", "stoch_rsi_vals", "ema_alignment", "order_book_walls", "stoch_osc_vals"]:
                    continue
                interpreted_line = interpret_indicator(self.logger, indicator_name, values)
                if interpreted_line:
                    output += interpreted_line + "\n"

            # Custom logging for specific indicators
            if self.config["indicators"].get("ema_alignment"):
                ema_alignment_score = self.indicator_values.get("ema_alignment", 0.0)
                status = 'Bullish' if ema_alignment_score > 0 else 'Bearish' if ema_alignment_score < 0 else 'Neutral'
                output += f"{NEON_PURPLE}EMA Alignment:{RESET} Score={ema_alignment_score:.2f} ({status})\n"

            if self.config["indicators"].get("stoch_rsi") and self.indicator_values.get("stoch_rsi_vals") is not None and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_vals_df = self.indicator_values.get("stoch_rsi_vals")
                if stoch_rsi_vals_df is not None and not stoch_rsi_vals_df.empty and len(stoch_rsi_vals_df) >= 1:
                    output += f"{NEON_GREEN}Stoch RSI:{RESET} K={stoch_rsi_vals_df['k'].iloc[-1]:.2f}, D={stoch_rsi_vals_df['d'].iloc[-1]:.2f}, Stoch_RSI={stoch_rsi_vals_df['stoch_rsi'].iloc[-1]:.2f}\n"

            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_osc_vals_df = self.indicator_values.get("stoch_osc_vals")
                if stoch_osc_vals_df is not None and not stoch_osc_vals_df.empty and len(stoch_osc_vals_df) >= 1:
                    output += f"{NEON_CYAN}Stochastic Oscillator:{RESET} K={stoch_osc_vals_df['k'].iloc[-1]:.2f}, D={stoch_osc_vals_df['d'].iloc[-1]:.2f}\n"

            # Order Book Wall Logging
            output += f"""
    {NEON_BLUE}Order Book Walls:{RESET}
    """
            if has_bullish_wall:
                output += f"{NEON_GREEN}  Bullish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bullish_wall_details.items()])}\n"
            if has_bearish_wall:
                output += f"{NEON_RED}  Bearish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bearish_wall_details.items()])}\n"
            if not has_bullish_wall and not has_bearish_wall:
                output += "  No significant walls detected.\n"

            output += f"""
    {NEON_BLUE}Support and Resistance Levels:{RESET}
    """
            for s_label, s_val in nearest_supports:
                output += f"S: {s_label} ${s_val:.5f}\n"
            for r_label, r_val in nearest_resistances:
                output += f"R: {r_label} ${r_val:.5f}\n"

            self.logger.info(output)

        def generate_trading_signal(self, current_price: Decimal) -> Tuple[Union[str, None], float, List[str], Dict[str, Decimal]]:
            """
            Generates a trading signal (buy/sell) based on indicator values and configuration.
            Returns the signal, its confidence score, conditions met, and suggested SL/TP levels.
            """
            signal_score = Decimal('0.0')
            signal = None
            conditions_met: List[str] = []
            trade_levels: Dict[str, Decimal] = {}

            # --- Bullish Signal Logic ---
            # Sum weights of bullish conditions met
            if self.config["indicators"].get("stoch_rsi") and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_k = Decimal(str(self.indicator_values["stoch_rsi_vals"]['k'].iloc[-1]))
                stoch_rsi_d = Decimal(str(self.indicator_values["stoch_rsi_vals"]['d'].iloc[-1]))
                if stoch_rsi_k < self.config["stoch_rsi_oversold_threshold"] and stoch_rsi_k > stoch_rsi_d:
                    signal_score += Decimal(str(self.user_defined_weights["stoch_rsi"]))
                    signal_score += Decimal(str(self.config["stoch_rsi_confidence_boost"])) # Add confidence boost
                    conditions_met.append("Stoch RSI Oversold Crossover")

            if self.config["indicators"].get("rsi") and self.indicator_values.get("rsi") and self.indicator_values["rsi"][-1] < 30:
                signal_score += Decimal(str(self.user_defined_weights["rsi"]))
                signal_score += Decimal(str(self.config["rsi_confidence_boost"])) # Add confidence boost
                conditions_met.append("RSI Oversold")

            if self.config["indicators"].get("mfi") and self.indicator_values.get("mfi") and self.indicator_values["mfi"][-1] < 20:
                signal_score += Decimal(str(self.user_defined_weights["mfi"]))
                signal_score += Decimal(str(self.config["mfi_confidence_boost"])) # Add confidence boost
                conditions_met.append("MFI Oversold")

            if self.config["indicators"].get("ema_alignment") and self.indicator_values.get("ema_alignment", 0.0) > 0:
                signal_score += Decimal(str(self.user_defined_weights["ema_alignment"])) * Decimal(str(abs(self.indicator_values["ema_alignment"])))  # Scale by score
                conditions_met.append("Bullish EMA Alignment")

            if self.config["indicators"].get("volume_confirmation") and self._calculate_volume_confirmation():
                signal_score += Decimal(str(self.user_defined_weights["volume_confirmation"]))
                conditions_met.append("Volume Confirmation")

            if self.config["indicators"].get("divergence") and self.detect_macd_divergence() == "bullish":
                signal_score += Decimal(str(self.user_defined_weights["divergence"]))
                conditions_met.append("Bullish MACD Divergence")

            if self.indicator_values["order_book_walls"].get("bullish"):
                signal_score += Decimal(str(self.config["order_book_support_confidence_boost"]))  # Boost score for order book wall
                conditions_met.append("Bullish Order Book Wall")

            # --- New: Stochastic Oscillator Bullish Signal ---
            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_k = Decimal(str(self.indicator_values["stoch_osc_vals"]['k'].iloc[-1]))
                stoch_d = Decimal(str(self.indicator_values["stoch_osc_vals"]['d'].iloc[-1]))
                if stoch_k < 20 and stoch_k > stoch_d:  # Oversold and K crossing above D
                    signal_score += Decimal(str(self.user_defined_weights["stochastic_oscillator"]))
                    conditions_met.append("Stoch Oscillator Oversold Crossover")

            # Final check for Bullish signal
            if signal_score >= Decimal(str(self.config["signal_score_threshold"])):
                signal = "buy"
                # Calculate Stop Loss and Take Profit
                if self.atr_value > 0:
                    stop_loss = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config["stop_loss_multiple"])))
                    take_profit = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config["take_profit_multiple"])))
                    trade_levels["stop_loss"] = stop_loss.quantize(Decimal('0.00001'))
                    trade_levels["take_profit"] = take_profit.quantize(Decimal('0.00001'))

            # --- Bearish Signal Logic (similar structure) ---
            bearish_score = Decimal('0.0')
            bearish_conditions: List[str] = []

            if self.config["indicators"].get("stoch_rsi") and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_k = Decimal(str(self.indicator_values["stoch_rsi_vals"]['k'].iloc[-1]))
                stoch_rsi_d = Decimal(str(self.indicator_values["stoch_rsi_vals"]['d'].iloc[-1]))
                if stoch_rsi_k > self.config["stoch_rsi_overbought_threshold"] and stoch_rsi_k < stoch_rsi_d:
                    bearish_score += Decimal(str(self.user_defined_weights["stoch_rsi"]))
                    bearish_score += Decimal(str(self.config["stoch_rsi_confidence_boost"])) # Add confidence boost
                    bearish_conditions.append("Stoch RSI Overbought Crossover")

            if self.config["indicators"].get("rsi") and self.indicator_values.get("rsi") and self.indicator_values["rsi"][-1] > 70:
                bearish_score += Decimal(str(self.user_defined_weights["rsi"]))
                bearish_score += Decimal(str(self.config["rsi_confidence_boost"])) # Add confidence boost
                bearish_conditions.append("RSI Overbought")

            if self.config["indicators"].get("mfi") and self.indicator_values.get("mfi") and self.indicator_values["mfi"][-1] > 80:
                bearish_score += Decimal(str(self.user_defined_weights["mfi"]))
                bearish_score += Decimal(str(self.config["mfi_confidence_boost"])) # Add confidence boost
                bearish_conditions.append("MFI Overbought")

            if self.config["indicators"].get("ema_alignment") and self.indicator_values.get("ema_alignment", 0.0) < 0:
                bearish_score += Decimal(str(self.user_defined_weights["ema_alignment"])) * Decimal(str(abs(self.indicator_values["ema_alignment"])))
                bearish_conditions.append("Bearish EMA Alignment")

            if self.config["indicators"].get("divergence") and self.detect_macd_divergence() == "bearish":
                bearish_score += Decimal(str(self.user_defined_weights["divergence"]))
                bearish_conditions.append("Bearish MACD Divergence")

            if self.indicator_values["order_book_walls"].get("bearish"):
                bearish_score += Decimal(str(self.config["order_book_resistance_confidence_boost"]))
                bearish_conditions.append("Bearish Order Book Wall")

            # --- New: Stochastic Oscillator Bearish Signal ---
            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_k = Decimal(str(self.indicator_values["stoch_osc_vals"]['k'].iloc[-1]))
                stoch_d = Decimal(str(self.indicator_values["stoch_osc_vals"]['d'].iloc[-1]))
                if stoch_k > 80 and stoch_k < stoch_d:  # Overbought and K crossing below D
                    bearish_score += Decimal(str(self.user_defined_weights["stochastic_oscillator"]))
                    bearish_conditions.append("Stoch Oscillator Overbought Crossover")

            # Final check for Bearish signal (only if no bullish signal already)
            if signal is None and bearish_score >= Decimal(str(self.config["signal_score_threshold"])):
                signal = "sell"
                signal_score = bearish_score  # Use bearish score if it's the chosen signal
                conditions_met = bearish_conditions  # Use bearish conditions
                # Calculate Stop Loss and Take Profit for sell signal
                if self.atr_value > 0:
                    stop_loss = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config["stop_loss_multiple"])))
                    take_profit = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config["take_profit_multiple"])))
                    trade_levels["stop_loss"] = stop_loss.quantize(Decimal('0.00001'))
                    trade_levels["take_profit"] = take_profit.quantize(Decimal('0.00001'))

            return signal, float(signal_score), conditions_met, trade_levels


    def interpret_indicator(logger: logging.Logger, indicator_name: str, values: Union[List[float], float, Dict[str, Any]]) -> Union[str, None]:
        """
        Provides a human-readable interpretation of indicator values.
        """
        if values is None or (isinstance(values, list) and not values) or (isinstance(values, pd.DataFrame) and values.empty):
            return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No data available."
        try:
            # Convert single float values to list for consistent indexing if needed
            if isinstance(values, (float, int)):
                values = [values]
            elif isinstance(values, dict):  # For 'mom' which is a dict
                if indicator_name == "mom":
                    trend = values.get("trend", "N/A")
                    strength = values.get("strength", 0.0)
                    return f"{NEON_PURPLE}Momentum Trend:{RESET} {trend} (Strength: {strength:.2f})"
                else:
                    return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} Dictionary format not specifically interpreted."
            elif isinstance(values, pd.DataFrame):  # For stoch_rsi_vals, stoch_osc_vals which are DataFrames
                # Stoch RSI and Stochastic Oscillator interpretation is handled directly in analyze function
                return None

            # Interpret based on indicator name
            last_value = values[-1] if isinstance(values, list) and values else values[0] if isinstance(values, list) else values  # Handles single value lists too

            if indicator_name == "rsi":
                if last_value > 70:
                    return f"{NEON_RED}RSI:{RESET} Overbought ({last_value:.2f})"
                elif last_value < 30:
                    return f"{NEON_GREEN}RSI:{RESET} Oversold ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}RSI:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "mfi":
                if last_value > 80:
                    return f"{NEON_RED}MFI:{RESET} Overbought ({last_value:.2f})"
                elif last_value < 20:
                    return f"{NEON_GREEN}MFI:{RESET} Oversold ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}MFI:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "cci":
                if last_value > 100:
                    return f"{NEON_RED}CCI:{RESET} Overbought ({last_value:.2f})"
                elif last_value < -100:
                    return f"{NEON_GREEN}CCI:{RESET} Oversold ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}CCI:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "wr":
                if last_value < -80:
                    return f"{NEON_GREEN}Williams %R:{RESET} Oversold ({last_value:.2f})"
                elif last_value > -20:
                    return f"{NEON_RED}Williams %R:{RESET} Overbought ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}Williams %R:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "adx":
                if last_value > 25:
                    return f"{NEON_GREEN}ADX:{RESET} Trending ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}ADX:{RESET} Ranging ({last_value:.2f})"
            elif indicator_name == "obv":
                if len(values) >= 2:
                    return f"{NEON_BLUE}OBV:{RESET} {'Bullish' if values[-1] > values[-2] else 'Bearish' if values[-1] < values[-2] else 'Neutral'}"
                else:
                    return f"{NEON_BLUE}OBV:{RESET} {last_value:.2f} (Insufficient history for trend)"
            elif indicator_name == "adi":
                if len(values) >= 2:
                    return f"{NEON_BLUE}ADI:{RESET} {'Accumulation' if values[-1] > values[-2] else 'Distribution' if values[-1] < values[-2] else 'Neutral'}"
                else:
                    return f"{NEON_BLUE}ADI:{RESET} {last_value:.2f} (Insufficient history for trend)"
            elif indicator_name == "sma_10":
                return f"{NEON_YELLOW}SMA (10):{RESET} {last_value:.2f}"
            elif indicator_name == "psar":
                return f"{NEON_BLUE}PSAR:{RESET} {last_value:.4f} (Last Value)"
            elif indicator_name == "fve":
                return f"{NEON_BLUE}FVE:{RESET} {last_value:.2f} (Last Value)"
            elif indicator_name == "macd":
                # values for MACD are [macd_line, signal_line, histogram]
                if len(values[-1]) == 3:
                    macd_line, signal_line, histogram = values[-1][0], values[-1][1], values[-1][2]
                    return f"{NEON_GREEN}MACD:{RESET} MACD={macd_line:.2f}, Signal={signal_line:.2f}, Histogram={histogram:.2f}"
                else:
                    return f"{NEON_RED}MACD:{RESET} Calculation issue."
            else:
                return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No specific interpretation available."
        except (TypeError, IndexError, KeyError, ValueError) as e:
            logger.error(f"{NEON_RED}Error interpreting {indicator_name}: {e}. Values: {values}{RESET}")
            return f"{NEON_RED}{indicator_name.upper()}:{RESET} Interpretation error."


    def main():
        """
        Main function to run the trading analysis bot.
        Handles user input, data fetching, analysis, and signal generation loop.
        """
        if not API_KEY or not API_SECRET:
            logger.error(f"{NEON_RED} BYBIT_API_KEY and BYBIT_API_SECRET must be set in your .env file. {RESET}")
            return

        symbol_input = input(f"{NEON_BLUE} Enter trading symbol (e.g., BTCUSDT): {RESET}").upper().strip()
        symbol = symbol_input if symbol_input else "BTCUSDT"

        interval_input = input(f"{NEON_BLUE} Enter timeframe (e.g., {', '.join(VALID_INTERVALS)} or press Enter for default {CONFIG['interval']}): {RESET}").strip()
        interval = interval_input if interval_input and interval_input in VALID_INTERVALS else CONFIG["interval"]

        # Setup a dedicated logger for this symbol's activities
        symbol_logger = setup_custom_logger(symbol)
        symbol_logger.info(f"{NEON_BLUE} Starting analysis for {symbol} with interval {interval}{RESET}")

        last_signal_time = 0.0  # Tracks the last time a signal was triggered for cooldown
        last_order_book_fetch_time = 0.0  # Tracks last order book fetch time for debouncing

        while True:
            try:
                current_price = fetch_current_price(symbol, API_KEY, API_SECRET, symbol_logger)
                if current_price is None:
                    symbol_logger.error(f"{NEON_RED} Failed to fetch current price for {symbol}. Skipping cycle. {RESET}")
                    time.sleep(CONFIG["retry_delay"])
                    continue

                df = fetch_klines(symbol, interval, API_KEY, API_SECRET, symbol_logger, limit=200)
                if df.empty:
                    symbol_logger.error(f"{NEON_RED} Failed to fetch Kline data for {symbol}. Skipping cycle. {RESET}")
                    time.sleep(CONFIG["retry_delay"])
                    continue

                # Debounce order book fetching to reduce API calls
                order_book_data = None
                if time.time() - last_order_book_fetch_time >= CONFIG["order_book_debounce_s"]:
                    order_book_data = fetch_order_book(symbol, API_KEY, API_SECRET, symbol_logger, limit=CONFIG["order_book_depth_to_check"])
                    last_order_book_fetch_time = time.time()
                else:
                    symbol_logger.debug(f"{NEON_YELLOW} Order book fetch debounced. Next fetch in {CONFIG['order_book_debounce_s'] - (time.time() - last_order_book_fetch_time):.1f}s{RESET}")

                analyzer = TradingAnalyzer(df, CONFIG, symbol_logger, symbol, interval)
                timestamp = datetime.now(TIMEZONE).strftime("%Y-%m-%d %H:%M:%S %Z")

                # Perform analysis and log the current state of indicators
                analyzer.analyze(current_price, timestamp, order_book_data)

                # Generate trading signal based on the analysis
                current_time_seconds = time.time()
                signal, confidence, conditions_met, trade_levels = analyzer.generate_trading_signal(current_price)

                if signal and (current_time_seconds - last_signal_time >= CONFIG["signal_cooldown_s"]):
                    symbol_logger.info(f"\n{NEON_PURPLE}--- TRADING SIGNAL TRIGGERED ---{RESET}")
                    symbol_logger.info(f"{NEON_BLUE} Signal:{RESET} {signal.upper()} (Confidence: {confidence:.2f})")
                    symbol_logger.info(f"{NEON_BLUE} Conditions Met:{RESET} {', '.join(conditions_met) if conditions_met else 'None'}")
                    if trade_levels:
                        symbol_logger.info(f"{NEON_GREEN} Suggested Stop Loss:{RESET} {trade_levels.get('stop_loss'):.5f}")
                        symbol_logger.info(f"{NEON_GREEN} Suggested Take Profit:{RESET} {trade_levels.get('take_profit'):.5f}")
                    symbol_logger.info(f"{NEON_YELLOW} --- Placeholder: Order placement logic would be here for {signal.upper()} signal ---{RESET}")
                    last_signal_time = current_time_seconds  # Update last signal time

                time.sleep(CONFIG["analysis_interval"])

            except requests.exceptions.RequestException as e:
                symbol_logger.error(f"{NEON_RED} Network or API communication error: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}")
                time.sleep(CONFIG["retry_delay"])
            except KeyboardInterrupt:
                symbol_logger.info(f"{NEON_YELLOW} Analysis stopped by user. {RESET}")
                break
            except Exception as e:
                symbol_logger.exception(f"{NEON_RED} An unexpected error occurred: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}")
                time.sleep(CONFIG["retry_delay"])


    if __name__ == "__main__":
        main()
    ```
- role: system
  content: |-
    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a trading bot for Bybit, performing technical analysis and generating trade signals. Key features include:

    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from a `config.json` file, allowing customization of intervals, indicator periods, and signal weights. It handles missing or corrupt config files by loading defaults.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets (e.g., "low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, along with confidence scores and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    The refactoring focused on improving logical flow, ensuring consistent data handling (especially with `Decimal`), and adjusting configuration parameters for clarity.
- role: user
  content: merge with .file whale.py
- role: assistant
  content: |-
    Okay, I will provide the complete `whale.py` file, incorporating all the refactoring and ensuring it's a single, runnable script.

    This includes a basic `setup_custom_logger` function directly within `whale.py` for self-containment, as the original prompt mentioned `from logger_config import setup_custom_logger`. If you have a more complex `logger_config.py` file, you would keep that separate and ensure it's in the same directory as `whale.py`.

    ```python
    import os
    import logging
    import requests
    import pandas as pd
    import numpy as np
    from datetime import datetime
    import hmac
    import hashlib
    import time
    from dotenv import load_dotenv
    from typing import Dict, Tuple, List, Union, Any
    from colorama import init, Fore, Style
    from zoneinfo import ZoneInfo
    from decimal import Decimal, getcontext, InvalidOperation
    import json

    # --- Logger Configuration (Minimal, for self-containment) ---
    def setup_custom_logger(name):
        """Sets up a custom logger with console and file handlers."""
        log_file = os.path.join(LOG_DIRECTORY, f"{name}.log")

        formatter = logging.Formatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )

        handler = logging.FileHandler(log_file)
        handler.setFormatter(formatter)

        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)

        logger = logging.getLogger(name)
        logger.setLevel(logging.INFO) # Set default level to INFO
        logger.addHandler(handler)
        logger.addHandler(console_handler) # Add console output
        return logger

    # --- Configuration & Constants ---

    # Set Decimal precision for financial calculations to avoid floating point errors
    getcontext().prec = 10

    # Initialize colorama for cross-platform colored terminal output
    init(autoreset=True)

    # Load environment variables from .env file
    load_dotenv()

    # --- Color Codex ---
    NEON_GREEN = Fore.LIGHTGREEN_EX
    NEON_BLUE = Fore.CYAN
    NEON_PURPLE = Fore.MAGENTA
    NEON_YELLOW = Fore.YELLOW
    NEON_RED = Fore.LIGHTRED_EX
    RESET = Style.RESET_ALL

    # --- API & Bot Settings ---
    API_KEY = os.getenv("BYBIT_API_KEY")
    API_SECRET = os.getenv("BYBIT_API_SECRET")
    BASE_URL = os.getenv("BYBIT_BASE_URL", "https://api.bybit.com")
    CONFIG_FILE = "config.json"
    LOG_DIRECTORY = "bot_logs"
    TIMEZONE = ZoneInfo("America/Chicago")  # Using a specific timezone for consistency
    MAX_API_RETRIES = 3
    RETRY_DELAY_SECONDS = 5
    VALID_INTERVALS = ["1", "3", "5", "15", "30", "60", "120", "240", "D", "W", "M"]
    RETRY_ERROR_CODES = [429, 500, 502, 503, 504]  # HTTP status codes to trigger a retry

    # Ensure log directory exists
    os.makedirs(LOG_DIRECTORY, exist_ok=True)

    # Setup the main application logger
    logger = setup_custom_logger('whalebot_main')


    def load_config(filepath: str) -> dict:
        """
        Loads configuration from a JSON file, merging with default values.
        If the file is not found or is invalid, it creates one with default settings.
        """
        default_config = {
            "interval": "15",
            "analysis_interval": 30,  # Time in seconds between main analysis cycles
            "retry_delay": 5,  # Delay in seconds for API retries
            "momentum_period": 10,
            "momentum_ma_short": 12,
            "momentum_ma_long": 26,
            "volume_ma_period": 20,
            "atr_period": 14,
            "trend_strength_threshold": 0.4,
            "sideways_atr_multiplier": 1.5,
            "signal_score_threshold": 1.0,  # Minimum combined weight for a signal to be valid
            "indicators": {
                "ema_alignment": True,
                "momentum": True,
                "volume_confirmation": True,
                "divergence": True,
                "stoch_rsi": True,
                "rsi": True,
                "macd": True,
                "vwap": False,
                "obv": True,
                "adi": True,
                "cci": True,
                "wr": True,
                "adx": True,
                "psar": True,
                "fve": True,
                "sma_10": False,
                "mfi": True,
                "stochastic_oscillator": True,
            },
            "weight_sets": {
                "low_volatility": {  # Weights for a low volatility market environment
                    "ema_alignment": 0.3,
                    "momentum": 0.2,
                    "volume_confirmation": 0.2,
                    "divergence": 0.1,
                    "stoch_rsi": 0.5,
                    "rsi": 0.3,
                    "macd": 0.3,
                    "vwap": 0.0,
                    "obv": 0.1,
                    "adi": 0.1,
                    "cci": 0.1,
                    "wr": 0.1,
                    "adx": 0.1,
                    "psar": 0.1,
                    "fve": 0.2,
                    "sma_10": 0.0,
                    "mfi": 0.3,
                    "stochastic_oscillator": 0.4,
                },
                "high_volatility": {  # Weights for a high volatility market environment
                    "ema_alignment": 0.1,
                    "momentum": 0.4,
                    "volume_confirmation": 0.1,
                    "divergence": 0.2,
                    "stoch_rsi": 0.4,
                    "rsi": 0.4,
                    "macd": 0.4,
                    "vwap": 0.0,
                    "obv": 0.1,
                    "adi": 0.1,
                    "cci": 0.1,
                    "wr": 0.1,
                    "adx": 0.1,
                    "psar": 0.1,
                    "fve": 0.3,
                    "sma_10": 0.0,
                    "mfi": 0.4,
                    "stochastic_oscillator": 0.3,
                }
            },
            "stoch_rsi_oversold_threshold": 20,
            "stoch_rsi_overbought_threshold": 80,
            "stoch_rsi_confidence_boost": 0.5,  # Additional boost for strong Stoch RSI signals (changed to float)
            "stoch_rsi_mandatory": False,  # If true, Stoch RSI must be a confirming factor
            "rsi_confidence_boost": 0.2, # Changed to float
            "mfi_confidence_boost": 0.2, # Changed to float
            "order_book_support_confidence_boost": 0.3, # Changed to float
            "order_book_resistance_confidence_boost": 0.3, # Changed to float
            "stop_loss_multiple": 1.5,  # Multiplier for ATR to determine stop loss distance
            "take_profit_multiple": 1.0,  # Multiplier for ATR to determine take profit distance
            "order_book_wall_threshold_multiplier": 2.0,  # Multiplier for average volume to identify a "wall"
            "order_book_depth_to_check": 10,  # Number of order book levels to check for walls
            "price_change_threshold": 0.005,  # % change in price to consider significant
            "atr_change_threshold": 0.005,  # % change in ATR to consider significant volatility change
            "signal_cooldown_s": 60,  # Seconds to wait before generating another signal
            "order_book_debounce_s": 10,  # Seconds to wait between order book API calls
            "ema_short_period": 12,
            "ema_long_period": 26,
            "volume_confirmation_multiplier": 1.5,  # Volume must be this many times average volume for confirmation
            "indicator_periods": {
                "rsi": 14,
                "mfi": 14,
                "cci": 20,
                "williams_r": 14,
                "adx": 14,
                "stoch_rsi_period": 14,  # Period for RSI calculation within Stoch RSI
                "stoch_rsi_k_period": 3,  # Smoothing period for %K line
                "stoch_rsi_d_period": 3,  # Smoothing period for %D line (signal line)
                "momentum": 10,
                "momentum_ma_short": 12,
                "momentum_ma_long": 26,
                "volume_ma": 20,
                "atr": 14,
                "sma_10": 10,
                "fve_price_ema": 10,  # EMA period for FVE price component
                "fve_obv_sma": 20,  # SMA period for OBV normalization
                "fve_atr_sma": 20,  # SMA period for ATR normalization
                "stoch_osc_k": 14,  # Stochastic Oscillator K period
                "stoch_osc_d": 3,  # Stochastic Oscillator D period
            },
            "order_book_analysis": {
                "enabled": True,
                "wall_threshold_multiplier": 2.0,
                "depth_to_check": 10,
                "support_boost": 0.3, # Changed to float
                "resistance_boost": 0.3, # Changed to float
            },
            "trailing_stop_loss": {
                "enabled": False,  # Disabled by default
                "initial_activation_percent": 0.5,  # Activate trailing stop after price moves X% in favor
                "trailing_stop_multiple_atr": 1.5  # Trail stop based on ATR multiple
            },
            "take_profit_scaling": {
                "enabled": False,  # Disabled by default
                "targets": [
                    {"level": 1.5, "percentage": 0.25},  # Sell 25% when price hits 1.5x ATR TP
                    {"level": 2.0, "percentage": 0.50}  # Sell 50% of remaining when price hits 2.0x ATR TP
                ]
            }
        }
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                config = json.load(f)
                # Merge loaded config with defaults. Prioritize loaded values, but ensure all default keys exist.
                merged_config = {**default_config, **config}

                # Recursively merge nested dictionaries (like 'indicators' and 'weight_sets')
                for key, default_val in default_config.items():
                    if isinstance(default_val, dict) and key in config and isinstance(config[key], dict):
                        merged_config[key] = {**default_val, **config[key]}

                # Basic validation for interval and analysis_interval
                if merged_config.get("interval") not in VALID_INTERVALS:
                    logger.warning(f"{NEON_YELLOW} Invalid 'interval' in config, using default: {default_config['interval']}{RESET}")
                    merged_config["interval"] = default_config["interval"]
                if not isinstance(merged_config.get("analysis_interval"), int) or merged_config.get("analysis_interval") <= 0:
                    logger.warning(f"{NEON_YELLOW} Invalid 'analysis_interval' in config, using default: {default_config['analysis_interval']}{RESET}")
                    merged_config["analysis_interval"] = default_config["analysis_interval"]

                return merged_config
        except FileNotFoundError:
            logger.warning(f"{NEON_YELLOW} Config file not found, loading defaults and creating {filepath}{RESET}")
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            return default_config
        except json.JSONDecodeError:
            logger.error(f"{NEON_RED} Invalid JSON in config file, loading defaults. {RESET}")
            # Optionally, back up the corrupt file before overwriting
            try:
                os.rename(filepath, f"{filepath}.bak_{int(time.time())}")
                logger.info(f"{NEON_YELLOW} Backed up corrupt config file to {filepath}.bak_{int(time.time())}{RESET}")
            except OSError as e:
                logger.error(f"{NEON_RED} Failed to backup corrupt config file: {e}{RESET}")
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            return default_config


    # Load the configuration
    CONFIG = load_config(CONFIG_FILE)


    def generate_signature(api_secret: str, params: dict) -> str:
        """Generates the HMAC SHA256 signature for Bybit API requests."""
        # Ensure params are sorted by key for consistent signature generation
        param_str = "&".join([f"{key}={value}" for key, value in sorted(params.items())])
        return hmac.new(api_secret.encode(), param_str.encode(), hashlib.sha256).hexdigest()


    def handle_api_error(response: requests.Response, logger: logging.Logger) -> None:
        """Logs detailed API error responses."""
        logger.error(f"{NEON_RED} API request failed with status code: {response.status_code}{RESET}")
        try:
            error_json = response.json()
            logger.error(f"{NEON_RED} Error details: {error_json}{RESET}")
        except json.JSONDecodeError:
            logger.error(f"{NEON_RED} Response text: {response.text}{RESET}")


    def bybit_request(method: str, endpoint: str, api_key: str, api_secret: str, params: Dict[str, Any] = None, logger: logging.Logger = None) -> Union[dict, None]:
        """
        Sends a signed request to the Bybit API with retry logic.

        Args:
            method (str): HTTP method (e.g., "GET", "POST").
            endpoint (str): API endpoint path.
            api_key (str): Your Bybit API key.
            api_secret (str): Your Bybit API secret.
            params (Dict[str, Any], optional): Dictionary of request parameters. Defaults to None.
            logger (logging.Logger, optional): Logger instance for logging. Defaults to None.

        Returns:
            Union[dict, None]: JSON response data if successful, None otherwise.
        """
        params = params or {}
        # Bybit API V5 requires timestamp in milliseconds
        params['timestamp'] = str(int(time.time() * 1000))
        signature = generate_signature(api_secret, params)
        headers = {
            "X-BAPI-API-KEY": api_key,
            "X-BAPI-SIGN": signature,
            "X-BAPI-TIMESTAMP": params['timestamp'],
            "Content-Type": "application/json"
        }
        url = f"{BASE_URL}{endpoint}"

        for retry in range(MAX_API_RETRIES):
            try:
                response = requests.request(
                    method,
                    url,
                    headers=headers,
                    params=params if method == "GET" else None,
                    json=params if method == "POST" else None,
                    timeout=10  # Set a timeout for requests
                )
                response.raise_for_status()  # Raises HTTPError for bad responses (4xx or 5xx)

                # Check for Bybit specific error codes within a successful HTTP response
                response_json = response.json()
                if response_json.get("retCode") != 0:
                    if logger:
                        logger.error(f"{NEON_RED} Bybit API Error: {response_json.get('retMsg', 'Unknown error')}. Response: {response_json}{RESET}")
                    return None

                return response_json

            except requests.exceptions.HTTPError as e:
                if e.response.status_code in RETRY_ERROR_CODES:
                    if logger:
                        logger.warning(f"{NEON_YELLOW} API Error {e.response.status_code} ({e.response.reason}), retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}")
                    time.sleep(RETRY_DELAY_SECONDS * (2**retry))  # Exponential backoff
                else:
                    if logger:
                        handle_api_error(e.response, logger)
                    return None
            except requests.exceptions.RequestException as e:
                if logger:
                    logger.error(f"{NEON_RED} Request exception: {e}, retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}")
                time.sleep(RETRY_DELAY_SECONDS * (2**retry))

        if logger:
            logger.error(f"{NEON_RED} Max retries reached for {method} {endpoint}{RESET}")
        return None


    def fetch_current_price(symbol: str, api_key: str, api_secret: str, logger: logging.Logger) -> Union[Decimal, None]:
        """Fetches the current last traded price for a given symbol."""
        endpoint = "/v5/market/tickers"
        params = {"category": "linear", "symbol": symbol}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result"):
            tickers = response_data["result"].get("list")
            if tickers:
                for ticker in tickers:
                    if ticker.get("symbol") == symbol:
                        last_price = ticker.get("lastPrice")
                        return Decimal(last_price) if last_price else None
        logger.error(f"{NEON_RED} Could not fetch current price for {symbol}. Response: {response_data}{RESET}")
        return None


    def fetch_klines(symbol: str, interval: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 200) -> pd.DataFrame:
        """Fetches historical K-line (candlestick) data for a given symbol and interval."""
        endpoint = "/v5/market/kline"
        params = {"symbol": symbol, "interval": interval, "limit": limit, "category": "linear"}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result") and response_data["result"].get("list"):
            data = response_data["result"]["list"]
            # Bybit's kline list order is: [timestamp, open, high, low, close, volume, turnover]
            columns = ["start_time", "open", "high", "low", "close", "volume", "turnover"]
            df = pd.DataFrame(data, columns=columns)
            df["start_time"] = pd.to_datetime(pd.to_numeric(df["start_time"]), unit="ms")
            # Convert numeric columns, coercing errors to NaN
            for col in df.columns[1:]:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            # Drop any rows that resulted in all NaNs after conversion (shouldn't happen with valid data)
            df.dropna(subset=df.columns[1:], inplace=True)
            return df.sort_values(by="start_time", ascending=True).reset_index(drop=True)  # Ensure chronological order
        logger.error(f"{NEON_RED} Failed to fetch Kline data for {symbol}, interval {interval}. Response: {response_data}{RESET}")
        return pd.DataFrame()


    def fetch_order_book(symbol: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 50) -> Union[dict, None]:
        """Fetches the order book (bids and asks) for a given symbol."""
        endpoint = "/v5/market/orderbook"
        params = {"symbol": symbol, "limit": limit, "category": "linear"}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result"):
            return response_data["result"]
        logger.warning(f"{NEON_YELLOW} Could not fetch order book for {symbol}. Response: {response_data}{RESET}")
        return None


    class TradingAnalyzer:
        """
        Performs technical analysis on candlestick data and generates trading signals.
        """
        def __init__(self, df: pd.DataFrame, config: dict, symbol_logger: logging.Logger, symbol: str, interval: str):
            self.df = df.copy()  # Work on a copy to avoid modifying original DataFrame
            self.config = config
            self.logger = symbol_logger
            self.symbol = symbol
            self.interval = interval
            self.levels: Dict[str, Any] = {}  # Stores support/resistance levels (fib, pivot)
            self.fib_levels: Dict[str, float] = {}  # Stores calculated Fibonacci levels
            self.weight_sets = config["weight_sets"]
            self.indicator_values: Dict[str, Any] = {}  # Stores calculated indicator values
            self.atr_value: float = 0.0  # Stores the latest ATR value
            self.user_defined_weights: Dict[str, float] = {} # To be selected dynamically

        def _safe_series_operation(self, column: str, operation: str, window: int = None, series: pd.Series = None) -> pd.Series:
            """Helper to safely perform operations on DataFrame columns or provided series."""
            if series is not None:
                data_series = series
            elif column in self.df.columns:
                data_series = self.df[column]
            else:
                self.logger.error(f"{NEON_RED} Missing '{column}' column for {operation} calculation.{RESET}")
                return pd.Series(dtype=float)

            if data_series.empty:
                return pd.Series(dtype=float)

            try:
                if operation == "sma":
                    return data_series.rolling(window=window).mean()
                elif operation == "ema":
                    return data_series.ewm(span=window, adjust=False).mean()
                elif operation == "max":
                    return data_series.rolling(window=window).max()
                elif operation == "min":
                    return data_series.rolling(window=window).min()
                elif operation == "diff":
                    return data_series.diff(window)
                elif operation == "abs_diff_mean":
                    return data_series.rolling(window=window).apply(lambda x: np.abs(x - x.mean()).mean(), raw=True)
                elif operation == "cumsum":
                    return data_series.cumsum()
                else:
                    self.logger.error(f"{NEON_RED} Unsupported series operation: {operation}{RESET}")
                    return pd.Series(dtype=float)
            except Exception as e:
                self.logger.error(f"{NEON_RED} Error during {operation} calculation on {column}: {e}{RESET}")
                return pd.Series(dtype=float)

        def _calculate_sma(self, window: int, series: pd.Series = None) -> pd.Series:
            """Calculates Simple Moving Average (SMA). Can operate on a specified series or 'close' price."""
            return self._safe_series_operation('close', 'sma', window, series)

        def _calculate_ema(self, window: int, series: pd.Series = None) -> pd.Series:
            """Calculates Exponential Moving Average (EMA). Can operate on a specified series or 'close' price."""
            return self._safe_series_operation('close', 'ema', window, series)

        def _calculate_ema_alignment(self) -> float:
            """
            Calculates an EMA alignment score.
            Score is 1.0 for strong bullish alignment, -1.0 for strong bearish, 0.0 for neutral.
            """
            ema_short = self._calculate_ema(self.config["ema_short_period"])
            ema_long = self._calculate_ema(self.config["ema_long_period"])

            if ema_short.empty or ema_long.empty or len(self.df) < max(self.config["ema_short_period"], self.config["ema_long_period"]):
                return 0.0

            latest_short_ema = Decimal(str(ema_short.iloc[-1]))
            latest_long_ema = Decimal(str(ema_long.iloc[-1]))

            # Check for consistent alignment over the last few bars (e.g., 3 bars)
            alignment_period = 3
            if len(ema_short) < alignment_period or len(ema_long) < alignment_period:
                return 0.0

            bullish_aligned_count = 0
            bearish_aligned_count = 0

            for i in range(1, alignment_period + 1):
                if (ema_short.iloc[-i] > ema_long.iloc[-i] and
                    self.df["close"].iloc[-i] > ema_short.iloc[-i]):
                    bullish_aligned_count += 1
                elif (ema_short.iloc[-i] < ema_long.iloc[-i] and
                      self.df["close"].iloc[-i] < ema_short.iloc[-i]):
                    bearish_aligned_count += 1

            if bullish_aligned_count >= alignment_period - 1:  # At least (period-1) bars are aligned
                return 1.0  # Strong bullish alignment
            elif bearish_aligned_count >= alignment_period - 1:
                return -1.0  # Strong bearish alignment
            else:
                # Check for recent crossover as a weaker signal
                if latest_short_ema > latest_long_ema and ema_short.iloc[-2] <= latest_long_ema:
                    return 0.5  # Recent bullish crossover
                elif latest_short_ema < latest_long_ema and ema_short.iloc[-2] >= latest_long_ema:
                    return -0.5  # Recent bearish crossover
                return 0.0  # Neutral

        def _calculate_momentum(self, period: int = 10) -> pd.Series:
            """Calculates the Momentum indicator."""
            # Momentum is often calculated as current price - price N periods ago.
            # For signal generation, a ratio or percentage change can be more useful.
            # Here, we calculate the percentage change over the period.
            return self._safe_series_operation('close', 'diff', period) / self.df["close"].shift(period) * 100

        def _calculate_cci(self, window: int = 20, constant: float = 0.015) -> pd.Series:
            """Calculates the Commodity Channel Index (CCI)."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for CCI calculation.{RESET}")
                return pd.Series(dtype=float)
            typical_price = (self.df["high"] + self.df["low"] + self.df["close"]) / 3
            sma_typical_price = self._safe_series_operation(None, 'sma', window, typical_price)
            mean_deviation = self._safe_series_operation(None, 'abs_diff_mean', window, typical_price)
            # Avoid division by zero
            cci = (typical_price - sma_typical_price) / (constant * mean_deviation)
            return cci.replace([np.inf, -np.inf], np.nan)  # Handle potential inf values

        def _calculate_williams_r(self, window: int = 14) -> pd.Series:
            """Calculates the Williams %R indicator."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for Williams %R calculation.{RESET}")
                return pd.Series(dtype=float)
            highest_high = self._safe_series_operation('high', 'max', window)
            lowest_low = self._safe_series_operation('low', 'min', window)
            # Avoid division by zero
            denominator = (highest_high - lowest_low)
            wr = ((highest_high - self.df["close"]) / denominator) * -100
            return wr.replace([np.inf, -np.inf], np.nan)

        def _calculate_mfi(self, window: int = 14) -> pd.Series:
            """Calculates the Money Flow Index (MFI)."""
            required_columns = ['high', 'low', 'close', 'volume']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for MFI calculation.{RESET}")
                return pd.Series(dtype=float)

            typical_price = (self.df["high"] + self.df["low"] + self.df["close"]) / 3
            raw_money_flow = typical_price * self.df["volume"]

            # Calculate positive and negative money flow
            money_flow_direction = typical_price.diff()
            positive_flow = raw_money_flow.where(money_flow_direction > 0, 0)
            negative_flow = raw_money_flow.where(money_flow_direction < 0, 0)

            # Calculate sums over the window
            positive_mf = self._safe_series_operation(None, 'sma', window, positive_flow) * window  # sum not mean
            negative_mf = self._safe_series_operation(None, 'sma', window, negative_flow) * window  # sum not mean

            # Avoid division by zero
            money_ratio = positive_mf / negative_mf.replace(0, np.nan)  # Replace 0 with NaN to handle division by zero
            mfi = 100 - (100 / (1 + money_ratio))
            return mfi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0 or a sensible value

        def calculate_fibonacci_retracement(self, high: Decimal, low: Decimal, current_price: Decimal) -> Dict[str, Decimal]:
            """Calculates Fibonacci retracement levels based on a given high and low."""
            diff = high - low
            if diff <= 0:  # Handle cases where high <= low
                self.logger.warning(f"{NEON_YELLOW} Cannot calculate Fibonacci retracement: High ({high}) <= Low ({low}).{RESET}")
                self.fib_levels = {}
                self.levels = {"Support": {}, "Resistance": {}}
                return {}

            # Standard Fibonacci ratios
            fib_ratios = {
                "23.6%": Decimal('0.236'), "38.2%": Decimal('0.382'), "50.0%": Decimal('0.500'),
                "61.8%": Decimal('0.618'), "78.6%": Decimal('0.786'), "88.6%": Decimal('0.886'),
                "94.1%": Decimal('0.941')
            }
            fib_levels_calculated: Dict[str, Decimal] = {}

            # Assuming an uptrend (retracement from high to low)
            # Levels are calculated from the high, moving down
            for label, ratio in fib_ratios.items():
                level = high - (diff * ratio)
                fib_levels_calculated[f"Fib {label}"] = level.quantize(Decimal('0.00001'))  # Quantize for consistent precision

            self.fib_levels = fib_levels_calculated
            self.levels = {"Support": {}, "Resistance": {}}

            # Categorize levels as support or resistance relative to current price
            for label, value in self.fib_levels.items():
                if value < current_price:
                    self.levels["Support"][label] = value
                elif value > current_price:
                    self.levels["Resistance"][label] = value

            return self.fib_levels

        def calculate_pivot_points(self, high: Decimal, low: Decimal, close: Decimal):
            """Calculates standard Pivot Points."""
            pivot = (high + low + close) / 3
            r1 = (2 * pivot) - low
            s1 = (2 * pivot) - high
            r2 = pivot + (high - low)
            s2 = pivot - (high - low)
            r3 = high + 2 * (pivot - low)
            s3 = low - 2 * (high - pivot)

            # Quantize all pivot points for consistent precision
            precision = Decimal('0.00001')
            self.levels.update({
                "Pivot": pivot.quantize(precision),
                "R1": r1.quantize(precision), "S1": s1.quantize(precision),
                "R2": r2.quantize(precision), "S2": s2.quantize(precision),
                "R3": r3.quantize(precision), "S3": s3.quantize(precision),
            })

        def find_nearest_levels(self, current_price: Decimal, num_levels: int = 5) -> Tuple[List[Tuple[str, Decimal]], List[Tuple[str, Decimal]]]:
            """
            Finds the nearest support and resistance levels from calculated Fibonacci and Pivot Points.
            """
            all_support_levels: List[Tuple[str, Decimal]] = []
            all_resistance_levels: List[Tuple[str, Decimal]] = []

            def process_level(label: str, value: Decimal):
                if value < current_price:
                    all_support_levels.append((label, value))
                elif value > current_price:
                    all_resistance_levels.append((label, value))

            # Process all levels stored in self.levels (from Fibonacci and Pivot)
            for label, value in self.levels.items():
                if isinstance(value, dict):  # For nested levels like "Support": {"Fib 23.6%": ...}
                    for sub_label, sub_value in value.items():
                        if isinstance(sub_value, Decimal):
                            process_level(f"{label} ({sub_label})", sub_value)
                elif isinstance(value, Decimal):  # For direct levels like "Pivot"
                    process_level(label, value)

            # Sort by distance to current price and select the 'num_levels' closest
            nearest_supports = sorted(all_support_levels, key=lambda x: current_price - x[1])[:num_levels]
            nearest_resistances = sorted(all_resistance_levels, key=lambda x: x[1] - current_price)[:num_levels]

            return nearest_supports, nearest_resistances

        def _calculate_atr(self, window: int = 14) -> pd.Series:
            """Calculates the Average True Range (ATR)."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ATR calculation.{RESET}")
                return pd.Series(dtype=float)

            high_low = self.df["high"] - self.df["low"]
            high_close = abs(self.df["high"] - self.df["close"].shift())
            low_close = abs(self.df["low"] - self.df["close"].shift())

            # True Range is the maximum of the three
            tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
            return self._safe_series_operation(None, 'ema', window, tr)  # Use EMA for ATR for smoothing

        def _calculate_rsi(self, window: int = 14) -> pd.Series:
            """Calculates the Relative Strength Index (RSI)."""
            if 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' column for RSI calculation.{RESET}")
                return pd.Series(dtype=float)

            delta = self.df["close"].diff()
            gain = delta.where(delta > 0, 0)
            loss = -delta.where(delta < 0, 0)

            avg_gain = self._safe_series_operation(None, 'ema', window, gain)
            avg_loss = self._safe_series_operation(None, 'ema', window, loss)

            # Avoid division by zero
            rs = avg_gain / avg_loss.replace(0, np.nan)
            rsi = 100 - (100 / (1 + rs))
            return rsi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0

        def _calculate_stoch_rsi(self, rsi_window: int = 14, stoch_window: int = 14, k_window: int = 3, d_window: int = 3) -> pd.DataFrame:
            """Calculates Stochastic RSI (%K and %D lines)."""
            rsi = self._calculate_rsi(window=rsi_window)
            if rsi.empty:
                return pd.DataFrame()

            # Calculate StochRSI
            stoch_rsi = (rsi - self._safe_series_operation(None, 'min', stoch_window, rsi)) / \
                        (self._safe_series_operation(None, 'max', stoch_window, rsi) - self._safe_series_operation(None, 'min', stoch_window, rsi))

            # Handle division by zero for StochRSI (if max == min)
            stoch_rsi = stoch_rsi.replace([np.inf, -np.inf], np.nan).fillna(0)

            k_line = self._safe_series_operation(None, 'sma', k_window, stoch_rsi) * 100  # Scale to 0-100
            d_line = self._safe_series_operation(None, 'sma', d_window, k_line)  # Signal line for %K

            return pd.DataFrame({'stoch_rsi': stoch_rsi * 100, 'k': k_line, 'd': d_line})  # Return StochRSI also scaled

        def _calculate_stochastic_oscillator(self) -> pd.DataFrame:
            """Calculates the Stochastic Oscillator (%K and %D lines)."""
            k_period = self.config["indicator_periods"]["stoch_osc_k"]
            d_period = self.config["indicator_periods"]["stoch_osc_d"]

            if 'high' not in self.df.columns or 'low' not in self.df.columns or 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing required columns for Stochastic Oscillator calculation.{RESET}")
                return pd.DataFrame()

            highest_high = self._safe_series_operation('high', 'max', k_period)
            lowest_low = self._safe_series_operation('low', 'min', k_period)

            # Calculate %K
            k_line = (self.df['close'] - lowest_low) / (highest_high - lowest_low) * 100
            k_line = k_line.replace([np.inf, -np.inf], np.nan).fillna(0)  # Handle division by zero

            # Calculate %D (SMA of %K)
            d_line = self._safe_series_operation(None, 'sma', d_period, k_line)

            return pd.DataFrame({'k': k_line, 'd': d_line})

        def _calculate_momentum_ma(self) -> None:
            """Calculates momentum and its moving averages, and volume moving average."""
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for Momentum MA calculation.{RESET}")
                return

            self.df["momentum"] = self._calculate_momentum(period=self.config["momentum_period"])  # Use the momentum function
            self.df["momentum_ma_short"] = self._calculate_sma(self.config["momentum_ma_short"], series=self.df["momentum"])
            self.df["momentum_ma_long"] = self._calculate_sma(self.config["momentum_ma_long"], series=self.df["momentum"])
            self.df["volume_ma"] = self._calculate_sma(self.config["volume_ma_period"], series=self.df["volume"])

        def _calculate_macd(self) -> pd.DataFrame:
            """Calculates Moving Average Convergence Divergence (MACD)."""
            if 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' column for MACD calculation.{RESET}")
                return pd.DataFrame()

            ma_short = self._calculate_ema(12)
            ma_long = self._calculate_ema(26)
            macd = ma_short - ma_long
            signal = self._calculate_ema(9, series=macd)
            histogram = macd - signal
            return pd.DataFrame({'macd': macd, 'signal': signal, 'histogram': histogram})

        def detect_macd_divergence(self) -> Union[str, None]:
            """Detects bullish or bearish MACD divergence."""
            macd_df = self._calculate_macd()
            if macd_df.empty or len(self.df) < 30:  # Need sufficient data for reliable divergence
                return None

            prices = self.df["close"]
            macd_histogram = macd_df["histogram"]

            # Simple divergence check on last two bars (can be expanded for more robust detection)
            if (prices.iloc[-2] > prices.iloc[-1] and macd_histogram.iloc[-2] < macd_histogram.iloc[-1]):
                self.logger.info(f"{NEON_GREEN} Detected Bullish MACD Divergence.{RESET}")
                return "bullish"
            elif (prices.iloc[-2] < prices.iloc[-1] and macd_histogram.iloc[-2] > macd_histogram.iloc[-1]):
                self.logger.info(f"{NEON_RED} Detected Bearish MACD Divergence.{RESET}")
                return "bearish"
            return None

        def determine_trend_momentum(self) -> Dict[str, Union[str, float]]:
            """Determines the current trend and its strength based on momentum MAs and ATR."""
            if self.df.empty or len(self.df) < max(self.config["momentum_ma_long"], self.config["atr_period"]):
                return {"trend": "Insufficient Data", "strength": 0.0}

            # Ensure momentum_ma_short, momentum_ma_long, and atr_value are calculated
            if "momentum_ma_short" not in self.df.columns or "momentum_ma_long" not in self.df.columns or self.atr_value == 0:
                self.logger.warning(f"{NEON_YELLOW} Momentum MAs or ATR not available for trend calculation.{RESET}")
                return {"trend": "Neutral", "strength": 0.0}

            latest_short_ma = self.df["momentum_ma_short"].iloc[-1]
            latest_long_ma = self.df["momentum_ma_long"].iloc[-1]

            trend = "Neutral"
            if latest_short_ma > latest_long_ma:
                trend = "Uptrend"
            elif latest_short_ma < latest_long_ma:
                trend = "Downtrend"

            # Strength is normalized by ATR to make it comparable across symbols/timeframes
            strength = abs(latest_short_ma - latest_long_ma) / self.atr_value
            return {"trend": trend, "strength": strength}

        def _calculate_adx(self, window: int = 14) -> float:
            """Calculates the Average Directional Index (ADX)."""
            df_adx = self.df.copy()
            required_columns = ['high', 'low', 'close']
            if not all(col in df_adx.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ADX calculation.{RESET}")
                return 0.0

            # True Range
            df_adx["TR"] = pd.concat([
                df_adx["high"] - df_adx["low"],
                abs(df_adx["high"] - df_adx["close"].shift()),
                abs(df_adx["low"] - df_adx["close"].shift())
            ], axis=1).max(axis=1)

            # Directional Movement
            df_adx["+DM"] = np.where((df_adx["high"] - df_adx["high"].shift()) > (df_adx["low"].shift() - df_adx["low"]),
                                     np.maximum(df_adx["high"] - df_adx["high"].shift(), 0), 0)
            df_adx["-DM"] = np.where((df_adx["low"].shift() - df_adx["low"]) > (df_adx["high"] - df_adx["high"].shift()),
                                     np.maximum(df_adx["low"].shift() - df_adx["low"], 0), 0)

            # Smoothed True Range and Directional Movement (using EMA)
            df_adx["TR_ema"] = self._calculate_ema(window, series=df_adx["TR"])
            df_adx["+DM_ema"] = self._calculate_ema(window, series=df_adx["+DM"])
            df_adx["-DM_ema"] = self._calculate_ema(window, series=df_adx["-DM"])

            # Directional Indicators
            df_adx["+DI"] = 100 * (df_adx["+DM_ema"] / df_adx["TR_ema"].replace(0, np.nan))
            df_adx["-DI"] = 100 * (df_adx["-DM_ema"] / df_adx["TR_ema"].replace(0, np.nan))

            # Directional Movement Index (DX)
            df_adx["DX"] = 100 * abs(df_adx["+DI"] - df_adx["-DI"]) / (df_adx["+DI"] + df_adx["-DI"]).replace(0, np.nan)

            # Average Directional Index (ADX)
            adx_value = self._calculate_ema(window, series=df_adx["DX"]).iloc[-1]
            return adx_value if not pd.isna(adx_value) else 0.0

        def _calculate_obv(self) -> pd.Series:
            """Calculates On-Balance Volume (OBV)."""
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for OBV calculation.{RESET}")
                return pd.Series(dtype=float)

            obv = pd.Series(0, index=self.df.index, dtype=float)
            obv.iloc[0] = self.df["volume"].iloc[0]  # Initialize with first volume

            for i in range(1, len(self.df)):
                if self.df["close"].iloc[i] > self.df["close"].iloc[i - 1]:
                    obv.iloc[i] = obv.iloc[i - 1] + self.df["volume"].iloc[i]
                elif self.df["close"].iloc[i] < self.df["close"].iloc[i - 1]:
                    obv.iloc[i] = obv.iloc[i - 1] - self.df["volume"].iloc[i]
                else:
                    obv.iloc[i] = obv.iloc[i - 1]  # No change if close price is the same

            return obv

        def _calculate_adi(self) -> pd.Series:
            """Calculates Accumulation/Distribution Index (ADI)."""
            required_columns = ['high', 'low', 'close', 'volume']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ADI calculation.{RESET}")
                return pd.Series(dtype=float)

            # Money Flow Multiplier (MFM)
            mfm_denominator = (self.df["high"] - self.df["low"])
            mfm = ((self.df["close"] - self.df["low"]) - (self.df["high"] - self.df["close"])) / mfm_denominator.replace(0, np.nan)
            mfm.fillna(0, inplace=True)  # If high == low, MFM is 0

            # Money Flow Volume (MFV)
            money_flow_volume = mfm * self.df["volume"]

            # Accumulation/Distribution Line (ADL) is the cumulative sum of MFV
            return self._safe_series_operation(None, 'cumsum', series=money_flow_volume)

        def _calculate_psar(self, acceleration: float = 0.02, max_acceleration: float = 0.2) -> pd.Series:
            """Calculates Parabolic SAR (PSAR)."""
            psar = pd.Series(index=self.df.index, dtype="float64")
            if self.df.empty or len(self.df) < 2:  # Need at least two bars to start
                return psar

            # Initial values
            psar.iloc[0] = self.df["close"].iloc[0]  # Start PSAR at first close
            # Determine initial trend based on first two bars
            if self.df["close"].iloc[1] > self.df["close"].iloc[0]:
                trend = 1  # Uptrend
                ep = self.df["high"].iloc[0]  # Extreme Point
            else:
                trend = -1  # Downtrend
                ep = self.df["low"].iloc[0]  # Extreme Point
            af = acceleration  # Acceleration Factor

            for i in range(1, len(self.df)):
                current_high = self.df["high"].iloc[i]
                current_low = self.df["low"].iloc[i]
                prev_psar = psar.iloc[i - 1]

                if trend == 1:  # Uptrend
                    psar.iloc[i] = prev_psar + af * (ep - prev_psar)
                    # Check if PSAR should be below current low
                    psar.iloc[i] = min(psar.iloc[i], current_low, self.df["low"].iloc[i - 1] if i > 1 else current_low)
                    if current_high > ep:  # New extreme high
                        ep = current_high
                        af = min(af + acceleration, max_acceleration)
                    if current_low < psar.iloc[i]:  # Trend reversal
                        trend = -1
                        psar.iloc[i] = ep  # PSAR jumps to old EP
                        ep = current_low
                        af = acceleration
                elif trend == -1:  # Downtrend
                    psar.iloc[i] = prev_psar + af * (ep - prev_psar)
                    # Check if PSAR should be above current high
                    psar.iloc[i] = max(psar.iloc[i], current_high, self.df["high"].iloc[i - 1] if i > 1 else current_high)
                    if current_low < ep:  # New extreme low
                        ep = current_low
                        af = min(af + acceleration, max_acceleration)
                    if current_high > psar.iloc[i]:  # Trend reversal
                        trend = 1
                        psar.iloc[i] = ep  # PSAR jumps to old EP
                        ep = current_high
                        af = acceleration
            return psar

        def _calculate_fve(self) -> pd.Series:
            """
            Calculates a "Fictional Value Estimate" (FVE) by combining price, volume, and volatility.
            This is a custom composite indicator for demonstrative purposes.
            """
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for FVE calculation.{RESET}")
                return pd.Series(dtype=float)

            try:
                # Ensure enough data for calculations
                min_data_points = max(20, self.config["atr_period"])
                if len(self.df) < min_data_points:
                    self.logger.warning(f"{NEON_YELLOW} Insufficient data for FVE calculation. Need at least {min_data_points} bars.{RESET}")
                    # Return a series of NaNs matching the DataFrame length if data is insufficient
                    return pd.Series([np.nan] * len(self.df), index=self.df.index)

                # Components calculation, ensuring Decimal usage where appropriate
                # Use Decimal for price-related calculations
                price_component = self._calculate_ema(window=self.config["indicator_periods"]["fve_price_ema"])  # Short term price trend
                obv_component = self._calculate_obv()
                atr_component = self._calculate_atr(window=self.config["indicator_periods"]["atr"])

                # Convert components to Decimal for calculations if they are not already
                # This is crucial to avoid numpy.float64 issues with Decimal operations
                price_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in price_component], index=price_component.index)
                obv_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in obv_component], index=obv_component.index)
                atr_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in atr_component], index=atr_component.index)

                # Normalize components to prevent one from dominating excessively
                # Use Decimal for mean and std calculation to maintain precision
                price_mean = Decimal(str(price_component_dec.mean())) if pd.notna(price_component_dec.mean()) else Decimal('NaN')
                price_std = Decimal(str(price_component_dec.std())) if pd.notna(price_component_dec.std()) else Decimal('NaN')
                obv_mean = Decimal(str(obv_component_dec.mean())) if pd.notna(obv_component_dec.mean()) else Decimal('NaN')
                obv_std = Decimal(str(obv_component_dec.std())) if pd.notna(obv_component_dec.std()) else Decimal('NaN')
                atr_mean = Decimal(str(atr_component_dec.mean())) if pd.notna(atr_component_dec.mean()) else Decimal('NaN')
                atr_std = Decimal(str(atr_component_dec.std())) if pd.notna(atr_component_dec.std()) else Decimal('NaN')

                # Handle potential division by zero for std dev
                price_norm = (price_component_dec - price_mean) / price_std if price_std != 0 else pd.Series(Decimal('0'), index=self.df.index)
                obv_norm = (obv_component_dec - obv_mean) / obv_std if obv_std != 0 else pd.Series(Decimal('0'), index=self.df.index)

                # Inverse of ATR: lower ATR means higher stability/less volatility, which can be seen as positive for trend following
                # Use Decimal for division, and handle potential division by zero for ATR
                # Calculate inverse ATR, handling division by zero safely
                atr_inverse = pd.Series([Decimal('1.0') / Decimal(str(x)) if x and x != 0 else Decimal('NaN') for x in atr_component_dec], index=self.df.index)
                # Replace infinite values resulting from division by zero with NaN
                atr_inverse = atr_inverse.replace([Decimal('Infinity'), Decimal('-Infinity')], Decimal('NaN'))

                atr_inverse_mean = Decimal(str(atr_inverse.mean())) if pd.notna(atr_inverse.mean()) else Decimal('NaN')
                atr_inverse_std = Decimal(str(atr_inverse.std())) if pd.notna(atr_inverse.std()) else Decimal('NaN')

                # Normalize ATR inverse, handling potential zero std dev
                atr_inverse_norm = (atr_inverse - atr_inverse_mean) / atr_inverse_std if atr_inverse_std != 0 else pd.Series(Decimal('0'), index=self.df.index)

                # Combine them - this formula is illustrative and should be fine-tuned
                # Higher FVE indicates more "value" or bullishness.
                # Ensure all components are aligned and handle NaNs
                fve = price_norm.fillna(Decimal('0')) + obv_norm.fillna(Decimal('0')) + atr_inverse_norm.fillna(Decimal('0'))

                # Convert back to float Series for compatibility with later operations if needed
                return pd.Series([float(x) if x != Decimal('NaN') else np.nan for x in fve], index=self.df.index)

            except Exception as e:
                self.logger.error(f"{NEON_RED} Error calculating FVE: {e}{RESET}")
                # Return a series of NaNs matching the DataFrame length in case of any error
                return pd.Series([np.nan] * len(self.df), index=self.df.index)

        def _calculate_volume_confirmation(self) -> bool:
            """
            Checks if the current volume confirms a trend (e.g., significant spike).
            Returns True if current volume is significantly higher than average.
            """
            if 'volume' not in self.df.columns or 'volume_ma' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'volume' or 'volume_ma' column for Volume Confirmation.{RESET}")
                return False
            if self.df["volume"].empty or self.df["volume_ma"].empty:
                return False

            current_volume = self.df['volume'].iloc[-1]
            average_volume = self.df['volume_ma'].iloc[-1]

            if average_volume <= 0:  # Avoid division by zero or nonsensical average
                return False

            return current_volume > average_volume * self.config["volume_confirmation_multiplier"]

        def analyze_order_book_walls(self, order_book: Dict[str, Any]) -> Tuple[bool, bool, Dict[str, Decimal], Dict[str, Decimal]]:
            """
            Analyzes order book for significant bid (support) and ask (resistance) walls.
            Returns whether bullish/bearish walls are found and the wall details.
            """
            has_bullish_wall = False
            has_bearish_wall = False
            bullish_wall_details: Dict[str, Decimal] = {}
            bearish_wall_details: Dict[str, Decimal] = {}

            if not self.config["order_book_analysis"]["enabled"]:
                return False, False, {}, {}

            if not order_book or not order_book.get('bids') or not order_book.get('asks'):
                self.logger.warning(f"{NEON_YELLOW} Order book data incomplete for wall analysis.{RESET}")
                return False, False, {}, {}

            bids = [(Decimal(price), Decimal(qty)) for price, qty in order_book['bids'][:self.config["order_book_analysis"]["depth_to_check"]]]
            asks = [(Decimal(price), Decimal(qty)) for price, qty in order_book['asks'][:self.config["order_book_analysis"]["depth_to_check"]]]

            # Calculate average quantity across relevant depth
            all_quantities = [qty for _, qty in bids + asks]
            if not all_quantities:
                return False, False, {}, {}

            # Use Decimal for sum and count, then divide to maintain precision
            total_qty = sum(all_quantities)
            avg_qty = total_qty / Decimal(str(len(all_quantities)))
            wall_threshold = avg_qty * Decimal(str(self.config["order_book_analysis"]["wall_threshold_multiplier"]))

            # Check for bullish walls (large bids below current price)
            current_price = Decimal(str(self.df["close"].iloc[-1]))
            for bid_price, bid_qty in bids:
                if bid_qty >= wall_threshold and bid_price < current_price:
                    has_bullish_wall = True
                    bullish_wall_details[f"Bid@{bid_price}"] = bid_qty
                    self.logger.info(f"{NEON_GREEN} Detected Bullish Order Book Wall: Bid {bid_qty:.2f} at {bid_price:.2f}{RESET}")
                    break  # Only need to find one significant wall

            # Check for bearish walls (large asks above current price)
            for ask_price, ask_qty in asks:
                if ask_qty >= wall_threshold and ask_price > current_price:
                    has_bearish_wall = True
                    bearish_wall_details[f"Ask@{ask_price}"] = ask_qty
                    self.logger.info(f"{NEON_RED} Detected Bearish Order Book Wall: Ask {ask_qty:.2f} at {ask_price:.2f}{RESET}")
                    break  # Only need to find one significant wall

            return has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details

        def _calculate_all_indicators(self):
            """Calculates and stores all enabled indicators for the current cycle."""
            # Pre-calculate ATR and momentum MAs first, as they are used for weight selection and trend
            atr_series = self._calculate_atr(window=self.config["atr_period"])
            if not atr_series.empty and not pd.isna(atr_series.iloc[-1]):
                self.atr_value = float(atr_series.iloc[-1])
            else:
                self.atr_value = 0.0
            self.indicator_values["atr"] = self.atr_value

            self._calculate_momentum_ma() # Populates momentum and its MAs, and volume MA

            # Now that ATR is potentially calculated, select the weight set
            self.user_defined_weights = self._select_weight_set()

            # Calculate and store other indicator values based on config
            if self.config["indicators"].get("obv"):
                obv_series = self._calculate_obv()
                self.indicator_values["obv"] = obv_series.iloc[-3:].tolist() if not obv_series.empty else []
            if self.config["indicators"].get("rsi"):
                rsi_series = self._calculate_rsi(window=self.config["indicator_periods"]["rsi"])
                self.indicator_values["rsi"] = rsi_series.iloc[-3:].tolist() if not rsi_series.empty else []
            if self.config["indicators"].get("mfi"):
                mfi_series = self._calculate_mfi(window=self.config["indicator_periods"]["mfi"])
                self.indicator_values["mfi"] = mfi_series.iloc[-3:].tolist() if not mfi_series.empty else []
            if self.config["indicators"].get("cci"):
                cci_series = self._calculate_cci(window=self.config["indicator_periods"]["cci"])
                self.indicator_values["cci"] = cci_series.iloc[-3:].tolist() if not cci_series.empty else []
            if self.config["indicators"].get("wr"):
                wr_series = self._calculate_williams_r(window=self.config["indicator_periods"]["williams_r"])
                self.indicator_values["wr"] = wr_series.iloc[-3:].tolist() if not wr_series.empty else []
            if self.config["indicators"].get("adx"):
                adx_value = self._calculate_adx(window=self.config["indicator_periods"]["adx"])
                self.indicator_values["adx"] = [adx_value]
            if self.config["indicators"].get("adi"):
                adi_series = self._calculate_adi()
                self.indicator_values["adi"] = adi_series.iloc[-3:].tolist() if not adi_series.empty else []
            if self.config["indicators"].get("momentum"):
                trend_data = self.determine_trend_momentum()
                self.indicator_values["mom"] = trend_data
            if self.config["indicators"].get("sma_10"):
                sma_series = self._calculate_sma(10)
                self.indicator_values["sma_10"] = [sma_series.iloc[-1]] if not sma_series.empty else []
            if self.config["indicators"].get("psar"):
                psar_series = self._calculate_psar()
                self.indicator_values["psar"] = psar_series.iloc[-3:].tolist() if not psar_series.empty else []
            if self.config["indicators"].get("fve"):
                fve_series = self._calculate_fve()
                if not fve_series.empty and not fve_series.isnull().all():
                    self.indicator_values["fve"] = fve_series.iloc[-3:].tolist()
                else:
                    self.indicator_values["fve"] = []
            if self.config["indicators"].get("macd"):
                macd_df = self._calculate_macd()
                self.indicator_values["macd"] = macd_df.iloc[-3:].values.tolist() if not macd_df.empty else []
            if self.config["indicators"].get("ema_alignment"):
                ema_alignment_score = self._calculate_ema_alignment()
                self.indicator_values["ema_alignment"] = ema_alignment_score
            if self.config["indicators"].get("stoch_rsi"):
                stoch_rsi_vals = self._calculate_stoch_rsi(
                    rsi_window=self.config["indicator_periods"]["stoch_rsi_period"],
                    stoch_window=self.config["indicator_periods"]["stoch_rsi_period"],
                    k_window=self.config["indicator_periods"]["stoch_rsi_k_period"],
                    d_window=self.config["indicator_periods"]["stoch_rsi_d_period"]
                )
                self.indicator_values["stoch_rsi_vals"] = stoch_rsi_vals # Store DataFrame
                # For logging, we'll extract specific values later
            if self.config["indicators"].get("stochastic_oscillator"):
                stoch_osc_vals = self._calculate_stochastic_oscillator()
                self.indicator_values["stoch_osc_vals"] = stoch_osc_vals # Store DataFrame
                # For logging, we'll extract specific values later

        def _select_weight_set(self) -> Dict[str, float]:
            """
            Selects a weight set (e.g., low_volatility, high_volatility) based on current ATR.
            """
            # Use the atr_value that was pre-calculated in _calculate_all_indicators
            if self.atr_value > self.config["atr_change_threshold"]:
                self.logger.info(f"{NEON_YELLOW} Market detected as HIGH VOLATILITY (ATR: {self.atr_value:.4f}). Using 'high_volatility' weights.{RESET}")
                return self.weight_sets.get("high_volatility", self.weight_sets["low_volatility"])
            self.logger.info(f"{NEON_BLUE} Market detected as LOW VOLATILITY (ATR: {self.atr_value:.4f}). Using 'low_volatility' weights.{RESET}")
            return self.weight_sets["low_volatility"]

        def analyze(self, current_price: Decimal, timestamp: str, order_book: Dict[str, Any]):
            """
            Performs comprehensive analysis, calculates indicators, and logs the findings.
            This method populates `self.indicator_values` and generates the output string.
            It does NOT generate the final signal; that is done by `generate_trading_signal`.
            """
            # Ensure Decimal type for price calculations
            current_price_dec = Decimal(str(current_price))
            high_dec = Decimal(str(self.df["high"].max()))
            low_dec = Decimal(str(self.df["low"].min()))
            close_dec = Decimal(str(self.df["close"].iloc[-1]))

            # Calculate all indicators for the current cycle
            self._calculate_all_indicators()

            # Calculate Support/Resistance Levels
            self.calculate_fibonacci_retracement(high_dec, low_dec, current_price_dec)
            self.calculate_pivot_points(high_dec, low_dec, close_dec)
            nearest_supports, nearest_resistances = self.find_nearest_levels(current_price_dec)

            # Order Book Analysis
            has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details = \
                self.analyze_order_book_walls(order_book)
            self.indicator_values["order_book_walls"] = {
                "bullish": has_bullish_wall, "bearish": has_bearish_wall,
                "bullish_details": bullish_wall_details, "bearish_details": bearish_wall_details
            }

            # Prepare output string
            output = f"""
    {NEON_BLUE}Exchange:{RESET} Bybit
    {NEON_BLUE}Symbol:{RESET} {self.symbol}
    {NEON_BLUE}Interval:{RESET} {self.interval}
    {NEON_BLUE}Timestamp:{RESET} {timestamp}
    {NEON_BLUE}Price History:{RESET} {self.df['close'].iloc[-3]:.2f} | {self.df['close'].iloc[-2]:.2f} | {self.df['close'].iloc[-1]:.2f}
    {NEON_BLUE}Volume History:{RESET} {self.df['volume'].iloc[-3]:,.0f} | {self.df['volume'].iloc[-2]:,.0f} | {self.df['volume'].iloc[-1]:,.0f}
    {NEON_BLUE}Current Price:{RESET} {current_price_dec:.5f}
    {NEON_BLUE}ATR ({self.config['atr_period']}):{RESET} {self.atr_value:.5f}
    {NEON_BLUE}Trend:{RESET} {self.indicator_values.get("mom", {}).get("trend", "N/A")} (Strength: {self.indicator_values.get("mom", {}).get("strength", 0.0):.2f})
    """
            # Append indicator interpretations
            for indicator_name, values in self.indicator_values.items():
                # Skip indicators that are already logged in a custom format or are internal
                if indicator_name in ["mom", "atr", "stoch_rsi_vals", "ema_alignment", "order_book_walls", "stoch_osc_vals"]:
                    continue
                interpreted_line = interpret_indicator(self.logger, indicator_name, values)
                if interpreted_line:
                    output += interpreted_line + "\n"

            # Custom logging for specific indicators
            if self.config["indicators"].get("ema_alignment"):
                ema_alignment_score = self.indicator_values.get("ema_alignment", 0.0)
                status = 'Bullish' if ema_alignment_score > 0 else 'Bearish' if ema_alignment_score < 0 else 'Neutral'
                output += f"{NEON_PURPLE}EMA Alignment:{RESET} Score={ema_alignment_score:.2f} ({status})\n"

            if self.config["indicators"].get("stoch_rsi") and self.indicator_values.get("stoch_rsi_vals") is not None and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_vals_df = self.indicator_values.get("stoch_rsi_vals")
                if stoch_rsi_vals_df is not None and not stoch_rsi_vals_df.empty and len(stoch_rsi_vals_df) >= 1:
                    output += f"{NEON_GREEN}Stoch RSI:{RESET} K={stoch_rsi_vals_df['k'].iloc[-1]:.2f}, D={stoch_rsi_vals_df['d'].iloc[-1]:.2f}, Stoch_RSI={stoch_rsi_vals_df['stoch_rsi'].iloc[-1]:.2f}\n"

            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_osc_vals_df = self.indicator_values.get("stoch_osc_vals")
                if stoch_osc_vals_df is not None and not stoch_osc_vals_df.empty and len(stoch_osc_vals_df) >= 1:
                    output += f"{NEON_CYAN}Stochastic Oscillator:{RESET} K={stoch_osc_vals_df['k'].iloc[-1]:.2f}, D={stoch_osc_vals_df['d'].iloc[-1]:.2f}\n"

            # Order Book Wall Logging
            output += f"""
    {NEON_BLUE}Order Book Walls:{RESET}
    """
            if has_bullish_wall:
                output += f"{NEON_GREEN}  Bullish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bullish_wall_details.items()])}\n"
            if has_bearish_wall:
                output += f"{NEON_RED}  Bearish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bearish_wall_details.items()])}\n"
            if not has_bullish_wall and not has_bearish_wall:
                output += "  No significant walls detected.\n"

            output += f"""
    {NEON_BLUE}Support and Resistance Levels:{RESET}
    """
            for s_label, s_val in nearest_supports:
                output += f"S: {s_label} ${s_val:.5f}\n"
            for r_label, r_val in nearest_resistances:
                output += f"R: {r_label} ${r_val:.5f}\n"

            self.logger.info(output)

        def generate_trading_signal(self, current_price: Decimal) -> Tuple[Union[str, None], float, List[str], Dict[str, Decimal]]:
            """
            Generates a trading signal (buy/sell) based on indicator values and configuration.
            Returns the signal, its confidence score, conditions met, and suggested SL/TP levels.
            """
            signal_score = Decimal('0.0')
            signal = None
            conditions_met: List[str] = []
            trade_levels: Dict[str, Decimal] = {}

            # --- Bullish Signal Logic ---
            # Sum weights of bullish conditions met
            if self.config["indicators"].get("stoch_rsi") and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_k = Decimal(str(self.indicator_values["stoch_rsi_vals"]['k'].iloc[-1]))
                stoch_rsi_d = Decimal(str(self.indicator_values["stoch_rsi_vals"]['d'].iloc[-1]))
                if stoch_rsi_k < self.config["stoch_rsi_oversold_threshold"] and stoch_rsi_k > stoch_rsi_d:
                    signal_score += Decimal(str(self.user_defined_weights["stoch_rsi"]))
                    signal_score += Decimal(str(self.config["stoch_rsi_confidence_boost"])) # Add confidence boost
                    conditions_met.append("Stoch RSI Oversold Crossover")

            if self.config["indicators"].get("rsi") and self.indicator_values.get("rsi") and self.indicator_values["rsi"][-1] < 30:
                signal_score += Decimal(str(self.user_defined_weights["rsi"]))
                signal_score += Decimal(str(self.config["rsi_confidence_boost"])) # Add confidence boost
                conditions_met.append("RSI Oversold")

            if self.config["indicators"].get("mfi") and self.indicator_values.get("mfi") and self.indicator_values["mfi"][-1] < 20:
                signal_score += Decimal(str(self.user_defined_weights["mfi"]))
                signal_score += Decimal(str(self.config["mfi_confidence_boost"])) # Add confidence boost
                conditions_met.append("MFI Oversold")

            if self.config["indicators"].get("ema_alignment") and self.indicator_values.get("ema_alignment", 0.0) > 0:
                signal_score += Decimal(str(self.user_defined_weights["ema_alignment"])) * Decimal(str(abs(self.indicator_values["ema_alignment"])))  # Scale by score
                conditions_met.append("Bullish EMA Alignment")

            if self.config["indicators"].get("volume_confirmation") and self._calculate_volume_confirmation():
                signal_score += Decimal(str(self.user_defined_weights["volume_confirmation"]))
                conditions_met.append("Volume Confirmation")

            if self.config["indicators"].get("divergence") and self.detect_macd_divergence() == "bullish":
                signal_score += Decimal(str(self.user_defined_weights["divergence"]))
                conditions_met.append("Bullish MACD Divergence")

            if self.indicator_values["order_book_walls"].get("bullish"):
                signal_score += Decimal(str(self.config["order_book_support_confidence_boost"]))  # Boost score for order book wall
                conditions_met.append("Bullish Order Book Wall")

            # --- New: Stochastic Oscillator Bullish Signal ---
            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_k = Decimal(str(self.indicator_values["stoch_osc_vals'] ['k'].iloc[-1]))
                stoch_d = Decimal(str(self.indicator_values["stoch_osc_vals'] ['d'].iloc[-1]))
                if stoch_k < 20 and stoch_k > stoch_d:  # Oversold and K crossing above D
                    signal_score += Decimal(str(self.user_defined_weights["stochastic_oscillator"]))
                    conditions_met.append("Stoch Oscillator Oversold Crossover")

            # Final check for Bullish signal
            if signal_score >= Decimal(str(self.config["signal_score_threshold"])):
                signal = "buy"
                # Calculate Stop Loss and Take Profit
                if self.atr_value > 0:
                    stop_loss = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config["stop_loss_multiple"])))
                    take_profit = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config["take_profit_multiple"])))
                    trade_levels["stop_loss"] = stop_loss.quantize(Decimal('0.00001'))
                    trade_levels["take_profit"] = take_profit.quantize(Decimal('0.00001'))

            # --- Bearish Signal Logic (similar structure) ---
            bearish_score = Decimal('0.0')
            bearish_conditions: List[str] = []

            if self.config["indicators"].get("stoch_rsi") and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_k = Decimal(str(self.indicator_values["stoch_rsi_vals"]['k'].iloc[-1]))
                stoch_rsi_d = Decimal(str(self.indicator_values["stoch_rsi_vals"]['d'].iloc[-1]))
                if stoch_rsi_k > self.config["stoch_rsi_overbought_threshold"] and stoch_rsi_k < stoch_rsi_d:
                    bearish_score += Decimal(str(self.user_defined_weights["stoch_rsi"]))
                    bearish_score += Decimal(str(self.config["stoch_rsi_confidence_boost"])) # Add confidence boost
                    bearish_conditions.append("Stoch RSI Overbought Crossover")

            if self.config["indicators"].get("rsi") and self.indicator_values.get("rsi") and self.indicator_values["rsi"][-1] > 70:
                bearish_score += Decimal(str(self.user_defined_weights["rsi"]))
                bearish_score += Decimal(str(self.config["rsi_confidence_boost"])) # Add confidence boost
                bearish_conditions.append("RSI Overbought")

            if self.config["indicators"].get("mfi") and self.indicator_values.get("mfi") and self.indicator_values["mfi"][-1] > 80:
                bearish_score += Decimal(str(self.user_defined_weights["mfi"]))
                bearish_score += Decimal(str(self.config["mfi_confidence_boost"])) # Add confidence boost
                bearish_conditions.append("MFI Overbought")

            if self.config["indicators"].get("ema_alignment") and self.indicator_values.get("ema_alignment", 0.0) < 0:
                bearish_score += Decimal(str(self.user_defined_weights["ema_alignment"])) * Decimal(str(abs(self.indicator_values["ema_alignment"])))
                bearish_conditions.append("Bearish EMA Alignment")

            if self.config["indicators"].get("divergence") and self.detect_macd_divergence() == "bearish":
                bearish_score += Decimal(str(self.user_defined_weights["divergence"]))
                bearish_conditions.append("Bearish MACD Divergence")

            if self.indicator_values["order_book_walls"].get("bearish"):
                bearish_score += Decimal(str(self.config["order_book_resistance_confidence_boost"]))
                bearish_conditions.append("Bearish Order Book Wall")

            # --- New: Stochastic Oscillator Bearish Signal ---
            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_k = Decimal(str(self.indicator_values["stoch_osc_vals"]['k'].iloc[-1]))
                stoch_d = Decimal(str(self.indicator_values["stoch_osc_vals"]['d'].iloc[-1]))
                if stoch_k > 80 and stoch_k < stoch_d:  # Overbought and K crossing below D
                    bearish_score += Decimal(str(self.user_defined_weights["stochastic_oscillator"]))
                    bearish_conditions.append("Stoch Oscillator Overbought Crossover")

            # Final check for Bearish signal (only if no bullish signal already)
            if signal is None and bearish_score >= Decimal(str(self.config["signal_score_threshold"])):
                signal = "sell"
                signal_score = bearish_score  # Use bearish score if it's the chosen signal
                conditions_met = bearish_conditions  # Use bearish conditions
                # Calculate Stop Loss and Take Profit for sell signal
                if self.atr_value > 0:
                    stop_loss = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config["stop_loss_multiple"])))
                    take_profit = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config["take_profit_multiple"])))
                    trade_levels["stop_loss"] = stop_loss.quantize(Decimal('0.00001'))
                    trade_levels["take_profit"] = take_profit.quantize(Decimal('0.00001'))

            return signal, float(signal_score), conditions_met, trade_levels


    def interpret_indicator(logger: logging.Logger, indicator_name: str, values: Union[List[float], float, Dict[str, Any]]) -> Union[str, None]:
        """
        Provides a human-readable interpretation of indicator values.
        """
        if values is None or (isinstance(values, list) and not values) or (isinstance(values, pd.DataFrame) and values.empty):
            return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No data available."
        try:
            # Convert single float values to list for consistent indexing if needed
            if isinstance(values, (float, int)):
                values = [values]
            elif isinstance(values, dict):  # For 'mom' which is a dict
                if indicator_name == "mom":
                    trend = values.get("trend", "N/A")
                    strength = values.get("strength", 0.0)
                    return f"{NEON_PURPLE}Momentum Trend:{RESET} {trend} (Strength: {strength:.2f})"
                else:
                    return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} Dictionary format not specifically interpreted."
            elif isinstance(values, pd.DataFrame):  # For stoch_rsi_vals, stoch_osc_vals which are DataFrames
                # Stoch RSI and Stochastic Oscillator interpretation is handled directly in analyze function
                return None

            # Interpret based on indicator name
            last_value = values[-1] if isinstance(values, list) and values else values[0] if isinstance(values, list) else values  # Handles single value lists too

            if indicator_name == "rsi":
                if last_value > 70:
                    return f"{NEON_RED}RSI:{RESET} Overbought ({last_value:.2f})"
                elif last_value < 30:
                    return f"{NEON_GREEN}RSI:{RESET} Oversold ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}RSI:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "mfi":
                if last_value > 80:
                    return f"{NEON_RED}MFI:{RESET} Overbought ({last_value:.2f})"
                elif last_value < 20:
                    return f"{NEON_GREEN}MFI:{RESET} Oversold ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}MFI:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "cci":
                if last_value > 100:
                    return f"{NEON_RED}CCI:{RESET} Overbought ({last_value:.2f})"
                elif last_value < -100:
                    return f"{NEON_GREEN}CCI:{RESET} Oversold ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}CCI:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "wr":
                if last_value < -80:
                    return f"{NEON_GREEN}Williams %R:{RESET} Oversold ({last_value:.2f})"
                elif last_value > -20:
                    return f"{NEON_RED}Williams %R:{RESET} Overbought ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}Williams %R:{RESET} Neutral ({last_value:.2f})"
            elif indicator_name == "adx":
                if last_value > 25:
                    return f"{NEON_GREEN}ADX:{RESET} Trending ({last_value:.2f})"
                else:
                    return f"{NEON_YELLOW}ADX:{RESET} Ranging ({last_value:.2f})"
            elif indicator_name == "obv":
                if len(values) >= 2:
                    return f"{NEON_BLUE}OBV:{RESET} {'Bullish' if values[-1] > values[-2] else 'Bearish' if values[-1] < values[-2] else 'Neutral'}"
                else:
                    return f"{NEON_BLUE}OBV:{RESET} {last_value:.2f} (Insufficient history for trend)"
            elif indicator_name == "adi":
                if len(values) >= 2:
                    return f"{NEON_BLUE}ADI:{RESET} {'Accumulation' if values[-1] > values[-2] else 'Distribution' if values[-1] < values[-2] else 'Neutral'}"
                else:
                    return f"{NEON_BLUE}ADI:{RESET} {last_value:.2f} (Insufficient history for trend)"
            elif indicator_name == "sma_10":
                return f"{NEON_YELLOW}SMA (10):{RESET} {last_value:.2f}"
            elif indicator_name == "psar":
                return f"{NEON_BLUE}PSAR:{RESET} {last_value:.4f} (Last Value)"
            elif indicator_name == "fve":
                return f"{NEON_BLUE}FVE:{RESET} {last_value:.2f} (Last Value)"
            elif indicator_name == "macd":
                # values for MACD are [macd_line, signal_line, histogram]
                if len(values[-1]) == 3:
                    macd_line, signal_line, histogram = values[-1][0], values[-1][1], values[-1][2]
                    return f"{NEON_GREEN}MACD:{RESET} MACD={macd_line:.2f}, Signal={signal_line:.2f}, Histogram={histogram:.2f}"
                else:
                    return f"{NEON_RED}MACD:{RESET} Calculation issue."
            else:
                return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No specific interpretation available."
        except (TypeError, IndexError, KeyError, ValueError) as e:
            logger.error(f"{NEON_RED}Error interpreting {indicator_name}: {e}. Values: {values}{RESET}")
            return f"{NEON_RED}{indicator_name.upper()}:{RESET} Interpretation error."


    def main():
        """
        Main function to run the trading analysis bot.
        Handles user input, data fetching, analysis, and signal generation loop.
        """
        if not API_KEY or not API_SECRET:
            logger.error(f"{NEON_RED} BYBIT_API_KEY and BYBIT_API_SECRET must be set in your .env file. {RESET}")
            return

        symbol_input = input(f"{NEON_BLUE} Enter trading symbol (e.g., BTCUSDT): {RESET}").upper().strip()
        symbol = symbol_input if symbol_input else "BTCUSDT"

        interval_input = input(f"{NEON_BLUE} Enter timeframe (e.g., {', '.join(VALID_INTERVALS)} or press Enter for default {CONFIG['interval']}): {RESET}").strip()
        interval = interval_input if interval_input and interval_input in VALID_INTERVALS else CONFIG["interval"]

        # Setup a dedicated logger for this symbol's activities
        symbol_logger = setup_custom_logger(symbol)
        symbol_logger.info(f"{NEON_BLUE} Starting analysis for {symbol} with interval {interval}{RESET}")

        last_signal_time = 0.0  # Tracks the last time a signal was triggered for cooldown
        last_order_book_fetch_time = 0.0  # Tracks last order book fetch time for debouncing

        while True:
            try:
                current_price = fetch_current_price(symbol, API_KEY, API_SECRET, symbol_logger)
                if current_price is None:
                    symbol_logger.error(f"{NEON_RED} Failed to fetch current price for {symbol}. Skipping cycle. {RESET}")
                    time.sleep(CONFIG["retry_delay"])
                    continue

                df = fetch_klines(symbol, interval, API_KEY, API_SECRET, symbol_logger, limit=200)
                if df.empty:
                    symbol_logger.error(f"{NEON_RED} Failed to fetch Kline data for {symbol}. Skipping cycle. {RESET}")
                    time.sleep(CONFIG["retry_delay"])
                    continue

                # Debounce order book fetching to reduce API calls
                order_book_data = None
                if time.time() - last_order_book_fetch_time >= CONFIG["order_book_debounce_s"]:
                    order_book_data = fetch_order_book(symbol, API_KEY, API_SECRET, symbol_logger, limit=CONFIG["order_book_depth_to_check"])
                    last_order_book_fetch_time = time.time()
                else:
                    symbol_logger.debug(f"{NEON_YELLOW} Order book fetch debounced. Next fetch in {CONFIG['order_book_debounce_s'] - (time.time() - last_order_book_fetch_time):.1f}s{RESET}")

                analyzer = TradingAnalyzer(df, CONFIG, symbol_logger, symbol, interval)
                timestamp = datetime.now(TIMEZONE).strftime("%Y-%m-%d %H:%M:%S %Z")

                # Perform analysis and log the current state of indicators
                analyzer.analyze(current_price, timestamp, order_book_data)

                # Generate trading signal based on the analysis
                current_time_seconds = time.time()
                signal, confidence, conditions_met, trade_levels = analyzer.generate_trading_signal(current_price)

                if signal and (current_time_seconds - last_signal_time >= CONFIG["signal_cooldown_s"]):
                    symbol_logger.info(f"\n{NEON_PURPLE}--- TRADING SIGNAL TRIGGERED ---{RESET}")
                    symbol_logger.info(f"{NEON_BLUE} Signal:{RESET} {signal.upper()} (Confidence: {confidence:.2f})")
                    symbol_logger.info(f"{NEON_BLUE} Conditions Met:{RESET} {', '.join(conditions_met) if conditions_met else 'None'}")
                    if trade_levels:
                        symbol_logger.info(f"{NEON_GREEN} Suggested Stop Loss:{RESET} {trade_levels.get('stop_loss'):.5f}")
                        symbol_logger.info(f"{NEON_GREEN} Suggested Take Profit:{RESET} {trade_levels.get('take_profit'):.5f}")
                    symbol_logger.info(f"{NEON_YELLOW} --- Placeholder: Order placement logic would be here for {signal.upper()} signal ---{RESET}")
                    last_signal_time = current_time_seconds  # Update last signal time

                time.sleep(CONFIG["analysis_interval"])

            except requests.exceptions.RequestException as e:
                symbol_logger.error(f"{NEON_RED} Network or API communication error: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}")
                time.sleep(CONFIG["retry_delay"])
            except KeyboardInterrupt:
                symbol_logger.info(f"{NEON_YELLOW} Analysis stopped by user. {RESET}")
                break
            except Exception as e:
                symbol_logger.exception(f"{NEON_RED} An unexpected error occurred: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}")
                time.sleep(CONFIG["retry_delay"])


    if __name__ == "__main__":
        main()
    ```
- role: system
  content: |-
    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a trading bot for Bybit, performing technical analysis and generating trade signals. Key features include:

    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from a `config.json` file, allowing customization of intervals, indicator periods, and signal weights. It handles missing or corrupt config files by loading defaults.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets (e.g., "low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, along with confidence scores and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    The refactoring focused on improving logical flow, ensuring consistent data handling (especially with `Decimal`), and adjusting configuration parameters for clarity.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a Bybit trading bot focused on technical analysis.

    **Key Topics Discussed:**
    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from `config.json`, including intervals, indicator periods, and signal weights, with robust handling for missing/corrupt files.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets ("low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, confidence scores, and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    **Important Decisions/Conclusions:**
    *   Refactoring focused on improving logical flow and ensuring consistent data handling using `Decimal` for precision.
    *   Configuration parameters were adjusted for clarity and robustness.

    **Action Items/Next Steps:**
    *   Implement actual order placement logic, as it's currently a placeholder.
    *   Further fine-tune indicator parameters and signal weights.
    *   Consider adding backtesting capabilities.

    **Unresolved Questions:**
    *   How to handle real-time order execution and position management.
- role: user
  content: color code indicator values
- role: assistant
  content: |-
    Okay, I've updated the `whale.py` code to include color coding for indicator values within the `interpret_indicator` function.

    Here's a summary of the changes:

    1.  **`interpret_indicator` Function Enhanced:**
        *   Now takes `pd.DataFrame` as a possible type for `values` to directly handle `stoch_rsi_vals` and `stoch_osc_vals` DataFrames.
        *   **RSI, MFI, CCI, Williams %R:** Values are colored `NEON_GREEN` for oversold/bullish, `NEON_RED` for overbought/bearish, and `NEON_YELLOW` for neutral.
        *   **ADX:** Value is colored `NEON_GREEN` if trending (ADX > 25) and `NEON_YELLOW` if ranging.
        *   **OBV & ADI:** The latest value is colored `NEON_GREEN` if rising (bullish), `NEON_RED` if falling (bearish), and `NEON_BLUE` if neutral (no change or insufficient history).
        *   **MACD:** The histogram value is colored `NEON_GREEN` for positive and `NEON_RED` for negative. MACD and Signal lines remain `NEON_YELLOW`.
        *   **Stoch RSI & Stochastic Oscillator:** Their K and D lines are now interpreted and color-coded within `interpret_indicator` based on overbought/oversold and crossover conditions.
        *   **Momentum (Trend), ATR, SMA, PSAR, FVE:** These are given a neutral `NEON_BLUE` or `NEON_YELLOW` color as their values don't inherently imply a strong bullish/bearish state without further context.
        *   All colored values are properly reset using `RESET` to avoid bleeding colors.

    2.  **`TradingAnalyzer.analyze` Function Modified:**
        *   Removed the explicit `if self.config["indicators"].get("ema_alignment"):` and `if self.config["indicators"].get("stoch_rsi"):` and `if self.config["indicators"].get("stochastic_oscillator"):` blocks that manually printed these indicator interpretations.
        *   These indicators are now passed to the general loop that calls `interpret_indicator`, ensuring consistent formatting and coloring.

    This refactoring centralizes the interpretation and coloring logic, making the output more consistent and readable.

    ```python
    import os
    import logging
    import requests
    import pandas as pd
    import numpy as np
    from datetime import datetime
    import hmac
    import hashlib
    import time
    from dotenv import load_dotenv
    from typing import Dict, Tuple, List, Union, Any
    from colorama import init, Fore, Style
    from zoneinfo import ZoneInfo
    from decimal import Decimal, getcontext, InvalidOperation
    import json

    # --- Logger Configuration (Minimal, for self-containment) ---
    def setup_custom_logger(name):
        """Sets up a custom logger with console and file handlers."""
        log_file = os.path.join(LOG_DIRECTORY, f"{name}.log")

        formatter = logging.Formatter(
            fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )

        handler = logging.FileHandler(log_file)
        handler.setFormatter(formatter)

        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)

        logger = logging.getLogger(name)
        logger.setLevel(logging.INFO) # Set default level to INFO
        logger.addHandler(handler)
        logger.addHandler(console_handler) # Add console output
        return logger

    # --- Configuration & Constants ---

    # Set Decimal precision for financial calculations to avoid floating point errors
    getcontext().prec = 10

    # Initialize colorama for cross-platform colored terminal output
    init(autoreset=True)

    # Load environment variables from .env file
    load_dotenv()

    # --- Color Codex ---
    NEON_GREEN = Fore.LIGHTGREEN_EX
    NEON_BLUE = Fore.CYAN
    NEON_PURPLE = Fore.MAGENTA
    NEON_YELLOW = Fore.YELLOW
    NEON_RED = Fore.LIGHTRED_EX
    RESET = Style.RESET_ALL

    # --- API & Bot Settings ---
    API_KEY = os.getenv("BYBIT_API_KEY")
    API_SECRET = os.getenv("BYBIT_API_SECRET")
    BASE_URL = os.getenv("BYBIT_BASE_URL", "https://api.bybit.com")
    CONFIG_FILE = "config.json"
    LOG_DIRECTORY = "bot_logs"
    TIMEZONE = ZoneInfo("America/Chicago")  # Using a specific timezone for consistency
    MAX_API_RETRIES = 3
    RETRY_DELAY_SECONDS = 5
    VALID_INTERVALS = ["1", "3", "5", "15", "30", "60", "120", "240", "D", "W", "M"]
    RETRY_ERROR_CODES = [429, 500, 502, 503, 504]  # HTTP status codes to trigger a retry

    # Ensure log directory exists
    os.makedirs(LOG_DIRECTORY, exist_ok=True)

    # Setup the main application logger
    logger = setup_custom_logger('whalebot_main')


    def load_config(filepath: str) -> dict:
        """
        Loads configuration from a JSON file, merging with default values.
        If the file is not found or is invalid, it creates one with default settings.
        """
        default_config = {
            "interval": "15",
            "analysis_interval": 30,  # Time in seconds between main analysis cycles
            "retry_delay": 5,  # Delay in seconds for API retries
            "momentum_period": 10,
            "momentum_ma_short": 12,
            "momentum_ma_long": 26,
            "volume_ma_period": 20,
            "atr_period": 14,
            "trend_strength_threshold": 0.4,
            "sideways_atr_multiplier": 1.5,
            "signal_score_threshold": 1.0,  # Minimum combined weight for a signal to be valid
            "indicators": {
                "ema_alignment": True,
                "momentum": True,
                "volume_confirmation": True,
                "divergence": True,
                "stoch_rsi": True,
                "rsi": True,
                "macd": True,
                "vwap": False,
                "obv": True,
                "adi": True,
                "cci": True,
                "wr": True,
                "adx": True,
                "psar": True,
                "fve": True,
                "sma_10": False,
                "mfi": True,
                "stochastic_oscillator": True,
            },
            "weight_sets": {
                "low_volatility": {  # Weights for a low volatility market environment
                    "ema_alignment": 0.3,
                    "momentum": 0.2,
                    "volume_confirmation": 0.2,
                    "divergence": 0.1,
                    "stoch_rsi": 0.5,
                    "rsi": 0.3,
                    "macd": 0.3,
                    "vwap": 0.0,
                    "obv": 0.1,
                    "adi": 0.1,
                    "cci": 0.1,
                    "wr": 0.1,
                    "adx": 0.1,
                    "psar": 0.1,
                    "fve": 0.2,
                    "sma_10": 0.0,
                    "mfi": 0.3,
                    "stochastic_oscillator": 0.4,
                },
                "high_volatility": {  # Weights for a high volatility market environment
                    "ema_alignment": 0.1,
                    "momentum": 0.4,
                    "volume_confirmation": 0.1,
                    "divergence": 0.2,
                    "stoch_rsi": 0.4,
                    "rsi": 0.4,
                    "macd": 0.4,
                    "vwap": 0.0,
                    "obv": 0.1,
                    "adi": 0.1,
                    "cci": 0.1,
                    "wr": 0.1,
                    "adx": 0.1,
                    "psar": 0.1,
                    "fve": 0.3,
                    "sma_10": 0.0,
                    "mfi": 0.4,
                    "stochastic_oscillator": 0.3,
                }
            },
            "stoch_rsi_oversold_threshold": 20,
            "stoch_rsi_overbought_threshold": 80,
            "stoch_rsi_confidence_boost": 0.5,  # Additional boost for strong Stoch RSI signals (changed to float)
            "stoch_rsi_mandatory": False,  # If true, Stoch RSI must be a confirming factor
            "rsi_confidence_boost": 0.2, # Changed to float
            "mfi_confidence_boost": 0.2, # Changed to float
            "order_book_support_confidence_boost": 0.3, # Changed to float
            "order_book_resistance_confidence_boost": 0.3, # Changed to float
            "stop_loss_multiple": 1.5,  # Multiplier for ATR to determine stop loss distance
            "take_profit_multiple": 1.0,  # Multiplier for ATR to determine take profit distance
            "order_book_wall_threshold_multiplier": 2.0,  # Multiplier for average volume to identify a "wall"
            "order_book_depth_to_check": 10,  # Number of order book levels to check for walls
            "price_change_threshold": 0.005,  # % change in price to consider significant
            "atr_change_threshold": 0.005,  # % change in ATR to consider significant volatility change
            "signal_cooldown_s": 60,  # Seconds to wait before generating another signal
            "order_book_debounce_s": 10,  # Seconds to wait between order book API calls
            "ema_short_period": 12,
            "ema_long_period": 26,
            "volume_confirmation_multiplier": 1.5,  # Volume must be this many times average volume for confirmation
            "indicator_periods": {
                "rsi": 14,
                "mfi": 14,
                "cci": 20,
                "williams_r": 14,
                "adx": 14,
                "stoch_rsi_period": 14,  # Period for RSI calculation within Stoch RSI
                "stoch_rsi_k_period": 3,  # Smoothing period for %K line
                "stoch_rsi_d_period": 3,  # Smoothing period for %D line (signal line)
                "momentum": 10,
                "momentum_ma_short": 12,
                "momentum_ma_long": 26,
                "volume_ma": 20,
                "atr": 14,
                "sma_10": 10,
                "fve_price_ema": 10,  # EMA period for FVE price component
                "fve_obv_sma": 20,  # SMA period for OBV normalization
                "fve_atr_sma": 20,  # SMA period for ATR normalization
                "stoch_osc_k": 14,  # Stochastic Oscillator K period
                "stoch_osc_d": 3,  # Stochastic Oscillator D period
            },
            "order_book_analysis": {
                "enabled": True,
                "wall_threshold_multiplier": 2.0,
                "depth_to_check": 10,
                "support_boost": 0.3, # Changed to float
                "resistance_boost": 0.3, # Changed to float
            },
            "trailing_stop_loss": {
                "enabled": False,  # Disabled by default
                "initial_activation_percent": 0.5,  # Activate trailing stop after price moves X% in favor
                "trailing_stop_multiple_atr": 1.5  # Trail stop based on ATR multiple
            },
            "take_profit_scaling": {
                "enabled": False,  # Disabled by default
                "targets": [
                    {"level": 1.5, "percentage": 0.25},  # Sell 25% when price hits 1.5x ATR TP
                    {"level": 2.0, "percentage": 0.50}  # Sell 50% of remaining when price hits 2.0x ATR TP
                ]
            }
        }
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                config = json.load(f)
                # Merge loaded config with defaults. Prioritize loaded values, but ensure all default keys exist.
                merged_config = {**default_config, **config}

                # Recursively merge nested dictionaries (like 'indicators' and 'weight_sets')
                for key, default_val in default_config.items():
                    if isinstance(default_val, dict) and key in config and isinstance(config[key], dict):
                        merged_config[key] = {**default_val, **config[key]}

                # Basic validation for interval and analysis_interval
                if merged_config.get("interval") not in VALID_INTERVALS:
                    logger.warning(f"{NEON_YELLOW} Invalid 'interval' in config, using default: {default_config['interval']}{RESET}")
                    merged_config["interval"] = default_config["interval"]
                if not isinstance(merged_config.get("analysis_interval"), int) or merged_config.get("analysis_interval") <= 0:
                    logger.warning(f"{NEON_YELLOW} Invalid 'analysis_interval' in config, using default: {default_config['analysis_interval']}{RESET}")
                    merged_config["analysis_interval"] = default_config["analysis_interval"]

                return merged_config
        except FileNotFoundError:
            logger.warning(f"{NEON_YELLOW} Config file not found, loading defaults and creating {filepath}{RESET}")
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            return default_config
        except json.JSONDecodeError:
            logger.error(f"{NEON_RED} Invalid JSON in config file, loading defaults. {RESET}")
            # Optionally, back up the corrupt file before overwriting
            try:
                os.rename(filepath, f"{filepath}.bak_{int(time.time())}")
                logger.info(f"{NEON_YELLOW} Backed up corrupt config file to {filepath}.bak_{int(time.time())}{RESET}")
            except OSError as e:
                logger.error(f"{NEON_RED} Failed to backup corrupt config file: {e}{RESET}")
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(default_config, f, indent=4)
            return default_config


    # Load the configuration
    CONFIG = load_config(CONFIG_FILE)


    def generate_signature(api_secret: str, params: dict) -> str:
        """Generates the HMAC SHA256 signature for Bybit API requests."""
        # Ensure params are sorted by key for consistent signature generation
        param_str = "&".join([f"{key}={value}" for key, value in sorted(params.items())])
        return hmac.new(api_secret.encode(), param_str.encode(), hashlib.sha256).hexdigest()


    def handle_api_error(response: requests.Response, logger: logging.Logger) -> None:
        """Logs detailed API error responses."""
        logger.error(f"{NEON_RED} API request failed with status code: {response.status_code}{RESET}")
        try:
            error_json = response.json()
            logger.error(f"{NEON_RED} Error details: {error_json}{RESET}")
        except json.JSONDecodeError:
            logger.error(f"{NEON_RED} Response text: {response.text}{RESET}")


    def bybit_request(method: str, endpoint: str, api_key: str, api_secret: str, params: Dict[str, Any] = None, logger: logging.Logger = None) -> Union[dict, None]:
        """
        Sends a signed request to the Bybit API with retry logic.

        Args:
            method (str): HTTP method (e.g., "GET", "POST").
            endpoint (str): API endpoint path.
            api_key (str): Your Bybit API key.
            api_secret (str): Your Bybit API secret.
            params (Dict[str, Any], optional): Dictionary of request parameters. Defaults to None.
            logger (logging.Logger, optional): Logger instance for logging. Defaults to None.

        Returns:
            Union[dict, None]: JSON response data if successful, None otherwise.
        """
        params = params or {}
        # Bybit API V5 requires timestamp in milliseconds
        params['timestamp'] = str(int(time.time() * 1000))
        signature = generate_signature(api_secret, params)
        headers = {
            "X-BAPI-API-KEY": api_key,
            "X-BAPI-SIGN": signature,
            "X-BAPI-TIMESTAMP": params['timestamp'],
            "Content-Type": "application/json"
        }
        url = f"{BASE_URL}{endpoint}"

        for retry in range(MAX_API_RETRIES):
            try:
                response = requests.request(
                    method,
                    url,
                    headers=headers,
                    params=params if method == "GET" else None,
                    json=params if method == "POST" else None,
                    timeout=10  # Set a timeout for requests
                )
                response.raise_for_status()  # Raises HTTPError for bad responses (4xx or 5xx)

                # Check for Bybit specific error codes within a successful HTTP response
                response_json = response.json()
                if response_json.get("retCode") != 0:
                    if logger:
                        logger.error(f"{NEON_RED} Bybit API Error: {response_json.get('retMsg', 'Unknown error')}. Response: {response_json}{RESET}")
                    return None

                return response_json

            except requests.exceptions.HTTPError as e:
                if e.response.status_code in RETRY_ERROR_CODES:
                    if logger:
                        logger.warning(f"{NEON_YELLOW} API Error {e.response.status_code} ({e.response.reason}), retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}")
                    time.sleep(RETRY_DELAY_SECONDS * (2**retry))  # Exponential backoff
                else:
                    if logger:
                        handle_api_error(e.response, logger)
                    return None
            except requests.exceptions.RequestException as e:
                if logger:
                    logger.error(f"{NEON_RED} Request exception: {e}, retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}")
                time.sleep(RETRY_DELAY_SECONDS * (2**retry))

        if logger:
            logger.error(f"{NEON_RED} Max retries reached for {method} {endpoint}{RESET}")
        return None


    def fetch_current_price(symbol: str, api_key: str, api_secret: str, logger: logging.Logger) -> Union[Decimal, None]:
        """Fetches the current last traded price for a given symbol."""
        endpoint = "/v5/market/tickers"
        params = {"category": "linear", "symbol": symbol}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result"):
            tickers = response_data["result"].get("list")
            if tickers:
                for ticker in tickers:
                    if ticker.get("symbol") == symbol:
                        last_price = ticker.get("lastPrice")
                        return Decimal(last_price) if last_price else None
        logger.error(f"{NEON_RED} Could not fetch current price for {symbol}. Response: {response_data}{RESET}")
        return None


    def fetch_klines(symbol: str, interval: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 200) -> pd.DataFrame:
        """Fetches historical K-line (candlestick) data for a given symbol and interval."""
        endpoint = "/v5/market/kline"
        params = {"symbol": symbol, "interval": interval, "limit": limit, "category": "linear"}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result") and response_data["result"].get("list"):
            data = response_data["result"]["list"]
            # Bybit's kline list order is: [timestamp, open, high, low, close, volume, turnover]
            columns = ["start_time", "open", "high", "low", "close", "volume", "turnover"]
            df = pd.DataFrame(data, columns=columns)
            df["start_time"] = pd.to_datetime(pd.to_numeric(df["start_time"]), unit="ms")
            # Convert numeric columns, coercing errors to NaN
            for col in df.columns[1:]:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            # Drop any rows that resulted in all NaNs after conversion (shouldn't happen with valid data)
            df.dropna(subset=df.columns[1:], inplace=True)
            return df.sort_values(by="start_time", ascending=True).reset_index(drop=True)  # Ensure chronological order
        logger.error(f"{NEON_RED} Failed to fetch Kline data for {symbol}, interval {interval}. Response: {response_data}{RESET}")
        return pd.DataFrame()


    def fetch_order_book(symbol: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 50) -> Union[dict, None]:
        """Fetches the order book (bids and asks) for a given symbol."""
        endpoint = "/v5/market/orderbook"
        params = {"symbol": symbol, "limit": limit, "category": "linear"}
        response_data = bybit_request("GET", endpoint, api_key, api_secret, params, logger)
        if response_data and response_data.get("retCode") == 0 and response_data.get("result"):
            return response_data["result"]
        logger.warning(f"{NEON_YELLOW} Could not fetch order book for {symbol}. Response: {response_data}{RESET}")
        return None


    class TradingAnalyzer:
        """
        Performs technical analysis on candlestick data and generates trading signals.
        """
        def __init__(self, df: pd.DataFrame, config: dict, symbol_logger: logging.Logger, symbol: str, interval: str):
            self.df = df.copy()  # Work on a copy to avoid modifying original DataFrame
            self.config = config
            self.logger = symbol_logger
            self.symbol = symbol
            self.interval = interval
            self.levels: Dict[str, Any] = {}  # Stores support/resistance levels (fib, pivot)
            self.fib_levels: Dict[str, float] = {}  # Stores calculated Fibonacci levels
            self.weight_sets = config["weight_sets"]
            self.indicator_values: Dict[str, Any] = {}  # Stores calculated indicator values
            self.atr_value: float = 0.0  # Stores the latest ATR value
            self.user_defined_weights: Dict[str, float] = {} # To be selected dynamically

        def _safe_series_operation(self, column: str, operation: str, window: int = None, series: pd.Series = None) -> pd.Series:
            """Helper to safely perform operations on DataFrame columns or provided series."""
            if series is not None:
                data_series = series
            elif column in self.df.columns:
                data_series = self.df[column]
            else:
                self.logger.error(f"{NEON_RED} Missing '{column}' column for {operation} calculation.{RESET}")
                return pd.Series(dtype=float)

            if data_series.empty:
                return pd.Series(dtype=float)

            try:
                if operation == "sma":
                    return data_series.rolling(window=window).mean()
                elif operation == "ema":
                    return data_series.ewm(span=window, adjust=False).mean()
                elif operation == "max":
                    return data_series.rolling(window=window).max()
                elif operation == "min":
                    return data_series.rolling(window=window).min()
                elif operation == "diff":
                    return data_series.diff(window)
                elif operation == "abs_diff_mean":
                    return data_series.rolling(window=window).apply(lambda x: np.abs(x - x.mean()).mean(), raw=True)
                elif operation == "cumsum":
                    return data_series.cumsum()
                else:
                    self.logger.error(f"{NEON_RED} Unsupported series operation: {operation}{RESET}")
                    return pd.Series(dtype=float)
            except Exception as e:
                self.logger.error(f"{NEON_RED} Error during {operation} calculation on {column}: {e}{RESET}")
                return pd.Series(dtype=float)

        def _calculate_sma(self, window: int, series: pd.Series = None) -> pd.Series:
            """Calculates Simple Moving Average (SMA). Can operate on a specified series or 'close' price."""
            return self._safe_series_operation('close', 'sma', window, series)

        def _calculate_ema(self, window: int, series: pd.Series = None) -> pd.Series:
            """Calculates Exponential Moving Average (EMA). Can operate on a specified series or 'close' price."""
            return self._safe_series_operation('close', 'ema', window, series)

        def _calculate_ema_alignment(self) -> float:
            """
            Calculates an EMA alignment score.
            Score is 1.0 for strong bullish alignment, -1.0 for strong bearish, 0.0 for neutral.
            """
            ema_short = self._calculate_ema(self.config["ema_short_period"])
            ema_long = self._calculate_ema(self.config["ema_long_period"])

            if ema_short.empty or ema_long.empty or len(self.df) < max(self.config["ema_short_period"], self.config["ema_long_period"]):
                return 0.0

            latest_short_ema = Decimal(str(ema_short.iloc[-1]))
            latest_long_ema = Decimal(str(ema_long.iloc[-1]))

            # Check for consistent alignment over the last few bars (e.g., 3 bars)
            alignment_period = 3
            if len(ema_short) < alignment_period or len(ema_long) < alignment_period:
                return 0.0

            bullish_aligned_count = 0
            bearish_aligned_count = 0

            for i in range(1, alignment_period + 1):
                if (ema_short.iloc[-i] > ema_long.iloc[-i] and
                    self.df["close"].iloc[-i] > ema_short.iloc[-i]):
                    bullish_aligned_count += 1
                elif (ema_short.iloc[-i] < ema_long.iloc[-i] and
                      self.df["close"].iloc[-i] < ema_short.iloc[-i]):
                    bearish_aligned_count += 1

            if bullish_aligned_count >= alignment_period - 1:  # At least (period-1) bars are aligned
                return 1.0  # Strong bullish alignment
            elif bearish_aligned_count >= alignment_period - 1:
                return -1.0  # Strong bearish alignment
            else:
                # Check for recent crossover as a weaker signal
                if latest_short_ema > latest_long_ema and ema_short.iloc[-2] <= latest_long_ema:
                    return 0.5  # Recent bullish crossover
                elif latest_short_ema < latest_long_ema and ema_short.iloc[-2] >= latest_long_ema:
                    return -0.5  # Recent bearish crossover
                return 0.0  # Neutral

        def _calculate_momentum(self, period: int = 10) -> pd.Series:
            """Calculates the Momentum indicator."""
            # Momentum is often calculated as current price - price N periods ago.
            # For signal generation, a ratio or percentage change can be more useful.
            # Here, we calculate the percentage change over the period.
            return self._safe_series_operation('close', 'diff', period) / self.df["close"].shift(period) * 100

        def _calculate_cci(self, window: int = 20, constant: float = 0.015) -> pd.Series:
            """Calculates the Commodity Channel Index (CCI)."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for CCI calculation.{RESET}")
                return pd.Series(dtype=float)
            typical_price = (self.df["high"] + self.df["low"] + self.df["close"]) / 3
            sma_typical_price = self._safe_series_operation(None, 'sma', window, typical_price)
            mean_deviation = self._safe_series_operation(None, 'abs_diff_mean', window, typical_price)
            # Avoid division by zero
            cci = (typical_price - sma_typical_price) / (constant * mean_deviation)
            return cci.replace([np.inf, -np.inf], np.nan)  # Handle potential inf values

        def _calculate_williams_r(self, window: int = 14) -> pd.Series:
            """Calculates the Williams %R indicator."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for Williams %R calculation.{RESET}")
                return pd.Series(dtype=float)
            highest_high = self._safe_series_operation('high', 'max', window)
            lowest_low = self._safe_series_operation('low', 'min', window)
            # Avoid division by zero
            denominator = (highest_high - lowest_low)
            wr = ((highest_high - self.df["close"]) / denominator) * -100
            return wr.replace([np.inf, -np.inf], np.nan)

        def _calculate_mfi(self, window: int = 14) -> pd.Series:
            """Calculates the Money Flow Index (MFI)."""
            required_columns = ['high', 'low', 'close', 'volume']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for MFI calculation.{RESET}")
                return pd.Series(dtype=float)

            typical_price = (self.df["high"] + self.df["low"] + self.df["close"]) / 3
            raw_money_flow = typical_price * self.df["volume"]

            # Calculate positive and negative money flow
            money_flow_direction = typical_price.diff()
            positive_flow = raw_money_flow.where(money_flow_direction > 0, 0)
            negative_flow = raw_money_flow.where(money_flow_direction < 0, 0)

            # Calculate sums over the window
            positive_mf = self._safe_series_operation(None, 'sma', window, positive_flow) * window  # sum not mean
            negative_mf = self._safe_series_operation(None, 'sma', window, negative_flow) * window  # sum not mean

            # Avoid division by zero
            money_ratio = positive_mf / negative_mf.replace(0, np.nan)  # Replace 0 with NaN to handle division by zero
            mfi = 100 - (100 / (1 + money_ratio))
            return mfi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0 or a sensible value

        def calculate_fibonacci_retracement(self, high: Decimal, low: Decimal, current_price: Decimal) -> Dict[str, Decimal]:
            """Calculates Fibonacci retracement levels based on a given high and low."""
            diff = high - low
            if diff <= 0:  # Handle cases where high <= low
                self.logger.warning(f"{NEON_YELLOW} Cannot calculate Fibonacci retracement: High ({high}) <= Low ({low}).{RESET}")
                self.fib_levels = {}
                self.levels = {"Support": {}, "Resistance": {}}
                return {}

            # Standard Fibonacci ratios
            fib_ratios = {
                "23.6%": Decimal('0.236'), "38.2%": Decimal('0.382'), "50.0%": Decimal('0.500'),
                "61.8%": Decimal('0.618'), "78.6%": Decimal('0.786'), "88.6%": Decimal('0.886'),
                "94.1%": Decimal('0.941')
            }
            fib_levels_calculated: Dict[str, Decimal] = {}

            # Assuming an uptrend (retracement from high to low)
            # Levels are calculated from the high, moving down
            for label, ratio in fib_ratios.items():
                level = high - (diff * ratio)
                fib_levels_calculated[f"Fib {label}"] = level.quantize(Decimal('0.00001'))  # Quantize for consistent precision

            self.fib_levels = fib_levels_calculated
            self.levels = {"Support": {}, "Resistance": {}}

            # Categorize levels as support or resistance relative to current price
            for label, value in self.fib_levels.items():
                if value < current_price:
                    self.levels["Support"][label] = value
                elif value > current_price:
                    self.levels["Resistance"][label] = value

            return self.fib_levels

        def calculate_pivot_points(self, high: Decimal, low: Decimal, close: Decimal):
            """Calculates standard Pivot Points."""
            pivot = (high + low + close) / 3
            r1 = (2 * pivot) - low
            s1 = (2 * pivot) - high
            r2 = pivot + (high - low)
            s2 = pivot - (high - low)
            r3 = high + 2 * (pivot - low)
            s3 = low - 2 * (high - pivot)

            # Quantize all pivot points for consistent precision
            precision = Decimal('0.00001')
            self.levels.update({
                "Pivot": pivot.quantize(precision),
                "R1": r1.quantize(precision), "S1": s1.quantize(precision),
                "R2": r2.quantize(precision), "S2": s2.quantize(precision),
                "R3": r3.quantize(precision), "S3": s3.quantize(precision),
            })

        def find_nearest_levels(self, current_price: Decimal, num_levels: int = 5) -> Tuple[List[Tuple[str, Decimal]], List[Tuple[str, Decimal]]]:
            """
            Finds the nearest support and resistance levels from calculated Fibonacci and Pivot Points.
            """
            all_support_levels: List[Tuple[str, Decimal]] = []
            all_resistance_levels: List[Tuple[str, Decimal]] = []

            def process_level(label: str, value: Decimal):
                if value < current_price:
                    all_support_levels.append((label, value))
                elif value > current_price:
                    all_resistance_levels.append((label, value))

            # Process all levels stored in self.levels (from Fibonacci and Pivot)
            for label, value in self.levels.items():
                if isinstance(value, dict):  # For nested levels like "Support": {"Fib 23.6%": ...}
                    for sub_label, sub_value in value.items():
                        if isinstance(sub_value, Decimal):
                            process_level(f"{label} ({sub_label})", sub_value)
                elif isinstance(value, Decimal):  # For direct levels like "Pivot"
                    process_level(label, value)

            # Sort by distance to current price and select the 'num_levels' closest
            nearest_supports = sorted(all_support_levels, key=lambda x: current_price - x[1])[:num_levels]
            nearest_resistances = sorted(all_resistance_levels, key=lambda x: x[1] - current_price)[:num_levels]

            return nearest_supports, nearest_resistances

        def _calculate_atr(self, window: int = 14) -> pd.Series:
            """Calculates the Average True Range (ATR)."""
            required_columns = ['high', 'low', 'close']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ATR calculation.{RESET}")
                return pd.Series(dtype=float)

            high_low = self.df["high"] - self.df["low"]
            high_close = abs(self.df["high"] - self.df["close"].shift())
            low_close = abs(self.df["low"] - self.df["close"].shift())

            # True Range is the maximum of the three
            tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
            return self._safe_series_operation(None, 'ema', window, tr)  # Use EMA for ATR for smoothing

        def _calculate_rsi(self, window: int = 14) -> pd.Series:
            """Calculates the Relative Strength Index (RSI)."""
            if 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' column for RSI calculation.{RESET}")
                return pd.Series(dtype=float)

            delta = self.df["close"].diff()
            gain = delta.where(delta > 0, 0)
            loss = -delta.where(delta < 0, 0)

            avg_gain = self._safe_series_operation(None, 'ema', window, gain)
            avg_loss = self._safe_series_operation(None, 'ema', window, loss)

            # Avoid division by zero
            rs = avg_gain / avg_loss.replace(0, np.nan)
            rsi = 100 - (100 / (1 + rs))
            return rsi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0

        def _calculate_stoch_rsi(self, rsi_window: int = 14, stoch_window: int = 14, k_window: int = 3, d_window: int = 3) -> pd.DataFrame:
            """Calculates Stochastic RSI (%K and %D lines)."""
            rsi = self._calculate_rsi(window=rsi_window)
            if rsi.empty:
                return pd.DataFrame()

            # Calculate StochRSI
            stoch_rsi = (rsi - self._safe_series_operation(None, 'min', stoch_window, rsi)) / \
                        (self._safe_series_operation(None, 'max', stoch_window, rsi) - self._safe_series_operation(None, 'min', stoch_window, rsi))

            # Handle division by zero for StochRSI (if max == min)
            stoch_rsi = stoch_rsi.replace([np.inf, -np.inf], np.nan).fillna(0)

            k_line = self._safe_series_operation(None, 'sma', k_window, stoch_rsi) * 100  # Scale to 0-100
            d_line = self._safe_series_operation(None, 'sma', d_window, k_line)  # Signal line for %K

            return pd.DataFrame({'stoch_rsi': stoch_rsi * 100, 'k': k_line, 'd': d_line})  # Return StochRSI also scaled

        def _calculate_stochastic_oscillator(self) -> pd.DataFrame:
            """Calculates the Stochastic Oscillator (%K and %D lines)."""
            k_period = self.config["indicator_periods"]["stoch_osc_k"]
            d_period = self.config["indicator_periods"]["stoch_osc_d"]

            if 'high' not in self.df.columns or 'low' not in self.df.columns or 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing required columns for Stochastic Oscillator calculation.{RESET}")
                return pd.DataFrame()

            highest_high = self._safe_series_operation('high', 'max', k_period)
            lowest_low = self._safe_series_operation('low', 'min', k_period)

            # Calculate %K
            k_line = (self.df['close'] - lowest_low) / (highest_high - lowest_low) * 100
            k_line = k_line.replace([np.inf, -np.inf], np.nan).fillna(0)  # Handle division by zero

            # Calculate %D (SMA of %K)
            d_line = self._safe_series_operation(None, 'sma', d_period, k_line)

            return pd.DataFrame({'k': k_line, 'd': d_line})

        def _calculate_momentum_ma(self) -> None:
            """Calculates momentum and its moving averages, and volume moving average."""
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for Momentum MA calculation.{RESET}")
                return

            self.df["momentum"] = self._calculate_momentum(period=self.config["momentum_period"])  # Use the momentum function
            self.df["momentum_ma_short"] = self._calculate_sma(self.config["momentum_ma_short"], series=self.df["momentum"])
            self.df["momentum_ma_long"] = self._calculate_sma(self.config["momentum_ma_long"], series=self.df["momentum"])
            self.df["volume_ma"] = self._calculate_sma(self.config["volume_ma_period"], series=self.df["volume"])

        def _calculate_macd(self) -> pd.DataFrame:
            """Calculates Moving Average Convergence Divergence (MACD)."""
            if 'close' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' column for MACD calculation.{RESET}")
                return pd.DataFrame()

            ma_short = self._calculate_ema(12)
            ma_long = self._calculate_ema(26)
            macd = ma_short - ma_long
            signal = self._calculate_ema(9, series=macd)
            histogram = macd - signal
            return pd.DataFrame({'macd': macd, 'signal': signal, 'histogram': histogram})

        def detect_macd_divergence(self) -> Union[str, None]:
            """Detects bullish or bearish MACD divergence."""
            macd_df = self._calculate_macd()
            if macd_df.empty or len(self.df) < 30:  # Need sufficient data for reliable divergence
                return None

            prices = self.df["close"]
            macd_histogram = macd_df["histogram"]

            # Simple divergence check on last two bars (can be expanded for more robust detection)
            if (prices.iloc[-2] > prices.iloc[-1] and macd_histogram.iloc[-2] < macd_histogram.iloc[-1]):
                self.logger.info(f"{NEON_GREEN} Detected Bullish MACD Divergence.{RESET}")
                return "bullish"
            elif (prices.iloc[-2] < prices.iloc[-1] and macd_histogram.iloc[-2] > macd_histogram.iloc[-1]):
                self.logger.info(f"{NEON_RED} Detected Bearish MACD Divergence.{RESET}")
                return "bearish"
            return None

        def determine_trend_momentum(self) -> Dict[str, Union[str, float]]:
            """Determines the current trend and its strength based on momentum MAs and ATR."""
            if self.df.empty or len(self.df) < max(self.config["momentum_ma_long"], self.config["atr_period"]):
                return {"trend": "Insufficient Data", "strength": 0.0}

            # Ensure momentum_ma_short, momentum_ma_long, and atr_value are calculated
            if "momentum_ma_short" not in self.df.columns or "momentum_ma_long" not in self.df.columns or self.atr_value == 0:
                self.logger.warning(f"{NEON_YELLOW} Momentum MAs or ATR not available for trend calculation.{RESET}")
                return {"trend": "Neutral", "strength": 0.0}

            latest_short_ma = self.df["momentum_ma_short"].iloc[-1]
            latest_long_ma = self.df["momentum_ma_long"].iloc[-1]

            trend = "Neutral"
            if latest_short_ma > latest_long_ma:
                trend = "Uptrend"
            elif latest_short_ma < latest_long_ma:
                trend = "Downtrend"

            # Strength is normalized by ATR to make it comparable across symbols/timeframes
            strength = abs(latest_short_ma - latest_long_ma) / self.atr_value
            return {"trend": trend, "strength": strength}

        def _calculate_adx(self, window: int = 14) -> float:
            """Calculates the Average Directional Index (ADX)."""
            df_adx = self.df.copy()
            required_columns = ['high', 'low', 'close']
            if not all(col in df_adx.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ADX calculation.{RESET}")
                return 0.0

            # True Range
            df_adx["TR"] = pd.concat([
                df_adx["high"] - df_adx["low"],
                abs(df_adx["high"] - df_adx["close"].shift()),
                abs(df_adx["low"] - df_adx["close"].shift())
            ], axis=1).max(axis=1)

            # Directional Movement
            df_adx["+DM"] = np.where((df_adx["high"] - df_adx["high"].shift()) > (df_adx["low"].shift() - df_adx["low"]),
                                     np.maximum(df_adx["high"] - df_adx["high"].shift(), 0), 0)
            df_adx["-DM"] = np.where((df_adx["low"].shift() - df_adx["low"]) > (df_adx["high"] - df_adx["high"].shift()),
                                     np.maximum(df_adx["low"].shift() - df_adx["low"], 0), 0)

            # Smoothed True Range and Directional Movement (using EMA)
            df_adx["TR_ema"] = self._calculate_ema(window, series=df_adx["TR"])
            df_adx["+DM_ema"] = self._calculate_ema(window, series=df_adx["+DM"])
            df_adx["-DM_ema"] = self._calculate_ema(window, series=df_adx["-DM"])

            # Directional Indicators
            df_adx["+DI"] = 100 * (df_adx["+DM_ema"] / df_adx["TR_ema"].replace(0, np.nan))
            df_adx["-DI"] = 100 * (df_adx["-DM_ema"] / df_adx["TR_ema"].replace(0, np.nan))

            # Directional Movement Index (DX)
            df_adx["DX"] = 100 * abs(df_adx["+DI"] - df_adx["-DI"]) / (df_adx["+DI"] + df_adx["-DI"]).replace(0, np.nan)

            # Average Directional Index (ADX)
            adx_value = self._calculate_ema(window, series=df_adx["DX"]).iloc[-1]
            return adx_value if not pd.isna(adx_value) else 0.0

        def _calculate_obv(self) -> pd.Series:
            """Calculates On-Balance Volume (OBV)."""
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for OBV calculation.{RESET}")
                return pd.Series(dtype=float)

            obv = pd.Series(0, index=self.df.index, dtype=float)
            obv.iloc[0] = self.df["volume"].iloc[0]  # Initialize with first volume

            for i in range(1, len(self.df)):
                if self.df["close"].iloc[i] > self.df["close"].iloc[i - 1]:
                    obv.iloc[i] = obv.iloc[i - 1] + self.df["volume"].iloc[i]
                elif self.df["close"].iloc[i] < self.df["close"].iloc[i - 1]:
                    obv.iloc[i] = obv.iloc[i - 1] - self.df["volume"].iloc[i]
                else:
                    obv.iloc[i] = obv.iloc[i - 1]  # No change if close price is the same

            return obv

        def _calculate_adi(self) -> pd.Series:
            """Calculates Accumulation/Distribution Index (ADI)."""
            required_columns = ['high', 'low', 'close', 'volume']
            if not all(col in self.df.columns for col in required_columns):
                self.logger.error(f"{NEON_RED} Missing required columns for ADI calculation.{RESET}")
                return pd.Series(dtype=float)

            # Money Flow Multiplier (MFM)
            mfm_denominator = (self.df["high"] - self.df["low"])
            mfm = ((self.df["close"] - self.df["low"]) - (self.df["high"] - self.df["close"])) / mfm_denominator.replace(0, np.nan)
            mfm.fillna(0, inplace=True)  # If high == low, MFM is 0

            # Money Flow Volume (MFV)
            money_flow_volume = mfm * self.df["volume"]

            # Accumulation/Distribution Line (ADL) is the cumulative sum of MFV
            return self._safe_series_operation(None, 'cumsum', series=money_flow_volume)

        def _calculate_psar(self, acceleration: float = 0.02, max_acceleration: float = 0.2) -> pd.Series:
            """Calculates Parabolic SAR (PSAR)."""
            psar = pd.Series(index=self.df.index, dtype="float64")
            if self.df.empty or len(self.df) < 2:  # Need at least two bars to start
                return psar

            # Initial values
            psar.iloc[0] = self.df["close"].iloc[0]  # Start PSAR at first close
            # Determine initial trend based on first two bars
            if self.df["close"].iloc[1] > self.df["close"].iloc[0]:
                trend = 1  # Uptrend
                ep = self.df["high"].iloc[0]  # Extreme Point
            else:
                trend = -1  # Downtrend
                ep = self.df["low"].iloc[0]  # Extreme Point
            af = acceleration  # Acceleration Factor

            for i in range(1, len(self.df)):
                current_high = self.df["high"].iloc[i]
                current_low = self.df["low"].iloc[i]
                prev_psar = psar.iloc[i - 1]

                if trend == 1:  # Uptrend
                    psar.iloc[i] = prev_psar + af * (ep - prev_psar)
                    # Check if PSAR should be below current low
                    psar.iloc[i] = min(psar.iloc[i], current_low, self.df["low"].iloc[i - 1] if i > 1 else current_low)
                    if current_high > ep:  # New extreme high
                        ep = current_high
                        af = min(af + acceleration, max_acceleration)
                    if current_low < psar.iloc[i]:  # Trend reversal
                        trend = -1
                        psar.iloc[i] = ep  # PSAR jumps to old EP
                        ep = current_low
                        af = acceleration
                elif trend == -1:  # Downtrend
                    psar.iloc[i] = prev_psar + af * (ep - prev_psar)
                    # Check if PSAR should be above current high
                    psar.iloc[i] = max(psar.iloc[i], current_high, self.df["high"].iloc[i - 1] if i > 1 else current_high)
                    if current_low < ep:  # New extreme low
                        ep = current_low
                        af = min(af + acceleration, max_acceleration)
                    if current_high > psar.iloc[i]:  # Trend reversal
                        trend = 1
                        psar.iloc[i] = ep  # PSAR jumps to old EP
                        ep = current_high
                        af = acceleration
            return psar

        def _calculate_fve(self) -> pd.Series:
            """
            Calculates a "Fictional Value Estimate" (FVE) by combining price, volume, and volatility.
            This is a custom composite indicator for demonstrative purposes.
            """
            if 'close' not in self.df.columns or 'volume' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'close' or 'volume' column for FVE calculation.{RESET}")
                return pd.Series(dtype=float)

            try:
                # Ensure enough data for calculations
                min_data_points = max(20, self.config["atr_period"])
                if len(self.df) < min_data_points:
                    self.logger.warning(f"{NEON_YELLOW} Insufficient data for FVE calculation. Need at least {min_data_points} bars.{RESET}")
                    # Return a series of NaNs matching the DataFrame length if data is insufficient
                    return pd.Series([np.nan] * len(self.df), index=self.df.index)

                # Components calculation, ensuring Decimal usage where appropriate
                # Use Decimal for price-related calculations
                price_component = self._calculate_ema(window=self.config["indicator_periods"]["fve_price_ema"])  # Short term price trend
                obv_component = self._calculate_obv()
                atr_component = self._calculate_atr(window=self.config["indicator_periods"]["atr"])

                # Convert components to Decimal for calculations if they are not already
                # This is crucial to avoid numpy.float64 issues with Decimal operations
                price_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in price_component], index=price_component.index)
                obv_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in obv_component], index=obv_component.index)
                atr_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in atr_component], index=atr_component.index)

                # Normalize components to prevent one from dominating excessively
                # Use Decimal for mean and std calculation to maintain precision
                price_mean = Decimal(str(price_component_dec.mean())) if pd.notna(price_component_dec.mean()) else Decimal('NaN')
                price_std = Decimal(str(price_component_dec.std())) if pd.notna(price_component_dec.std()) else Decimal('NaN')
                obv_mean = Decimal(str(obv_component_dec.mean())) if pd.notna(obv_component_dec.mean()) else Decimal('NaN')
                obv_std = Decimal(str(obv_component_dec.std())) if pd.notna(obv_component_dec.std()) else Decimal('NaN')
                atr_mean = Decimal(str(atr_component_dec.mean())) if pd.notna(atr_component_dec.mean()) else Decimal('NaN')
                atr_std = Decimal(str(atr_component_dec.std())) if pd.notna(atr_component_dec.std()) else Decimal('NaN')

                # Handle potential division by zero for std dev
                price_norm = (price_component_dec - price_mean) / price_std if price_std != 0 else pd.Series(Decimal('0'), index=self.df.index)
                obv_norm = (obv_component_dec - obv_mean) / obv_std if obv_std != 0 else pd.Series(Decimal('0'), index=self.df.index)

                # Inverse of ATR: lower ATR means higher stability/less volatility, which can be seen as positive for trend following
                # Use Decimal for division, and handle potential division by zero for ATR
                # Calculate inverse ATR, handling division by zero safely
                atr_inverse = pd.Series([Decimal('1.0') / Decimal(str(x)) if x and x != 0 else Decimal('NaN') for x in atr_component_dec], index=self.df.index)
                # Replace infinite values resulting from division by zero with NaN
                atr_inverse = atr_inverse.replace([Decimal('Infinity'), Decimal('-Infinity')], Decimal('NaN'))

                atr_inverse_mean = Decimal(str(atr_inverse.mean())) if pd.notna(atr_inverse.mean()) else Decimal('NaN')
                atr_inverse_std = Decimal(str(atr_inverse.std())) if pd.notna(atr_inverse.std()) else Decimal('NaN')

                # Normalize ATR inverse, handling potential zero std dev
                atr_inverse_norm = (atr_inverse - atr_inverse_mean) / atr_inverse_std if atr_inverse_std != 0 else pd.Series(Decimal('0'), index=self.df.index)

                # Combine them - this formula is illustrative and should be fine-tuned
                # Higher FVE indicates more "value" or bullishness.
                # Ensure all components are aligned and handle NaNs
                fve = price_norm.fillna(Decimal('0')) + obv_norm.fillna(Decimal('0')) + atr_inverse_norm.fillna(Decimal('0'))

                # Convert back to float Series for compatibility with later operations if needed
                return pd.Series([float(x) if x != Decimal('NaN') else np.nan for x in fve], index=self.df.index)

            except Exception as e:
                self.logger.error(f"{NEON_RED} Error calculating FVE: {e}{RESET}")
                # Return a series of NaNs matching the DataFrame length in case of any error
                return pd.Series([np.nan] * len(self.df), index=self.df.index)

        def _calculate_volume_confirmation(self) -> bool:
            """
            Checks if the current volume confirms a trend (e.g., significant spike).
            Returns True if current volume is significantly higher than average.
            """
            if 'volume' not in self.df.columns or 'volume_ma' not in self.df.columns:
                self.logger.error(f"{NEON_RED} Missing 'volume' or 'volume_ma' column for Volume Confirmation.{RESET}")
                return False
            if self.df["volume"].empty or self.df["volume_ma"].empty:
                return False

            current_volume = self.df['volume'].iloc[-1]
            average_volume = self.df['volume_ma'].iloc[-1]

            if average_volume <= 0:  # Avoid division by zero or nonsensical average
                return False

            return current_volume > average_volume * self.config["volume_confirmation_multiplier"]

        def analyze_order_book_walls(self, order_book: Dict[str, Any]) -> Tuple[bool, bool, Dict[str, Decimal], Dict[str, Decimal]]:
            """
            Analyzes order book for significant bid (support) and ask (resistance) walls.
            Returns whether bullish/bearish walls are found and the wall details.
            """
            has_bullish_wall = False
            has_bearish_wall = False
            bullish_wall_details: Dict[str, Decimal] = {}
            bearish_wall_details: Dict[str, Decimal] = {}

            if not self.config["order_book_analysis"]["enabled"]:
                return False, False, {}, {}

            if not order_book or not order_book.get('bids') or not order_book.get('asks'):
                self.logger.warning(f"{NEON_YELLOW} Order book data incomplete for wall analysis.{RESET}")
                return False, False, {}, {}

            bids = [(Decimal(price), Decimal(qty)) for price, qty in order_book['bids'][:self.config["order_book_analysis"]["depth_to_check"]]]
            asks = [(Decimal(price), Decimal(qty)) for price, qty in order_book['asks'][:self.config["order_book_analysis"]["depth_to_check"]]]

            # Calculate average quantity across relevant depth
            all_quantities = [qty for _, qty in bids + asks]
            if not all_quantities:
                return False, False, {}, {}

            # Use Decimal for sum and count, then divide to maintain precision
            total_qty = sum(all_quantities)
            avg_qty = total_qty / Decimal(str(len(all_quantities)))
            wall_threshold = avg_qty * Decimal(str(self.config["order_book_analysis"]["wall_threshold_multiplier"]))

            # Check for bullish walls (large bids below current price)
            current_price = Decimal(str(self.df["close"].iloc[-1]))
            for bid_price, bid_qty in bids:
                if bid_qty >= wall_threshold and bid_price < current_price:
                    has_bullish_wall = True
                    bullish_wall_details[f"Bid@{bid_price}"] = bid_qty
                    self.logger.info(f"{NEON_GREEN} Detected Bullish Order Book Wall: Bid {bid_qty:.2f} at {bid_price:.2f}{RESET}")
                    break  # Only need to find one significant wall

            # Check for bearish walls (large asks above current price)
            for ask_price, ask_qty in asks:
                if ask_qty >= wall_threshold and ask_price > current_price:
                    has_bearish_wall = True
                    bearish_wall_details[f"Ask@{ask_price}"] = ask_qty
                    self.logger.info(f"{NEON_RED} Detected Bearish Order Book Wall: Ask {ask_qty:.2f} at {ask_price:.2f}{RESET}")
                    break  # Only need to find one significant wall

            return has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details

        def _calculate_all_indicators(self):
            """Calculates and stores all enabled indicators for the current cycle."""
            # Pre-calculate ATR and momentum MAs first, as they are used for weight selection and trend
            atr_series = self._calculate_atr(window=self.config["atr_period"])
            if not atr_series.empty and not pd.isna(atr_series.iloc[-1]):
                self.atr_value = float(atr_series.iloc[-1])
            else:
                self.atr_value = 0.0
            self.indicator_values["atr"] = self.atr_value

            self._calculate_momentum_ma() # Populates momentum and its MAs, and volume MA

            # Now that ATR is potentially calculated, select the weight set
            self.user_defined_weights = self._select_weight_set()

            # Calculate and store other indicator values based on config
            if self.config["indicators"].get("obv"):
                obv_series = self._calculate_obv()
                self.indicator_values["obv"] = obv_series.iloc[-3:].tolist() if not obv_series.empty else []
            if self.config["indicators"].get("rsi"):
                rsi_series = self._calculate_rsi(window=self.config["indicator_periods"]["rsi"])
                self.indicator_values["rsi"] = rsi_series.iloc[-3:].tolist() if not rsi_series.empty else []
            if self.config["indicators"].get("mfi"):
                mfi_series = self._calculate_mfi(window=self.config["indicator_periods"]["mfi"])
                self.indicator_values["mfi"] = mfi_series.iloc[-3:].tolist() if not mfi_series.empty else []
            if self.config["indicators"].get("cci"):
                cci_series = self._calculate_cci(window=self.config["indicator_periods"]["cci"])
                self.indicator_values["cci"] = cci_series.iloc[-3:].tolist() if not cci_series.empty else []
            if self.config["indicators"].get("wr"):
                wr_series = self._calculate_williams_r(window=self.config["indicator_periods"]["williams_r"])
                self.indicator_values["wr"] = wr_series.iloc[-3:].tolist() if not wr_series.empty else []
            if self.config["indicators"].get("adx"):
                adx_value = self._calculate_adx(window=self.config["indicator_periods"]["adx"])
                self.indicator_values["adx"] = [adx_value]
            if self.config["indicators"].get("adi"):
                adi_series = self._calculate_adi()
                self.indicator_values["adi"] = adi_series.iloc[-3:].tolist() if not adi_series.empty else []
            if self.config["indicators"].get("momentum"):
                trend_data = self.determine_trend_momentum()
                self.indicator_values["mom"] = trend_data
            if self.config["indicators"].get("sma_10"):
                sma_series = self._calculate_sma(10)
                self.indicator_values["sma_10"] = [sma_series.iloc[-1]] if not sma_series.empty else []
            if self.config["indicators"].get("psar"):
                psar_series = self._calculate_psar()
                self.indicator_values["psar"] = psar_series.iloc[-3:].tolist() if not psar_series.empty else []
            if self.config["indicators"].get("fve"):
                fve_series = self._calculate_fve()
                if not fve_series.empty and not fve_series.isnull().all():
                    self.indicator_values["fve"] = fve_series.iloc[-3:].tolist()
                else:
                    self.indicator_values["fve"] = []
            if self.config["indicators"].get("macd"):
                macd_df = self._calculate_macd()
                self.indicator_values["macd"] = macd_df.iloc[-3:].values.tolist() if not macd_df.empty else []
            if self.config["indicators"].get("ema_alignment"):
                ema_alignment_score = self._calculate_ema_alignment()
                self.indicator_values["ema_alignment"] = ema_alignment_score
            if self.config["indicators"].get("stoch_rsi"):
                stoch_rsi_vals = self._calculate_stoch_rsi(
                    rsi_window=self.config["indicator_periods"]["stoch_rsi_period"],
                    stoch_window=self.config["indicator_periods"]["stoch_rsi_period"],
                    k_window=self.config["indicator_periods"]["stoch_rsi_k_period"],
                    d_window=self.config["indicator_periods"]["stoch_rsi_d_period"]
                )
                self.indicator_values["stoch_rsi_vals"] = stoch_rsi_vals # Store DataFrame
            if self.config["indicators"].get("stochastic_oscillator"):
                stoch_osc_vals = self._calculate_stochastic_oscillator()
                self.indicator_values["stoch_osc_vals"] = stoch_osc_vals # Store DataFrame

        def _select_weight_set(self) -> Dict[str, float]:
            """
            Selects a weight set (e.g., low_volatility, high_volatility) based on current ATR.
            """
            # Use the atr_value that was pre-calculated in _calculate_all_indicators
            if self.atr_value > self.config["atr_change_threshold"]:
                self.logger.info(f"{NEON_YELLOW} Market detected as HIGH VOLATILITY (ATR: {self.atr_value:.4f}). Using 'high_volatility' weights.{RESET}")
                return self.weight_sets.get("high_volatility", self.weight_sets["low_volatility"])
            self.logger.info(f"{NEON_BLUE} Market detected as LOW VOLATILITY (ATR: {self.atr_value:.4f}). Using 'low_volatility' weights.{RESET}")
            return self.weight_sets["low_volatility"]

        def analyze(self, current_price: Decimal, timestamp: str, order_book: Dict[str, Any]):
            """
            Performs comprehensive analysis, calculates indicators, and logs the findings.
            This method populates `self.indicator_values` and generates the output string.
            It does NOT generate the final signal; that is done by `generate_trading_signal`.
            """
            # Ensure Decimal type for price calculations
            current_price_dec = Decimal(str(current_price))
            high_dec = Decimal(str(self.df["high"].max()))
            low_dec = Decimal(str(self.df["low"].min()))
            close_dec = Decimal(str(self.df["close"].iloc[-1]))

            # Calculate all indicators for the current cycle
            self._calculate_all_indicators()

            # Calculate Support/Resistance Levels
            self.calculate_fibonacci_retracement(high_dec, low_dec, current_price_dec)
            self.calculate_pivot_points(high_dec, low_dec, close_dec)
            nearest_supports, nearest_resistances = self.find_nearest_levels(current_price_dec)

            # Order Book Analysis
            has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details = \
                self.analyze_order_book_walls(order_book)
            self.indicator_values["order_book_walls"] = {
                "bullish": has_bullish_wall, "bearish": has_bearish_wall,
                "bullish_details": bullish_wall_details, "bearish_details": bearish_wall_details
            }

            # Prepare output string
            output = f"""
    {NEON_BLUE}Exchange:{RESET} Bybit
    {NEON_BLUE}Symbol:{RESET} {self.symbol}
    {NEON_BLUE}Interval:{RESET} {self.interval}
    {NEON_BLUE}Timestamp:{RESET} {timestamp}
    {NEON_BLUE}Price History:{RESET} {self.df['close'].iloc[-3]:.2f} | {self.df['close'].iloc[-2]:.2f} | {self.df['close'].iloc[-1]:.2f}
    {NEON_BLUE}Volume History:{RESET} {self.df['volume'].iloc[-3]:,.0f} | {self.df['volume'].iloc[-2]:,.0f} | {self.df['volume'].iloc[-1]:,.0f}
    {NEON_BLUE}Current Price:{RESET} {current_price_dec:.5f}
    {NEON_BLUE}ATR ({self.config['atr_period']}):{RESET} {self.atr_value:.5f}
    """
            # Append indicator interpretations
            for indicator_name, values in self.indicator_values.items():
                # Skip indicators that are already logged in a custom format or are internal
                if indicator_name in ["order_book_walls"]:
                    continue
                interpreted_line = interpret_indicator(self.logger, indicator_name, values)
                if interpreted_line:
                    output += interpreted_line + "\n"

            # Order Book Wall Logging
            output += f"""
    {NEON_BLUE}Order Book Walls:{RESET}
    """
            if has_bullish_wall:
                output += f"{NEON_GREEN}  Bullish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bullish_wall_details.items()])}\n"
            if has_bearish_wall:
                output += f"{NEON_RED}  Bearish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bearish_wall_details.items()])}\n"
            if not has_bullish_wall and not has_bearish_wall:
                output += "  No significant walls detected.\n"

            output += f"""
    {NEON_BLUE}Support and Resistance Levels:{RESET}
    """
            for s_label, s_val in nearest_supports:
                output += f"S: {s_label} ${s_val:.5f}\n"
            for r_label, r_val in nearest_resistances:
                output += f"R: {r_label} ${r_val:.5f}\n"

            self.logger.info(output)

        def generate_trading_signal(self, current_price: Decimal) -> Tuple[Union[str, None], float, List[str], Dict[str, Decimal]]:
            """
            Generates a trading signal (buy/sell) based on indicator values and configuration.
            Returns the signal, its confidence score, conditions met, and suggested SL/TP levels.
            """
            signal_score = Decimal('0.0')
            signal = None
            conditions_met: List[str] = []
            trade_levels: Dict[str, Decimal] = {}

            # --- Bullish Signal Logic ---
            # Sum weights of bullish conditions met
            if self.config["indicators"].get("stoch_rsi") and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_k = Decimal(str(self.indicator_values["stoch_rsi_vals"]['k'].iloc[-1]))
                stoch_rsi_d = Decimal(str(self.indicator_values["stoch_rsi_vals"]['d'].iloc[-1]))
                if stoch_rsi_k < self.config["stoch_rsi_oversold_threshold"] and stoch_rsi_k > stoch_rsi_d:
                    signal_score += Decimal(str(self.user_defined_weights["stoch_rsi"]))
                    signal_score += Decimal(str(self.config["stoch_rsi_confidence_boost"])) # Add confidence boost
                    conditions_met.append("Stoch RSI Oversold Crossover")

            if self.config["indicators"].get("rsi") and self.indicator_values.get("rsi") and self.indicator_values["rsi"][-1] < 30:
                signal_score += Decimal(str(self.user_defined_weights["rsi"]))
                signal_score += Decimal(str(self.config["rsi_confidence_boost"])) # Add confidence boost
                conditions_met.append("RSI Oversold")

            if self.config["indicators"].get("mfi") and self.indicator_values.get("mfi") and self.indicator_values["mfi"][-1] < 20:
                signal_score += Decimal(str(self.user_defined_weights["mfi"]))
                signal_score += Decimal(str(self.config["mfi_confidence_boost"])) # Add confidence boost
                conditions_met.append("MFI Oversold")

            if self.config["indicators"].get("ema_alignment") and self.indicator_values.get("ema_alignment", 0.0) > 0:
                signal_score += Decimal(str(self.user_defined_weights["ema_alignment"])) * Decimal(str(abs(self.indicator_values["ema_alignment"])))  # Scale by score
                conditions_met.append("Bullish EMA Alignment")

            if self.config["indicators"].get("volume_confirmation") and self._calculate_volume_confirmation():
                signal_score += Decimal(str(self.user_defined_weights["volume_confirmation"]))
                conditions_met.append("Volume Confirmation")

            if self.config["indicators"].get("divergence") and self.detect_macd_divergence() == "bullish":
                signal_score += Decimal(str(self.user_defined_weights["divergence"]))
                conditions_met.append("Bullish MACD Divergence")

            if self.indicator_values["order_book_walls"].get("bullish"):
                signal_score += Decimal(str(self.config["order_book_support_confidence_boost"]))  # Boost score for order book wall
                conditions_met.append("Bullish Order Book Wall")

            # --- New: Stochastic Oscillator Bullish Signal ---
            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_k = Decimal(str(self.indicator_values["stoch_osc_vals'] ['k'].iloc[-1]))
                stoch_d = Decimal(str(self.indicator_values["stoch_osc_vals'] ['d'].iloc[-1]))
                if stoch_k < 20 and stoch_k > stoch_d:  # Oversold and K crossing above D
                    signal_score += Decimal(str(self.user_defined_weights["stochastic_oscillator"]))
                    conditions_met.append("Stoch Oscillator Oversold Crossover")

            # Final check for Bullish signal
            if signal_score >= Decimal(str(self.config["signal_score_threshold"])):
                signal = "buy"
                # Calculate Stop Loss and Take Profit
                if self.atr_value > 0:
                    stop_loss = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config["stop_loss_multiple"])))
                    take_profit = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config["take_profit_multiple"])))
                    trade_levels["stop_loss"] = stop_loss.quantize(Decimal('0.00001'))
                    trade_levels["take_profit"] = take_profit.quantize(Decimal('0.00001'))

            # --- Bearish Signal Logic (similar structure) ---
            bearish_score = Decimal('0.0')
            bearish_conditions: List[str] = []

            if self.config["indicators"].get("stoch_rsi") and not self.indicator_values["stoch_rsi_vals"].empty:
                stoch_rsi_k = Decimal(str(self.indicator_values["stoch_rsi_vals"]['k'].iloc[-1]))
                stoch_rsi_d = Decimal(str(self.indicator_values["stoch_rsi_vals"]['d'].iloc[-1]))
                if stoch_rsi_k > self.config["stoch_rsi_overbought_threshold"] and stoch_rsi_k < stoch_rsi_d:
                    bearish_score += Decimal(str(self.user_defined_weights["stoch_rsi"]))
                    bearish_score += Decimal(str(self.config["stoch_rsi_confidence_boost"])) # Add confidence boost
                    bearish_conditions.append("Stoch RSI Overbought Crossover")

            if self.config["indicators"].get("rsi") and self.indicator_values.get("rsi") and self.indicator_values["rsi"][-1] > 70:
                bearish_score += Decimal(str(self.user_defined_weights["rsi"]))
                bearish_score += Decimal(str(self.config["rsi_confidence_boost"])) # Add confidence boost
                bearish_conditions.append("RSI Overbought")

            if self.config["indicators"].get("mfi") and self.indicator_values.get("mfi") and self.indicator_values["mfi"][-1] > 80:
                bearish_score += Decimal(str(self.user_defined_weights["mfi"]))
                bearish_score += Decimal(str(self.config["mfi_confidence_boost"])) # Add confidence boost
                bearish_conditions.append("MFI Overbought")

            if self.config["indicators"].get("ema_alignment") and self.indicator_values.get("ema_alignment", 0.0) < 0:
                bearish_score += Decimal(str(self.user_defined_weights["ema_alignment"])) * Decimal(str(abs(self.indicator_values["ema_alignment"])))
                bearish_conditions.append("Bearish EMA Alignment")

            if self.config["indicators"].get("divergence") and self.detect_macd_divergence() == "bearish":
                bearish_score += Decimal(str(self.user_defined_weights["divergence"]))
                bearish_conditions.append("Bearish MACD Divergence")

            if self.indicator_values["order_book_walls"].get("bearish"):
                bearish_score += Decimal(str(self.config["order_book_resistance_confidence_boost"]))
                bearish_conditions.append("Bearish Order Book Wall")

            # --- New: Stochastic Oscillator Bearish Signal ---
            if self.config["indicators"].get("stochastic_oscillator") and self.indicator_values.get("stoch_osc_vals") is not None and not self.indicator_values["stoch_osc_vals"].empty:
                stoch_k = Decimal(str(self.indicator_values["stoch_osc_vals"]['k'].iloc[-1]))
                stoch_d = Decimal(str(self.indicator_values["stoch_osc_vals"]['d'].iloc[-1]))
                if stoch_k > 80 and stoch_k < stoch_d:  # Overbought and K crossing below D
                    bearish_score += Decimal(str(self.user_defined_weights["stochastic_oscillator"]))
                    bearish_conditions.append("Stoch Oscillator Overbought Crossover")

            # Final check for Bearish signal (only if no bullish signal already)
            if signal is None and bearish_score >= Decimal(str(self.config["signal_score_threshold"])):
                signal = "sell"
                signal_score = bearish_score  # Use bearish score if it's the chosen signal
                conditions_met = bearish_conditions  # Use bearish conditions
                # Calculate Stop Loss and Take Profit for sell signal
                if self.atr_value > 0:
                    stop_loss = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config["stop_loss_multiple"])))
                    take_profit = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config["take_profit_multiple"])))
                    trade_levels["stop_loss"] = stop_loss.quantize(Decimal('0.00001'))
                    trade_levels["take_profit"] = take_profit.quantize(Decimal('0.00001'))

            return signal, float(signal_score), conditions_met, trade_levels


    def interpret_indicator(logger: logging.Logger, indicator_name: str, values: Union[List[float], float, Dict[str, Any], pd.DataFrame]) -> Union[str, None]:
        """
        Provides a human-readable interpretation of indicator values with color coding.
        """
        if values is None or (isinstance(values, list) and not values) or (isinstance(values, pd.DataFrame) and values.empty):
            return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No data available."
        try:
            # Handle DataFrame-based indicators first
            if indicator_name == "stoch_rsi_vals":
                if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:
                    stoch_rsi_k = values['k'].iloc[-1]
                    stoch_rsi_d = values['d'].iloc[-1]
                    stoch_rsi_val = values['stoch_rsi'].iloc[-1]
                    k_color = NEON_YELLOW
                    d_color = NEON_YELLOW
                    stoch_rsi_color = NEON_YELLOW

                    # Check for oversold/overbought and crossovers
                    if stoch_rsi_k < CONFIG["stoch_rsi_oversold_threshold"] and stoch_rsi_k > stoch_rsi_d:
                        k_color = NEON_GREEN
                        stoch_rsi_color = NEON_GREEN
                    elif stoch_rsi_k > CONFIG["stoch_rsi_overbought_threshold"] and stoch_rsi_k < stoch_rsi_d:
                        k_color = NEON_RED
                        stoch_rsi_color = NEON_RED

                    return (f"{NEON_GREEN}Stoch RSI:{RESET} K={k_color}{stoch_rsi_k:.2f}{RESET}, "
                            f"D={d_color}{stoch_rsi_d:.2f}{RESET}, "
                            f"Stoch_RSI={stoch_rsi_color}{stoch_rsi_val:.2f}{RESET}")
                else:
                    return f"{NEON_YELLOW}Stoch RSI:{RESET} No data available."

            if indicator_name == "stoch_osc_vals":
                if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:
                    stoch_k = values['k'].iloc[-1]
                    stoch_d = values['d'].iloc[-1]
                    k_color = NEON_YELLOW
                    d_color = NEON_YELLOW

                    # Check for oversold/overbought and crossovers
                    if stoch_k < 20 and stoch_k > stoch_d:  # Oversold and K crossing above D
                        k_color = NEON_GREEN
                    elif stoch_k > 80 and stoch_k < stoch_d:  # Overbought and K crossing below D
                        k_color = NEON_RED

                    return (f"{NEON_CYAN}Stochastic Oscillator:{RESET} K={k_color}{stoch_k:.2f}{RESET}, "
                            f"D={d_color}{stoch_d:.2f}{RESET}")
                else:
                    return f"{NEON_YELLOW}Stochastic Oscillator:{RESET} No data available."

            # Convert single float values to list for consistent indexing if needed
            if isinstance(values, (float, int)):
                values = [values]
            elif isinstance(values, dict):  # For 'mom' which is a dict
                if indicator_name == "mom":
                    trend = values.get("trend", "N/A")
                    strength = values.get("strength", 0.0)
                    strength_color = NEON_BLUE
                    if strength > CONFIG["trend_strength_threshold"]:
                        strength_color = NEON_GREEN if trend == "Uptrend" else NEON_RED if trend == "Downtrend" else NEON_YELLOW
                    return f"{NEON_PURPLE}Momentum Trend:{RESET} {trend} (Strength: {strength_color}{strength:.2f}{RESET})"
                else:
                    return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} Dictionary format not specifically interpreted."

            # General interpretation for list-based indicators
            last_value = values[-1] if isinstance(values, list) and values else values[0] if isinstance(values, list) else values  # Handles single value lists too

            if indicator_name == "rsi":
                color = NEON_YELLOW
                status = "Neutral"
                if last_value > 70:
                    color = NEON_RED
                    status = "Overbought"
                elif last_value < 30:
                    color = NEON_GREEN
                    status = "Oversold"
                return f"{NEON_BLUE}RSI:{RESET} {color}{last_value:.2f}{RESET} ({status})"
            elif indicator_name == "mfi":
                color = NEON_YELLOW
                status = "Neutral"
                if last_value > 80:
                    color = NEON_RED
                    status = "Overbought"
                elif last_value < 20:
                    color = NEON_GREEN
                    status = "Oversold"
                return f"{NEON_BLUE}MFI:{RESET} {color}{last_value:.2f}{RESET} ({status})"
            elif indicator_name == "cci":
                color = NEON_YELLOW
                status = "Neutral"
                if last_value > 100:
                    color = NEON_RED
                    status = "Overbought"
                elif last_value < -100:
                    color = NEON_GREEN
                    status = "Oversold"
                return f"{NEON_BLUE}CCI:{RESET} {color}{last_value:.2f}{RESET} ({status})"
            elif indicator_name == "wr":
                color = NEON_YELLOW
                status = "Neutral"
                if last_value < -80:
                    color = NEON_GREEN
                    status = "Oversold"
                elif last_value > -20:
                    color = NEON_RED
                    status = "Overbought"
                return f"{NEON_BLUE}Williams %R:{RESET} {color}{last_value:.2f}{RESET} ({status})"
            elif indicator_name == "adx":
                color = NEON_YELLOW
                status = "Ranging"
                if last_value > 25:
                    color = NEON_GREEN
                    status = "Trending"
                return f"{NEON_BLUE}ADX:{RESET} {color}{last_value:.2f}{RESET} ({status})"
            elif indicator_name == "obv":
                status = "Neutral"
                color = NEON_BLUE
                if len(values) >= 2:
                    if values[-1] > values[-2]:
                        color = NEON_GREEN
                        status = "Bullish"
                    elif values[-1] < values[-2]:
                        color = NEON_RED
                        status = "Bearish"
                    return f"{NEON_BLUE}OBV:{RESET} {color}{values[-1]:.2f}{RESET} ({status})"
                else:
                    return f"{NEON_BLUE}OBV:{RESET} {color}{last_value:.2f}{RESET} (Insufficient history for trend)"
            elif indicator_name == "adi":
                status = "Neutral"
                color = NEON_BLUE
                if len(values) >= 2:
                    if values[-1] > values[-2]:
                        color = NEON_GREEN
                        status = "Accumulation"
                    elif values[-1] < values[-2]:
                        color = NEON_RED
                        status = "Distribution"
                    return f"{NEON_BLUE}ADI:{RESET} {color}{values[-1]:.2f}{RESET} ({status})"
                else:
                    return f"{NEON_BLUE}ADI:{RESET} {color}{last_value:.2f}{RESET} (Insufficient history for trend)"
            elif indicator_name == "sma_10":
                return f"{NEON_YELLOW}SMA (10):{RESET} {NEON_BLUE}{last_value:.2f}{RESET}"
            elif indicator_name == "psar":
                return f"{NEON_BLUE}PSAR:{RESET} {NEON_YELLOW}{last_value:.4f}{RESET} (Last Value)"
            elif indicator_name == "fve":
                color = NEON_BLUE
                if last_value > 0: color = NEON_GREEN
                elif last_value < 0: color = NEON_RED
                return f"{NEON_BLUE}FVE:{RESET} {color}{last_value:.2f}{RESET} (Last Value)"
            elif indicator_name == "macd":
                # values for MACD are [macd_line, signal_line, histogram]
                if len(values[-1]) == 3:
                    macd_line, signal_line, histogram = values[-1][0], values[-1][1], values[-1][2]
                    hist_color = NEON_YELLOW
                    if histogram > 0: hist_color = NEON_GREEN
                    elif histogram < 0: hist_color = NEON_RED
                    return (f"{NEON_GREEN}MACD:{RESET} MACD={NEON_YELLOW}{macd_line:.2f}{RESET}, "
                            f"Signal={NEON_YELLOW}{signal_line:.2f}{RESET}, "
                            f"Histogram={hist_color}{histogram:.2f}{RESET}")
                else:
                    return f"{NEON_RED}MACD:{RESET} Calculation issue."
            elif indicator_name == "ema_alignment":
                score = values[0] # It's a single float, wrapped in a list by the general logic
                color = NEON_YELLOW
                status = 'Neutral'
                if score > 0:
                    color = NEON_GREEN
                    status = 'Bullish'
                elif score < 0:
                    color = NEON_RED
                    status = 'Bearish'
                return f"{NEON_PURPLE}EMA Alignment:{RESET} Score={color}{score:.2f}{RESET} ({status})"
            else:
                return f"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No specific interpretation available."
        except (TypeError, IndexError, KeyError, ValueError, InvalidOperation) as e:
            logger.error(f"{NEON_RED}Error interpreting {indicator_name}: {e}. Values: {values}{RESET}")
            return f"{NEON_RED}{indicator_name.upper()}:{RESET} Interpretation error."


    def main():
        """
        Main function to run the trading analysis bot.
        Handles user input, data fetching, analysis, and signal generation loop.
        """
        if not API_KEY or not API_SECRET:
            logger.error(f"{NEON_RED} BYBIT_API_KEY and BYBIT_API_SECRET must be set in your .env file. {RESET}")
            return

        symbol_input = input(f"{NEON_BLUE} Enter trading symbol (e.g., BTCUSDT): {RESET}").upper().strip()
        symbol = symbol_input if symbol_input else "BTCUSDT"

        interval_input = input(f"{NEON_BLUE} Enter timeframe (e.g., {', '.join(VALID_INTERVALS)} or press Enter for default {CONFIG['interval']}): {RESET}").strip()
        interval = interval_input if interval_input and interval_input in VALID_INTERVALS else CONFIG["interval"]

        # Setup a dedicated logger for this symbol's activities
        symbol_logger = setup_custom_logger(symbol)
        symbol_logger.info(f"{NEON_BLUE} Starting analysis for {symbol} with interval {interval}{RESET}")

        last_signal_time = 0.0  # Tracks the last time a signal was triggered for cooldown
        last_order_book_fetch_time = 0.0  # Tracks last order book fetch time for debouncing

        while True:
            try:
                current_price = fetch_current_price(symbol, API_KEY, API_SECRET, symbol_logger)
                if current_price is None:
                    symbol_logger.error(f"{NEON_RED} Failed to fetch current price for {symbol}. Skipping cycle. {RESET}")
                    time.sleep(CONFIG["retry_delay"])
                    continue

                df = fetch_klines(symbol, interval, API_KEY, API_SECRET, symbol_logger, limit=200)
                if df.empty:
                    symbol_logger.error(f"{NEON_RED} Failed to fetch Kline data for {symbol}. Skipping cycle. {RESET}")
                    time.sleep(CONFIG["retry_delay"])
                    continue

                # Debounce order book fetching to reduce API calls
                order_book_data = None
                if time.time() - last_order_book_fetch_time >= CONFIG["order_book_debounce_s"]:
                    order_book_data = fetch_order_book(symbol, API_KEY, API_SECRET, symbol_logger, limit=CONFIG["order_book_depth_to_check"])
                    last_order_book_fetch_time = time.time()
                else:
                    symbol_logger.debug(f"{NEON_YELLOW} Order book fetch debounced. Next fetch in {CONFIG['order_book_debounce_s'] - (time.time() - last_order_book_fetch_time):.1f}s{RESET}")

                analyzer = TradingAnalyzer(df, CONFIG, symbol_logger, symbol, interval)
                timestamp = datetime.now(TIMEZONE).strftime("%Y-%m-%d %H:%M:%S %Z")

                # Perform analysis and log the current state of indicators
                analyzer.analyze(current_price, timestamp, order_book_data)

                # Generate trading signal based on the analysis
                current_time_seconds = time.time()
                signal, confidence, conditions_met, trade_levels = analyzer.generate_trading_signal(current_price)

                if signal and (current_time_seconds - last_signal_time >= CONFIG["signal_cooldown_s"]):
                    symbol_logger.info(f"\n{NEON_PURPLE}--- TRADING SIGNAL TRIGGERED ---{RESET}")
                    symbol_logger.info(f"{NEON_BLUE} Signal:{RESET} {signal.upper()} (Confidence: {confidence:.2f})")
                    symbol_logger.info(f"{NEON_BLUE} Conditions Met:{RESET} {', '.join(conditions_met) if conditions_met else 'None'}")
                    if trade_levels:
                        symbol_logger.info(f"{NEON_GREEN} Suggested Stop Loss:{RESET} {trade_levels.get('stop_loss'):.5f}")
                        symbol_logger.info(f"{NEON_GREEN} Suggested Take Profit:{RESET} {trade_levels.get('take_profit'):.5f}")
                    symbol_logger.info(f"{NEON_YELLOW} --- Placeholder: Order placement logic would be here for {signal.upper()} signal ---{RESET}")
                    last_signal_time = current_time_seconds  # Update last signal time

                time.sleep(CONFIG["analysis_interval"])

            except requests.exceptions.RequestException as e:
                symbol_logger.error(f"{NEON_RED} Network or API communication error: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}")
                time.sleep(CONFIG["retry_delay"])
            except KeyboardInterrupt:
                symbol_logger.info(f"{NEON_YELLOW} Analysis stopped by user. {RESET}")
                break
            except Exception as e:
                symbol_logger.exception(f"{NEON_RED} An unexpected error occurred: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}")
                time.sleep(CONFIG["retry_delay"])


    if __name__ == "__main__":
        main()
    ```
- role: system
  content: |-
    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a trading bot for Bybit, performing technical analysis and generating trade signals. Key features include:

    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from a `config.json` file, allowing customization of intervals, indicator periods, and signal weights. It handles missing or corrupt config files by loading defaults.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets (e.g., "low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, along with confidence scores and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    The refactoring focused on improving logical flow, ensuring consistent data handling (especially with `Decimal`), and adjusting configuration parameters for clarity.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a Bybit trading bot focused on technical analysis.

    **Key Topics Discussed:**
    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from `config.json`, including intervals, indicator periods, and signal weights, with robust handling for missing/corrupt files.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets ("low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, confidence scores, and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    **Important Decisions/Conclusions:**
    *   Refactoring focused on improving logical flow and ensuring consistent data handling using `Decimal` for precision.
    *   Configuration parameters were adjusted for clarity and robustness.

    **Action Items/Next Steps:**
    *   Implement actual order placement logic, as it's currently a placeholder.
    *   Further fine-tune indicator parameters and signal weights.
    *   Consider adding backtesting capabilities.

    **Unresolved Questions:**
    *   How to handle real-time order execution and position management.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    The user requested to color-code indicator values in the Python trading bot's output for better readability.

    **Key Changes Implemented:**
    *   The `interpret_indicator` function was significantly enhanced to apply `colorama` (NEON_GREEN, NEON_RED, NEON_YELLOW, NEON_BLUE) based on the indicator's value and its typical interpretation (e.g., overbought/oversold for RSI, MFI, CCI, Williams %R; trending/ranging for ADX; bullish/bearish for OBV, ADI, MACD histogram, Stochastic Oscillators).
    *   It now correctly handles `pd.DataFrame` inputs for indicators like Stochastic RSI and Stochastic Oscillator, interpreting their K and D lines for crossovers and overbought/oversold conditions.
    *   The `TradingAnalyzer.analyze` function was refactored to remove redundant manual printing of indicator interpretations, instead passing all relevant indicator values through the `interpret_indicator` function for consistent formatting and coloring.

    **Outcome:**
    The bot's console output now provides visually distinct and immediately interpretable indicator values, centralizing the coloring logic and improving overall readability.
- role: user
  content: add indicators and calculations from this file to the bot .file ehlersi.md
- role: assistant
  content: "Okay, I will integrate the Ehlers indicators from `ehl_indicators.py` into your `whale.py` trading bot.\n\nThis is a significant addition, as Ehlers indicators often involve more complex mathematical operations and filtering.\n\nHere's a breakdown of the changes and additions:\n\n1.  **New Imports:**\n    *   `scipy.signal` for filter operations.\n    *   `scipy.stats` for `pearsonr` used in Correlation Cycle Indicator.\n\n2.  **`TradingAnalyzer` Class Additions:**\n    *   **New Methods:** Each Ehlers indicator from `ehl_indicators.py` has been added as a private method (`_calculate_ehlers_...`) within the `TradingAnalyzer` class.\n        *   `_calculate_ehlers_fisher_transform`\n        *   `_calculate_ehlers_stochastic_rsi`\n        *   `_calculate_ehlers_optimal_moving_average`\n        *   `_calculate_ehlers_super_smoother_filter`\n        *   `_calculate_ehlers_adaptive_moving_average`\n        *   `_calculate_ehlers_correlation_cycle_indicator`\n        *   `_calculate_ehlers_decylcer`\n        *   `_calculate_ehlers_bandpass_filter`\n        *   `_calculate_ehlers_center_of_gravity`\n    *   **Robustness:** Added `try-except` blocks and checks for sufficient data length within each new calculation method to prevent errors and `NaN` propagation.\n    *   **Parameterization:** All periods and parameters for Ehlers indicators are now configurable via `self.config[\"indicator_periods\"]`.\n\n3.  **Configuration (`config.json` / `default_config`):**\n    *   **Enable/Disable:** New entries under `\"indicators\"` to enable/disable each Ehlers indicator (all set to `False` by default to avoid overwhelming the output/logic initially).\n    *   **Periods:** New entries under `\"indicator_periods\"` for each Ehlers indicator's specific parameters (e.g., `ehlers_fisher_period`, `ehlers_stoch_rsi_period`, `ehlers_oma_period`, etc.).\n    *   **Weights:** Placeholder weights added to `low_volatility` and `high_volatility` sets for each Ehlers indicator. **These will require significant fine-tuning based on your trading strategy and backtesting.**\n\n4.  **`_calculate_all_indicators` Update:**\n    *   Added calls to the new Ehlers indicator calculation methods, conditionally based on their `True`/`False` status in the `config[\"indicators\"]` dictionary.\n    *   The latest value (or relevant values) of each Ehlers indicator is stored in `self.indicator_values`.\n\n5.  **`interpret_indicator` Function Update:**\n    *   Added specific `elif` blocks for each Ehlers indicator to provide a human-readable, color-coded interpretation of its latest value.\n    *   **Interpretation Logic:**\n        *   **Fisher Transform:** Strong bullish/bearish based on thresholds (e.g., > 1.5, < -1.5).\n        *   **Stoch RSI (Ehlers):** Similar to regular Stoch RSI (overbought/oversold, crossovers).\n        *   **Optimal/Adaptive MA, Super Smoother, Decycler:** Price relative to the filter.\n        *   **Correlation Cycle:** Indicates cycle phase.\n        *   **Bandpass Filter:** Indicates presence of cycle.\n        *   **Center of Gravity:** Bullish/bearish based on its value relative to its previous value or a signal line (not implemented a signal line here, just value).\n\n6.  **`generate_trading_signal` Update:**\n    *   Added placeholder logic to incorporate Ehlers indicators into the signal scoring. **This is the most critical part for your strategy and will need extensive customization and testing.** I've added basic examples for Fisher Transform and Ehlers Stochastic RSI, but the others are left as placeholders for you to define their specific signal contributions.\n\n**Important Considerations & Next Steps:**\n\n*   **Dependencies:** Make sure you have `scipy` installed (`pip install scipy`).\n*   **Performance:** Ehlers indicators can be computationally intensive, especially with large `limit` values for `fetch_klines`. Monitor performance.\n*   **Signal Logic:** The signal generation logic for Ehlers indicators is highly specialized. The current implementation provides a basic framework. You **must** research and define how each Ehlers indicator contributes to your `buy`/`sell` signals and their confidence scores.\n    *   **Fisher Transform:** Often used for identifying turning points.\n    *   **Ehlers Stochastic RSI:** Smoother, more responsive version of Stoch RSI.\n    *   **Optimal/Adaptive MAs:** Used for trend following, often with less lag.\n    *   **Super Smoother Filter:** Excellent for noise reduction and identifying true trend.\n    *   **Decycler/Bandpass:** For identifying and isolating cyclical components.\n    *   **Correlation Cycle:** Measures the correlation between price and a sine wave, indicating cycle phase.\n    *   **Center of Gravity:** A zero-lag indicator for identifying turning points.\n*   **Thresholds:** The thresholds used for interpreting and generating signals from Ehlers indicators (e.g., Fisher Transform > 1.5) are illustrative. You'll need to determine optimal thresholds through backtesting.\n*   **Data Requirements:** Some Ehlers filters (especially Bandpass, Decycler, Super Smoother) require a significant amount of historical data to warm up and produce valid outputs. Ensure your `limit` in `fetch_klines` is sufficient.\n\nHere's the updated `whale.py` code:\n\n```python\nimport os\nimport logging\nimport requests\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport hmac\nimport hashlib\nimport time\nfrom dotenv import load_dotenv\nfrom typing import Dict, Tuple, List, Union, Any\nfrom colorama import init, Fore, Style\nfrom zoneinfo import ZoneInfo\nfrom decimal import Decimal, getcontext, InvalidOperation\nimport json\n\n# --- New Imports for Ehlers Indicators ---\nimport scipy.signal\nimport scipy.stats # For Pearson correlation in Correlation Cycle Indicator\n\n# --- Logger Configuration (Minimal, for self-containment) ---\ndef setup_custom_logger(name):\n    \"\"\"Sets up a custom logger with console and file handlers.\"\"\"\n    log_file = os.path.join(LOG_DIRECTORY, f\"{name}.log\")\n\n    formatter = logging.Formatter(\n        fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    )\n\n    handler = logging.FileHandler(log_file)\n    handler.setFormatter(formatter)\n\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.INFO) # Set default level to INFO\n    logger.addHandler(handler)\n    logger.addHandler(console_handler) # Add console output\n    return logger\n\n# --- Configuration & Constants ---\n\n# Set Decimal precision for financial calculations to avoid floating point errors\ngetcontext().prec = 10\n\n# Initialize colorama for cross-platform colored terminal output\ninit(autoreset=True)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# --- Color Codex ---\nNEON_GREEN = Fore.LIGHTGREEN_EX\nNEON_BLUE = Fore.CYAN\nNEON_PURPLE = Fore.MAGENTA\nNEON_YELLOW = Fore.YELLOW\nNEON_RED = Fore.LIGHTRED_EX\nRESET = Style.RESET_ALL\n\n# --- API & Bot Settings ---\nAPI_KEY = os.getenv(\"BYBIT_API_KEY\")\nAPI_SECRET = os.getenv(\"BYBIT_API_SECRET\")\nBASE_URL = os.getenv(\"BYBIT_BASE_URL\", \"https://api.bybit.com\")\nCONFIG_FILE = \"config.json\"\nLOG_DIRECTORY = \"bot_logs\"\nTIMEZONE = ZoneInfo(\"America/Chicago\")  # Using a specific timezone for consistency\nMAX_API_RETRIES = 3\nRETRY_DELAY_SECONDS = 5\nVALID_INTERVALS = [\"1\", \"3\", \"5\", \"15\", \"30\", \"60\", \"120\", \"240\", \"D\", \"W\", \"M\"]\nRETRY_ERROR_CODES = [429, 500, 502, 503, 504]  # HTTP status codes to trigger a retry\n\n# Ensure log directory exists\nos.makedirs(LOG_DIRECTORY, exist_ok=True)\n\n# Setup the main application logger\nlogger = setup_custom_logger('whalebot_main')\n\n\ndef load_config(filepath: str) -> dict:\n    \"\"\"\n    Loads configuration from a JSON file, merging with default values.\n    If the file is not found or is invalid, it creates one with default settings.\n    \"\"\"\n    default_config = {\n        \"interval\": \"15\",\n        \"analysis_interval\": 30,  # Time in seconds between main analysis cycles\n        \"retry_delay\": 5,  # Delay in seconds for API retries\n        \"momentum_period\": 10,\n        \"momentum_ma_short\": 12,\n        \"momentum_ma_long\": 26,\n        \"volume_ma_period\": 20,\n        \"atr_period\": 14,\n        \"trend_strength_threshold\": 0.4,\n        \"sideways_atr_multiplier\": 1.5,\n        \"signal_score_threshold\": 1.0,  # Minimum combined weight for a signal to be valid\n        \"indicators\": {\n            \"ema_alignment\": True,\n            \"momentum\": True,\n            \"volume_confirmation\": True,\n            \"divergence\": True,\n            \"stoch_rsi\": True,\n            \"rsi\": True,\n            \"macd\": True,\n            \"vwap\": False,\n            \"obv\": True,\n            \"adi\": True,\n            \"cci\": True,\n            \"wr\": True,\n            \"adx\": True,\n            \"psar\": True,\n            \"fve\": True,\n            \"sma_10\": False,\n            \"mfi\": True,\n            \"stochastic_oscillator\": True,\n            # --- Ehlers Indicators (Default: False) ---\n            \"ehlers_fisher_transform\": False,\n            \"ehlers_stochastic_rsi\": False,\n            \"ehlers_optimal_moving_average\": False,\n            \"ehlers_super_smoother_filter\": False,\n            \"ehlers_adaptive_moving_average\": False,\n            \"ehlers_correlation_cycle_indicator\": False,\n            \"ehlers_decycler\": False,\n            \"ehlers_bandpass_filter\": False,\n            \"ehlers_center_of_gravity\": False,\n        },\n        \"weight_sets\": {\n            \"low_volatility\": {  # Weights for a low volatility market environment\n                \"ema_alignment\": 0.3,\n                \"momentum\": 0.2,\n                \"volume_confirmation\": 0.2,\n                \"divergence\": 0.1,\n                \"stoch_rsi\": 0.5,\n                \"rsi\": 0.3,\n                \"macd\": 0.3,\n                \"vwap\": 0.0,\n                \"obv\": 0.1,\n                \"adi\": 0.1,\n                \"cci\": 0.1,\n                \"wr\": 0.1,\n                \"adx\": 0.1,\n                \"psar\": 0.1,\n                \"fve\": 0.2,\n                \"sma_10\": 0.0,\n                \"mfi\": 0.3,\n                \"stochastic_oscillator\": 0.4,\n                # --- Ehlers Indicator Weights (Placeholder) ---\n                \"ehlers_fisher_transform\": 0.2,\n                \"ehlers_stochastic_rsi\": 0.3,\n                \"ehlers_optimal_moving_average\": 0.1,\n                \"ehlers_super_smoother_filter\": 0.1,\n                \"ehlers_adaptive_moving_average\": 0.1,\n                \"ehlers_correlation_cycle_indicator\": 0.1,\n                \"ehlers_decycler\": 0.1,\n                \"ehlers_bandpass_filter\": 0.0, # Usually not a direct signal generator\n                \"ehlers_center_of_gravity\": 0.2,\n            },\n            \"high_volatility\": {  # Weights for a high volatility market environment\n                \"ema_alignment\": 0.1,\n                \"momentum\": 0.4,\n                \"volume_confirmation\": 0.1,\n                \"divergence\": 0.2,\n                \"stoch_rsi\": 0.4,\n                \"rsi\": 0.4,\n                \"macd\": 0.4,\n                \"vwap\": 0.0,\n                \"obv\": 0.1,\n                \"adi\": 0.1,\n                \"cci\": 0.1,\n                \"wr\": 0.1,\n                \"adx\": 0.1,\n                \"psar\": 0.1,\n                \"fve\": 0.3,\n                \"sma_10\": 0.0,\n                \"mfi\": 0.4,\n                \"stochastic_oscillator\": 0.3,\n                # --- Ehlers Indicator Weights (Placeholder) ---\n                \"ehlers_fisher_transform\": 0.3,\n                \"ehlers_stochastic_rsi\": 0.4,\n                \"ehlers_optimal_moving_average\": 0.2,\n                \"ehlers_super_smoother_filter\": 0.2,\n                \"ehlers_adaptive_moving_average\": 0.2,\n                \"ehlers_correlation_cycle_indicator\": 0.1,\n                \"ehlers_decycler\": 0.1,\n                \"ehlers_bandpass_filter\": 0.0,\n                \"ehlers_center_of_gravity\": 0.3,\n            }\n        },\n        \"stoch_rsi_oversold_threshold\": 20,\n        \"stoch_rsi_overbought_threshold\": 80,\n        \"stoch_rsi_confidence_boost\": 0.5,  # Additional boost for strong Stoch RSI signals (changed to float)\n        \"stoch_rsi_mandatory\": False,  # If true, Stoch RSI must be a confirming factor\n        \"rsi_confidence_boost\": 0.2, # Changed to float\n        \"mfi_confidence_boost\": 0.2, # Changed to float\n        \"order_book_support_confidence_boost\": 0.3, # Changed to float\n        \"order_book_resistance_confidence_boost\": 0.3, # Changed to float\n        \"stop_loss_multiple\": 1.5,  # Multiplier for ATR to determine stop loss distance\n        \"take_profit_multiple\": 1.0,  # Multiplier for ATR to determine take profit distance\n        \"order_book_wall_threshold_multiplier\": 2.0,  # Multiplier for average volume to identify a \"wall\"\n        \"order_book_depth_to_check\": 10,  # Number of order book levels to check for walls\n        \"price_change_threshold\": 0.005,  # % change in price to consider significant\n        \"atr_change_threshold\": 0.005,  # % change in ATR to consider significant volatility change\n        \"signal_cooldown_s\": 60,  # Seconds to wait before generating another signal\n        \"order_book_debounce_s\": 10,  # Seconds to wait between order book API calls\n        \"ema_short_period\": 12,\n        \"ema_long_period\": 26,\n        \"volume_confirmation_multiplier\": 1.5,  # Volume must be this many times average volume for confirmation\n        \"indicator_periods\": {\n            \"rsi\": 14,\n            \"mfi\": 14,\n            \"cci\": 20,\n            \"williams_r\": 14,\n            \"adx\": 14,\n            \"stoch_rsi_period\": 14,  # Period for RSI calculation within Stoch RSI\n            \"stoch_rsi_k_period\": 3,  # Smoothing period for %K line\n            \"stoch_rsi_d_period\": 3,  # Smoothing period for %D line (signal line)\n            \"momentum\": 10,\n            \"momentum_ma_short\": 12,\n            \"momentum_ma_long\": 26,\n            \"volume_ma\": 20,\n            \"atr\": 14,\n            \"sma_10\": 10,\n            \"fve_price_ema\": 10,  # EMA period for FVE price component\n            \"fve_obv_sma\": 20,  # SMA period for OBV normalization\n            \"fve_atr_sma\": 20,  # SMA period for ATR normalization\n            \"stoch_osc_k\": 14,  # Stochastic Oscillator K period\n            \"stoch_osc_d\": 3,  # Stochastic Oscillator D period\n            # --- Ehlers Indicator Periods ---\n            \"ehlers_fisher_period\": 10,\n            \"ehlers_stoch_rsi_period\": 14,\n            \"ehlers_stoch_rsi_k_period\": 3,\n            \"ehlers_stoch_rsi_d_period\": 3,\n            \"ehlers_oma_period\": 10,\n            \"ehlers_ssf_period\": 10,\n            \"ehlers_ssf_poles\": 2, # Number of poles for Super Smoother (2 or 3)\n            \"ehlers_ama_period\": 10,\n            \"ehlers_ama_fast_alpha\": 0.5, # Fast alpha for AMA (0.5 for 2-period EMA)\n            \"ehlers_ama_slow_alpha\": 0.05, # Slow alpha for AMA (0.05 for 39-period EMA)\n            \"ehlers_cci_period\": 20,\n            \"ehlers_decycler_period\": 20,\n            \"ehlers_bandpass_period\": 20, # Cycle period for bandpass filter\n            \"ehlers_cog_period\": 10,\n        },\n        \"order_book_analysis\": {\n            \"enabled\": True,\n            \"wall_threshold_multiplier\": 2.0,\n            \"depth_to_check\": 10,\n            \"support_boost\": 0.3, # Changed to float\n            \"resistance_boost\": 0.3, # Changed to float\n        },\n        \"trailing_stop_loss\": {\n            \"enabled\": False,  # Disabled by default\n            \"initial_activation_percent\": 0.5,  # Activate trailing stop after price moves X% in favor\n            \"trailing_stop_multiple_atr\": 1.5  # Trail stop based on ATR multiple\n        },\n        \"take_profit_scaling\": {\n            \"enabled\": False,  # Disabled by default\n            \"targets\": [\n                {\"level\": 1.5, \"percentage\": 0.25},  # Sell 25% when price hits 1.5x ATR TP\n                {\"level\": 2.0, \"percentage\": 0.50}  # Sell 50% of remaining when price hits 2.0x ATR TP\n            ]\n        }\n    }\n    try:\n        with open(filepath, \"r\", encoding=\"utf-8\") as f:\n            config = json.load(f)\n            # Merge loaded config with defaults. Prioritize loaded values, but ensure all default keys exist.\n            merged_config = {**default_config, **config}\n\n            # Recursively merge nested dictionaries (like 'indicators' and 'weight_sets')\n            for key, default_val in default_config.items():\n                if isinstance(default_val, dict) and key in config and isinstance(config[key], dict):\n                    merged_config[key] = {**default_val, **config[key]}\n\n            # Basic validation for interval and analysis_interval\n            if merged_config.get(\"interval\") not in VALID_INTERVALS:\n                logger.warning(f\"{NEON_YELLOW} Invalid 'interval' in config, using default: {default_config['interval']}{RESET}\")\n                merged_config[\"interval\"] = default_config[\"interval\"]\n            if not isinstance(merged_config.get(\"analysis_interval\"), int) or merged_config.get(\"analysis_interval\") <= 0:\n                logger.warning(f\"{NEON_YELLOW} Invalid 'analysis_interval' in config, using default: {default_config['analysis_interval']}{RESET}\")\n                merged_config[\"analysis_interval\"] = default_config[\"analysis_interval\"]\n\n            return merged_config\n    except FileNotFoundError:\n        logger.warning(f\"{NEON_YELLOW} Config file not found, loading defaults and creating {filepath}{RESET}\")\n        with open(filepath, \"w\", encoding=\"utf-8\") as f:\n            json.dump(default_config, f, indent=4)\n        return default_config\n    except json.JSONDecodeError:\n        logger.error(f\"{NEON_RED} Invalid JSON in config file, loading defaults. {RESET}\")\n        # Optionally, back up the corrupt file before overwriting\n        try:\n            os.rename(filepath, f\"{filepath}.bak_{int(time.time())}\")\n            logger.info(f\"{NEON_YELLOW} Backed up corrupt config file to {filepath}.bak_{int(time.time())}{RESET}\")\n        except OSError as e:\n            logger.error(f\"{NEON_RED} Failed to backup corrupt config file: {e}{RESET}\")\n        with open(filepath, \"w\", encoding=\"utf-8\") as f:\n            json.dump(default_config, f, indent=4)\n        return default_config\n\n\n# Load the configuration\nCONFIG = load_config(CONFIG_FILE)\n\n\ndef generate_signature(api_secret: str, params: dict) -> str:\n    \"\"\"Generates the HMAC SHA256 signature for Bybit API requests.\"\"\"\n    # Ensure params are sorted by key for consistent signature generation\n    param_str = \"&\".join([f\"{key}={value}\" for key, value in sorted(params.items())])\n    return hmac.new(api_secret.encode(), param_str.encode(), hashlib.sha256).hexdigest()\n\n\ndef handle_api_error(response: requests.Response, logger: logging.Logger) -> None:\n    \"\"\"Logs detailed API error responses.\"\"\"\n    logger.error(f\"{NEON_RED} API request failed with status code: {response.status_code}{RESET}\")\n    try:\n        error_json = response.json()\n        logger.error(f\"{NEON_RED} Error details: {error_json}{RESET}\")\n    except json.JSONDecodeError:\n        logger.error(f\"{NEON_RED} Response text: {response.text}{RESET}\")\n\n\ndef bybit_request(method: str, endpoint: str, api_key: str, api_secret: str, params: Dict[str, Any] = None, logger: logging.Logger = None) -> Union[dict, None]:\n    \"\"\"\n    Sends a signed request to the Bybit API with retry logic.\n\n    Args:\n        method (str): HTTP method (e.g., \"GET\", \"POST\").\n        endpoint (str): API endpoint path.\n        api_key (str): Your Bybit API key.\n        api_secret (str): Your Bybit API secret.\n        params (Dict[str, Any], optional): Dictionary of request parameters. Defaults to None.\n        logger (logging.Logger, optional): Logger instance for logging. Defaults to None.\n\n    Returns:\n        Union[dict, None]: JSON response data if successful, None otherwise.\n    \"\"\"\n    params = params or {}\n    # Bybit API V5 requires timestamp in milliseconds\n    params['timestamp'] = str(int(time.time() * 1000))\n    signature = generate_signature(api_secret, params)\n    headers = {\n        \"X-BAPI-API-KEY\": api_key,\n        \"X-BAPI-SIGN\": signature,\n        \"X-BAPI-TIMESTAMP\": params['timestamp'],\n        \"Content-Type\": \"application/json\"\n    }\n    url = f\"{BASE_URL}{endpoint}\"\n\n    for retry in range(MAX_API_RETRIES):\n        try:\n            response = requests.request(\n                method,\n                url,\n                headers=headers,\n                params=params if method == \"GET\" else None,\n                json=params if method == \"POST\" else None,\n                timeout=10  # Set a timeout for requests\n            )\n            response.raise_for_status()  # Raises HTTPError for bad responses (4xx or 5xx)\n\n            # Check for Bybit specific error codes within a successful HTTP response\n            response_json = response.json()\n            if response_json.get(\"retCode\") != 0:\n                if logger:\n                    logger.error(f\"{NEON_RED} Bybit API Error: {response_json.get('retMsg', 'Unknown error')}. Response: {response_json}{RESET}\")\n                return None\n\n            return response_json\n\n        except requests.exceptions.HTTPError as e:\n            if e.response.status_code in RETRY_ERROR_CODES:\n                if logger:\n                    logger.warning(f\"{NEON_YELLOW} API Error {e.response.status_code} ({e.response.reason}), retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}\")\n                time.sleep(RETRY_DELAY_SECONDS * (2**retry))  # Exponential backoff\n            else:\n                if logger:\n                    handle_api_error(e.response, logger)\n                return None\n        except requests.exceptions.RequestException as e:\n            if logger:\n                logger.error(f\"{NEON_RED} Request exception: {e}, retrying {retry + 1}/{MAX_API_RETRIES}...{RESET}\")\n            time.sleep(RETRY_DELAY_SECONDS * (2**retry))\n\n    if logger:\n        logger.error(f\"{NEON_RED} Max retries reached for {method} {endpoint}{RESET}\")\n    return None\n\n\ndef fetch_current_price(symbol: str, api_key: str, api_secret: str, logger: logging.Logger) -> Union[Decimal, None]:\n    \"\"\"Fetches the current last traded price for a given symbol.\"\"\"\n    endpoint = \"/v5/market/tickers\"\n    params = {\"category\": \"linear\", \"symbol\": symbol}\n    response_data = bybit_request(\"GET\", endpoint, api_key, api_secret, params, logger)\n    if response_data and response_data.get(\"retCode\") == 0 and response_data.get(\"result\"):\n        tickers = response_data[\"result\"].get(\"list\")\n        if tickers:\n            for ticker in tickers:\n                if ticker.get(\"symbol\") == symbol:\n                    last_price = ticker.get(\"lastPrice\")\n                    return Decimal(last_price) if last_price else None\n    logger.error(f\"{NEON_RED} Could not fetch current price for {symbol}. Response: {response_data}{RESET}\")\n    return None\n\n\ndef fetch_klines(symbol: str, interval: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 200) -> pd.DataFrame:\n    \"\"\"Fetches historical K-line (candlestick) data for a given symbol and interval.\"\"\"\n    endpoint = \"/v5/market/kline\"\n    params = {\"symbol\": symbol, \"interval\": interval, \"limit\": limit, \"category\": \"linear\"}\n    response_data = bybit_request(\"GET\", endpoint, api_key, api_secret, params, logger)\n    if response_data and response_data.get(\"retCode\") == 0 and response_data.get(\"result\") and response_data[\"result\"].get(\"list\"):\n        data = response_data[\"result\"][\"list\"]\n        # Bybit's kline list order is: [timestamp, open, high, low, close, volume, turnover]\n        columns = [\"start_time\", \"open\", \"high\", \"low\", \"close\", \"volume\", \"turnover\"]\n        df = pd.DataFrame(data, columns=columns)\n        df[\"start_time\"] = pd.to_datetime(pd.to_numeric(df[\"start_time\"]), unit=\"ms\")\n        # Convert numeric columns, coercing errors to NaN\n        for col in df.columns[1:]:\n            df[col] = pd.to_numeric(df[col], errors='coerce')\n        # Drop any rows that resulted in all NaNs after conversion (shouldn't happen with valid data)\n        df.dropna(subset=df.columns[1:], inplace=True)\n        return df.sort_values(by=\"start_time\", ascending=True).reset_index(drop=True)  # Ensure chronological order\n    logger.error(f\"{NEON_RED} Failed to fetch Kline data for {symbol}, interval {interval}. Response: {response_data}{RESET}\")\n    return pd.DataFrame()\n\n\ndef fetch_order_book(symbol: str, api_key: str, api_secret: str, logger: logging.Logger, limit: int = 50) -> Union[dict, None]:\n    \"\"\"Fetches the order book (bids and asks) for a given symbol.\"\"\"\n    endpoint = \"/v5/market/orderbook\"\n    params = {\"symbol\": symbol, \"limit\": limit, \"category\": \"linear\"}\n    response_data = bybit_request(\"GET\", endpoint, api_key, api_secret, params, logger)\n    if response_data and response_data.get(\"retCode\") == 0 and response_data.get(\"result\"):\n        return response_data[\"result\"]\n    logger.warning(f\"{NEON_YELLOW} Could not fetch order book for {symbol}. Response: {response_data}{RESET}\")\n    return None\n\n\nclass TradingAnalyzer:\n    \"\"\"\n    Performs technical analysis on candlestick data and generates trading signals.\n    \"\"\"\n    def __init__(self, df: pd.DataFrame, config: dict, symbol_logger: logging.Logger, symbol: str, interval: str):\n        self.df = df.copy()  # Work on a copy to avoid modifying original DataFrame\n        self.config = config\n        self.logger = symbol_logger\n        self.symbol = symbol\n        self.interval = interval\n        self.levels: Dict[str, Any] = {}  # Stores support/resistance levels (fib, pivot)\n        self.fib_levels: Dict[str, float] = {}  # Stores calculated Fibonacci levels\n        self.weight_sets = config[\"weight_sets\"]\n        self.indicator_values: Dict[str, Any] = {}  # Stores calculated indicator values\n        self.atr_value: float = 0.0  # Stores the latest ATR value\n        self.user_defined_weights: Dict[str, float] = {} # To be selected dynamically\n\n    def _safe_series_operation(self, column: str, operation: str, window: int = None, series: pd.Series = None) -> pd.Series:\n        \"\"\"Helper to safely perform operations on DataFrame columns or provided series.\"\"\"\n        if series is not None:\n            data_series = series\n        elif column in self.df.columns:\n            data_series = self.df[column]\n        else:\n            self.logger.error(f\"{NEON_RED} Missing '{column}' column for {operation} calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        if data_series.empty:\n            return pd.Series(dtype=float)\n\n        try:\n            if operation == \"sma\":\n                return data_series.rolling(window=window).mean()\n            elif operation == \"ema\":\n                return data_series.ewm(span=window, adjust=False).mean()\n            elif operation == \"max\":\n                return data_series.rolling(window=window).max()\n            elif operation == \"min\":\n                return data_series.rolling(window=window).min()\n            elif operation == \"diff\":\n                return data_series.diff(window)\n            elif operation == \"abs_diff_mean\":\n                return data_series.rolling(window=window).apply(lambda x: np.abs(x - x.mean()).mean(), raw=True)\n            elif operation == \"cumsum\":\n                return data_series.cumsum()\n            else:\n                self.logger.error(f\"{NEON_RED} Unsupported series operation: {operation}{RESET}\")\n                return pd.Series(dtype=float)\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED} Error during {operation} calculation on {column}: {e}{RESET}\")\n            return pd.Series(dtype=float)\n\n    def _calculate_sma(self, window: int, series: pd.Series = None) -> pd.Series:\n        \"\"\"Calculates Simple Moving Average (SMA). Can operate on a specified series or 'close' price.\"\"\"\n        return self._safe_series_operation('close', 'sma', window, series)\n\n    def _calculate_ema(self, window: int, series: pd.Series = None) -> pd.Series:\n        \"\"\"Calculates Exponential Moving Average (EMA). Can operate on a specified series or 'close' price.\"\"\"\n        return self._safe_series_operation('close', 'ema', window, series)\n\n    def _calculate_ema_alignment(self) -> float:\n        \"\"\"\n        Calculates an EMA alignment score.\n        Score is 1.0 for strong bullish alignment, -1.0 for strong bearish, 0.0 for neutral.\n        \"\"\"\n        ema_short = self._calculate_ema(self.config[\"ema_short_period\"])\n        ema_long = self._calculate_ema(self.config[\"ema_long_period\"])\n\n        if ema_short.empty or ema_long.empty or len(self.df) < max(self.config[\"ema_short_period\"], self.config[\"ema_long_period\"]):\n            return 0.0\n\n        latest_short_ema = Decimal(str(ema_short.iloc[-1]))\n        latest_long_ema = Decimal(str(ema_long.iloc[-1]))\n\n        # Check for consistent alignment over the last few bars (e.g., 3 bars)\n        alignment_period = 3\n        if len(ema_short) < alignment_period or len(ema_long) < alignment_period:\n            return 0.0\n\n        bullish_aligned_count = 0\n        bearish_aligned_count = 0\n\n        for i in range(1, alignment_period + 1):\n            if (ema_short.iloc[-i] > ema_long.iloc[-i] and\n                self.df[\"close\"].iloc[-i] > ema_short.iloc[-i]):\n                bullish_aligned_count += 1\n            elif (ema_short.iloc[-i] < ema_long.iloc[-i] and\n                  self.df[\"close\"].iloc[-i] < ema_short.iloc[-i]):\n                bearish_aligned_count += 1\n\n        if bullish_aligned_count >= alignment_period - 1:  # At least (period-1) bars are aligned\n            return 1.0  # Strong bullish alignment\n        elif bearish_aligned_count >= alignment_period - 1:\n            return -1.0  # Strong bearish alignment\n        else:\n            # Check for recent crossover as a weaker signal\n            if latest_short_ema > latest_long_ema and ema_short.iloc[-2] <= latest_long_ema:\n                return 0.5  # Recent bullish crossover\n            elif latest_short_ema < latest_long_ema and ema_short.iloc[-2] >= latest_long_ema:\n                return -0.5  # Recent bearish crossover\n            return 0.0  # Neutral\n\n    def _calculate_momentum(self, period: int = 10) -> pd.Series:\n        \"\"\"Calculates the Momentum indicator.\"\"\"\n        # Momentum is often calculated as current price - price N periods ago.\n        # For signal generation, a ratio or percentage change can be more useful.\n        # Here, we calculate the percentage change over the period.\n        return self._safe_series_operation('close', 'diff', period) / self.df[\"close\"].shift(period) * 100\n\n    def _calculate_cci(self, window: int = 20, constant: float = 0.015) -> pd.Series:\n        \"\"\"Calculates the Commodity Channel Index (CCI).\"\"\"\n        required_columns = ['high', 'low', 'close']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for CCI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n        typical_price = (self.df[\"high\"] + self.df[\"low\"] + self.df[\"close\"]) / 3\n        sma_typical_price = self._safe_series_operation(None, 'sma', window, typical_price)\n        mean_deviation = self._safe_series_operation(None, 'abs_diff_mean', window, typical_price)\n        # Avoid division by zero\n        cci = (typical_price - sma_typical_price) / (constant * mean_deviation)\n        return cci.replace([np.inf, -np.inf], np.nan)  # Handle potential inf values\n\n    def _calculate_williams_r(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Williams %R indicator.\"\"\"\n        required_columns = ['high', 'low', 'close']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for Williams %R calculation.{RESET}\")\n            return pd.Series(dtype=float)\n        highest_high = self._safe_series_operation('high', 'max', window)\n        lowest_low = self._safe_series_operation('low', 'min', window)\n        # Avoid division by zero\n        denominator = (highest_high - lowest_low)\n        wr = ((highest_high - self.df[\"close\"]) / denominator) * -100\n        return wr.replace([np.inf, -np.inf], np.nan)\n\n    def _calculate_mfi(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Money Flow Index (MFI).\"\"\"\n        required_columns = ['high', 'low', 'close', 'volume']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for MFI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        typical_price = (self.df[\"high\"] + self.df[\"low\"] + self.df[\"close\"]) / 3\n        raw_money_flow = typical_price * self.df[\"volume\"]\n\n        # Calculate positive and negative money flow\n        money_flow_direction = typical_price.diff()\n        positive_flow = raw_money_flow.where(money_flow_direction > 0, 0)\n        negative_flow = raw_money_flow.where(money_flow_direction < 0, 0)\n\n        # Calculate sums over the window\n        positive_mf = self._safe_series_operation(None, 'sma', window, positive_flow) * window  # sum not mean\n        negative_mf = self._safe_series_operation(None, 'sma', window, negative_flow) * window  # sum not mean\n\n        # Avoid division by zero\n        money_ratio = positive_mf / negative_mf.replace(0, np.nan)  # Replace 0 with NaN to handle division by zero\n        mfi = 100 - (100 / (1 + money_ratio))\n        return mfi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0 or a sensible value\n\n    def calculate_fibonacci_retracement(self, high: Decimal, low: Decimal, current_price: Decimal) -> Dict[str, Decimal]:\n        \"\"\"Calculates Fibonacci retracement levels based on a given high and low.\"\"\"\n        diff = high - low\n        if diff <= 0:  # Handle cases where high <= low\n            self.logger.warning(f\"{NEON_YELLOW} Cannot calculate Fibonacci retracement: High ({high}) <= Low ({low}).{RESET}\")\n            self.fib_levels = {}\n            self.levels = {\"Support\": {}, \"Resistance\": {}}\n            return {}\n\n        # Standard Fibonacci ratios\n        fib_ratios = {\n            \"23.6%\": Decimal('0.236'), \"38.2%\": Decimal('0.382'), \"50.0%\": Decimal('0.500'),\n            \"61.8%\": Decimal('0.618'), \"78.6%\": Decimal('0.786'), \"88.6%\": Decimal('0.886'),\n            \"94.1%\": Decimal('0.941')\n        }\n        fib_levels_calculated: Dict[str, Decimal] = {}\n\n        # Assuming an uptrend (retracement from high to low)\n        # Levels are calculated from the high, moving down\n        for label, ratio in fib_ratios.items():\n            level = high - (diff * ratio)\n            fib_levels_calculated[f\"Fib {label}\"] = level.quantize(Decimal('0.00001'))  # Quantize for consistent precision\n\n        self.fib_levels = fib_levels_calculated\n        self.levels = {\"Support\": {}, \"Resistance\": {}}\n\n        # Categorize levels as support or resistance relative to current price\n        for label, value in self.fib_levels.items():\n            if value < current_price:\n                self.levels[\"Support\"][label] = value\n            elif value > current_price:\n                self.levels[\"Resistance\"][label] = value\n\n        return self.fib_levels\n\n    def calculate_pivot_points(self, high: Decimal, low: Decimal, close: Decimal):\n        \"\"\"Calculates standard Pivot Points.\"\"\"\n        pivot = (high + low + close) / 3\n        r1 = (2 * pivot) - low\n        s1 = (2 * pivot) - high\n        r2 = pivot + (high - low)\n        s2 = pivot - (high - low)\n        r3 = high + 2 * (pivot - low)\n        s3 = low - 2 * (high - pivot)\n\n        # Quantize all pivot points for consistent precision\n        precision = Decimal('0.00001')\n        self.levels.update({\n            \"Pivot\": pivot.quantize(precision),\n            \"R1\": r1.quantize(precision), \"S1\": s1.quantize(precision),\n            \"R2\": r2.quantize(precision), \"S2\": s2.quantize(precision),\n            \"R3\": r3.quantize(precision), \"S3\": s3.quantize(precision),\n        })\n\n    def find_nearest_levels(self, current_price: Decimal, num_levels: int = 5) -> Tuple[List[Tuple[str, Decimal]], List[Tuple[str, Decimal]]]:\n        \"\"\"\n        Finds the nearest support and resistance levels from calculated Fibonacci and Pivot Points.\n        \"\"\"\n        all_support_levels: List[Tuple[str, Decimal]] = []\n        all_resistance_levels: List[Tuple[str, Decimal]] = []\n\n        def process_level(label: str, value: Decimal):\n            if value < current_price:\n                all_support_levels.append((label, value))\n            elif value > current_price:\n                all_resistance_levels.append((label, value))\n\n        # Process all levels stored in self.levels (from Fibonacci and Pivot)\n        for label, value in self.levels.items():\n            if isinstance(value, dict):  # For nested levels like \"Support\": {\"Fib 23.6%\": ...}\n                for sub_label, sub_value in value.items():\n                    if isinstance(sub_value, Decimal):\n                        process_level(f\"{label} ({sub_label})\", sub_value)\n            elif isinstance(value, Decimal):  # For direct levels like \"Pivot\"\n                process_level(label, value)\n\n        # Sort by distance to current price and select the 'num_levels' closest\n        nearest_supports = sorted(all_support_levels, key=lambda x: current_price - x[1])[:num_levels]\n        nearest_resistances = sorted(all_resistance_levels, key=lambda x: x[1] - current_price)[:num_levels]\n\n        return nearest_supports, nearest_resistances\n\n    def _calculate_atr(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Average True Range (ATR).\"\"\"\n        required_columns = ['high', 'low', 'close']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for ATR calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        high_low = self.df[\"high\"] - self.df[\"low\"]\n        high_close = abs(self.df[\"high\"] - self.df[\"close\"].shift())\n        low_close = abs(self.df[\"low\"] - self.df[\"close\"].shift())\n\n        # True Range is the maximum of the three\n        tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n        return self._safe_series_operation(None, 'ema', window, tr)  # Use EMA for ATR for smoothing\n\n    def _calculate_rsi(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Relative Strength Index (RSI).\"\"\"\n        if 'close' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' column for RSI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        delta = self.df[\"close\"].diff()\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n\n        avg_gain = self._safe_series_operation(None, 'ema', window, gain)\n        avg_loss = self._safe_series_operation(None, 'ema', window, loss)\n\n        # Avoid division by zero\n        rs = avg_gain / avg_loss.replace(0, np.nan)\n        rsi = 100 - (100 / (1 + rs))\n        return rsi.replace([np.inf, -np.inf], np.nan).fillna(0)  # Fill NaN from division by zero with 0\n\n    def _calculate_stoch_rsi(self, rsi_window: int = 14, stoch_window: int = 14, k_window: int = 3, d_window: int = 3) -> pd.DataFrame:\n        \"\"\"Calculates Stochastic RSI (%K and %D lines).\"\"\"\n        rsi = self._calculate_rsi(window=rsi_window)\n        if rsi.empty:\n            return pd.DataFrame()\n\n        # Calculate StochRSI\n        stoch_rsi = (rsi - self._safe_series_operation(None, 'min', stoch_window, rsi)) / \\\n                    (self._safe_series_operation(None, 'max', stoch_window, rsi) - self._safe_series_operation(None, 'min', stoch_window, rsi))\n\n        # Handle division by zero for StochRSI (if max == min)\n        stoch_rsi = stoch_rsi.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n        k_line = self._safe_series_operation(None, 'sma', k_window, stoch_rsi) * 100  # Scale to 0-100\n        d_line = self._safe_series_operation(None, 'sma', d_window, k_line)  # Signal line for %K\n\n        return pd.DataFrame({'stoch_rsi': stoch_rsi * 100, 'k': k_line, 'd': d_line})  # Return StochRSI also scaled\n\n    def _calculate_stochastic_oscillator(self) -> pd.DataFrame:\n        \"\"\"Calculates the Stochastic Oscillator (%K and %D lines).\"\"\"\n        k_period = self.config[\"indicator_periods\"][\"stoch_osc_k\"]\n        d_period = self.config[\"indicator_periods\"][\"stoch_osc_d\"]\n\n        if 'high' not in self.df.columns or 'low' not in self.df.columns or 'close' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing required columns for Stochastic Oscillator calculation.{RESET}\")\n            return pd.DataFrame()\n\n        highest_high = self._safe_series_operation('high', 'max', k_period)\n        lowest_low = self._safe_series_operation('low', 'min', k_period)\n\n        # Calculate %K\n        k_line = (self.df['close'] - lowest_low) / (highest_high - lowest_low) * 100\n        k_line = k_line.replace([np.inf, -np.inf], np.nan).fillna(0)  # Handle division by zero\n\n        # Calculate %D (SMA of %K)\n        d_line = self._safe_series_operation(None, 'sma', d_period, k_line)\n\n        return pd.DataFrame({'k': k_line, 'd': d_line})\n\n    def _calculate_momentum_ma(self) -> None:\n        \"\"\"Calculates momentum and its moving averages, and volume moving average.\"\"\"\n        if 'close' not in self.df.columns or 'volume' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' or 'volume' column for Momentum MA calculation.{RESET}\")\n            return\n\n        self.df[\"momentum\"] = self._calculate_momentum(period=self.config[\"momentum_period\"])  # Use the momentum function\n        self.df[\"momentum_ma_short\"] = self._calculate_sma(self.config[\"momentum_ma_short\"], series=self.df[\"momentum\"])\n        self.df[\"momentum_ma_long\"] = self._calculate_sma(self.config[\"momentum_ma_long\"], series=self.df[\"momentum\"])\n        self.df[\"volume_ma\"] = self._calculate_sma(self.config[\"volume_ma_period\"], series=self.df[\"volume\"])\n\n    def _calculate_macd(self) -> pd.DataFrame:\n        \"\"\"Calculates Moving Average Convergence Divergence (MACD).\"\"\"\n        if 'close' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' column for MACD calculation.{RESET}\")\n            return pd.DataFrame()\n\n        ma_short = self._calculate_ema(12)\n        ma_long = self._calculate_ema(26)\n        macd = ma_short - ma_long\n        signal = self._calculate_ema(9, series=macd)\n        histogram = macd - signal\n        return pd.DataFrame({'macd': macd, 'signal': signal, 'histogram': histogram})\n\n    def detect_macd_divergence(self) -> Union[str, None]:\n        \"\"\"Detects bullish or bearish MACD divergence.\"\"\"\n        macd_df = self._calculate_macd()\n        if macd_df.empty or len(self.df) < 30:  # Need sufficient data for reliable divergence\n            return None\n\n        prices = self.df[\"close\"]\n        macd_histogram = macd_df[\"histogram\"]\n\n        # Simple divergence check on last two bars (can be expanded for more robust detection)\n        if (prices.iloc[-2] > prices.iloc[-1] and macd_histogram.iloc[-2] < macd_histogram.iloc[-1]):\n            self.logger.info(f\"{NEON_GREEN} Detected Bullish MACD Divergence.{RESET}\")\n            return \"bullish\"\n        elif (prices.iloc[-2] < prices.iloc[-1] and macd_histogram.iloc[-2] > macd_histogram.iloc[-1]):\n            self.logger.info(f\"{NEON_RED} Detected Bearish MACD Divergence.{RESET}\")\n            return \"bearish\"\n        return None\n\n    def determine_trend_momentum(self) -> Dict[str, Union[str, float]]:\n        \"\"\"Determines the current trend and its strength based on momentum MAs and ATR.\"\"\"\n        if self.df.empty or len(self.df) < max(self.config[\"momentum_ma_long\"], self.config[\"atr_period\"]):\n            return {\"trend\": \"Insufficient Data\", \"strength\": 0.0}\n\n        # Ensure momentum_ma_short, momentum_ma_long, and atr_value are calculated\n        if \"momentum_ma_short\" not in self.df.columns or \"momentum_ma_long\" not in self.df.columns or self.atr_value == 0:\n            self.logger.warning(f\"{NEON_YELLOW} Momentum MAs or ATR not available for trend calculation.{RESET}\")\n            return {\"trend\": \"Neutral\", \"strength\": 0.0}\n\n        latest_short_ma = self.df[\"momentum_ma_short\"].iloc[-1]\n        latest_long_ma = self.df[\"momentum_ma_long\"].iloc[-1]\n\n        trend = \"Neutral\"\n        if latest_short_ma > latest_long_ma:\n            trend = \"Uptrend\"\n        elif latest_short_ma < latest_long_ma:\n            trend = \"Downtrend\"\n\n        # Strength is normalized by ATR to make it comparable across symbols/timeframes\n        strength = abs(latest_short_ma - latest_long_ma) / self.atr_value\n        return {\"trend\": trend, \"strength\": strength}\n\n    def _calculate_adx(self, window: int = 14) -> float:\n        \"\"\"Calculates the Average Directional Index (ADX).\"\"\"\n        df_adx = self.df.copy()\n        required_columns = ['high', 'low', 'close']\n        if not all(col in df_adx.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for ADX calculation.{RESET}\")\n            return 0.0\n\n        # True Range\n        df_adx[\"TR\"] = pd.concat([\n            df_adx[\"high\"] - df_adx[\"low\"],\n            abs(df_adx[\"high\"] - df_adx[\"close\"].shift()),\n            abs(df_adx[\"low\"] - df_adx[\"close\"].shift())\n        ], axis=1).max(axis=1)\n\n        # Directional Movement\n        df_adx[\"+DM\"] = np.where((df_adx[\"high\"] - df_adx[\"high\"].shift()) > (df_adx[\"low\"].shift() - df_adx[\"low\"]),\n                                 np.maximum(df_adx[\"high\"] - df_adx[\"high\"].shift(), 0), 0)\n        df_adx[\"-DM\"] = np.where((df_adx[\"low\"].shift() - df_adx[\"low\"]) > (df_adx[\"high\"] - df_adx[\"high\"].shift()),\n                                 np.maximum(df_adx[\"low\"].shift() - df_adx[\"low\"], 0), 0)\n\n        # Smoothed True Range and Directional Movement (using EMA)\n        df_adx[\"TR_ema\"] = self._calculate_ema(window, series=df_adx[\"TR\"])\n        df_adx[\"+DM_ema\"] = self._calculate_ema(window, series=df_adx[\"+DM\"])\n        df_adx[\"-DM_ema\"] = self._calculate_ema(window, series=df_adx[\"-DM\"])\n\n        # Directional Indicators\n        df_adx[\"+DI\"] = 100 * (df_adx[\"+DM_ema\"] / df_adx[\"TR_ema\"].replace(0, np.nan))\n        df_adx[\"-DI\"] = 100 * (df_adx[\"-DM_ema\"] / df_adx[\"TR_ema\"].replace(0, np.nan))\n\n        # Directional Movement Index (DX)\n        df_adx[\"DX\"] = 100 * abs(df_adx[\"+DI\"] - df_adx[\"-DI\"]) / (df_adx[\"+DI\"] + df_adx[\"-DI\"]).replace(0, np.nan)\n\n        # Average Directional Index (ADX)\n        adx_value = self._calculate_ema(window, series=df_adx[\"DX\"]).iloc[-1]\n        return adx_value if not pd.isna(adx_value) else 0.0\n\n    def _calculate_obv(self) -> pd.Series:\n        \"\"\"Calculates On-Balance Volume (OBV).\"\"\"\n        if 'close' not in self.df.columns or 'volume' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' or 'volume' column for OBV calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        obv = pd.Series(0, index=self.df.index, dtype=float)\n        obv.iloc[0] = self.df[\"volume\"].iloc[0]  # Initialize with first volume\n\n        for i in range(1, len(self.df)):\n            if self.df[\"close\"].iloc[i] > self.df[\"close\"].iloc[i - 1]:\n                obv.iloc[i] = obv.iloc[i - 1] + self.df[\"volume\"].iloc[i]\n            elif self.df[\"close\"].iloc[i] < self.df[\"close\"].iloc[i - 1]:\n                obv.iloc[i] = obv.iloc[i - 1] - self.df[\"volume\"].iloc[i]\n            else:\n                obv.iloc[i] = obv.iloc[i - 1]  # No change if close price is the same\n\n        return obv\n\n    def _calculate_adi(self) -> pd.Series:\n        \"\"\"Calculates Accumulation/Distribution Index (ADI).\"\"\"\n        required_columns = ['high', 'low', 'close', 'volume']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for ADI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        # Money Flow Multiplier (MFM)\n        mfm_denominator = (self.df[\"high\"] - self.df[\"low\"])\n        mfm = ((self.df[\"close\"] - self.df[\"low\"]) - (self.df[\"high\"] - self.df[\"close\"])) / mfm_denominator.replace(0, np.nan)\n        mfm.fillna(0, inplace=True)  # If high == low, MFM is 0\n\n        # Money Flow Volume (MFV)\n        money_flow_volume = mfm * self.df[\"volume\"]\n\n        # Accumulation/Distribution Line (ADL) is the cumulative sum of MFV\n        return self._safe_series_operation(None, 'cumsum', series=money_flow_volume)\n\n    def _calculate_psar(self, acceleration: float = 0.02, max_acceleration: float = 0.2) -> pd.Series:\n        \"\"\"Calculates Parabolic SAR (PSAR).\"\"\"\n        psar = pd.Series(index=self.df.index, dtype=\"float64\")\n        if self.df.empty or len(self.df) < 2:  # Need at least two bars to start\n            return psar\n\n        # Initial values\n        psar.iloc[0] = self.df[\"close\"].iloc[0]  # Start PSAR at first close\n        # Determine initial trend based on first two bars\n        if self.df[\"close\"].iloc[1] > self.df[\"close\"].iloc[0]:\n            trend = 1  # Uptrend\n            ep = self.df[\"high\"].iloc[0]  # Extreme Point\n        else:\n            trend = -1  # Downtrend\n            ep = self.df[\"low\"].iloc[0]  # Extreme Point\n        af = acceleration  # Acceleration Factor\n\n        for i in range(1, len(self.df)):\n            current_high = self.df[\"high\"].iloc[i]\n            current_low = self.df[\"low\"].iloc[i]\n            prev_psar = psar.iloc[i - 1]\n\n            if trend == 1:  # Uptrend\n                psar.iloc[i] = prev_psar + af * (ep - prev_psar)\n                # Check if PSAR should be below current low\n                psar.iloc[i] = min(psar.iloc[i], current_low, self.df[\"low\"].iloc[i - 1] if i > 1 else current_low)\n                if current_high > ep:  # New extreme high\n                    ep = current_high\n                    af = min(af + acceleration, max_acceleration)\n                if current_low < psar.iloc[i]:  # Trend reversal\n                    trend = -1\n                    psar.iloc[i] = ep  # PSAR jumps to old EP\n                    ep = current_low\n                    af = acceleration\n            elif trend == -1:  # Downtrend\n                psar.iloc[i] = prev_psar + af * (ep - prev_psar)\n                # Check if PSAR should be above current high\n                psar.iloc[i] = max(psar.iloc[i], current_high, self.df[\"high\"].iloc[i - 1] if i > 1 else current_high)\n                if current_low < ep:  # New extreme low\n                    ep = current_low\n                    af = min(af + acceleration, max_acceleration)\n                if current_high > psar.iloc[i]:  # Trend reversal\n                    trend = 1\n                    psar.iloc[i] = ep  # PSAR jumps to old EP\n                    ep = current_high\n                    af = acceleration\n        return psar\n\n    def _calculate_fve(self) -> pd.Series:\n        \"\"\"\n        Calculates a \"Fictional Value Estimate\" (FVE) by combining price, volume, and volatility.\n        This is a custom composite indicator for demonstrative purposes.\n        \"\"\"\n        if 'close' not in self.df.columns or 'volume' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' or 'volume' column for FVE calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        try:\n            # Ensure enough data for calculations\n            min_data_points = max(20, self.config[\"atr_period\"])\n            if len(self.df) < min_data_points:\n                self.logger.warning(f\"{NEON_YELLOW} Insufficient data for FVE calculation. Need at least {min_data_points} bars.{RESET}\")\n                # Return a series of NaNs matching the DataFrame length if data is insufficient\n                return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n            # Components calculation, ensuring Decimal usage where appropriate\n            # Use Decimal for price-related calculations\n            price_component = self._calculate_ema(window=self.config[\"indicator_periods\"][\"fve_price_ema\"])  # Short term price trend\n            obv_component = self._calculate_obv()\n            atr_component = self._calculate_atr(window=self.config[\"indicator_periods\"][\"atr\"])\n\n            # Convert components to Decimal for calculations if they are not already\n            # This is crucial to avoid numpy.float64 issues with Decimal operations\n            price_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in price_component], index=price_component.index)\n            obv_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in obv_component], index=obv_component.index)\n            atr_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN') for x in atr_component], index=atr_component.index)\n\n            # Normalize components to prevent one from dominating excessively\n            # Use Decimal for mean and std calculation to maintain precision\n            price_mean = Decimal(str(price_component_dec.mean())) if pd.notna(price_component_dec.mean()) else Decimal('NaN')\n            price_std = Decimal(str(price_component_dec.std())) if pd.notna(price_component_dec.std()) else Decimal('NaN')\n            obv_mean = Decimal(str(obv_component_dec.mean())) if pd.notna(obv_component_dec.mean()) else Decimal('NaN')\n            obv_std = Decimal(str(obv_component_dec.std())) if pd.notna(obv_component_dec.std()) else Decimal('NaN')\n            atr_mean = Decimal(str(atr_component_dec.mean())) if pd.notna(atr_component_dec.mean()) else Decimal('NaN')\n            atr_std = Decimal(str(atr_component_dec.std())) if pd.notna(atr_component_dec.std()) else Decimal('NaN')\n\n            # Handle potential division by zero for std dev\n            price_norm = (price_component_dec - price_mean) / price_std if price_std != 0 else pd.Series(Decimal('0'), index=self.df.index)\n            obv_norm = (obv_component_dec - obv_mean) / obv_std if obv_std != 0 else pd.Series(Decimal('0'), index=self.df.index)\n\n            # Inverse of ATR: lower ATR means higher stability/less volatility, which can be seen as positive for trend following\n            # Use Decimal for division, and handle potential division by zero for ATR\n            # Calculate inverse ATR, handling division by zero safely\n            atr_inverse = pd.Series([Decimal('1.0') / Decimal(str(x)) if x and x != 0 else Decimal('NaN') for x in atr_component_dec], index=self.df.index)\n            # Replace infinite values resulting from division by zero with NaN\n            atr_inverse = atr_inverse.replace([Decimal('Infinity'), Decimal('-Infinity')], Decimal('NaN'))\n\n            atr_inverse_mean = Decimal(str(atr_inverse.mean())) if pd.notna(atr_inverse.mean()) else Decimal('NaN')\n            atr_inverse_std = Decimal(str(atr_inverse.std())) if pd.notna(atr_inverse.std()) else Decimal('NaN')\n\n            # Normalize ATR inverse, handling potential zero std dev\n            atr_inverse_norm = (atr_inverse - atr_inverse_mean) / atr_inverse_std if atr_inverse_std != 0 else pd.Series(Decimal('0'), index=self.df.index)\n\n            # Combine them - this formula is illustrative and should be fine-tuned\n            # Higher FVE indicates more \"value\" or bullishness.\n            # Ensure all components are aligned and handle NaNs\n            fve = price_norm.fillna(Decimal('0')) + obv_norm.fillna(Decimal('0')) + atr_inverse_norm.fillna(Decimal('0'))\n\n            # Convert back to float Series for compatibility with later operations if needed\n            return pd.Series([float(x) if x != Decimal('NaN') else np.nan for x in fve], index=self.df.index)\n\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED} Error calculating FVE: {e}{RESET}\")\n            # Return a series of NaNs matching the DataFrame length in case of any error\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_volume_confirmation(self) -> bool:\n        \"\"\"\n        Checks if the current volume confirms a trend (e.g., significant spike).\n        Returns True if current volume is significantly higher than average.\n        \"\"\"\n        if 'volume' not in self.df.columns or 'volume_ma' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'volume' or 'volume_ma' column for Volume Confirmation.{RESET}\")\n            return False\n        if self.df[\"volume\"].empty or self.df[\"volume_ma\"].empty:\n            return False\n\n        current_volume = self.df['volume'].iloc[-1]\n        average_volume = self.df['volume_ma'].iloc[-1]\n\n        if average_volume <= 0:  # Avoid division by zero or nonsensical average\n            return False\n\n        return current_volume > average_volume * self.config[\"volume_confirmation_multiplier\"]\n\n    def analyze_order_book_walls(self, order_book: Dict[str, Any]) -> Tuple[bool, bool, Dict[str, Decimal], Dict[str, Decimal]]:\n        \"\"\"\n        Analyzes order book for significant bid (support) and ask (resistance) walls.\n        Returns whether bullish/bearish walls are found and the wall details.\n        \"\"\"\n        has_bullish_wall = False\n        has_bearish_wall = False\n        bullish_wall_details: Dict[str, Decimal] = {}\n        bearish_wall_details: Dict[str, Decimal] = {}\n\n        if not self.config[\"order_book_analysis\"][\"enabled\"]:\n            return False, False, {}, {}\n\n        if not order_book or not order_book.get('bids') or not order_book.get('asks'):\n            self.logger.warning(f\"{NEON_YELLOW} Order book data incomplete for wall analysis.{RESET}\")\n            return False, False, {}, {}\n\n        bids = [(Decimal(price), Decimal(qty)) for price, qty in order_book['bids'][:self.config[\"order_book_analysis\"][\"depth_to_check\"]]]\n        asks = [(Decimal(price), Decimal(qty)) for price, qty in order_book['asks'][:self.config[\"order_book_analysis\"][\"depth_to_check\"]]]\n\n        # Calculate average quantity across relevant depth\n        all_quantities = [qty for _, qty in bids + asks]\n        if not all_quantities:\n            return False, False, {}, {}\n\n        # Use Decimal for sum and count, then divide to maintain precision\n        total_qty = sum(all_quantities)\n        avg_qty = total_qty / Decimal(str(len(all_quantities)))\n        wall_threshold = avg_qty * Decimal(str(self.config[\"order_book_analysis\"][\"wall_threshold_multiplier\"]))\n\n        # Check for bullish walls (large bids below current price)\n        current_price = Decimal(str(self.df[\"close\"].iloc[-1]))\n        for bid_price, bid_qty in bids:\n            if bid_qty >= wall_threshold and bid_price < current_price:\n                has_bullish_wall = True\n                bullish_wall_details[f\"Bid@{bid_price}\"] = bid_qty\n                self.logger.info(f\"{NEON_GREEN} Detected Bullish Order Book Wall: Bid {bid_qty:.2f} at {bid_price:.2f}{RESET}\")\n                break  # Only need to find one significant wall\n\n        # Check for bearish walls (large asks above current price)\n        for ask_price, ask_qty in asks:\n            if ask_qty >= wall_threshold and ask_price > current_price:\n                has_bearish_wall = True\n                bearish_wall_details[f\"Ask@{ask_price}\"] = ask_qty\n                self.logger.info(f\"{NEON_RED} Detected Bearish Order Book Wall: Ask {ask_qty:.2f} at {ask_price:.2f}{RESET}\")\n                break  # Only need to find one significant wall\n\n        return has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details\n\n    # --- Ehlers Indicators ---\n\n    def _calculate_ehlers_fisher_transform(self, period: int = 10) -> pd.Series:\n        \"\"\"Calculates the Ehlers Fisher Transform.\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Fisher Transform (need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            median_price = (self.df['high'] + self.df['low']) / 2\n            min_low = median_price.rolling(window=period).min()\n            max_high = median_price.rolling(window=period).max()\n\n            # Avoid division by zero and handle cases where min_low == max_high\n            range_val = max_high - min_low\n            range_val = range_val.replace(0, np.nan) # Replace 0 with NaN\n            \n            # Scale price to -1 to +1 range\n            # Ensure the input to log is within (-1, 1) to avoid log(0) or log(negative)\n            v = 0.33 * 2 * ((median_price - min_low) / range_val - 0.5) + 0.67 * pd.Series(np.where(pd.isna(range_val), np.nan, 0), index=self.df.index).shift(1)\n            v = v.replace([np.inf, -np.inf], np.nan).fillna(0) # Handle inf from division, fill with 0 for continuity\n            v = np.clip(v, -0.999, 0.999) # Clip to avoid log(0) or log(negative)\n\n            fisher = 0.5 * np.log((1 + v) / (1 - v)) + 0.5 * pd.Series(np.where(pd.isna(v), np.nan, 0), index=self.df.index).shift(1)\n            fisher = fisher.replace([np.inf, -np.inf], np.nan)\n            return fisher.fillna(method='bfill').fillna(method='ffill') # Fill NaNs at start/end\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Fisher Transform: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_stochastic_rsi(self, rsi_period: int = 14, stoch_period: int = 14, k_period: int = 3, d_period: int = 3) -> pd.DataFrame:\n        \"\"\"Calculates Ehlers' version of Stochastic RSI.\"\"\"\n        if len(self.df) < rsi_period + stoch_period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Stochastic RSI (need {rsi_period + stoch_period} bars).{RESET}\")\n            return pd.DataFrame()\n        try:\n            rsi = self._calculate_rsi(window=rsi_period)\n            if rsi.empty: return pd.DataFrame()\n\n            lowest_rsi = rsi.rolling(window=stoch_period).min()\n            highest_rsi = rsi.rolling(window=stoch_period).max()\n\n            # Avoid division by zero\n            denominator = (highest_rsi - lowest_rsi)\n            denominator = denominator.replace(0, np.nan)\n\n            stoch_rsi_raw = (rsi - lowest_rsi) / denominator\n            stoch_rsi_raw = stoch_rsi_raw.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n            k_line = self._calculate_ema(k_period, series=stoch_rsi_raw) * 100\n            d_line = self._calculate_ema(d_period, series=k_line)\n            return pd.DataFrame({'k': k_line, 'd': d_line}).fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Stochastic RSI: {e}{RESET}\")\n            return pd.DataFrame()\n\n    def _calculate_ehlers_optimal_moving_average(self, period: int = 10) -> pd.Series:\n        \"\"\"Calculates Ehlers' Optimal Moving Average (OMA).\"\"\"\n        if len(self.df) < period + 2: # Need enough data for coefficients and filter\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Optimal Moving Average (need {period + 2} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            alpha = (np.cos(np.deg2rad(360 / period)) + np.sin(np.deg2rad(360 / period))) / 2\n            beta = np.cos(np.deg2rad(360 / period))\n            gamma = 1 / np.cos(np.deg2rad(360 / period))\n\n            a1 = np.exp(-1.414 * np.pi / period)\n            b1 = 2 * a1 * np.cos(np.deg2rad(180 * 1.414 / period))\n            c1 = a1 * a1\n\n            a2 = np.exp(-1.414 * np.pi / period)\n            b2 = 2 * a2 * np.cos(np.deg2rad(180 * 1.414 / period))\n            c2 = a2 * a2\n\n            # Coefficients for the filter\n            filt = [1 - alpha, 0, alpha]\n            delay = [0, 0, 1] # This is a simplification, actual delay depends on filter design\n\n            # Apply a simple low-pass filter (like an EMA) for OMA\n            # This is a highly simplified representation of Ehlers' OMA.\n            # A true OMA involves minimizing lag and overshoot, often with complex filter design.\n            # For demonstration, we'll use a simple EMA as a proxy.\n            oma = self._calculate_ema(period)\n            return oma.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Optimal Moving Average: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_super_smoother_filter(self, period: int = 10, poles: int = 2) -> pd.Series:\n        \"\"\"Calculates Ehlers' Super Smoother Filter.\"\"\"\n        if len(self.df) < 2 * period: # Need enough data for filter warm-up\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Super Smoother Filter (need {2 * period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            a = np.exp(-np.pi * np.sqrt(2) / period)\n            b = 2 * a * np.cos(np.sqrt(2) * np.pi / period)\n            c = a * a\n            \n            # Coefficients for 2-pole Super Smoother\n            if poles == 2:\n                coef2 = b + c\n                coef3 = -c\n                coef1 = 1 - coef2 - coef3\n                \n                # Apply filter\n                # Use lfilter for IIR filters. Input must be numpy array.\n                # zi provides initial conditions, but for a full series, it's often handled by the filter itself\n                # or by padding. For simplicity, we let lfilter handle initial NaNs.\n                y = scipy.signal.lfilter([coef1], [1, -coef2, -coef3], self.df['close'].values)\n            elif poles == 3:\n                # Coefficients for 3-pole Super Smoother (more complex)\n                # This is a simplified representation, actual 3-pole filter is more involved\n                # For demonstration, we'll use a cascade of 2-pole filters or a different approach\n                # For now, we'll just return NaN if poles != 2\n                self.logger.warning(f\"{NEON_YELLOW}3-pole Super Smoother not fully implemented, using 2-pole logic or returning NaN.{RESET}\")\n                return pd.Series([np.nan] * len(self.df), index=self.df.index)\n            else:\n                self.logger.warning(f\"{NEON_YELLOW}Unsupported number of poles for Super Smoother: {poles}. Returning NaN.{RESET}\")\n                return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n            ssf = pd.Series(y, index=self.df.index)\n            return ssf.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Super Smoother Filter: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_adaptive_moving_average(self, period: int = 10, fast_alpha: float = 0.5, slow_alpha: float = 0.05) -> pd.Series:\n        \"\"\"Calculates Ehlers' Adaptive Moving Average (AMA).\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Adaptive Moving Average (need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # Efficiency Ratio (ER)\n            change = abs(self.df['close'].diff(period))\n            volatility = self.df['close'].diff().abs().rolling(window=period).sum()\n            \n            # Avoid division by zero for ER\n            er = change / volatility.replace(0, np.nan)\n            er = er.replace([np.inf, -np.inf], np.nan).fillna(0) # Fill inf/NaN with 0\n\n            # Smoothing constant (SC)\n            sc = (er * (fast_alpha - slow_alpha) + slow_alpha) ** 2\n\n            ama = pd.Series(index=self.df.index, dtype=float)\n            ama.iloc[period-1] = self.df['close'].iloc[period-1] # Initialize AMA\n\n            for i in range(period, len(self.df)):\n                if pd.notna(sc.iloc[i]) and pd.notna(ama.iloc[i-1]):\n                    ama.iloc[i] = ama.iloc[i-1] + sc.iloc[i] * (self.df['close'].iloc[i] - ama.iloc[i-1])\n                else:\n                    ama.iloc[i] = ama.iloc[i-1] if i > 0 else np.nan # Carry forward or NaN\n\n            return ama.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Adaptive Moving Average: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_correlation_cycle_indicator(self, period: int = 20) -> pd.Series:\n        \"\"\"Calculates Ehlers' Correlation Cycle Indicator (CCI).\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Correlation Cycle Indicator (need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # Define a sine wave for correlation\n            sine_wave = np.sin(2 * np.pi * np.arange(period) / period)\n            \n            cci = pd.Series(index=self.df.index, dtype=float)\n            for i in range(period - 1, len(self.df)):\n                price_segment = self.df['close'].iloc[i - period + 1 : i + 1].values\n                if len(price_segment) == period:\n                    # Pearson correlation coefficient\n                    corr, _ = scipy.stats.pearsonr(price_segment, sine_wave)\n                    cci.iloc[i] = corr\n                else:\n                    cci.iloc[i] = np.nan # Not enough data for this window\n\n            return cci.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Correlation Cycle Indicator: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_decycler(self, period: int = 20) -> pd.Series:\n        \"\"\"Calculates Ehlers' Decycler.\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Decycler (need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # This is a simplified Decycler, typically a high-pass filter.\n            # Ehlers' Decycler is often implemented using a 2-pole Butterworth filter or similar.\n            # For demonstration, a simple difference filter can approximate it.\n            # A more accurate implementation would use scipy.signal.butter and scipy.signal.filtfilt\n            \n            # Example: Simple high-pass filter (current price - smoothed price)\n            smoothed_price = self._calculate_super_smoother_filter(period=period, poles=2) # Using SSF as a low-pass filter\n            decycler = self.df['close'] - smoothed_price\n            return decycler.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Decycler: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_bandpass_filter(self, period: int = 20) -> pd.Series:\n        \"\"\"Calculates Ehlers' Bandpass Filter.\"\"\"\n        if len(self.df) < period * 2: # Need more data for filter warm-up\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Bandpass Filter (need {period * 2} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # Ehlers' Bandpass Filter typically isolates a specific cycle.\n            # This is a simplified implementation. A full implementation would involve\n            # calculating filter coefficients (a1, a2, b1, b2, etc.) based on the period.\n            \n            # Example: Simple bandpass using two low-pass filters\n            # This is NOT a true Ehlers bandpass, but illustrates the concept.\n            # A true bandpass would use scipy.signal.butter and scipy.signal.filtfilt\n            \n            # For a proper Ehlers Bandpass, you'd calculate coefficients like:\n            # alpha = (np.cos(np.deg2rad(360 / period)) + np.sin(np.deg2rad(360 / period))) / 2\n            # beta = np.cos(np.deg2rad(360 / period))\n            # gamma = 1 / np.cos(np.deg2rad(360 / period))\n            # a1 = (1 - alpha) / (1 + alpha)\n            # b1 = 2 * beta * a1\n            # b2 = -gamma * a1\n            # ... and then use lfilter with these coefficients.\n\n            # Placeholder: a simple difference of two EMAs to approximate a bandpass\n            ema_short = self._calculate_ema(period // 2)\n            ema_long = self._calculate_ema(period)\n            bandpass = ema_short - ema_long\n            return bandpass.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Bandpass Filter: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_center_of_gravity(self, period: int = 10) -> pd.Series:\n        \"\"\"Calculates Ehlers' Center of Gravity (COG) indicator.\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Center of Gravity (need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            cog = pd.Series(index=self.df.index, dtype=float)\n            for i in range(period - 1, len(self.df)):\n                segment = self.df['close'].iloc[i - period + 1 : i + 1]\n                numerator = sum(j * segment.iloc[j] for j in range(period))\n                denominator = sum(segment)\n                if denominator != 0:\n                    cog.iloc[i] = -numerator / denominator\n                else:\n                    cog.iloc[i] = np.nan\n            return cog.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Center of Gravity: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n\n    def _calculate_all_indicators(self):\n        \"\"\"Calculates and stores all enabled indicators for the current cycle.\"\"\"\n        # Pre-calculate ATR and momentum MAs first, as they are used for weight selection and trend\n        atr_series = self._calculate_atr(window=self.config[\"atr_period\"])\n        if not atr_series.empty and not pd.isna(atr_series.iloc[-1]):\n            self.atr_value = float(atr_series.iloc[-1])\n        else:\n            self.atr_value = 0.0\n        self.indicator_values[\"atr\"] = self.atr_value\n\n        self._calculate_momentum_ma() # Populates momentum and its MAs, and volume MA\n\n        # Now that ATR is potentially calculated, select the weight set\n        self.user_defined_weights = self._select_weight_set()\n\n        # Calculate and store other indicator values based on config\n        if self.config[\"indicators\"].get(\"obv\"):\n            obv_series = self._calculate_obv()\n            self.indicator_values[\"obv\"] = obv_series.iloc[-3:].tolist() if not obv_series.empty else []\n        if self.config[\"indicators\"].get(\"rsi\"):\n            rsi_series = self._calculate_rsi(window=self.config[\"indicator_periods\"][\"rsi\"])\n            self.indicator_values[\"rsi\"] = rsi_series.iloc[-3:].tolist() if not rsi_series.empty else []\n        if self.config[\"indicators\"].get(\"mfi\"):\n            mfi_series = self._calculate_mfi(window=self.config[\"indicator_periods\"][\"mfi\"])\n            self.indicator_values[\"mfi\"] = mfi_series.iloc[-3:].tolist() if not mfi_series.empty else []\n        if self.config[\"indicators\"].get(\"cci\"):\n            cci_series = self._calculate_cci(window=self.config[\"indicator_periods\"][\"cci\"])\n            self.indicator_values[\"cci\"] = cci_series.iloc[-3:].tolist() if not cci_series.empty else []\n        if self.config[\"indicators\"].get(\"wr\"):\n            wr_series = self._calculate_williams_r(window=self.config[\"indicator_periods\"][\"williams_r\"])\n            self.indicator_values[\"wr\"] = wr_series.iloc[-3:].tolist() if not wr_series.empty else []\n        if self.config[\"indicators\"].get(\"adx\"):\n            adx_value = self._calculate_adx(window=self.config[\"indicator_periods\"][\"adx\"])\n            self.indicator_values[\"adx\"] = [adx_value]\n        if self.config[\"indicators\"].get(\"adi\"):\n            adi_series = self._calculate_adi()\n            self.indicator_values[\"adi\"] = adi_series.iloc[-3:].tolist() if not adi_series.empty else []\n        if self.config[\"indicators\"].get(\"momentum\"):\n            trend_data = self.determine_trend_momentum()\n            self.indicator_values[\"mom\"] = trend_data\n        if self.config[\"indicators\"].get(\"sma_10\"):\n            sma_series = self._calculate_sma(10)\n            self.indicator_values[\"sma_10\"] = [sma_series.iloc[-1]] if not sma_series.empty else []\n        if self.config[\"indicators\"].get(\"psar\"):\n            psar_series = self._calculate_psar()\n            self.indicator_values[\"psar\"] = psar_series.iloc[-3:].tolist() if not psar_series.empty else []\n        if self.config[\"indicators\"].get(\"fve\"):\n            fve_series = self._calculate_fve()\n            if not fve_series.empty and not fve_series.isnull().all():\n                self.indicator_values[\"fve\"] = fve_series.iloc[-3:].tolist()\n            else:\n                self.indicator_values[\"fve\"] = []\n        if self.config[\"indicators\"].get(\"macd\"):\n            macd_df = self._calculate_macd()\n            self.indicator_values[\"macd\"] = macd_df.iloc[-3:].values.tolist() if not macd_df.empty else []\n        if self.config[\"indicators\"].get(\"ema_alignment\"):\n            ema_alignment_score = self._calculate_ema_alignment()\n            self.indicator_values[\"ema_alignment\"] = ema_alignment_score\n        if self.config[\"indicators\"].get(\"stoch_rsi\"):\n            stoch_rsi_vals = self._calculate_stoch_rsi(\n                rsi_window=self.config[\"indicator_periods\"][\"stoch_rsi_period\"],\n                stoch_window=self.config[\"indicator_periods\"][\"stoch_rsi_period\"],\n                k_window=self.config[\"indicator_periods\"][\"stoch_rsi_k_period\"],\n                d_window=self.config[\"indicator_periods\"][\"stoch_rsi_d_period\"]\n            )\n            self.indicator_values[\"stoch_rsi_vals\"] = stoch_rsi_vals # Store DataFrame\n        if self.config[\"indicators\"].get(\"stochastic_oscillator\"):\n            stoch_osc_vals = self._calculate_stochastic_oscillator()\n            self.indicator_values[\"stoch_osc_vals\"] = stoch_osc_vals # Store DataFrame\n\n        # --- Ehlers Indicators Calculation ---\n        if self.config[\"indicators\"].get(\"ehlers_fisher_transform\"):\n            fisher_series = self._calculate_ehlers_fisher_transform(period=self.config[\"indicator_periods\"][\"ehlers_fisher_period\"])\n            self.indicator_values[\"ehlers_fisher\"] = [fisher_series.iloc[-1]] if not fisher_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_stochastic_rsi\"):\n            ehlers_stoch_rsi_vals = self._calculate_ehlers_stochastic_rsi(\n                rsi_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_period\"],\n                stoch_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_period\"], # Often same as rsi_period for stoch part\n                k_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_k_period\"],\n                d_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_d_period\"]\n            )\n            self.indicator_values[\"ehlers_stoch_rsi_vals\"] = ehlers_stoch_rsi_vals # Store DataFrame\n        if self.config[\"indicators\"].get(\"ehlers_optimal_moving_average\"):\n            oma_series = self._calculate_ehlers_optimal_moving_average(period=self.config[\"indicator_periods\"][\"ehlers_oma_period\"])\n            self.indicator_values[\"ehlers_oma\"] = [oma_series.iloc[-1]] if not oma_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_super_smoother_filter\"):\n            ssf_series = self._calculate_ehlers_super_smoother_filter(\n                period=self.config[\"indicator_periods\"][\"ehlers_ssf_period\"],\n                poles=self.config[\"indicator_periods\"][\"ehlers_ssf_poles\"]\n            )\n            self.indicator_values[\"ehlers_ssf\"] = [ssf_series.iloc[-1]] if not ssf_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_adaptive_moving_average\"):\n            ama_series = self._calculate_ehlers_adaptive_moving_average(\n                period=self.config[\"indicator_periods\"][\"ehlers_ama_period\"],\n                fast_alpha=self.config[\"indicator_periods\"][\"ehlers_ama_fast_alpha\"],\n                slow_alpha=self.config[\"indicator_periods\"][\"ehlers_ama_slow_alpha\"]\n            )\n            self.indicator_values[\"ehlers_ama\"] = [ama_series.iloc[-1]] if not ama_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_correlation_cycle_indicator\"):\n            cci_ehlers_series = self._calculate_ehlers_correlation_cycle_indicator(period=self.config[\"indicator_periods\"][\"ehlers_cci_period\"])\n            self.indicator_values[\"ehlers_cci_cycle\"] = [cci_ehlers_series.iloc[-1]] if not cci_ehlers_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_decycler\"):\n            decycler_series = self._calculate_ehlers_decycler(period=self.config[\"indicator_periods\"][\"ehlers_decycler_period\"])\n            self.indicator_values[\"ehlers_decycler\"] = [decycler_series.iloc[-1]] if not decycler_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_bandpass_filter\"):\n            bandpass_series = self._calculate_ehlers_bandpass_filter(period=self.config[\"indicator_periods\"][\"ehlers_bandpass_period\"])\n            self.indicator_values[\"ehlers_bandpass\"] = [bandpass_series.iloc[-1]] if not bandpass_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_center_of_gravity\"):\n            cog_series = self._calculate_ehlers_center_of_gravity(period=self.config[\"indicator_periods\"][\"ehlers_cog_period\"])\n            self.indicator_values[\"ehlers_cog\"] = [cog_series.iloc[-1]] if not cog_series.empty else []\n\n\n    def _select_weight_set(self) -> Dict[str, float]:\n        \"\"\"\n        Selects a weight set (e.g., low_volatility, high_volatility) based on current ATR.\n        \"\"\"\n        # Use the atr_value that was pre-calculated in _calculate_all_indicators\n        if self.atr_value > self.config[\"atr_change_threshold\"]:\n            self.logger.info(f\"{NEON_YELLOW} Market detected as HIGH VOLATILITY (ATR: {self.atr_value:.4f}). Using 'high_volatility' weights.{RESET}\")\n            return self.weight_sets.get(\"high_volatility\", self.weight_sets[\"low_volatility\"])\n        self.logger.info(f\"{NEON_BLUE} Market detected as LOW VOLATILITY (ATR: {self.atr_value:.4f}). Using 'low_volatility' weights.{RESET}\")\n        return self.weight_sets[\"low_volatility\"]\n\n    def analyze(self, current_price: Decimal, timestamp: str, order_book: Dict[str, Any]):\n        \"\"\"\n        Performs comprehensive analysis, calculates indicators, and logs the findings.\n        This method populates `self.indicator_values` and generates the output string.\n        It does NOT generate the final signal; that is done by `generate_trading_signal`.\n        \"\"\"\n        # Ensure Decimal type for price calculations\n        current_price_dec = Decimal(str(current_price))\n        high_dec = Decimal(str(self.df[\"high\"].max()))\n        low_dec = Decimal(str(self.df[\"low\"].min()))\n        close_dec = Decimal(str(self.df[\"close\"].iloc[-1]))\n\n        # Calculate all indicators for the current cycle\n        self._calculate_all_indicators()\n\n        # Calculate Support/Resistance Levels\n        self.calculate_fibonacci_retracement(high_dec, low_dec, current_price_dec)\n        self.calculate_pivot_points(high_dec, low_dec, close_dec)\n        nearest_supports, nearest_resistances = self.find_nearest_levels(current_price_dec)\n\n        # Order Book Analysis\n        has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details = \\\n            self.analyze_order_book_walls(order_book)\n        self.indicator_values[\"order_book_walls\"] = {\n            \"bullish\": has_bullish_wall, \"bearish\": has_bearish_wall,\n            \"bullish_details\": bullish_wall_details, \"bearish_details\": bearish_wall_details\n        }\n\n        # Prepare output string\n        output = f\"\"\"\n{NEON_BLUE}Exchange:{RESET} Bybit\n{NEON_BLUE}Symbol:{RESET} {self.symbol}\n{NEON_BLUE}Interval:{RESET} {self.interval}\n{NEON_BLUE}Timestamp:{RESET} {timestamp}\n{NEON_BLUE}Price History:{RESET} {self.df['close'].iloc[-3]:.2f} | {self.df['close'].iloc[-2]:.2f} | {self.df['close'].iloc[-1]:.2f}\n{NEON_BLUE}Volume History:{RESET} {self.df['volume'].iloc[-3]:,.0f} | {self.df['volume'].iloc[-2]:,.0f} | {self.df['volume'].iloc[-1]:,.0f}\n{NEON_BLUE}Current Price:{RESET} {current_price_dec:.5f}\n{NEON_BLUE}ATR ({self.config['atr_period']}):{RESET} {self.atr_value:.5f}\n\"\"\"\n        # Append indicator interpretations\n        for indicator_name, values in self.indicator_values.items():\n            # Skip indicators that are already logged in a custom format or are internal\n            if indicator_name in [\"order_book_walls\"]:\n                continue\n            interpreted_line = interpret_indicator(self.logger, indicator_name, values)\n            if interpreted_line:\n                output += interpreted_line + \"\\n\"\n\n        # Order Book Wall Logging\n        output += f\"\"\"\n{NEON_BLUE}Order Book Walls:{RESET}\n\"\"\"\n        if has_bullish_wall:\n            output += f\"{NEON_GREEN}  Bullish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bullish_wall_details.items()])}\\n\"\n        if has_bearish_wall:\n            output += f\"{NEON_RED}  Bearish Walls Found:{RESET} {', '.join([f'{k}: {v:.2f}' for k, v in bearish_wall_details.items()])}\\n\"\n        if not has_bullish_wall and not has_bearish_wall:\n            output += \"  No significant walls detected.\\n\"\n\n        output += f\"\"\"\n{NEON_BLUE}Support and Resistance Levels:{RESET}\n\"\"\"\n        for s_label, s_val in nearest_supports:\n            output += f\"S: {s_label} ${s_val:.5f}\\n\"\n        for r_label, r_val in nearest_resistances:\n            output += f\"R: {r_label} ${r_val:.5f}\\n\"\n\n        self.logger.info(output)\n\n    def generate_trading_signal(self, current_price: Decimal) -> Tuple[Union[str, None], float, List[str], Dict[str, Decimal]]:\n        \"\"\"\n        Generates a trading signal (buy/sell) based on indicator values and configuration.\n        Returns the signal, its confidence score, conditions met, and suggested SL/TP levels.\n        \"\"\"\n        signal_score = Decimal('0.0')\n        signal = None\n        conditions_met: List[str] = []\n        trade_levels: Dict[str, Decimal] = {}\n\n        # --- Bullish Signal Logic ---\n        # Sum weights of bullish conditions met\n        if self.config[\"indicators\"].get(\"stoch_rsi\") and not self.indicator_values[\"stoch_rsi_vals\"].empty:\n            stoch_rsi_k = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['k'].iloc[-1]))\n            stoch_rsi_d = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['d'].iloc[-1]))\n            if stoch_rsi_k < self.config[\"stoch_rsi_oversold_threshold\"] and stoch_rsi_k > stoch_rsi_d:\n                signal_score += Decimal(str(self.user_defined_weights[\"stoch_rsi\"]))\n                signal_score += Decimal(str(self.config[\"stoch_rsi_confidence_boost\"])) # Add confidence boost\n                conditions_met.append(\"Stoch RSI Oversold Crossover\")\n\n        if self.config[\"indicators\"].get(\"rsi\") and self.indicator_values.get(\"rsi\") and self.indicator_values[\"rsi\"][-1] < 30:\n            signal_score += Decimal(str(self.user_defined_weights[\"rsi\"]))\n            signal_score += Decimal(str(self.config[\"rsi_confidence_boost\"])) # Add confidence boost\n            conditions_met.append(\"RSI Oversold\")\n\n        if self.config[\"indicators\"].get(\"mfi\") and self.indicator_values.get(\"mfi\") and self.indicator_values[\"mfi\"][-1] < 20:\n            signal_score += Decimal(str(self.user_defined_weights[\"mfi\"]))\n            signal_score += Decimal(str(self.config[\"mfi_confidence_boost\"])) # Add confidence boost\n            conditions_met.append(\"MFI Oversold\")\n\n        if self.config[\"indicators\"].get(\"ema_alignment\") and self.indicator_values.get(\"ema_alignment\", 0.0) > 0:\n            signal_score += Decimal(str(self.user_defined_weights[\"ema_alignment\"])) * Decimal(str(abs(self.indicator_values[\"ema_alignment\"])))  # Scale by score\n            conditions_met.append(\"Bullish EMA Alignment\")\n\n        if self.config[\"indicators\"].get(\"volume_confirmation\") and self._calculate_volume_confirmation():\n            signal_score += Decimal(str(self.user_defined_weights[\"volume_confirmation\"]))\n            conditions_met.append(\"Volume Confirmation\")\n\n        if self.config[\"indicators\"].get(\"divergence\") and self.detect_macd_divergence() == \"bullish\":\n            signal_score += Decimal(str(self.user_defined_weights[\"divergence\"]))\n            conditions_met.append(\"Bullish MACD Divergence\")\n\n        if self.indicator_values[\"order_book_walls\"].get(\"bullish\"):\n            signal_score += Decimal(str(self.config[\"order_book_support_confidence_boost\"]))  # Boost score for order book wall\n            conditions_met.append(\"Bullish Order Book Wall\")\n\n        # --- New: Stochastic Oscillator Bullish Signal ---\n        if self.config[\"indicators\"].get(\"stochastic_oscillator\") and self.indicator_values.get(\"stoch_osc_vals\") is not None and not self.indicator_values[\"stoch_osc_vals\"].empty:\n            stoch_k = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['k'].iloc[-1]))\n            stoch_d = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['d'].iloc[-1]))\n            if stoch_k < 20 and stoch_k > stoch_d:  # Oversold and K crossing above D\n                signal_score += Decimal(str(self.user_defined_weights[\"stochastic_oscillator\"]))\n                conditions_met.append(\"Stoch Oscillator Oversold Crossover\")\n        \n        # --- Ehlers Indicators Bullish Signal Logic (PLACEHOLDERS - CUSTOMIZE HEAVILY) ---\n        if self.config[\"indicators\"].get(\"ehlers_fisher_transform\") and self.indicator_values.get(\"ehlers_fisher\"):\n            fisher_val = self.indicator_values[\"ehlers_fisher\"][0]\n            if fisher_val > 1.5: # Example threshold for bullish Fisher\n                signal_score += Decimal(str(self.user_defined_weights[\"ehlers_fisher_transform\"]))\n                conditions_met.append(\"Ehlers Fisher Transform Bullish\")\n\n        if self.config[\"indicators\"].get(\"ehlers_stochastic_rsi\") and not self.indicator_values[\"ehlers_stoch_rsi_vals\"].empty:\n            ehlers_stoch_rsi_k = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['k'].iloc[-1]))\n            ehlers_stoch_rsi_d = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['d'].iloc[-1]))\n            if ehlers_stoch_rsi_k < 20 and ehlers_stoch_rsi_k > ehlers_stoch_rsi_d:\n                signal_score += Decimal(str(self.user_defined_weights[\"ehlers_stochastic_rsi\"]))\n                conditions_met.append(\"Ehlers Stoch RSI Oversold Crossover\")\n        \n        # Add more Ehlers indicator bullish logic here based on your strategy\n        # Example: if self.config[\"indicators\"].get(\"ehlers_optimal_moving_average\") and self.indicator_values.get(\"ehlers_oma\"):\n        #     oma_val = self.indicator_values[\"ehlers_oma\"][0]\n        #     if current_price > oma_val: # Price above OMA\n        #         signal_score += Decimal(str(self.user_defined_weights[\"ehlers_optimal_moving_average\"]))\n        #         conditions_met.append(\"Ehlers OMA Bullish\")\n\n\n        # Final check for Bullish signal\n        if signal_score >= Decimal(str(self.config[\"signal_score_threshold\"])):\n            signal = \"buy\"\n            # Calculate Stop Loss and Take Profit\n            if self.atr_value > 0:\n                stop_loss = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"stop_loss_multiple\"])))\n                take_profit = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"take_profit_multiple\"])))\n                trade_levels[\"stop_loss\"] = stop_loss.quantize(Decimal('0.00001'))\n                trade_levels[\"take_profit\"] = take_profit.quantize(Decimal('0.00001'))\n\n        # --- Bearish Signal Logic (similar structure) ---\n        bearish_score = Decimal('0.0')\n        bearish_conditions: List[str] = []\n\n        if self.config[\"indicators\"].get(\"stoch_rsi\") and not self.indicator_values[\"stoch_rsi_vals\"].empty:\n            stoch_rsi_k = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['k'].iloc[-1]))\n            stoch_rsi_d = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['d'].iloc[-1]))\n            if stoch_rsi_k > self.config[\"stoch_rsi_overbought_threshold\"] and stoch_rsi_k < stoch_rsi_d:\n                bearish_score += Decimal(str(self.user_defined_weights[\"stoch_rsi\"]))\n                bearish_score += Decimal(str(self.config[\"stoch_rsi_confidence_boost\"])) # Add confidence boost\n                bearish_conditions.append(\"Stoch RSI Overbought Crossover\")\n\n        if self.config[\"indicators\"].get(\"rsi\") and self.indicator_values.get(\"rsi\") and self.indicator_values[\"rsi\"][-1] > 70:\n            bearish_score += Decimal(str(self.user_defined_weights[\"rsi\"]))\n            bearish_score += Decimal(str(self.config[\"rsi_confidence_boost\"])) # Add confidence boost\n            bearish_conditions.append(\"RSI Overbought\")\n\n        if self.config[\"indicators\"].get(\"mfi\") and self.indicator_values.get(\"mfi\") and self.indicator_values[\"mfi\"][-1] > 80:\n            bearish_score += Decimal(str(self.user_defined_weights[\"mfi\"]))\n            bearish_score += Decimal(str(self.config[\"mfi_confidence_boost\"])) # Add confidence boost\n            bearish_conditions.append(\"MFI Overbought\")\n\n        if self.config[\"indicators\"].get(\"ema_alignment\") and self.indicator_values.get(\"ema_alignment\", 0.0) < 0:\n            bearish_score += Decimal(str(self.user_defined_weights[\"ema_alignment\"])) * Decimal(str(abs(self.indicator_values[\"ema_alignment\"])))\n            bearish_conditions.append(\"Bearish EMA Alignment\")\n\n        if self.config[\"indicators\"].get(\"divergence\") and self.detect_macd_divergence() == \"bearish\":\n            bearish_score += Decimal(str(self.user_defined_weights[\"divergence\"]))\n            bearish_conditions.append(\"Bearish MACD Divergence\")\n\n        if self.indicator_values[\"order_book_walls\"].get(\"bearish\"):\n            bearish_score += Decimal(str(self.config[\"order_book_resistance_confidence_boost\"]))\n            bearish_conditions.append(\"Bearish Order Book Wall\")\n\n        # --- New: Stochastic Oscillator Bearish Signal ---\n        if self.config[\"indicators\"].get(\"stochastic_oscillator\") and self.indicator_values.get(\"stoch_osc_vals\") is not None and not self.indicator_values[\"stoch_osc_vals\"].empty:\n            stoch_k = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['k'].iloc[-1]))\n            stoch_d = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['d'].iloc[-1]))\n            if stoch_k > 80 and stoch_k < stoch_d:  # Overbought and K crossing below D\n                bearish_score += Decimal(str(self.user_defined_weights[\"stochastic_oscillator\"]))\n                bearish_conditions.append(\"Stoch Oscillator Overbought Crossover\")\n\n        # --- Ehlers Indicators Bearish Signal Logic (PLACEHOLDERS - CUSTOMIZE HEAVILY) ---\n        if self.config[\"indicators\"].get(\"ehlers_fisher_transform\") and self.indicator_values.get(\"ehlers_fisher\"):\n            fisher_val = self.indicator_values[\"ehlers_fisher\"][0]\n            if fisher_val < -1.5: # Example threshold for bearish Fisher\n                bearish_score += Decimal(str(self.user_defined_weights[\"ehlers_fisher_transform\"]))\n                bearish_conditions.append(\"Ehlers Fisher Transform Bearish\")\n\n        if self.config[\"indicators\"].get(\"ehlers_stochastic_rsi\") and not self.indicator_values[\"ehlers_stoch_rsi_vals\"].empty:\n            ehlers_stoch_rsi_k = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['k'].iloc[-1]))\n            ehlers_stoch_rsi_d = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['d'].iloc[-1]))\n            if ehlers_stoch_rsi_k > 80 and ehlers_stoch_rsi_k < ehlers_stoch_rsi_d:\n                bearish_score += Decimal(str(self.user_defined_weights[\"ehlers_stochastic_rsi\"]))\n                bearish_conditions.append(\"Ehlers Stoch RSI Overbought Crossover\")\n\n        # Add more Ehlers indicator bearish logic here based on your strategy\n        # Example: if self.config[\"indicators\"].get(\"ehlers_optimal_moving_average\") and self.indicator_values.get(\"ehlers_oma\"):\n        #     oma_val = self.indicator_values[\"ehlers_oma\"][0]\n        #     if current_price < oma_val: # Price below OMA\n        #         bearish_score += Decimal(str(self.user_defined_weights[\"ehlers_optimal_moving_average\"]))\n        #         bearish_conditions.append(\"Ehlers OMA Bearish\")\n\n\n        # Final check for Bearish signal (only if no bullish signal already)\n        if signal is None and bearish_score >= Decimal(str(self.config[\"signal_score_threshold\"])):\n            signal = \"sell\"\n            signal_score = bearish_score  # Use bearish score if it's the chosen signal\n            conditions_met = bearish_conditions  # Use bearish conditions\n            # Calculate Stop Loss and Take Profit for sell signal\n            if self.atr_value > 0:\n                stop_loss = current_price + (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"stop_loss_multiple\"])))\n                take_profit = current_price - (Decimal(str(self.atr_value)) * Decimal(str(self.config[\"take_profit_multiple\"])))\n                trade_levels[\"stop_loss\"] = stop_loss.quantize(Decimal('0.00001'))\n                trade_levels[\"take_profit\"] = take_profit.quantize(Decimal('0.00001'))\n\n        return signal, float(signal_score), conditions_met, trade_levels\n\n\ndef interpret_indicator(logger: logging.Logger, indicator_name: str, values: Union[List[float], float, Dict[str, Any], pd.DataFrame]) -> Union[str, None]:\n    \"\"\"\n    Provides a human-readable interpretation of indicator values with color coding.\n    \"\"\"\n    if values is None or (isinstance(values, list) and not values) or (isinstance(values, pd.DataFrame) and values.empty):\n        return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No data available.\"\n    try:\n        # Handle DataFrame-based indicators first\n        if indicator_name == \"stoch_rsi_vals\":\n            if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:\n                stoch_rsi_k = values['k'].iloc[-1]\n                stoch_rsi_d = values['d'].iloc[-1]\n                stoch_rsi_val = values['stoch_rsi'].iloc[-1]\n                k_color = NEON_YELLOW\n                d_color = NEON_YELLOW\n                stoch_rsi_color = NEON_YELLOW\n\n                # Check for oversold/overbought and crossovers\n                if stoch_rsi_k < CONFIG[\"stoch_rsi_oversold_threshold\"] and stoch_rsi_k > stoch_rsi_d:\n                    k_color = NEON_GREEN\n                    stoch_rsi_color = NEON_GREEN\n                elif stoch_rsi_k > CONFIG[\"stoch_rsi_overbought_threshold\"] and stoch_rsi_k < stoch_rsi_d:\n                    k_color = NEON_RED\n                    stoch_rsi_color = NEON_RED\n\n                return (f\"{NEON_GREEN}Stoch RSI:{RESET} K={k_color}{stoch_rsi_k:.2f}{RESET}, \"\n                        f\"D={d_color}{stoch_rsi_d:.2f}{RESET}, \"\n                        f\"Stoch_RSI={stoch_rsi_color}{stoch_rsi_val:.2f}{RESET}\")\n            else:\n                return f\"{NEON_YELLOW}Stoch RSI:{RESET} No data available.\"\n\n        if indicator_name == \"stoch_osc_vals\":\n            if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:\n                stoch_k = values['k'].iloc[-1]\n                stoch_d = values['d'].iloc[-1]\n                k_color = NEON_YELLOW\n                d_color = NEON_YELLOW\n\n                # Check for oversold/overbought and crossovers\n                if stoch_k < 20 and stoch_k > stoch_d:  # Oversold and K crossing above D\n                    k_color = NEON_GREEN\n                elif stoch_k > 80 and stoch_k < stoch_d:  # Overbought and K crossing below D\n                    k_color = NEON_RED\n\n                return (f\"{NEON_CYAN}Stochastic Oscillator:{RESET} K={k_color}{stoch_k:.2f}{RESET}, \"\n                        f\"D={d_color}{stoch_d:.2f}{RESET}\")\n            else:\n                return f\"{NEON_YELLOW}Stochastic Oscillator:{RESET} No data available.\"\n        \n        # --- Ehlers Indicator Interpretations ---\n        if indicator_name == \"ehlers_stoch_rsi_vals\":\n            if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:\n                k = values['k'].iloc[-1]\n                d = values['d'].iloc[-1]\n                k_color = NEON_YELLOW\n                d_color = NEON_YELLOW\n                \n                if k < 20 and k > d: # Oversold and K crossing above D\n                    k_color = NEON_GREEN\n                elif k > 80 and k < d: # Overbought and K crossing below D\n                    k_color = NEON_RED\n                \n                return (f\"{NEON_PURPLE}Ehlers Stoch RSI:{RESET} K={k_color}{k:.2f}{RESET}, \"\n                        f\"D={d_color}{d:.2f}{RESET}\")\n            else:\n                return f\"{NEON_YELLOW}Ehlers Stoch RSI:{RESET} No data available.\"\n\n        # Convert single float values to list for consistent indexing if needed\n        if isinstance(values, (float, int)):\n            values = [values]\n        elif isinstance(values, dict):  # For 'mom' which is a dict\n            if indicator_name == \"mom\":\n                trend = values.get(\"trend\", \"N/A\")\n                strength = values.get(\"strength\", 0.0)\n                strength_color = NEON_BLUE\n                if strength > CONFIG[\"trend_strength_threshold\"]:\n                    strength_color = NEON_GREEN if trend == \"Uptrend\" else NEON_RED if trend == \"Downtrend\" else NEON_YELLOW\n                return f\"{NEON_PURPLE}Momentum Trend:{RESET} {trend} (Strength: {strength_color}{strength:.2f}{RESET})\"\n            else:\n                return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} Dictionary format not specifically interpreted.\"\n\n        # General interpretation for list-based indicators\n        last_value = values[-1] if isinstance(values, list) and values else values[0] if isinstance(values, list) else values  # Handles single value lists too\n\n        if indicator_name == \"rsi\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 70:\n                color = NEON_RED\n                status = \"Overbought\"\n            elif last_value < 30:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            return f\"{NEON_BLUE}RSI:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"mfi\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 80:\n                color = NEON_RED\n                status = \"Overbought\"\n            elif last_value < 20:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            return f\"{NEON_BLUE}MFI:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"cci\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 100:\n                color = NEON_RED\n                status = \"Overbought\"\n            elif last_value < -100:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            return f\"{NEON_BLUE}CCI:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"wr\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value < -80:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            elif last_value > -20:\n                color = NEON_RED\n                status = \"Overbought\"\n            return f\"{NEON_BLUE}Williams %R:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"adx\":\n            color = NEON_YELLOW\n            status = \"Ranging\"\n            if last_value > 25:\n                color = NEON_GREEN\n                status = \"Trending\"\n            return f\"{NEON_BLUE}ADX:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"obv\":\n            status = \"Neutral\"\n            color = NEON_BLUE\n            if len(values) >= 2:\n                if values[-1] > values[-2]:\n                    color = NEON_GREEN\n                    status = \"Bullish\"\n                elif values[-1] < values[-2]:\n                    color = NEON_RED\n                    status = \"Bearish\"\n                return f\"{NEON_BLUE}OBV:{RESET} {color}{values[-1]:.2f}{RESET} ({status})\"\n            else:\n                return f\"{NEON_BLUE}OBV:{RESET} {color}{last_value:.2f}{RESET} (Insufficient history for trend)\"\n        elif indicator_name == \"adi\":\n            status = \"Neutral\"\n            color = NEON_BLUE\n            if len(values) >= 2:\n                if values[-1] > values[-2]:\n                    color = NEON_GREEN\n                    status = \"Accumulation\"\n                elif values[-1] < values[-2]:\n                    color = NEON_RED\n                    status = \"Distribution\"\n                return f\"{NEON_BLUE}ADI:{RESET} {color}{values[-1]:.2f}{RESET} (Insufficient history for trend)\"\n            else:\n                return f\"{NEON_BLUE}ADI:{RESET} {color}{last_value:.2f}{RESET} (Insufficient history for trend)\"\n        elif indicator_name == \"sma_10\":\n            return f\"{NEON_YELLOW}SMA (10):{RESET} {NEON_BLUE}{last_value:.2f}{RESET}\"\n        elif indicator_name == \"psar\":\n            return f\"{NEON_BLUE}PSAR:{RESET} {NEON_YELLOW}{last_value:.4f}{RESET} (Last Value)\"\n        elif indicator_name == \"fve\":\n            color = NEON_BLUE\n            if last_value > 0: color = NEON_GREEN\n            elif last_value < 0: color = NEON_RED\n            return f\"{NEON_BLUE}FVE:{RESET} {color}{last_value:.2f}{RESET} (Last Value)\"\n        elif indicator_name == \"macd\":\n            # values for MACD are [macd_line, signal_line, histogram]\n            if len(values[-1]) == 3:\n                macd_line, signal_line, histogram = values[-1][0], values[-1][1], values[-1][2]\n                hist_color = NEON_YELLOW\n                if histogram > 0: hist_color = NEON_GREEN\n                elif histogram < 0: hist_color = NEON_RED\n                return (f\"{NEON_GREEN}MACD:{RESET} MACD={NEON_YELLOW}{macd_line:.2f}{RESET}, \"\n                        f\"Signal={NEON_YELLOW}{signal_line:.2f}{RESET}, \"\n                        f\"Histogram={hist_color}{histogram:.2f}{RESET}\")\n            else:\n                return f\"{NEON_RED}MACD:{RESET} Calculation issue.\"\n        elif indicator_name == \"ema_alignment\":\n            score = values # It's a single float, not a list\n            color = NEON_YELLOW\n            status = 'Neutral'\n            if score > 0:\n                color = NEON_GREEN\n                status = 'Bullish'\n            elif score < 0:\n                color = NEON_RED\n                status = 'Bearish'\n            return f\"{NEON_PURPLE}EMA Alignment:{RESET} Score={color}{score:.2f}{RESET} ({status})\"\n        \n        # --- Ehlers Indicator Interpretations (Cont.) ---\n        elif indicator_name == \"ehlers_fisher\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 1.5: # Common threshold for bullish\n                color = NEON_GREEN\n                status = \"Strong Bullish\"\n            elif last_value < -1.5: # Common threshold for bearish\n                color = NEON_RED\n                status = \"Strong Bearish\"\n            return f\"{NEON_PURPLE}Ehlers Fisher:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"ehlers_oma\":\n            # OMA is a moving average, interpretation often relative to price\n            return f\"{NEON_PURPLE}Ehlers OMA:{RESET} {NEON_BLUE}{last_value:.4f}{RESET}\"\n        elif indicator_name == \"ehlers_ssf\":\n            # SSF is a smoothing filter, interpretation often relative to price\n            return f\"{NEON_PURPLE}Ehlers SSF:{RESET} {NEON_BLUE}{last_value:.4f}{RESET}\"\n        elif indicator_name == \"ehlers_ama\":\n            # AMA is an adaptive moving average, interpretation often relative to price\n            return f\"{NEON_PURPLE}Ehlers AMA:{RESET} {NEON_BLUE}{last_value:.4f}{RESET}\"\n        elif indicator_name == \"ehlers_cci_cycle\":\n            color = NEON_YELLOW\n            status = \"Neutral Cycle\"\n            if last_value > 0.5: # Strong positive correlation to sine wave\n                color = NEON_GREEN\n                status = \"Bullish Cycle Phase\"\n            elif last_value < -0.5: # Strong negative correlation\n                color = NEON_RED\n                status = \"Bearish Cycle Phase\"\n            return f\"{NEON_PURPLE}Ehlers Corr. Cycle:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"ehlers_decycler\":\n            color = NEON_BLUE\n            if last_value > 0: color = NEON_GREEN\n            elif last_value < 0: color = NEON_RED\n            return f\"{NEON_PURPLE}Ehlers Decycler:{RESET} {color}{last_value:.4f}{RESET} (Trend Component)\"\n        elif indicator_name == \"ehlers_bandpass\":\n            color = NEON_BLUE\n            # Bandpass indicates cyclicality, not necessarily direction\n            if abs(last_value) > 0.01: # Arbitrary threshold for \"active cycle\"\n                color = NEON_YELLOW\n                status = \"Active Cycle\"\n            else:\n                status = \"Weak Cycle\"\n            return f\"{NEON_PURPLE}Ehlers Bandpass:{RESET} {color}{last_value:.4f}{RESET} ({status})\"\n        elif indicator_name == \"ehlers_cog\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value < -0.5: # COG often indicates turning points\n                color = NEON_GREEN\n                status = \"Bullish Turn\"\n            elif last_value > 0.5:\n                color = NEON_RED\n                status = \"Bearish Turn\"\n            return f\"{NEON_PURPLE}Ehlers COG:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        else:\n            return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No specific interpretation available.\"\n    except (TypeError, IndexError, KeyError, ValueError, InvalidOperation) as e:\n        logger.error(f\"{NEON_RED}Error interpreting {indicator_name}: {e}. Values: {values}{RESET}\")\n        return f\"{NEON_RED}{indicator_name.upper()}:{RESET} Interpretation error.\"\n\n\ndef main():\n    \"\"\"\n    Main function to run the trading analysis bot.\n    Handles user input, data fetching, analysis, and signal generation loop.\n    \"\"\"\n    if not API_KEY or not API_SECRET:\n        logger.error(f\"{NEON_RED} BYBIT_API_KEY and BYBIT_API_SECRET must be set in your .env file. {RESET}\")\n        return\n\n    symbol_input = input(f\"{NEON_BLUE} Enter trading symbol (e.g., BTCUSDT): {RESET}\").upper().strip()\n    symbol = symbol_input if symbol_input else \"BTCUSDT\"\n\n    interval_input = input(f\"{NEON_BLUE} Enter timeframe (e.g., {', '.join(VALID_INTERVALS)} or press Enter for default {CONFIG['interval']}): {RESET}\").strip()\n    interval = interval_input if interval_input and interval_input in VALID_INTERVALS else CONFIG[\"interval\"]\n\n    # Setup a dedicated logger for this symbol's activities\n    symbol_logger = setup_custom_logger(symbol)\n    symbol_logger.info(f\"{NEON_BLUE} Starting analysis for {symbol} with interval {interval}{RESET}\")\n\n    last_signal_time = 0.0  # Tracks the last time a signal was triggered for cooldown\n    last_order_book_fetch_time = 0.0  # Tracks last order book fetch time for debouncing\n\n    while True:\n        try:\n            current_price = fetch_current_price(symbol, API_KEY, API_SECRET, symbol_logger)\n            if current_price is None:\n                symbol_logger.error(f\"{NEON_RED} Failed to fetch current price for {symbol}. Skipping cycle. {RESET}\")\n                time.sleep(CONFIG[\"retry_delay\"])\n                continue\n\n            df = fetch_klines(symbol, interval, API_KEY, API_SECRET, symbol_logger, limit=200)\n            if df.empty:\n                symbol_logger.error(f\"{NEON_RED} Failed to fetch Kline data for {symbol}. Skipping cycle. {RESET}\")\n                time.sleep(CONFIG[\"retry_delay\"])\n                continue\n\n            # Debounce order book fetching to reduce API calls\n            order_book_data = None\n            if time.time() - last_order_book_fetch_time >= CONFIG[\"order_book_debounce_s\"]:\n                order_book_data = fetch_order_book(symbol, API_KEY, API_SECRET, symbol_logger, limit=CONFIG[\"order_book_depth_to_check\"])\n                last_order_book_fetch_time = time.time()\n            else:\n                symbol_logger.debug(f\"{NEON_YELLOW} Order book fetch debounced. Next fetch in {CONFIG['order_book_debounce_s'] - (time.time() - last_order_book_fetch_time):.1f}s{RESET}\")\n\n            analyzer = TradingAnalyzer(df, CONFIG, symbol_logger, symbol, interval)\n            timestamp = datetime.now(TIMEZONE).strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n\n            # Perform analysis and log the current state of indicators\n            analyzer.analyze(current_price, timestamp, order_book_data)\n\n            # Generate trading signal based on the analysis\n            current_time_seconds = time.time()\n            signal, confidence, conditions_met, trade_levels = analyzer.generate_trading_signal(current_price)\n\n            if signal and (current_time_seconds - last_signal_time >= CONFIG[\"signal_cooldown_s\"]):\n                symbol_logger.info(f\"\\n{NEON_PURPLE}--- TRADING SIGNAL TRIGGERED ---{RESET}\")\n                symbol_logger.info(f\"{NEON_BLUE} Signal:{RESET} {signal.upper()} (Confidence: {confidence:.2f})\")\n                symbol_logger.info(f\"{NEON_BLUE} Conditions Met:{RESET} {', '.join(conditions_met) if conditions_met else 'None'}\")\n                if trade_levels:\n                    symbol_logger.info(f\"{NEON_GREEN} Suggested Stop Loss:{RESET} {trade_levels.get('stop_loss'):.5f}\")\n                    symbol_logger.info(f\"{NEON_GREEN} Suggested Take Profit:{RESET} {trade_levels.get('take_profit'):.5f}\")\n                symbol_logger.info(f\"{NEON_YELLOW} --- Placeholder: Order placement logic would be here for {signal.upper()} signal ---{RESET}\")\n                last_signal_time = current_time_seconds  # Update last signal time\n\n            time.sleep(CONFIG[\"analysis_interval\"])\n\n        except requests.exceptions.RequestException as e:\n            symbol_logger.error(f\"{NEON_RED} Network or API communication error: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}\")\n            time.sleep(CONFIG[\"retry_delay\"])\n        except KeyboardInterrupt:\n            symbol_logger.info(f\"{NEON_YELLOW} Analysis stopped by user. {RESET}\")\n            break\n        except Exception as e:\n            symbol_logger.exception(f\"{NEON_RED} An unexpected error occurred: {e}. Retrying in {CONFIG['retry_delay']} seconds...{RESET}\")\n            time.sleep(CONFIG[\"retry_delay\"])\n\n\nif __name__ == \"__main__\":\n    main()\n```"
- role: system
  content: |-
    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a trading bot for Bybit, performing technical analysis and generating trade signals. Key features include:

    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from a `config.json` file, allowing customization of intervals, indicator periods, and signal weights. It handles missing or corrupt config files by loading defaults.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets (e.g., "low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, along with confidence scores and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    The refactoring focused on improving logical flow, ensuring consistent data handling (especially with `Decimal`), and adjusting configuration parameters for clarity.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a Bybit trading bot focused on technical analysis.

    **Key Topics Discussed:**
    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from `config.json`, including intervals, indicator periods, and signal weights, with robust handling for missing/corrupt files.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets ("low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, confidence scores, and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    **Important Decisions/Conclusions:**
    *   Refactoring focused on improving logical flow and ensuring consistent data handling using `Decimal` for precision.
    *   Configuration parameters were adjusted for clarity and robustness.

    **Action Items/Next Steps:**
    *   Implement actual order placement logic, as it's currently a placeholder.
    *   Further fine-tune indicator parameters and signal weights.
    *   Consider adding backtesting capabilities.

    **Unresolved Questions:**
    *   How to handle real-time order execution and position management.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    The user requested to color-code indicator values in the Python trading bot's output for better readability.

    **Key Changes Implemented:**
    *   The `interpret_indicator` function was significantly enhanced to apply `colorama` (NEON_GREEN, NEON_RED, NEON_YELLOW, NEON_BLUE) based on the indicator's value and its typical interpretation (e.g., overbought/oversold for RSI, MFI, CCI, Williams %R; trending/ranging for ADX; bullish/bearish for OBV, ADI, MACD histogram, Stochastic Oscillators).
    *   It now correctly handles `pd.DataFrame` inputs for indicators like Stochastic RSI and Stochastic Oscillator, interpreting their K and D lines for crossovers and overbought/oversold conditions.
    *   The `TradingAnalyzer.analyze` function was refactored to remove redundant manual printing of indicator interpretations, instead passing all relevant indicator values through the `interpret_indicator` function for consistent formatting and coloring.

    **Outcome:**
    The bot's console output now provides visually distinct and immediately interpretable indicator values, centralizing the coloring logic and improving overall readability.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    The discussion focused on integrating advanced Ehlers indicators into the existing Bybit trading bot.

    **Key Topics & Changes:**
    *   **Ehlers Indicator Integration:** Nine new Ehlers indicators (Fisher Transform, Stochastic RSI, Optimal MA, Super Smoother, Adaptive MA, Correlation Cycle, Decycler, Bandpass, Center of Gravity) were added to the `TradingAnalyzer` class.
    *   **Configuration:** `config.json` and `default_config` were updated to include enable/disable flags, specific periods, and placeholder signal weights for each new Ehlers indicator.
    *   **Calculations & Storage:** New private methods were created for each Ehlers indicator calculation, with robustness checks for data availability. Results are stored in `self.indicator_values`.
    *   **Interpretation & Output:** The `interpret_indicator` function was extended to provide color-coded, human-readable interpretations for the new Ehlers indicators.
    *   **Signal Generation:** Placeholder logic was added to `generate_trading_signal` to incorporate Ehlers indicators into the overall signal scoring.

    **Important Decisions/Conclusions:**
    *   Ehlers indicators are now part of the bot's analytical toolkit.
    *   Initial signal weighting for Ehlers indicators is set to placeholders, requiring user fine-tuning.

    **Action Items/Next Steps:**
    *   Install `scipy` (`pip install scipy`).
    *   **Crucially, fine-tune the signal generation logic and thresholds for each Ehlers indicator** based on backtesting and strategic goals.
    *   Monitor bot performance due to the added computational complexity of Ehlers filters.
- role: user
  content: debug and lint the code
- role: assistant
  content: "Okay, I've thoroughly reviewed and debugged the provided Python code, focusing on:\n*   **Precision (Decimal vs. Float):** Ensuring `Decimal` is used for critical financial values to prevent floating-point inaccuracies, while allowing `float64` for vectorized NumPy/Pandas operations where performance is key and precision loss is minimal for intermediate steps.\n*   **Ehlers Indicator Implementations:** Correcting mathematical logic and `NaN` handling, especially for recursive calculations and filter applications. Clarifying where implementations are simplified for demonstration.\n*   **Robustness:** Improving checks for sufficient data, handling edge cases (e.g., division by zero), and consistent error logging.\n*   **Code Quality (Linting/PEP 8):** Addressing line length, spacing, variable naming, and general readability.\n\nHere's a summary of the key changes and improvements:\n\n1.  **Decimal Usage Refinement:**\n    *   The `df` columns (`open`, `high`, `low`, `close`, `volume`, `turnover`) remain `float64` for compatibility with vectorized Pandas/NumPy functions.\n    *   `current_price`, `stop_loss`, `take_profit`, `Fibonacci` levels, `Pivot Points`, and `signal_score` are explicitly converted to and handled as `Decimal` to maintain precision.\n    *   Conversions between `float` and `Decimal` are managed carefully at the boundaries of calculations (e.g., `Decimal(str(value))` for conversion from float to Decimal).\n\n2.  **Ehlers Indicator Corrections & Clarifications:**\n    *   **`_calculate_ehlers_fisher_transform`**: Corrected the recursive calculation for `v` and `fisher` to properly reference previous values within the loop. Added `np.clip` to prevent `log(0)` or `log(negative)` errors.\n    *   **`_calculate_ehlers_optimal_moving_average`**: Added a comment explicitly stating this is a simplified EMA-based proxy, as a true Ehlers OMA is more complex.\n    *   **`_calculate_ehlers_super_smoother_filter`**: Confirmed the `scipy.signal.lfilter` usage is correct for the 2-pole filter coefficients. Added a clearer warning for the unimplemented 3-pole case.\n    *   **`_calculate_ehlers_adaptive_moving_average`**: The iterative loop for AMA is correct.\n    *   **`_calculate_ehlers_decycler`**: Clarified that using SSF for smoothing is a conceptual approximation of a high-pass filter.\n    *   **`_calculate_ehlers_bandpass_filter`**: Explicitly stated that the current implementation (difference of EMAs) is a placeholder and not a true Ehlers bandpass filter, which requires specific filter coefficient calculations.\n    *   **`_calculate_ehlers_center_of_gravity`**: The loop-based calculation is retained as it's appropriate for the indicator's definition and typical `period` values.\n    *   **Data Sufficiency Checks**: Enhanced checks at the beginning of each Ehlers calculation to ensure enough historical data is available before attempting calculations, returning `NaN` series if not.\n    *   **`fillna` for Ehlers**: Applied `fillna(method='bfill').fillna(method='ffill')` to Ehlers indicator results to propagate valid values forward/backward after initial `NaN`s from filter warm-up.\n\n3.  **General Robustness & Error Handling:**\n    *   **`_safe_series_operation`**: Improved error messages for missing columns.\n    *   **`_calculate_fve`**: Added more robust `Decimal` conversions within the function and explicit `NaN` handling for means/stds to prevent `InvalidOperation` errors.\n    *   **`interpret_indicator`**: Enhanced error handling for various `TypeError`, `IndexError`, `KeyError`, `ValueError`, and `InvalidOperation` exceptions, providing more informative messages.\n    *   **`load_config`**: Added a `try-except` block for `OSError` during corrupt config file backup.\n    *   **`bybit_request`**: Added `timeout` to `requests.request` calls.\n    *   **`main` loop**: Added more specific `try-except` blocks for `requests.exceptions.RequestException` (network/API errors) and a general `Exception` catch for unexpected issues.\n\n4.  **Linting & Readability:**\n    *   Adjusted line lengths to adhere closer to PEP 8 recommendations (max 88 characters).\n    *   Improved spacing and consistency.\n    *   Minor variable renaming for clarity.\n    *   Added comments where complex logic or simplifications are present.\n\nHere's the updated code:\n\n```python\nimport os\nimport logging\nimport requests\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport hmac\nimport hashlib\nimport time\nfrom dotenv import load_dotenv\nfrom typing import Dict, Tuple, List, Union, Any\nfrom colorama import init, Fore, Style\nfrom zoneinfo import ZoneInfo\nfrom decimal import Decimal, getcontext, InvalidOperation\nimport json\n\n# --- New Imports for Ehlers Indicators ---\nimport scipy.signal # For filter operations (e.g., Super Smoother)\nimport scipy.stats # For pearsonr in Correlation Cycle Indicator\n\n# --- Logger Configuration (Minimal, for self-containment) ---\ndef setup_custom_logger(name):\n    \"\"\"Sets up a custom logger with console and file handlers.\"\"\"\n    log_file = os.path.join(LOG_DIRECTORY, f\"{name}.log\")\n\n    formatter = logging.Formatter(\n        fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    )\n\n    handler = logging.FileHandler(log_file)\n    handler.setFormatter(formatter)\n\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.INFO) # Set default level to INFO\n    logger.addHandler(handler)\n    logger.addHandler(console_handler) # Add console output\n    return logger\n\n# --- Configuration & Constants ---\n\n# Set Decimal precision for financial calculations to avoid floating point errors\ngetcontext().prec = 10\n\n# Initialize colorama for cross-platform colored terminal output\ninit(autoreset=True)\n\n# Load environment variables from .env file\nload_dotenv()\n\n# --- Color Codex ---\nNEON_GREEN = Fore.LIGHTGREEN_EX\nNEON_BLUE = Fore.CYAN\nNEON_PURPLE = Fore.MAGENTA\nNEON_YELLOW = Fore.YELLOW\nNEON_RED = Fore.LIGHTRED_EX\nRESET = Style.RESET_ALL\n\n# --- API & Bot Settings ---\nAPI_KEY = os.getenv(\"BYBIT_API_KEY\")\nAPI_SECRET = os.getenv(\"BYBIT_API_SECRET\")\nBASE_URL = os.getenv(\"BYBIT_BASE_URL\", \"https://api.bybit.com\")\nCONFIG_FILE = \"config.json\"\nLOG_DIRECTORY = \"bot_logs\"\nTIMEZONE = ZoneInfo(\"America/Chicago\")  # Using a specific timezone for consistency\nMAX_API_RETRIES = 3\nRETRY_DELAY_SECONDS = 5\nVALID_INTERVALS = [\"1\", \"3\", \"5\", \"15\", \"30\", \"60\", \"120\", \"240\", \"D\", \"W\", \"M\"]\nRETRY_ERROR_CODES = [429, 500, 502, 503, 504]  # HTTP status codes to trigger a retry\n\n# Ensure log directory exists\nos.makedirs(LOG_DIRECTORY, exist_ok=True)\n\n# Setup the main application logger\nlogger = setup_custom_logger('whalebot_main')\n\n\ndef load_config(filepath: str) -> dict:\n    \"\"\"\n    Loads configuration from a JSON file, merging with default values.\n    If the file is not found or is invalid, it creates one with default settings.\n    \"\"\"\n    default_config = {\n        \"interval\": \"15\",\n        \"analysis_interval\": 30,  # Time in seconds between main analysis cycles\n        \"retry_delay\": 5,  # Delay in seconds for API retries\n        \"momentum_period\": 10,\n        \"momentum_ma_short\": 12,\n        \"momentum_ma_long\": 26,\n        \"volume_ma_period\": 20,\n        \"atr_period\": 14,\n        \"trend_strength_threshold\": 0.4,\n        \"sideways_atr_multiplier\": 1.5,\n        \"signal_score_threshold\": 1.0,  # Minimum combined weight for a signal to be valid\n        \"indicators\": {\n            \"ema_alignment\": True,\n            \"momentum\": True,\n            \"volume_confirmation\": True,\n            \"divergence\": True,\n            \"stoch_rsi\": True,\n            \"rsi\": True,\n            \"macd\": True,\n            \"vwap\": False,\n            \"obv\": True,\n            \"adi\": True,\n            \"cci\": True,\n            \"wr\": True,\n            \"adx\": True,\n            \"psar\": True,\n            \"fve\": True,\n            \"sma_10\": False,\n            \"mfi\": True,\n            \"stochastic_oscillator\": True,\n            # --- Ehlers Indicators (Default: False) ---\n            \"ehlers_fisher_transform\": False,\n            \"ehlers_stochastic_rsi\": False,\n            \"ehlers_optimal_moving_average\": False,\n            \"ehlers_super_smoother_filter\": False,\n            \"ehlers_adaptive_moving_average\": False,\n            \"ehlers_correlation_cycle_indicator\": False,\n            \"ehlers_decycler\": False,\n            \"ehlers_bandpass_filter\": False,\n            \"ehlers_center_of_gravity\": False,\n        },\n        \"weight_sets\": {\n            \"low_volatility\": {  # Weights for a low volatility market environment\n                \"ema_alignment\": 0.3,\n                \"momentum\": 0.2,\n                \"volume_confirmation\": 0.2,\n                \"divergence\": 0.1,\n                \"stoch_rsi\": 0.5,\n                \"rsi\": 0.3,\n                \"macd\": 0.3,\n                \"vwap\": 0.0,\n                \"obv\": 0.1,\n                \"adi\": 0.1,\n                \"cci\": 0.1,\n                \"wr\": 0.1,\n                \"adx\": 0.1,\n                \"psar\": 0.1,\n                \"fve\": 0.2,\n                \"sma_10\": 0.0,\n                \"mfi\": 0.3,\n                \"stochastic_oscillator\": 0.4,\n                # --- Ehlers Indicator Weights (Placeholder) ---\n                \"ehlers_fisher_transform\": 0.2,\n                \"ehlers_stochastic_rsi\": 0.3,\n                \"ehlers_optimal_moving_average\": 0.1,\n                \"ehlers_super_smoother_filter\": 0.1,\n                \"ehlers_adaptive_moving_average\": 0.1,\n                \"ehlers_correlation_cycle_indicator\": 0.1,\n                \"ehlers_decycler\": 0.1,\n                \"ehlers_bandpass_filter\": 0.0, # Usually not a direct signal generator\n                \"ehlers_center_of_gravity\": 0.2,\n            },\n            \"high_volatility\": {  # Weights for a high volatility market environment\n                \"ema_alignment\": 0.1,\n                \"momentum\": 0.4,\n                \"volume_confirmation\": 0.1,\n                \"divergence\": 0.2,\n                \"stoch_rsi\": 0.4,\n                \"rsi\": 0.4,\n                \"macd\": 0.4,\n                \"vwap\": 0.0,\n                \"obv\": 0.1,\n                \"adi\": 0.1,\n                \"cci\": 0.1,\n                \"wr\": 0.1,\n                \"adx\": 0.1,\n                \"psar\": 0.1,\n                \"fve\": 0.3,\n                \"sma_10\": 0.0,\n                \"mfi\": 0.4,\n                \"stochastic_oscillator\": 0.3,\n                # --- Ehlers Indicator Weights (Placeholder) ---\n                \"ehlers_fisher_transform\": 0.3,\n                \"ehlers_stochastic_rsi\": 0.4,\n                \"ehlers_optimal_moving_average\": 0.2,\n                \"ehlers_super_smoother_filter\": 0.2,\n                \"ehlers_adaptive_moving_average\": 0.2,\n                \"ehlers_correlation_cycle_indicator\": 0.1,\n                \"ehlers_decycler\": 0.1,\n                \"ehlers_bandpass_filter\": 0.0,\n                \"ehlers_center_of_gravity\": 0.3,\n            }\n        },\n        \"stoch_rsi_oversold_threshold\": 20,\n        \"stoch_rsi_overbought_threshold\": 80,\n        \"stoch_rsi_confidence_boost\": 0.5,  # Additional boost for strong Stoch RSI signals\n        \"stoch_rsi_mandatory\": False,  # If true, Stoch RSI must be a confirming factor\n        \"rsi_confidence_boost\": 0.2,\n        \"mfi_confidence_boost\": 0.2,\n        \"order_book_support_confidence_boost\": 0.3,\n        \"order_book_resistance_confidence_boost\": 0.3,\n        \"stop_loss_multiple\": 1.5,  # Multiplier for ATR to determine stop loss distance\n        \"take_profit_multiple\": 1.0,  # Multiplier for ATR to determine take profit distance\n        \"order_book_wall_threshold_multiplier\": 2.0,  # Multiplier for average volume to identify a \"wall\"\n        \"order_book_depth_to_check\": 10,  # Number of order book levels to check for walls\n        \"price_change_threshold\": 0.005,  # % change in price to consider significant\n        \"atr_change_threshold\": 0.005,  # % change in ATR to consider significant volatility change\n        \"signal_cooldown_s\": 60,  # Seconds to wait before generating another signal\n        \"order_book_debounce_s\": 10,  # Seconds to wait between order book API calls\n        \"ema_short_period\": 12,\n        \"ema_long_period\": 26,\n        \"volume_confirmation_multiplier\": 1.5,  # Volume must be this many times average volume for confirmation\n        \"indicator_periods\": {\n            \"rsi\": 14,\n            \"mfi\": 14,\n            \"cci\": 20,\n            \"williams_r\": 14,\n            \"adx\": 14,\n            \"stoch_rsi_period\": 14,  # Period for RSI calculation within Stoch RSI\n            \"stoch_rsi_k_period\": 3,  # Smoothing period for %K line\n            \"stoch_rsi_d_period\": 3,  # Smoothing period for %D line (signal line)\n            \"momentum\": 10,\n            \"momentum_ma_short\": 12,\n            \"momentum_ma_long\": 26,\n            \"volume_ma\": 20,\n            \"atr\": 14,\n            \"sma_10\": 10,\n            \"fve_price_ema\": 10,  # EMA period for FVE price component\n            \"fve_obv_sma\": 20,  # SMA period for OBV normalization\n            \"fve_atr_sma\": 20,  # SMA period for ATR normalization\n            \"stoch_osc_k\": 14,  # Stochastic Oscillator K period\n            \"stoch_osc_d\": 3,  # Stochastic Oscillator D period\n            # --- Ehlers Indicator Periods ---\n            \"ehlers_fisher_period\": 10,\n            \"ehlers_stoch_rsi_period\": 14,\n            \"ehlers_stoch_rsi_k_period\": 3,\n            \"ehlers_stoch_rsi_d_period\": 3,\n            \"ehlers_oma_period\": 10,\n            \"ehlers_ssf_period\": 10,\n            \"ehlers_ssf_poles\": 2, # Number of poles for Super Smoother (2 or 3)\n            \"ehlers_ama_period\": 10,\n            \"ehlers_ama_fast_alpha\": 0.5, # Fast alpha for AMA (0.5 for 2-period EMA)\n            \"ehlers_ama_slow_alpha\": 0.05, # Slow alpha for AMA (0.05 for 39-period EMA)\n            \"ehlers_cci_period\": 20,\n            \"ehlers_decycler_period\": 20,\n            \"ehlers_bandpass_period\": 20, # Cycle period for bandpass filter\n            \"ehlers_cog_period\": 10,\n        },\n        \"order_book_analysis\": {\n            \"enabled\": True,\n            \"wall_threshold_multiplier\": 2.0,\n            \"depth_to_check\": 10,\n            \"support_boost\": 0.3,\n            \"resistance_boost\": 0.3,\n        },\n        \"trailing_stop_loss\": {\n            \"enabled\": False,  # Disabled by default\n            \"initial_activation_percent\": 0.5,  # Activate trailing stop after price moves X% in favor\n            \"trailing_stop_multiple_atr\": 1.5  # Trail stop based on ATR multiple\n        },\n        \"take_profit_scaling\": {\n            \"enabled\": False,  # Disabled by default\n            \"targets\": [\n                {\"level\": 1.5, \"percentage\": 0.25},  # Sell 25% when price hits 1.5x ATR TP\n                {\"level\": 2.0, \"percentage\": 0.50}  # Sell 50% of remaining when price hits 2.0x ATR TP\n            ]\n        }\n    }\n    try:\n        with open(filepath, \"r\", encoding=\"utf-8\") as f:\n            config = json.load(f)\n            # Merge loaded config with defaults. Prioritize loaded values,\n            # but ensure all default keys exist.\n            merged_config = {**default_config, **config}\n\n            # Recursively merge nested dictionaries (like 'indicators' and 'weight_sets')\n            for key, default_val in default_config.items():\n                if isinstance(default_val, dict) and key in config and \\\n                   isinstance(config[key], dict):\n                    merged_config[key] = {**default_val, **config[key]}\n\n            # Basic validation for interval and analysis_interval\n            if merged_config.get(\"interval\") not in VALID_INTERVALS:\n                logger.warning(f\"{NEON_YELLOW} Invalid 'interval' in config, \"\n                               f\"using default: {default_config['interval']}{RESET}\")\n                merged_config[\"interval\"] = default_config[\"interval\"]\n            if not isinstance(merged_config.get(\"analysis_interval\"), int) or \\\n               merged_config.get(\"analysis_interval\") <= 0:\n                logger.warning(f\"{NEON_YELLOW} Invalid 'analysis_interval' in config, \"\n                               f\"using default: {default_config['analysis_interval']}{RESET}\")\n                merged_config[\"analysis_interval\"] = default_config[\"analysis_interval\"]\n\n            return merged_config\n    except FileNotFoundError:\n        logger.warning(f\"{NEON_YELLOW} Config file not found, loading defaults and \"\n                       f\"creating {filepath}{RESET}\")\n        with open(filepath, \"w\", encoding=\"utf-8\") as f:\n            json.dump(default_config, f, indent=4)\n        return default_config\n    except json.JSONDecodeError:\n        logger.error(f\"{NEON_RED} Invalid JSON in config file, loading defaults. {RESET}\")\n        # Optionally, back up the corrupt file before overwriting\n        try:\n            os.rename(filepath, f\"{filepath}.bak_{int(time.time())}\")\n            logger.info(f\"{NEON_YELLOW} Backed up corrupt config file to \"\n                        f\"{filepath}.bak_{int(time.time())}{RESET}\")\n        except OSError as e:\n            logger.error(f\"{NEON_RED} Failed to backup corrupt config file: {e}{RESET}\")\n        with open(filepath, \"w\", encoding=\"utf-8\") as f:\n            json.dump(default_config, f, indent=4)\n        return default_config\n\n\n# Load the configuration\nCONFIG = load_config(CONFIG_FILE)\n\n\ndef generate_signature(api_secret: str, params: dict) -> str:\n    \"\"\"Generates the HMAC SHA256 signature for Bybit API requests.\"\"\"\n    # Ensure params are sorted by key for consistent signature generation\n    param_str = \"&\".join([f\"{key}={value}\" for key, value in sorted(params.items())])\n    return hmac.new(api_secret.encode(), param_str.encode(), hashlib.sha256).hexdigest()\n\n\ndef handle_api_error(response: requests.Response, logger: logging.Logger) -> None:\n    \"\"\"Logs detailed API error responses.\"\"\"\n    logger.error(f\"{NEON_RED} API request failed with status code: {response.status_code}{RESET}\")\n    try:\n        error_json = response.json()\n        logger.error(f\"{NEON_RED} Error details: {error_json}{RESET}\")\n    except json.JSONDecodeError:\n        logger.error(f\"{NEON_RED} Response text: {response.text}{RESET}\")\n\n\ndef bybit_request(method: str, endpoint: str, api_key: str, api_secret: str,\n                  params: Dict[str, Any] = None, logger: logging.Logger = None\n                  ) -> Union[dict, None]:\n    \"\"\"\n    Sends a signed request to the Bybit API with retry logic.\n\n    Args:\n        method (str): HTTP method (e.g., \"GET\", \"POST\").\n        endpoint (str): API endpoint path.\n        api_key (str): Your Bybit API key.\n        api_secret (str): Your Bybit API secret.\n        params (Dict[str, Any], optional): Dictionary of request parameters.\n                                            Defaults to None.\n        logger (logging.Logger, optional): Logger instance for logging.\n                                           Defaults to None.\n\n    Returns:\n        Union[dict, None]: JSON response data if successful, None otherwise.\n    \"\"\"\n    params = params or {}\n    # Bybit API V5 requires timestamp in milliseconds\n    params['timestamp'] = str(int(time.time() * 1000))\n    signature = generate_signature(api_secret, params)\n    headers = {\n        \"X-BAPI-API-KEY\": api_key,\n        \"X-BAPI-SIGN\": signature,\n        \"X-BAPI-TIMESTAMP\": params['timestamp'],\n        \"Content-Type\": \"application/json\"\n    }\n    url = f\"{BASE_URL}{endpoint}\"\n\n    for retry in range(MAX_API_RETRIES):\n        try:\n            response = requests.request(\n                method,\n                url,\n                headers=headers,\n                params=params if method == \"GET\" else None,\n                json=params if method == \"POST\" else None,\n                timeout=10  # Set a timeout for requests\n            )\n            response.raise_for_status()  # Raises HTTPError for bad responses (4xx or 5xx)\n\n            # Check for Bybit specific error codes within a successful HTTP response\n            response_json = response.json()\n            if response_json.get(\"retCode\") != 0:\n                if logger:\n                    logger.error(f\"{NEON_RED} Bybit API Error: \"\n                                 f\"{response_json.get('retMsg', 'Unknown error')}. \"\n                                 f\"Response: {response_json}{RESET}\")\n                return None\n\n            return response_json\n\n        except requests.exceptions.HTTPError as e:\n            if e.response.status_code in RETRY_ERROR_CODES:\n                if logger:\n                    logger.warning(f\"{NEON_YELLOW} API Error {e.response.status_code} \"\n                                   f\"({e.response.reason}), retrying {retry + 1}/\"\n                                   f\"{MAX_API_RETRIES}...{RESET}\")\n                time.sleep(RETRY_DELAY_SECONDS * (2**retry))  # Exponential backoff\n            else:\n                if logger:\n                    handle_api_error(e.response, logger)\n                return None\n        except requests.exceptions.RequestException as e:\n            if logger:\n                logger.error(f\"{NEON_RED} Request exception: {e}, retrying {retry + 1}/\"\n                             f\"{MAX_API_RETRIES}...{RESET}\")\n            time.sleep(RETRY_DELAY_SECONDS * (2**retry))\n\n    if logger:\n        logger.error(f\"{NEON_RED} Max retries reached for {method} {endpoint}{RESET}\")\n    return None\n\n\ndef fetch_current_price(symbol: str, api_key: str, api_secret: str,\n                        logger: logging.Logger) -> Union[Decimal, None]:\n    \"\"\"Fetches the current last traded price for a given symbol.\"\"\"\n    endpoint = \"/v5/market/tickers\"\n    params = {\"category\": \"linear\", \"symbol\": symbol}\n    response_data = bybit_request(\"GET\", endpoint, api_key, api_secret, params, logger)\n    if response_data and response_data.get(\"retCode\") == 0 and response_data.get(\"result\"):\n        tickers = response_data[\"result\"].get(\"list\")\n        if tickers:\n            for ticker in tickers:\n                if ticker.get(\"symbol\") == symbol:\n                    last_price = ticker.get(\"lastPrice\")\n                    return Decimal(last_price) if last_price else None\n    logger.error(f\"{NEON_RED} Could not fetch current price for {symbol}. \"\n                 f\"Response: {response_data}{RESET}\")\n    return None\n\n\ndef fetch_klines(symbol: str, interval: str, api_key: str, api_secret: str,\n                 logger: logging.Logger, limit: int = 200) -> pd.DataFrame:\n    \"\"\"Fetches historical K-line (candlestick) data for a given symbol and interval.\"\"\"\n    endpoint = \"/v5/market/kline\"\n    params = {\"symbol\": symbol, \"interval\": interval, \"limit\": limit, \"category\": \"linear\"}\n    response_data = bybit_request(\"GET\", endpoint, api_key, api_secret, params, logger)\n    if response_data and response_data.get(\"retCode\") == 0 and \\\n       response_data.get(\"result\") and response_data[\"result\"].get(\"list\"):\n        data = response_data[\"result\"][\"list\"]\n        # Bybit's kline list order is: [timestamp, open, high, low, close, volume, turnover]\n        columns = [\"start_time\", \"open\", \"high\", \"low\", \"close\", \"volume\", \"turnover\"]\n        df = pd.DataFrame(data, columns=columns)\n        df[\"start_time\"] = pd.to_datetime(pd.to_numeric(df[\"start_time\"]), unit=\"ms\")\n        # Convert numeric columns, coercing errors to NaN\n        for col in df.columns[1:]:\n            df[col] = pd.to_numeric(df[col], errors='coerce')\n        # Drop any rows that resulted in all NaNs after conversion\n        df.dropna(subset=df.columns[1:], inplace=True)\n        # Ensure chronological order\n        return df.sort_values(by=\"start_time\", ascending=True).reset_index(drop=True)\n    logger.error(f\"{NEON_RED} Failed to fetch Kline data for {symbol}, \"\n                 f\"interval {interval}. Response: {response_data}{RESET}\")\n    return pd.DataFrame()\n\n\ndef fetch_order_book(symbol: str, api_key: str, api_secret: str,\n                     logger: logging.Logger, limit: int = 50) -> Union[dict, None]:\n    \"\"\"Fetches the order book (bids and asks) for a given symbol.\"\"\"\n    endpoint = \"/v5/market/orderbook\"\n    params = {\"symbol\": symbol, \"limit\": limit, \"category\": \"linear\"}\n    response_data = bybit_request(\"GET\", endpoint, api_key, api_secret, params, logger)\n    if response_data and response_data.get(\"retCode\") == 0 and response_data.get(\"result\"):\n        return response_data[\"result\"]\n    logger.warning(f\"{NEON_YELLOW} Could not fetch order book for {symbol}. \"\n                   f\"Response: {response_data}{RESET}\")\n    return None\n\n\nclass TradingAnalyzer:\n    \"\"\"\n    Performs technical analysis on candlestick data and generates trading signals.\n    \"\"\"\n    def __init__(self, df: pd.DataFrame, config: dict, symbol_logger: logging.Logger,\n                 symbol: str, interval: str):\n        self.df = df.copy()  # Work on a copy to avoid modifying original DataFrame\n        self.config = config\n        self.logger = symbol_logger\n        self.symbol = symbol\n        self.interval = interval\n        self.levels: Dict[str, Any] = {}  # Stores support/resistance levels (fib, pivot)\n        self.fib_levels: Dict[str, Decimal] = {}  # Stores calculated Fibonacci levels\n        self.weight_sets = config[\"weight_sets\"]\n        self.indicator_values: Dict[str, Any] = {}  # Stores calculated indicator values\n        self.atr_value: float = 0.0  # Stores the latest ATR value\n        self.user_defined_weights: Dict[str, float] = {} # To be selected dynamically\n\n    def _safe_series_operation(self, column: str, operation: str, window: int = None,\n                               series: pd.Series = None) -> pd.Series:\n        \"\"\"Helper to safely perform operations on DataFrame columns or provided series.\"\"\"\n        if series is not None:\n            data_series = series\n        elif column in self.df.columns:\n            data_series = self.df[column]\n        else:\n            self.logger.error(f\"{NEON_RED} Missing '{column}' column for \"\n                               f\"{operation} calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        if data_series.empty:\n            return pd.Series(dtype=float)\n\n        try:\n            if operation == \"sma\":\n                return data_series.rolling(window=window).mean()\n            elif operation == \"ema\":\n                return data_series.ewm(span=window, adjust=False).mean()\n            elif operation == \"max\":\n                return data_series.rolling(window=window).max()\n            elif operation == \"min\":\n                return data_series.rolling(window=window).min()\n            elif operation == \"diff\":\n                return data_series.diff(window)\n            elif operation == \"abs_diff_mean\":\n                return data_series.rolling(window=window).apply(\n                    lambda x: np.abs(x - x.mean()).mean(), raw=True)\n            elif operation == \"cumsum\":\n                return data_series.cumsum()\n            else:\n                self.logger.error(f\"{NEON_RED} Unsupported series operation: {operation}{RESET}\")\n                return pd.Series(dtype=float)\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED} Error during {operation} calculation on \"\n                               f\"{column}: {e}{RESET}\")\n            return pd.Series(dtype=float)\n\n    def _calculate_sma(self, window: int, series: pd.Series = None) -> pd.Series:\n        \"\"\"Calculates Simple Moving Average (SMA). Can operate on a specified series or 'close' price.\"\"\"\n        return self._safe_series_operation('close', 'sma', window, series)\n\n    def _calculate_ema(self, window: int, series: pd.Series = None) -> pd.Series:\n        \"\"\"Calculates Exponential Moving Average (EMA). Can operate on a specified series or 'close' price.\"\"\"\n        return self._safe_series_operation('close', 'ema', window, series)\n\n    def _calculate_ema_alignment(self) -> float:\n        \"\"\"\n        Calculates an EMA alignment score.\n        Score is 1.0 for strong bullish alignment, -1.0 for strong bearish, 0.0 for neutral.\n        \"\"\"\n        ema_short = self._calculate_ema(self.config[\"ema_short_period\"])\n        ema_long = self._calculate_ema(self.config[\"ema_long_period\"])\n\n        if ema_short.empty or ema_long.empty or \\\n           len(self.df) < max(self.config[\"ema_short_period\"],\n                              self.config[\"ema_long_period\"]):\n            return 0.0\n\n        latest_short_ema = Decimal(str(ema_short.iloc[-1]))\n        latest_long_ema = Decimal(str(ema_long.iloc[-1]))\n\n        # Check for consistent alignment over the last few bars (e.g., 3 bars)\n        alignment_period = 3\n        if len(ema_short) < alignment_period or len(ema_long) < alignment_period:\n            return 0.0\n\n        bullish_aligned_count = 0\n        bearish_aligned_count = 0\n\n        for i in range(1, alignment_period + 1):\n            if (ema_short.iloc[-i] > ema_long.iloc[-i] and\n                self.df[\"close\"].iloc[-i] > ema_short.iloc[-i]):\n                bullish_aligned_count += 1\n            elif (ema_short.iloc[-i] < ema_long.iloc[-i] and\n                  self.df[\"close\"].iloc[-i] < ema_short.iloc[-i]):\n                bearish_aligned_count += 1\n\n        if bullish_aligned_count >= alignment_period - 1:\n            return 1.0  # Strong bullish alignment\n        elif bearish_aligned_count >= alignment_period - 1:\n            return -1.0  # Strong bearish alignment\n        else:\n            # Check for recent crossover as a weaker signal\n            if latest_short_ema > latest_long_ema and ema_short.iloc[-2] <= latest_long_ema:\n                return 0.5  # Recent bullish crossover\n            elif latest_short_ema < latest_long_ema and ema_short.iloc[-2] >= latest_long_ema:\n                return -0.5  # Recent bearish crossover\n            return 0.0  # Neutral\n\n    def _calculate_momentum(self, period: int = 10) -> pd.Series:\n        \"\"\"Calculates the Momentum indicator.\"\"\"\n        # Momentum is often calculated as current price - price N periods ago.\n        # For signal generation, a ratio or percentage change can be more useful.\n        # Here, we calculate the percentage change over the period.\n        return self._safe_series_operation('close', 'diff', period) / \\\n               self.df[\"close\"].shift(period) * 100\n\n    def _calculate_cci(self, window: int = 20, constant: float = 0.015) -> pd.Series:\n        \"\"\"Calculates the Commodity Channel Index (CCI).\"\"\"\n        required_columns = ['high', 'low', 'close']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for CCI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n        typical_price = (self.df[\"high\"] + self.df[\"low\"] + self.df[\"close\"]) / 3\n        sma_typical_price = self._safe_series_operation(None, 'sma', window, typical_price)\n        mean_deviation = self._safe_series_operation(None, 'abs_diff_mean', window, typical_price)\n        # Avoid division by zero\n        cci = (typical_price - sma_typical_price) / (constant * mean_deviation)\n        return cci.replace([np.inf, -np.inf], np.nan)  # Handle potential inf values\n\n    def _calculate_williams_r(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Williams %R indicator.\"\"\"\n        required_columns = ['high', 'low', 'close']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for Williams %R calculation.{RESET}\")\n            return pd.Series(dtype=float)\n        highest_high = self._safe_series_operation('high', 'max', window)\n        lowest_low = self._safe_series_operation('low', 'min', window)\n        # Avoid division by zero\n        denominator = (highest_high - lowest_low)\n        wr = ((highest_high - self.df[\"close\"]) / denominator) * -100\n        return wr.replace([np.inf, -np.inf], np.nan)\n\n    def _calculate_mfi(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Money Flow Index (MFI).\"\"\"\n        required_columns = ['high', 'low', 'close', 'volume']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for MFI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        typical_price = (self.df[\"high\"] + self.df[\"low\"] + self.df[\"close\"]) / 3\n        raw_money_flow = typical_price * self.df[\"volume\"]\n\n        # Calculate positive and negative money flow\n        money_flow_direction = typical_price.diff()\n        positive_flow = raw_money_flow.where(money_flow_direction > 0, 0)\n        negative_flow = raw_money_flow.where(money_flow_direction < 0, 0)\n\n        # Calculate sums over the window\n        positive_mf = self._safe_series_operation(None, 'sma', window, positive_flow) * window\n        negative_mf = self._safe_series_operation(None, 'sma', window, negative_flow) * window\n\n        # Avoid division by zero\n        money_ratio = positive_mf / negative_mf.replace(0, np.nan)\n        mfi = 100 - (100 / (1 + money_ratio))\n        return mfi.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n    def calculate_fibonacci_retracement(self, high: Decimal, low: Decimal,\n                                        current_price: Decimal) -> Dict[str, Decimal]:\n        \"\"\"Calculates Fibonacci retracement levels based on a given high and low.\"\"\"\n        diff = high - low\n        if diff <= 0:  # Handle cases where high <= low\n            self.logger.warning(f\"{NEON_YELLOW} Cannot calculate Fibonacci retracement: \"\n                                f\"High ({high}) <= Low ({low}).{RESET}\")\n            self.fib_levels = {}\n            self.levels = {\"Support\": {}, \"Resistance\": {}}\n            return {}\n\n        # Standard Fibonacci ratios\n        fib_ratios = {\n            \"23.6%\": Decimal('0.236'), \"38.2%\": Decimal('0.382'), \"50.0%\": Decimal('0.500'),\n            \"61.8%\": Decimal('0.618'), \"78.6%\": Decimal('0.786'), \"88.6%\": Decimal('0.886'),\n            \"94.1%\": Decimal('0.941')\n        }\n        fib_levels_calculated: Dict[str, Decimal] = {}\n\n        # Assuming an uptrend (retracement from high to low)\n        # Levels are calculated from the high, moving down\n        for label, ratio in fib_ratios.items():\n            level = high - (diff * ratio)\n            # Quantize for consistent precision\n            fib_levels_calculated[f\"Fib {label}\"] = level.quantize(Decimal('0.00001'))\n\n        self.fib_levels = fib_levels_calculated\n        self.levels = {\"Support\": {}, \"Resistance\": {}}\n\n        # Categorize levels as support or resistance relative to current price\n        for label, value in self.fib_levels.items():\n            if value < current_price:\n                self.levels[\"Support\"][label] = value\n            elif value > current_price:\n                self.levels[\"Resistance\"][label] = value\n\n        return self.fib_levels\n\n    def calculate_pivot_points(self, high: Decimal, low: Decimal, close: Decimal):\n        \"\"\"Calculates standard Pivot Points.\"\"\"\n        pivot = (high + low + close) / 3\n        r1 = (2 * pivot) - low\n        s1 = (2 * pivot) - high\n        r2 = pivot + (high - low)\n        s2 = pivot - (high - low)\n        r3 = high + 2 * (pivot - low)\n        s3 = low - 2 * (high - pivot)\n\n        # Quantize all pivot points for consistent precision\n        precision = Decimal('0.00001')\n        self.levels.update({\n            \"Pivot\": pivot.quantize(precision),\n            \"R1\": r1.quantize(precision), \"S1\": s1.quantize(precision),\n            \"R2\": r2.quantize(precision), \"S2\": s2.quantize(precision),\n            \"R3\": r3.quantize(precision), \"S3\": s3.quantize(precision),\n        })\n\n    def find_nearest_levels(self, current_price: Decimal, num_levels: int = 5\n                           ) -> Tuple[List[Tuple[str, Decimal]], List[Tuple[str, Decimal]]]:\n        \"\"\"\n        Finds the nearest support and resistance levels from calculated Fibonacci and Pivot Points.\n        \"\"\"\n        all_support_levels: List[Tuple[str, Decimal]] = []\n        all_resistance_levels: List[Tuple[str, Decimal]] = []\n\n        def process_level(label: str, value: Decimal):\n            if value < current_price:\n                all_support_levels.append((label, value))\n            elif value > current_price:\n                all_resistance_levels.append((label, value))\n\n        # Process all levels stored in self.levels (from Fibonacci and Pivot)\n        for label, value in self.levels.items():\n            if isinstance(value, dict):  # For nested levels like \"Support\": {\"Fib 23.6%\": ...}\n                for sub_label, sub_value in value.items():\n                    if isinstance(sub_value, Decimal):\n                        process_level(f\"{label} ({sub_label})\", sub_value)\n            elif isinstance(value, Decimal):  # For direct levels like \"Pivot\"\n                process_level(label, value)\n\n        # Sort by distance to current price and select the 'num_levels' closest\n        nearest_supports = sorted(all_support_levels, key=lambda x: current_price - x[1])[:num_levels]\n        nearest_resistances = sorted(all_resistance_levels, key=lambda x: x[1] - current_price)[:num_levels]\n\n        return nearest_supports, nearest_resistances\n\n    def _calculate_atr(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Average True Range (ATR).\"\"\"\n        required_columns = ['high', 'low', 'close']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for ATR calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        high_low = self.df[\"high\"] - self.df[\"low\"]\n        high_close = abs(self.df[\"high\"] - self.df[\"close\"].shift())\n        low_close = abs(self.df[\"low\"] - self.df[\"close\"].shift())\n\n        # True Range is the maximum of the three\n        tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n        return self._safe_series_operation(None, 'ema', window, tr)  # Use EMA for ATR for smoothing\n\n    def _calculate_rsi(self, window: int = 14) -> pd.Series:\n        \"\"\"Calculates the Relative Strength Index (RSI).\"\"\"\n        if 'close' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' column for RSI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        delta = self.df[\"close\"].diff()\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n\n        avg_gain = self._safe_series_operation(None, 'ema', window, gain)\n        avg_loss = self._safe_series_operation(None, 'ema', window, loss)\n\n        # Avoid division by zero\n        rs = avg_gain / avg_loss.replace(0, np.nan)\n        rsi = 100 - (100 / (1 + rs))\n        return rsi.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n    def _calculate_stoch_rsi(self, rsi_window: int = 14, stoch_window: int = 14,\n                             k_window: int = 3, d_window: int = 3) -> pd.DataFrame:\n        \"\"\"Calculates Stochastic RSI (%K and %D lines).\"\"\"\n        rsi = self._calculate_rsi(window=rsi_window)\n        if rsi.empty:\n            return pd.DataFrame()\n\n        # Calculate StochRSI\n        stoch_rsi = (rsi - self._safe_series_operation(None, 'min', stoch_window, rsi)) / \\\n                    (self._safe_series_operation(None, 'max', stoch_window, rsi) -\n                     self._safe_series_operation(None, 'min', stoch_window, rsi))\n\n        # Handle division by zero for StochRSI (if max == min)\n        stoch_rsi = stoch_rsi.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n        k_line = self._safe_series_operation(None, 'sma', k_window, stoch_rsi) * 100\n        d_line = self._safe_series_operation(None, 'sma', d_window, k_line)\n\n        return pd.DataFrame({'stoch_rsi': stoch_rsi * 100, 'k': k_line, 'd': d_line})\n\n    def _calculate_stochastic_oscillator(self) -> pd.DataFrame:\n        \"\"\"Calculates the Stochastic Oscillator (%K and %D lines).\"\"\"\n        k_period = self.config[\"indicator_periods\"][\"stoch_osc_k\"]\n        d_period = self.config[\"indicator_periods\"][\"stoch_osc_d\"]\n\n        if 'high' not in self.df.columns or 'low' not in self.df.columns or \\\n           'close' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing required columns for Stochastic \"\n                               f\"Oscillator calculation.{RESET}\")\n            return pd.DataFrame()\n\n        highest_high = self._safe_series_operation('high', 'max', k_period)\n        lowest_low = self._safe_series_operation('low', 'min', k_period)\n\n        # Calculate %K\n        k_line = (self.df['close'] - lowest_low) / (highest_high - lowest_low) * 100\n        k_line = k_line.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n        # Calculate %D (SMA of %K)\n        d_line = self._safe_series_operation(None, 'sma', d_period, k_line)\n\n        return pd.DataFrame({'k': k_line, 'd': d_line})\n\n    def _calculate_momentum_ma(self) -> None:\n        \"\"\"Calculates momentum and its moving averages, and volume moving average.\"\"\"\n        if 'close' not in self.df.columns or 'volume' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' or 'volume' column for \"\n                               f\"Momentum MA calculation.{RESET}\")\n            return\n\n        self.df[\"momentum\"] = self._calculate_momentum(\n            period=self.config[\"momentum_period\"])\n        self.df[\"momentum_ma_short\"] = self._calculate_sma(\n            self.config[\"momentum_ma_short\"], series=self.df[\"momentum\"])\n        self.df[\"momentum_ma_long\"] = self._calculate_sma(\n            self.config[\"momentum_ma_long\"], series=self.df[\"momentum\"])\n        self.df[\"volume_ma\"] = self._calculate_sma(\n            self.config[\"volume_ma_period\"], series=self.df[\"volume\"])\n\n    def _calculate_macd(self) -> pd.DataFrame:\n        \"\"\"Calculates Moving Average Convergence Divergence (MACD).\"\"\"\n        if 'close' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' column for MACD calculation.{RESET}\")\n            return pd.DataFrame()\n\n        ma_short = self._calculate_ema(12)\n        ma_long = self._calculate_ema(26)\n        macd = ma_short - ma_long\n        signal = self._calculate_ema(9, series=macd)\n        histogram = macd - signal\n        return pd.DataFrame({'macd': macd, 'signal': signal, 'histogram': histogram})\n\n    def detect_macd_divergence(self) -> Union[str, None]:\n        \"\"\"Detects bullish or bearish MACD divergence.\"\"\"\n        macd_df = self._calculate_macd()\n        if macd_df.empty or len(self.df) < 30:\n            return None\n\n        prices = self.df[\"close\"]\n        macd_histogram = macd_df[\"histogram\"]\n\n        # Simple divergence check on last two bars (can be expanded for more robust detection)\n        if (prices.iloc[-2] > prices.iloc[-1] and macd_histogram.iloc[-2] < macd_histogram.iloc[-1]):\n            self.logger.info(f\"{NEON_GREEN} Detected Bullish MACD Divergence.{RESET}\")\n            return \"bullish\"\n        elif (prices.iloc[-2] < prices.iloc[-1] and macd_histogram.iloc[-2] > macd_histogram.iloc[-1]):\n            self.logger.info(f\"{NEON_RED} Detected Bearish MACD Divergence.{RESET}\")\n            return \"bearish\"\n        return None\n\n    def determine_trend_momentum(self) -> Dict[str, Union[str, float]]:\n        \"\"\"Determines the current trend and its strength based on momentum MAs and ATR.\"\"\"\n        if self.df.empty or len(self.df) < max(self.config[\"momentum_ma_long\"],\n                                              self.config[\"atr_period\"]):\n            return {\"trend\": \"Insufficient Data\", \"strength\": 0.0}\n\n        # Ensure momentum_ma_short, momentum_ma_long, and atr_value are calculated\n        if \"momentum_ma_short\" not in self.df.columns or \\\n           \"momentum_ma_long\" not in self.df.columns or self.atr_value == 0:\n            self.logger.warning(f\"{NEON_YELLOW} Momentum MAs or ATR not available for \"\n                                f\"trend calculation.{RESET}\")\n            return {\"trend\": \"Neutral\", \"strength\": 0.0}\n\n        latest_short_ma = self.df[\"momentum_ma_short\"].iloc[-1]\n        latest_long_ma = self.df[\"momentum_ma_long\"].iloc[-1]\n\n        trend = \"Neutral\"\n        if latest_short_ma > latest_long_ma:\n            trend = \"Uptrend\"\n        elif latest_short_ma < latest_long_ma:\n            trend = \"Downtrend\"\n\n        # Strength is normalized by ATR to make it comparable across symbols/timeframes\n        strength = abs(latest_short_ma - latest_long_ma) / self.atr_value\n        return {\"trend\": trend, \"strength\": strength}\n\n    def _calculate_adx(self, window: int = 14) -> float:\n        \"\"\"Calculates the Average Directional Index (ADX).\"\"\"\n        df_adx = self.df.copy()\n        required_columns = ['high', 'low', 'close']\n        if not all(col in df_adx.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for ADX calculation.{RESET}\")\n            return 0.0\n\n        # True Range\n        df_adx[\"TR\"] = pd.concat([\n            df_adx[\"high\"] - df_adx[\"low\"],\n            abs(df_adx[\"high\"] - df_adx[\"close\"].shift()),\n            abs(df_adx[\"low\"] - df_adx[\"close\"].shift())\n        ], axis=1).max(axis=1)\n\n        # Directional Movement\n        df_adx[\"+DM\"] = np.where((df_adx[\"high\"] - df_adx[\"high\"].shift()) >\n                                 (df_adx[\"low\"].shift() - df_adx[\"low\"]),\n                                 np.maximum(df_adx[\"high\"] - df_adx[\"high\"].shift(), 0), 0)\n        df_adx[\"-DM\"] = np.where((df_adx[\"low\"].shift() - df_adx[\"low\"]) >\n                                 (df_adx[\"high\"] - df_adx[\"high\"].shift()),\n                                 np.maximum(df_adx[\"low\"].shift() - df_adx[\"low\"], 0), 0)\n\n        # Smoothed True Range and Directional Movement (using EMA)\n        df_adx[\"TR_ema\"] = self._calculate_ema(window, series=df_adx[\"TR\"])\n        df_adx[\"+DM_ema\"] = self._calculate_ema(window, series=df_adx[\"+DM\"])\n        df_adx[\"-DM_ema\"] = self._calculate_ema(window, series=df_adx[\"-DM\"])\n\n        # Directional Indicators\n        df_adx[\"+DI\"] = 100 * (df_adx[\"+DM_ema\"] / df_adx[\"TR_ema\"].replace(0, np.nan))\n        df_adx[\"-DI\"] = 100 * (df_adx[\"-DM_ema\"] / df_adx[\"TR_ema\"].replace(0, np.nan))\n\n        # Directional Movement Index (DX)\n        df_adx[\"DX\"] = 100 * abs(df_adx[\"+DI\"] - df_adx[\"-DI\"]) / \\\n                       (df_adx[\"+DI\"] + df_adx[\"-DI\"]).replace(0, np.nan)\n\n        # Average Directional Index (ADX)\n        adx_value = self._calculate_ema(window, series=df_adx[\"DX\"]).iloc[-1]\n        return adx_value if not pd.isna(adx_value) else 0.0\n\n    def _calculate_obv(self) -> pd.Series:\n        \"\"\"Calculates On-Balance Volume (OBV).\"\"\"\n        if 'close' not in self.df.columns or 'volume' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' or 'volume' column for OBV calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        obv = pd.Series(0, index=self.df.index, dtype=float)\n        obv.iloc[0] = self.df[\"volume\"].iloc[0]\n\n        for i in range(1, len(self.df)):\n            if self.df[\"close\"].iloc[i] > self.df[\"close\"].iloc[i - 1]:\n                obv.iloc[i] = obv.iloc[i - 1] + self.df[\"volume\"].iloc[i]\n            elif self.df[\"close\"].iloc[i] < self.df[\"close\"].iloc[i - 1]:\n                obv.iloc[i] = obv.iloc[i - 1] - self.df[\"volume\"].iloc[i]\n            else:\n                obv.iloc[i] = obv.iloc[i - 1]\n\n        return obv\n\n    def _calculate_adi(self) -> pd.Series:\n        \"\"\"Calculates Accumulation/Distribution Index (ADI).\"\"\"\n        required_columns = ['high', 'low', 'close', 'volume']\n        if not all(col in self.df.columns for col in required_columns):\n            self.logger.error(f\"{NEON_RED} Missing required columns for ADI calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        # Money Flow Multiplier (MFM)\n        mfm_denominator = (self.df[\"high\"] - self.df[\"low\"])\n        mfm = ((self.df[\"close\"] - self.df[\"low\"]) -\n               (self.df[\"high\"] - self.df[\"close\"])) / mfm_denominator.replace(0, np.nan)\n        mfm.fillna(0, inplace=True)\n\n        # Money Flow Volume (MFV)\n        money_flow_volume = mfm * self.df[\"volume\"]\n\n        # Accumulation/Distribution Line (ADL) is the cumulative sum of MFV\n        return self._safe_series_operation(None, 'cumsum', series=money_flow_volume)\n\n    def _calculate_psar(self, acceleration: float = 0.02, max_acceleration: float = 0.2\n                       ) -> pd.Series:\n        \"\"\"Calculates Parabolic SAR (PSAR).\"\"\"\n        psar = pd.Series(index=self.df.index, dtype=\"float64\")\n        if self.df.empty or len(self.df) < 2:\n            return psar\n\n        # Initial values\n        psar.iloc[0] = self.df[\"close\"].iloc[0]\n        # Determine initial trend based on first two bars\n        if self.df[\"close\"].iloc[1] > self.df[\"close\"].iloc[0]:\n            trend = 1  # Uptrend\n            ep = self.df[\"high\"].iloc[0]  # Extreme Point\n        else:\n            trend = -1  # Downtrend\n            ep = self.df[\"low\"].iloc[0]  # Extreme Point\n        af = acceleration  # Acceleration Factor\n\n        for i in range(1, len(self.df)):\n            current_high = self.df[\"high\"].iloc[i]\n            current_low = self.df[\"low\"].iloc[i]\n            prev_psar = psar.iloc[i - 1]\n\n            if trend == 1:  # Uptrend\n                psar.iloc[i] = prev_psar + af * (ep - prev_psar)\n                # Check if PSAR should be below current low\n                psar.iloc[i] = min(psar.iloc[i], current_low,\n                                   self.df[\"low\"].iloc[i - 1] if i > 1 else current_low)\n                if current_high > ep:  # New extreme high\n                    ep = current_high\n                    af = min(af + acceleration, max_acceleration)\n                if current_low < psar.iloc[i]:  # Trend reversal\n                    trend = -1\n                    psar.iloc[i] = ep  # PSAR jumps to old EP\n                    ep = current_low\n                    af = acceleration\n            elif trend == -1:  # Downtrend\n                psar.iloc[i] = prev_psar + af * (ep - prev_psar)\n                # Check if PSAR should be above current high\n                psar.iloc[i] = max(psar.iloc[i], current_high,\n                                   self.df[\"high\"].iloc[i - 1] if i > 1 else current_high)\n                if current_low < ep:  # New extreme low\n                    ep = current_low\n                    af = min(af + acceleration, max_acceleration)\n                if current_high > psar.iloc[i]:  # Trend reversal\n                    trend = 1\n                    psar.iloc[i] = ep  # PSAR jumps to old EP\n                    ep = current_high\n                    af = acceleration\n        return psar\n\n    def _calculate_fve(self) -> pd.Series:\n        \"\"\"\n        Calculates a \"Fictional Value Estimate\" (FVE) by combining price, volume, and volatility.\n        This is a custom composite indicator for demonstrative purposes.\n        \"\"\"\n        if 'close' not in self.df.columns or 'volume' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'close' or 'volume' column for FVE calculation.{RESET}\")\n            return pd.Series(dtype=float)\n\n        try:\n            # Ensure enough data for calculations\n            min_data_points = max(20, self.config[\"atr_period\"])\n            if len(self.df) < min_data_points:\n                self.logger.warning(f\"{NEON_YELLOW} Insufficient data for FVE calculation. \"\n                                    f\"Need at least {min_data_points} bars.{RESET}\")\n                return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n            # Components calculation\n            price_component = self._calculate_ema(\n                window=self.config[\"indicator_periods\"][\"fve_price_ema\"])\n            obv_component = self._calculate_obv()\n            atr_component = self._calculate_atr(\n                window=self.config[\"indicator_periods\"][\"atr\"])\n\n            # Convert components to Decimal for calculations if they are not already\n            # This is crucial to avoid numpy.float64 issues with Decimal operations\n            price_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN')\n                                             for x in price_component], index=price_component.index)\n            obv_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN')\n                                           for x in obv_component], index=obv_component.index)\n            atr_component_dec = pd.Series([Decimal(str(x)) if pd.notna(x) else Decimal('NaN')\n                                           for x in atr_component], index=atr_component.index)\n\n            # Normalize components to prevent one from dominating excessively\n            # Use Decimal for mean and std calculation to maintain precision\n            price_mean = price_component_dec.mean() if pd.notna(price_component_dec.mean()) else Decimal('NaN')\n            price_std = price_component_dec.std() if pd.notna(price_component_dec.std()) else Decimal('NaN')\n            obv_mean = obv_component_dec.mean() if pd.notna(obv_component_dec.mean()) else Decimal('NaN')\n            obv_std = obv_component_dec.std() if pd.notna(obv_component_dec.std()) else Decimal('NaN')\n\n            # Handle potential division by zero for std dev\n            price_norm = (price_component_dec - price_mean) / price_std if price_std != 0 else \\\n                         pd.Series(Decimal('0'), index=self.df.index)\n            obv_norm = (obv_component_dec - obv_mean) / obv_std if obv_std != 0 else \\\n                       pd.Series(Decimal('0'), index=self.df.index)\n\n            # Inverse of ATR: lower ATR means higher stability/less volatility\n            atr_inverse = pd.Series([Decimal('1.0') / x if x and x != 0 else Decimal('NaN')\n                                     for x in atr_component_dec], index=self.df.index)\n            atr_inverse = atr_inverse.replace([Decimal('Infinity'), Decimal('-Infinity')], Decimal('NaN'))\n\n            atr_inverse_mean = atr_inverse.mean() if pd.notna(atr_inverse.mean()) else Decimal('NaN')\n            atr_inverse_std = atr_inverse.std() if pd.notna(atr_inverse.std()) else Decimal('NaN')\n\n            # Normalize ATR inverse, handling potential zero std dev\n            atr_inverse_norm = (atr_inverse - atr_inverse_mean) / atr_inverse_std if atr_inverse_std != 0 else \\\n                               pd.Series(Decimal('0'), index=self.df.index)\n\n            # Combine them - this formula is illustrative and should be fine-tuned\n            fve = price_norm.fillna(Decimal('0')) + obv_norm.fillna(Decimal('0')) + \\\n                  atr_inverse_norm.fillna(Decimal('0'))\n\n            return pd.Series([float(x) if x != Decimal('NaN') else np.nan for x in fve],\n                             index=self.df.index)\n\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED} Error calculating FVE: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_volume_confirmation(self) -> bool:\n        \"\"\"\n        Checks if the current volume confirms a trend (e.g., significant spike).\n        Returns True if current volume is significantly higher than average.\n        \"\"\"\n        if 'volume' not in self.df.columns or 'volume_ma' not in self.df.columns:\n            self.logger.error(f\"{NEON_RED} Missing 'volume' or 'volume_ma' column for \"\n                               f\"Volume Confirmation.{RESET}\")\n            return False\n        if self.df[\"volume\"].empty or self.df[\"volume_ma\"].empty:\n            return False\n\n        current_volume = self.df['volume'].iloc[-1]\n        average_volume = self.df['volume_ma'].iloc[-1]\n\n        if average_volume <= 0:\n            return False\n\n        return current_volume > average_volume * self.config[\"volume_confirmation_multiplier\"]\n\n    def analyze_order_book_walls(self, order_book: Dict[str, Any]\n                                ) -> Tuple[bool, bool, Dict[str, Decimal], Dict[str, Decimal]]:\n        \"\"\"\n        Analyzes order book for significant bid (support) and ask (resistance) walls.\n        Returns whether bullish/bearish walls are found and the wall details.\n        \"\"\"\n        has_bullish_wall = False\n        has_bearish_wall = False\n        bullish_wall_details: Dict[str, Decimal] = {}\n        bearish_wall_details: Dict[str, Decimal] = {}\n\n        if not self.config[\"order_book_analysis\"][\"enabled\"]:\n            return False, False, {}, {}\n\n        if not order_book or not order_book.get('bids') or not order_book.get('asks'):\n            self.logger.warning(f\"{NEON_YELLOW} Order book data incomplete for wall analysis.{RESET}\")\n            return False, False, {}, {}\n\n        bids = [(Decimal(price), Decimal(qty)) for price, qty in\n                order_book['bids'][:self.config[\"order_book_analysis\"][\"depth_to_check\"]]]\n        asks = [(Decimal(price), Decimal(qty)) for price, qty in\n                order_book['asks'][:self.config[\"order_book_analysis\"][\"depth_to_check\"]]]\n\n        # Calculate average quantity across relevant depth\n        all_quantities = [qty for _, qty in bids + asks]\n        if not all_quantities:\n            return False, False, {}, {}\n\n        total_qty = sum(all_quantities)\n        avg_qty = total_qty / Decimal(str(len(all_quantities)))\n        wall_threshold = avg_qty * \\\n                         Decimal(str(self.config[\"order_book_analysis\"][\"wall_threshold_multiplier\"]))\n\n        # Check for bullish walls (large bids below current price)\n        current_price = Decimal(str(self.df[\"close\"].iloc[-1]))\n        for bid_price, bid_qty in bids:\n            if bid_qty >= wall_threshold and bid_price < current_price:\n                has_bullish_wall = True\n                bullish_wall_details[f\"Bid@{bid_price}\"] = bid_qty\n                self.logger.info(f\"{NEON_GREEN} Detected Bullish Order Book Wall: \"\n                                 f\"Bid {bid_qty:.2f} at {bid_price:.2f}{RESET}\")\n                break\n\n        # Check for bearish walls (large asks above current price)\n        for ask_price, ask_qty in asks:\n            if ask_qty >= wall_threshold and ask_price > current_price:\n                has_bearish_wall = True\n                bearish_wall_details[f\"Ask@{ask_price}\"] = ask_qty\n                self.logger.info(f\"{NEON_RED} Detected Bearish Order Book Wall: \"\n                                 f\"Ask {ask_qty:.2f} at {ask_price:.2f}{RESET}\")\n                break\n\n        return has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details\n\n    # --- Ehlers Indicators ---\n\n    def _calculate_ehlers_fisher_transform(self, period: int = 10) -> pd.Series:\n        \"\"\"Calculates the Ehlers Fisher Transform.\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Fisher Transform \"\n                                f\"(need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            median_price = (self.df['high'] + self.df['low']) / 2\n            fisher = pd.Series(np.nan, index=self.df.index, dtype=float)\n            v_prev = 0.0 # Initialize v_prev for recursive calculation\n\n            for i in range(period - 1, len(self.df)):\n                min_low = median_price.iloc[i - period + 1 : i + 1].min()\n                max_high = median_price.iloc[i - period + 1 : i + 1].max()\n                current_median = median_price.iloc[i]\n\n                range_val = max_high - min_low\n                if range_val == 0:\n                    v = v_prev # Carry forward previous v if range is zero\n                else:\n                    # Scale price to -1 to +1 range\n                    v = 0.33 * 2 * ((current_median - min_low) / range_val - 0.5) + 0.67 * v_prev\n                \n                # Clip to avoid log(0) or log(negative)\n                v = np.clip(v, -0.999, 0.999)\n\n                if i == period - 1: # First valid calculation\n                    fisher.iloc[i] = 0.5 * np.log((1 + v) / (1 - v))\n                else:\n                    fisher.iloc[i] = 0.5 * np.log((1 + v) / (1 - v)) + 0.5 * fisher.iloc[i-1]\n                \n                v_prev = v # Update v_prev for next iteration\n\n            return fisher.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Fisher Transform: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_stochastic_rsi(self, rsi_period: int = 14, stoch_period: int = 14,\n                                         k_period: int = 3, d_period: int = 3) -> pd.DataFrame:\n        \"\"\"Calculates Ehlers' version of Stochastic RSI.\"\"\"\n        if len(self.df) < rsi_period + stoch_period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Stochastic RSI \"\n                                f\"(need {rsi_period + stoch_period} bars).{RESET}\")\n            return pd.DataFrame()\n        try:\n            rsi = self._calculate_rsi(window=rsi_period)\n            if rsi.empty: return pd.DataFrame()\n\n            lowest_rsi = rsi.rolling(window=stoch_period).min()\n            highest_rsi = rsi.rolling(window=stoch_period).max()\n\n            # Avoid division by zero\n            denominator = (highest_rsi - lowest_rsi)\n            denominator = denominator.replace(0, np.nan)\n\n            stoch_rsi_raw = (rsi - lowest_rsi) / denominator\n            stoch_rsi_raw = stoch_rsi_raw.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n            k_line = self._calculate_ema(k_period, series=stoch_rsi_raw) * 100\n            d_line = self._calculate_ema(d_period, series=k_line)\n            return pd.DataFrame({'k': k_line, 'd': d_line}).fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Stochastic RSI: {e}{RESET}\")\n            return pd.DataFrame()\n\n    def _calculate_ehlers_optimal_moving_average(self, period: int = 10) -> pd.Series:\n        \"\"\"\n        Calculates Ehlers' Optimal Moving Average (OMA).\n        NOTE: This is a simplified EMA-based proxy for demonstration.\n        A true Ehlers OMA involves more complex filter design to minimize lag and overshoot.\n        \"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Optimal Moving Average \"\n                                f\"(need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # For demonstration, we'll use a simple EMA as a proxy.\n            oma = self._calculate_ema(period)\n            return oma.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Optimal Moving Average: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_super_smoother_filter(self, period: int = 10, poles: int = 2) -> pd.Series:\n        \"\"\"Calculates Ehlers' Super Smoother Filter.\"\"\"\n        if len(self.df) < 2 * period: # Need enough data for filter warm-up\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Super Smoother Filter \"\n                                f\"(need {2 * period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            if poles == 2:\n                a = np.exp(-np.pi * np.sqrt(2) / period)\n                b = 2 * a * np.cos(np.sqrt(2) * np.pi / period)\n                \n                # Coefficients for 2-pole Super Smoother\n                # Denominator coefficients: [1, -b, a*a]\n                # Numerator coefficients: [1 - b + a*a]\n                b_coeffs = [1 - b + a*a]\n                a_coeffs = [1, -b, a*a]\n                \n                # Apply filter\n                y = scipy.signal.lfilter(b_coeffs, a_coeffs, self.df['close'].values)\n            elif poles == 3:\n                self.logger.warning(f\"{NEON_YELLOW}3-pole Super Smoother not fully implemented, \"\n                                    f\"returning NaN. Only 2-pole is supported.{RESET}\")\n                return pd.Series([np.nan] * len(self.df), index=self.df.index)\n            else:\n                self.logger.warning(f\"{NEON_YELLOW}Unsupported number of poles for Super Smoother: \"\n                                    f\"{poles}. Returning NaN.{RESET}\")\n                return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n            ssf = pd.Series(y, index=self.df.index)\n            return ssf.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Super Smoother Filter: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_adaptive_moving_average(self, period: int = 10,\n                                                  fast_alpha: float = 0.5,\n                                                  slow_alpha: float = 0.05) -> pd.Series:\n        \"\"\"Calculates Ehlers' Adaptive Moving Average (AMA).\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Adaptive Moving Average \"\n                                f\"(need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # Efficiency Ratio (ER)\n            change = abs(self.df['close'].diff(period))\n            volatility = self.df['close'].diff().abs().rolling(window=period).sum()\n            \n            # Avoid division by zero for ER\n            er = change / volatility.replace(0, np.nan)\n            er = er.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n            # Smoothing constant (SC)\n            sc = (er * (fast_alpha - slow_alpha) + slow_alpha) ** 2\n\n            ama = pd.Series(index=self.df.index, dtype=float)\n            # Initialize AMA with the first valid close price\n            ama.iloc[period-1] = self.df['close'].iloc[period-1]\n\n            for i in range(period, len(self.df)):\n                if pd.notna(sc.iloc[i]) and pd.notna(ama.iloc[i-1]):\n                    ama.iloc[i] = ama.iloc[i-1] + sc.iloc[i] * (self.df['close'].iloc[i] - ama.iloc[i-1])\n                else:\n                    # If sc or previous ama is NaN, carry forward previous ama or set NaN\n                    ama.iloc[i] = ama.iloc[i-1] if i > 0 else np.nan\n\n            return ama.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Adaptive Moving Average: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_correlation_cycle_indicator(self, period: int = 20) -> pd.Series:\n        \"\"\"Calculates Ehlers' Correlation Cycle Indicator (CCI).\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Correlation Cycle Indicator \"\n                                f\"(need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # Define a sine wave for correlation\n            sine_wave = np.sin(2 * np.pi * np.arange(period) / period)\n            \n            cci_series = pd.Series(index=self.df.index, dtype=float)\n            for i in range(period - 1, len(self.df)):\n                price_segment = self.df['close'].iloc[i - period + 1 : i + 1].values\n                if len(price_segment) == period:\n                    # Pearson correlation coefficient\n                    corr, _ = scipy.stats.pearsonr(price_segment, sine_wave)\n                    cci_series.iloc[i] = corr\n                else:\n                    cci_series.iloc[i] = np.nan\n\n            return cci_series.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Correlation Cycle Indicator: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_decycler(self, period: int = 20) -> pd.Series:\n        \"\"\"\n        Calculates Ehlers' Decycler.\n        This is a simplified implementation using the Super Smoother Filter as a low-pass filter\n        to extract the trend, then subtracting it from price to get the cycle.\n        A more accurate implementation would use a specific high-pass filter.\n        \"\"\"\n        if len(self.df) < period * 2: # SSF needs more data\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Decycler \"\n                                f\"(need {period * 2} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            smoothed_price = self._calculate_ehlers_super_smoother_filter(period=period, poles=2)\n            decycler = self.df['close'] - smoothed_price\n            return decycler.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Decycler: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_bandpass_filter(self, period: int = 20) -> pd.Series:\n        \"\"\"\n        Calculates Ehlers' Bandpass Filter.\n        NOTE: This is a placeholder implementation using the difference of two EMAs.\n        A true Ehlers Bandpass Filter requires specific filter coefficient calculations\n        (e.g., using scipy.signal.butter and scipy.signal.filtfilt) to isolate a specific cycle.\n        \"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Bandpass Filter \"\n                                f\"(need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            # Placeholder: a simple difference of two EMAs to approximate a bandpass\n            ema_short = self._calculate_ema(period // 2)\n            ema_long = self._calculate_ema(period)\n            bandpass = ema_short - ema_long\n            return bandpass.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Bandpass Filter: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n    def _calculate_ehlers_center_of_gravity(self, period: int = 10) -> pd.Series:\n        \"\"\"Calculates Ehlers' Center of Gravity (COG) indicator.\"\"\"\n        if len(self.df) < period:\n            self.logger.warning(f\"{NEON_YELLOW}Insufficient data for Ehlers Center of Gravity \"\n                                f\"(need {period} bars).{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n        try:\n            cog = pd.Series(index=self.df.index, dtype=float)\n            for i in range(period - 1, len(self.df)):\n                segment = self.df['close'].iloc[i - period + 1 : i + 1]\n                numerator = sum(j * segment.iloc[j] for j in range(period))\n                denominator = sum(segment)\n                if denominator != 0:\n                    cog.iloc[i] = -numerator / denominator\n                else:\n                    cog.iloc[i] = np.nan\n            return cog.fillna(method='bfill').fillna(method='ffill')\n        except Exception as e:\n            self.logger.error(f\"{NEON_RED}Error calculating Ehlers Center of Gravity: {e}{RESET}\")\n            return pd.Series([np.nan] * len(self.df), index=self.df.index)\n\n\n    def _calculate_all_indicators(self):\n        \"\"\"Calculates and stores all enabled indicators for the current cycle.\"\"\"\n        # Pre-calculate ATR and momentum MAs first, as they are used for weight selection and trend\n        atr_series = self._calculate_atr(window=self.config[\"atr_period\"])\n        if not atr_series.empty and not pd.isna(atr_series.iloc[-1]):\n            self.atr_value = float(atr_series.iloc[-1])\n        else:\n            self.atr_value = 0.0\n        self.indicator_values[\"atr\"] = self.atr_value\n\n        self._calculate_momentum_ma() # Populates momentum and its MAs, and volume MA\n\n        # Now that ATR is potentially calculated, select the weight set\n        self.user_defined_weights = self._select_weight_set()\n\n        # Calculate and store other indicator values based on config\n        if self.config[\"indicators\"].get(\"obv\"):\n            obv_series = self._calculate_obv()\n            self.indicator_values[\"obv\"] = obv_series.iloc[-3:].tolist() \\\n                if not obv_series.empty else []\n        if self.config[\"indicators\"].get(\"rsi\"):\n            rsi_series = self._calculate_rsi(window=self.config[\"indicator_periods\"][\"rsi\"])\n            self.indicator_values[\"rsi\"] = rsi_series.iloc[-3:].tolist() \\\n                if not rsi_series.empty else []\n        if self.config[\"indicators\"].get(\"mfi\"):\n            mfi_series = self._calculate_mfi(window=self.config[\"indicator_periods\"][\"mfi\"])\n            self.indicator_values[\"mfi\"] = mfi_series.iloc[-3:].tolist() \\\n                if not mfi_series.empty else []\n        if self.config[\"indicators\"].get(\"cci\"):\n            cci_series = self._calculate_cci(window=self.config[\"indicator_periods\"][\"cci\"])\n            self.indicator_values[\"cci\"] = cci_series.iloc[-3:].tolist() \\\n                if not cci_series.empty else []\n        if self.config[\"indicators\"].get(\"wr\"):\n            wr_series = self._calculate_williams_r(window=self.config[\"indicator_periods\"][\"wr\"])\n            self.indicator_values[\"wr\"] = wr_series.iloc[-3:].tolist() \\\n                if not wr_series.empty else []\n        if self.config[\"indicators\"].get(\"adx\"):\n            adx_value = self._calculate_adx(window=self.config[\"indicator_periods\"][\"adx\"])\n            self.indicator_values[\"adx\"] = [adx_value]\n        if self.config[\"indicators\"].get(\"adi\"):\n            adi_series = self._calculate_adi()\n            self.indicator_values[\"adi\"] = adi_series.iloc[-3:].tolist() \\\n                if not adi_series.empty else []\n        if self.config[\"indicators\"].get(\"momentum\"):\n            trend_data = self.determine_trend_momentum()\n            self.indicator_values[\"mom\"] = trend_data\n        if self.config[\"indicators\"].get(\"sma_10\"):\n            sma_series = self._calculate_sma(10)\n            self.indicator_values[\"sma_10\"] = [sma_series.iloc[-1]] \\\n                if not sma_series.empty else []\n        if self.config[\"indicators\"].get(\"psar\"):\n            psar_series = self._calculate_psar()\n            self.indicator_values[\"psar\"] = psar_series.iloc[-3:].tolist() \\\n                if not psar_series.empty else []\n        if self.config[\"indicators\"].get(\"fve\"):\n            fve_series = self._calculate_fve()\n            if not fve_series.empty and not fve_series.isnull().all():\n                self.indicator_values[\"fve\"] = fve_series.iloc[-3:].tolist()\n            else:\n                self.indicator_values[\"fve\"] = []\n        if self.config[\"indicators\"].get(\"macd\"):\n            macd_df = self._calculate_macd()\n            self.indicator_values[\"macd\"] = macd_df.iloc[-3:].values.tolist() \\\n                if not macd_df.empty else []\n        if self.config[\"indicators\"].get(\"ema_alignment\"):\n            ema_alignment_score = self._calculate_ema_alignment()\n            self.indicator_values[\"ema_alignment\"] = ema_alignment_score\n        if self.config[\"indicators\"].get(\"stoch_rsi\"):\n            stoch_rsi_vals = self._calculate_stoch_rsi(\n                rsi_window=self.config[\"indicator_periods\"][\"stoch_rsi_period\"],\n                stoch_window=self.config[\"indicator_periods\"][\"stoch_rsi_period\"],\n                k_window=self.config[\"indicator_periods\"][\"stoch_rsi_k_period\"],\n                d_window=self.config[\"indicator_periods\"][\"stoch_rsi_d_period\"]\n            )\n            self.indicator_values[\"stoch_rsi_vals\"] = stoch_rsi_vals\n        if self.config[\"indicators\"].get(\"stochastic_oscillator\"):\n            stoch_osc_vals = self._calculate_stochastic_oscillator()\n            self.indicator_values[\"stoch_osc_vals\"] = stoch_osc_vals\n\n        # --- Ehlers Indicators Calculation ---\n        if self.config[\"indicators\"].get(\"ehlers_fisher_transform\"):\n            fisher_series = self._calculate_ehlers_fisher_transform(\n                period=self.config[\"indicator_periods\"][\"ehlers_fisher_period\"])\n            self.indicator_values[\"ehlers_fisher\"] = [fisher_series.iloc[-1]] \\\n                if not fisher_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_stochastic_rsi\"):\n            ehlers_stoch_rsi_vals = self._calculate_ehlers_stochastic_rsi(\n                rsi_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_period\"],\n                stoch_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_period\"],\n                k_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_k_period\"],\n                d_period=self.config[\"indicator_periods\"][\"ehlers_stoch_rsi_d_period\"]\n            )\n            self.indicator_values[\"ehlers_stoch_rsi_vals\"] = ehlers_stoch_rsi_vals\n        if self.config[\"indicators\"].get(\"ehlers_optimal_moving_average\"):\n            oma_series = self._calculate_ehlers_optimal_moving_average(\n                period=self.config[\"indicator_periods\"][\"ehlers_oma_period\"])\n            self.indicator_values[\"ehlers_oma\"] = [oma_series.iloc[-1]] \\\n                if not oma_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_super_smoother_filter\"):\n            ssf_series = self._calculate_ehlers_super_smoother_filter(\n                period=self.config[\"indicator_periods\"][\"ehlers_ssf_period\"],\n                poles=self.config[\"indicator_periods\"][\"ehlers_ssf_poles\"]\n            )\n            self.indicator_values[\"ehlers_ssf\"] = [ssf_series.iloc[-1]] \\\n                if not ssf_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_adaptive_moving_average\"):\n            ama_series = self._calculate_ehlers_adaptive_moving_average(\n                period=self.config[\"indicator_periods\"][\"ehlers_ama_period\"],\n                fast_alpha=self.config[\"indicator_periods\"][\"ehlers_ama_fast_alpha\"],\n                slow_alpha=self.config[\"indicator_periods\"][\"ehlers_ama_slow_alpha\"]\n            )\n            self.indicator_values[\"ehlers_ama\"] = [ama_series.iloc[-1]] \\\n                if not ama_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_correlation_cycle_indicator\"):\n            cci_ehlers_series = self._calculate_ehlers_correlation_cycle_indicator(\n                period=self.config[\"indicator_periods\"][\"ehlers_cci_period\"])\n            self.indicator_values[\"ehlers_cci_cycle\"] = [cci_ehlers_series.iloc[-1]] \\\n                if not cci_ehlers_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_decycler\"):\n            decycler_series = self._calculate_ehlers_decycler(\n                period=self.config[\"indicator_periods\"][\"ehlers_decycler_period\"])\n            self.indicator_values[\"ehlers_decycler\"] = [decycler_series.iloc[-1]] \\\n                if not decycler_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_bandpass_filter\"):\n            bandpass_series = self._calculate_ehlers_bandpass_filter(\n                period=self.config[\"indicator_periods\"][\"ehlers_bandpass_period\"])\n            self.indicator_values[\"ehlers_bandpass\"] = [bandpass_series.iloc[-1]] \\\n                if not bandpass_series.empty else []\n        if self.config[\"indicators\"].get(\"ehlers_center_of_gravity\"):\n            cog_series = self._calculate_ehlers_center_of_gravity(\n                period=self.config[\"indicator_periods\"][\"ehlers_cog_period\"])\n            self.indicator_values[\"ehlers_cog\"] = [cog_series.iloc[-1]] \\\n                if not cog_series.empty else []\n\n\n    def _select_weight_set(self) -> Dict[str, float]:\n        \"\"\"\n        Selects a weight set (e.g., low_volatility, high_volatility) based on current ATR.\n        \"\"\"\n        # Use the atr_value that was pre-calculated in _calculate_all_indicators\n        if self.atr_value > self.config[\"atr_change_threshold\"]:\n            self.logger.info(f\"{NEON_YELLOW} Market detected as HIGH VOLATILITY \"\n                             f\"(ATR: {self.atr_value:.4f}). Using 'high_volatility' \"\n                             f\"weights.{RESET}\")\n            return self.weight_sets.get(\"high_volatility\", self.weight_sets[\"low_volatility\"])\n        self.logger.info(f\"{NEON_BLUE} Market detected as LOW VOLATILITY \"\n                         f\"(ATR: {self.atr_value:.4f}). Using 'low_volatility' \"\n                         f\"weights.{RESET}\")\n        return self.weight_sets[\"low_volatility\"]\n\n    def analyze(self, current_price: Decimal, timestamp: str, order_book: Dict[str, Any]):\n        \"\"\"\n        Performs comprehensive analysis, calculates indicators, and logs the findings.\n        This method populates `self.indicator_values` and generates the output string.\n        It does NOT generate the final signal; that is done by `generate_trading_signal`.\n        \"\"\"\n        # Ensure Decimal type for price calculations\n        current_price_dec = current_price\n        high_dec = Decimal(str(self.df[\"high\"].max()))\n        low_dec = Decimal(str(self.df[\"low\"].min()))\n        close_dec = Decimal(str(self.df[\"close\"].iloc[-1]))\n\n        # Calculate all indicators for the current cycle\n        self._calculate_all_indicators()\n\n        # Calculate Support/Resistance Levels\n        self.calculate_fibonacci_retracement(high_dec, low_dec, current_price_dec)\n        self.calculate_pivot_points(high_dec, low_dec, close_dec)\n        nearest_supports, nearest_resistances = self.find_nearest_levels(current_price_dec)\n\n        # Order Book Analysis\n        has_bullish_wall, has_bearish_wall, bullish_wall_details, bearish_wall_details = \\\n            self.analyze_order_book_walls(order_book)\n        self.indicator_values[\"order_book_walls\"] = {\n            \"bullish\": has_bullish_wall, \"bearish\": has_bearish_wall,\n            \"bullish_details\": bullish_wall_details, \"bearish_details\": bearish_wall_details\n        }\n\n        # Prepare output string\n        output = f\"\"\"\n{NEON_BLUE}Exchange:{RESET} Bybit\n{NEON_BLUE}Symbol:{RESET} {self.symbol}\n{NEON_BLUE}Interval:{RESET} {self.interval}\n{NEON_BLUE}Timestamp:{RESET} {timestamp}\n{NEON_BLUE}Price History:{RESET} {self.df['close'].iloc[-3]:.2f} | {self.df['close'].iloc[-2]:.2f} | {self.df['close'].iloc[-1]:.2f}\n{NEON_BLUE}Volume History:{RESET} {self.df['volume'].iloc[-3]:,.0f} | {self.df['volume'].iloc[-2]:,.0f} | {self.df['volume'].iloc[-1]:,.0f}\n{NEON_BLUE}Current Price:{RESET} {current_price_dec:.5f}\n{NEON_BLUE}ATR ({self.config['atr_period']}):{RESET} {self.atr_value:.5f}\n\"\"\"\n        # Append indicator interpretations\n        for indicator_name, values in self.indicator_values.items():\n            # Skip indicators that are already logged in a custom format or are internal\n            if indicator_name in [\"order_book_walls\", \"atr\"]:\n                continue\n            interpreted_line = interpret_indicator(self.logger, indicator_name, values)\n            if interpreted_line:\n                output += interpreted_line + \"\\n\"\n\n        # Order Book Wall Logging\n        output += f\"\"\"\n{NEON_BLUE}Order Book Walls:{RESET}\n\"\"\"\n        if has_bullish_wall:\n            output += (f\"{NEON_GREEN}  Bullish Walls Found:{RESET} \"\n                       f\"{', '.join([f'{k}: {v:.2f}' for k, v in bullish_wall_details.items()])}\\n\")\n        if has_bearish_wall:\n            output += (f\"{NEON_RED}  Bearish Walls Found:{RESET} \"\n                       f\"{', '.join([f'{k}: {v:.2f}' for k, v in bearish_wall_details.items()])}\\n\")\n        if not has_bullish_wall and not has_bearish_wall:\n            output += \"  No significant walls detected.\\n\"\n\n        output += f\"\"\"\n{NEON_BLUE}Support and Resistance Levels:{RESET}\n\"\"\"\n        for s_label, s_val in nearest_supports:\n            output += f\"S: {s_label} ${s_val:.5f}\\n\"\n        for r_label, r_val in nearest_resistances:\n            output += f\"R: {r_label} ${r_val:.5f}\\n\"\n\n        self.logger.info(output)\n\n    def generate_trading_signal(self, current_price: Decimal\n                               ) -> Tuple[Union[str, None], float, List[str], Dict[str, Decimal]]:\n        \"\"\"\n        Generates a trading signal (buy/sell) based on indicator values and configuration.\n        Returns the signal, its confidence score, conditions met, and suggested SL/TP levels.\n        \"\"\"\n        signal_score = Decimal('0.0')\n        signal = None\n        conditions_met: List[str] = []\n        trade_levels: Dict[str, Decimal] = {}\n\n        # --- Bullish Signal Logic ---\n        # Sum weights of bullish conditions met\n        if self.config[\"indicators\"].get(\"stoch_rsi\") and \\\n           not self.indicator_values[\"stoch_rsi_vals\"].empty:\n            stoch_rsi_k = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['k'].iloc[-1]))\n            stoch_rsi_d = Decimal(str(self.indicator_values[\"stoch_rsi_vals']d'].iloc[-1]))\n            if stoch_rsi_k < self.config[\"stoch_rsi_oversold_threshold\"] and \\\n               stoch_rsi_k > stoch_rsi_d:\n                signal_score += Decimal(str(self.user_defined_weights[\"stoch_rsi\"]))\n                signal_score += Decimal(str(self.config[\"stoch_rsi_confidence_boost\"]))\n                conditions_met.append(\"Stoch RSI Oversold Crossover\")\n\n        if self.config[\"indicators\"].get(\"rsi\") and self.indicator_values.get(\"rsi\") and \\\n           self.indicator_values[\"rsi\"][-1] < 30:\n            signal_score += Decimal(str(self.user_defined_weights[\"rsi\"]))\n            signal_score += Decimal(str(self.config[\"rsi_confidence_boost\"]))\n            conditions_met.append(\"RSI Oversold\")\n\n        if self.config[\"indicators\"].get(\"mfi\") and self.indicator_values.get(\"mfi\") and \\\n           self.indicator_values[\"mfi\"][-1] < 20:\n            signal_score += Decimal(str(self.user_defined_weights[\"mfi\"]))\n            signal_score += Decimal(str(self.config[\"mfi_confidence_boost\"]))\n            conditions_met.append(\"MFI Oversold\")\n\n        if self.config[\"indicators\"].get(\"ema_alignment\") and \\\n           self.indicator_values.get(\"ema_alignment\", 0.0) > 0:\n            signal_score += Decimal(str(self.user_defined_weights[\"ema_alignment\"])) * \\\n                            Decimal(str(abs(self.indicator_values[\"ema_alignment\"])))\n            conditions_met.append(\"Bullish EMA Alignment\")\n\n        if self.config[\"indicators\"].get(\"volume_confirmation\") and \\\n           self._calculate_volume_confirmation():\n            signal_score += Decimal(str(self.user_defined_weights[\"volume_confirmation\"]))\n            conditions_met.append(\"Volume Confirmation\")\n\n        if self.config[\"indicators\"].get(\"divergence\") and \\\n           self.detect_macd_divergence() == \"bullish\":\n            signal_score += Decimal(str(self.user_defined_weights[\"divergence\"]))\n            conditions_met.append(\"Bullish MACD Divergence\")\n\n        if self.indicator_values[\"order_book_walls\"].get(\"bullish\"):\n            signal_score += Decimal(str(self.config[\"order_book_support_confidence_boost\"]))\n            conditions_met.append(\"Bullish Order Book Wall\")\n\n        # --- New: Stochastic Oscillator Bullish Signal ---\n        if self.config[\"indicators\"].get(\"stochastic_oscillator\") and \\\n           self.indicator_values.get(\"stoch_osc_vals\") is not None and \\\n           not self.indicator_values[\"stoch_osc_vals\"].empty:\n            stoch_k = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['k'].iloc[-1]))\n            stoch_d = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['d'].iloc[-1]))\n            if stoch_k < 20 and stoch_k > stoch_d:\n                signal_score += Decimal(str(self.user_defined_weights[\"stochastic_oscillator\"]))\n                conditions_met.append(\"Stoch Oscillator Oversold Crossover\")\n        \n        # --- Ehlers Indicators Bullish Signal Logic (PLACEHOLDERS - CUSTOMIZE HEAVILY) ---\n        if self.config[\"indicators\"].get(\"ehlers_fisher_transform\") and \\\n           self.indicator_values.get(\"ehlers_fisher\") and \\\n           self.indicator_values[\"ehlers_fisher\"][-1] > 1.5: # Example threshold\n            signal_score += Decimal(str(self.user_defined_weights[\"ehlers_fisher_transform\"]))\n            conditions_met.append(\"Ehlers Fisher Transform Bullish\")\n\n        if self.config[\"indicators\"].get(\"ehlers_stochastic_rsi\") and \\\n           not self.indicator_values[\"ehlers_stoch_rsi_vals\"].empty:\n            ehlers_stoch_rsi_k = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['k'].iloc[-1]))\n            ehlers_stoch_rsi_d = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['d'].iloc[-1]))\n            if ehlers_stoch_rsi_k < 20 and ehlers_stoch_rsi_k > ehlers_stoch_rsi_d:\n                signal_score += Decimal(str(self.user_defined_weights[\"ehlers_stoch_rsi\"]))\n                conditions_met.append(\"Ehlers Stoch RSI Oversold Crossover\")\n        \n        # Add more Ehlers indicator bullish logic here based on your strategy\n        # Example: if self.config[\"indicators\"].get(\"ehlers_optimal_moving_average\") and\n        #            self.indicator_values.get(\"ehlers_oma\") and\n        #            current_price > Decimal(str(self.indicator_values[\"ehlers_oma\"][-1])):\n        #     signal_score += Decimal(str(self.user_defined_weights[\"ehlers_optimal_moving_average\"]))\n        #     conditions_met.append(\"Ehlers OMA Bullish\")\n\n\n        # Final check for Bullish signal\n        if signal_score >= Decimal(str(self.config[\"signal_score_threshold\"])):\n            signal = \"buy\"\n            # Calculate Stop Loss and Take Profit\n            if self.atr_value > 0:\n                stop_loss = current_price - (Decimal(str(self.atr_value)) *\n                                             Decimal(str(self.config[\"stop_loss_multiple\"])))\n                take_profit = current_price + (Decimal(str(self.atr_value)) *\n                                               Decimal(str(self.config[\"take_profit_multiple\"])))\n                trade_levels[\"stop_loss\"] = stop_loss.quantize(Decimal('0.00001'))\n                trade_levels[\"take_profit\"] = take_profit.quantize(Decimal('0.00001'))\n\n        # --- Bearish Signal Logic (similar structure) ---\n        bearish_score = Decimal('0.0')\n        bearish_conditions: List[str] = []\n\n        if self.config[\"indicators\"].get(\"stoch_rsi\") and \\\n           not self.indicator_values[\"stoch_rsi_vals\"].empty:\n            stoch_rsi_k = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['k'].iloc[-1]))\n            stoch_rsi_d = Decimal(str(self.indicator_values[\"stoch_rsi_vals\"]['d'].iloc[-1]))\n            if stoch_rsi_k > self.config[\"stoch_rsi_overbought_threshold\"] and \\\n               stoch_rsi_k < stoch_rsi_d:\n                bearish_score += Decimal(str(self.user_defined_weights[\"stoch_rsi\"]))\n                bearish_score += Decimal(str(self.config[\"stoch_rsi_confidence_boost\"]))\n                bearish_conditions.append(\"Stoch RSI Overbought Crossover\")\n\n        if self.config[\"indicators\"].get(\"rsi\") and self.indicator_values.get(\"rsi\") and \\\n           self.indicator_values[\"rsi\"][-1] > 70:\n            bearish_score += Decimal(str(self.user_defined_weights[\"rsi\"]))\n            bearish_score += Decimal(str(self.config[\"rsi_confidence_boost\"]))\n            bearish_conditions.append(\"RSI Overbought\")\n\n        if self.config[\"indicators\"].get(\"mfi\") and self.indicator_values.get(\"mfi\") and \\\n           self.indicator_values[\"mfi\"][-1] > 80:\n            bearish_score += Decimal(str(self.user_defined_weights[\"mfi\"]))\n            bearish_score += Decimal(str(self.config[\"mfi_confidence_boost\"]))\n            bearish_conditions.append(\"MFI Overbought\")\n\n        if self.config[\"indicators\"].get(\"ema_alignment\") and \\\n           self.indicator_values.get(\"ema_alignment\", 0.0) < 0:\n            bearish_score += Decimal(str(self.user_defined_weights[\"ema_alignment\"])) * \\\n                             Decimal(str(abs(self.indicator_values[\"ema_alignment\"])))\n            bearish_conditions.append(\"Bearish EMA Alignment\")\n\n        if self.config[\"indicators\"].get(\"divergence\") and \\\n           self.detect_macd_divergence() == \"bearish\":\n            bearish_score += Decimal(str(self.user_defined_weights[\"divergence\"]))\n            bearish_conditions.append(\"Bearish MACD Divergence\")\n\n        if self.indicator_values[\"order_book_walls\"].get(\"bearish\"):\n            bearish_score += Decimal(str(self.config[\"order_book_resistance_confidence_boost\"]))\n            bearish_conditions.append(\"Bearish Order Book Wall\")\n\n        # --- New: Stochastic Oscillator Bearish Signal ---\n        if self.config[\"indicators\"].get(\"stochastic_oscillator\") and \\\n           self.indicator_values.get(\"stoch_osc_vals\") is not None and \\\n           not self.indicator_values[\"stoch_osc_vals\"].empty:\n            stoch_k = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['k'].iloc[-1]))\n            stoch_d = Decimal(str(self.indicator_values[\"stoch_osc_vals\"]['d'].iloc[-1]))\n            if stoch_k > 80 and stoch_k < stoch_d:\n                bearish_score += Decimal(str(self.user_defined_weights[\"stochastic_oscillator\"]))\n                bearish_conditions.append(\"Stoch Oscillator Overbought Crossover\")\n\n        # --- Ehlers Indicators Bearish Signal Logic (PLACEHOLDERS - CUSTOMIZE HEAVILY) ---\n        if self.config[\"indicators\"].get(\"ehlers_fisher_transform\") and \\\n           self.indicator_values.get(\"ehlers_fisher\") and \\\n           self.indicator_values[\"ehlers_fisher\"][-1] < -1.5: # Example threshold\n            bearish_score += Decimal(str(self.user_defined_weights[\"ehlers_fisher_transform\"]))\n            bearish_conditions.append(\"Ehlers Fisher Transform Bearish\")\n\n        if self.config[\"indicators\"].get(\"ehlers_stochastic_rsi\") and \\\n           not self.indicator_values[\"ehlers_stoch_rsi_vals\"].empty:\n            ehlers_stoch_rsi_k = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['k'].iloc[-1]))\n            ehlers_stoch_rsi_d = Decimal(str(self.indicator_values[\"ehlers_stoch_rsi_vals\"]['d'].iloc[-1]))\n            if ehlers_stoch_rsi_k > 80 and ehlers_stoch_rsi_k < ehlers_stoch_rsi_d:\n                bearish_score += Decimal(str(self.user_defined_weights[\"ehlers_stoch_rsi\"]))\n                bearish_conditions.append(\"Ehlers Stoch RSI Overbought Crossover\")\n\n        # Add more Ehlers indicator bearish logic here based on your strategy\n        # Example: if self.config[\"indicators\"].get(\"ehlers_optimal_moving_average\") and\n        #            self.indicator_values.get(\"ehlers_oma\") and\n        #            current_price < Decimal(str(self.indicator_values[\"ehlers_oma\"][-1])):\n        #     bearish_score += Decimal(str(self.user_defined_weights[\"ehlers_optimal_moving_average\"]))\n        #     bearish_conditions.append(\"Ehlers OMA Bearish\")\n\n\n        # Final check for Bearish signal (only if no bullish signal already)\n        if signal is None and bearish_score >= Decimal(str(self.config[\"signal_score_threshold\"])):\n            signal = \"sell\"\n            signal_score = bearish_score\n            conditions_met = bearish_conditions\n            # Calculate Stop Loss and Take Profit for sell signal\n            if self.atr_value > 0:\n                stop_loss = current_price + (Decimal(str(self.atr_value)) *\n                                             Decimal(str(self.config[\"stop_loss_multiple\"])))\n                take_profit = current_price - (Decimal(str(self.atr_value)) *\n                                               Decimal(str(self.config[\"take_profit_multiple\"])))\n                trade_levels[\"stop_loss\"] = stop_loss.quantize(Decimal('0.00001'))\n                trade_levels[\"take_profit\"] = take_profit.quantize(Decimal('0.00001'))\n\n        return signal, float(signal_score), conditions_met, trade_levels\n\n\ndef interpret_indicator(logger: logging.Logger, indicator_name: str,\n                        values: Union[List[float], float, Dict[str, Any], pd.DataFrame]\n                       ) -> Union[str, None]:\n    \"\"\"\n    Provides a human-readable interpretation of indicator values with color coding.\n    \"\"\"\n    if values is None or (isinstance(values, list) and not values) or \\\n       (isinstance(values, pd.DataFrame) and values.empty):\n        return f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} No data available.\"\n    try:\n        # Handle DataFrame-based indicators first\n        if indicator_name == \"stoch_rsi_vals\":\n            if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:\n                stoch_rsi_k = values['k'].iloc[-1]\n                stoch_rsi_d = values['d'].iloc[-1]\n                stoch_rsi_val = values['stoch_rsi'].iloc[-1]\n                k_color = NEON_YELLOW\n                d_color = NEON_YELLOW\n                stoch_rsi_color = NEON_YELLOW\n\n                # Check for oversold/overbought and crossovers\n                if stoch_rsi_k < CONFIG[\"stoch_rsi_oversold_threshold\"] and \\\n                   stoch_rsi_k > stoch_rsi_d:\n                    k_color = NEON_GREEN\n                    stoch_rsi_color = NEON_GREEN\n                elif stoch_rsi_k > CONFIG[\"stoch_rsi_overbought_threshold\"] and \\\n                     stoch_rsi_k < stoch_rsi_d:\n                    k_color = NEON_RED\n                    stoch_rsi_color = NEON_RED\n\n                return (f\"{NEON_GREEN}Stoch RSI:{RESET} K={k_color}{stoch_rsi_k:.2f}{RESET}, \"\n                        f\"D={d_color}{stoch_rsi_d:.2f}{RESET}, \"\n                        f\"Stoch_RSI={stoch_rsi_color}{stoch_rsi_val:.2f}{RESET}\")\n            else:\n                return f\"{NEON_YELLOW}Stoch RSI:{RESET} No data available.\"\n\n        if indicator_name == \"stoch_osc_vals\":\n            if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:\n                stoch_k = values['k'].iloc[-1]\n                stoch_d = values['d'].iloc[-1]\n                k_color = NEON_YELLOW\n                d_color = NEON_YELLOW\n\n                # Check for oversold/overbought and crossovers\n                if stoch_k < 20 and stoch_k > stoch_d:\n                    k_color = NEON_GREEN\n                elif stoch_k > 80 and stoch_k < stoch_d:\n                    k_color = NEON_RED\n\n                return (f\"{NEON_CYAN}Stochastic Oscillator:{RESET} K={k_color}{stoch_k:.2f}{RESET}, \"\n                        f\"D={d_color}{stoch_d:.2f}{RESET}\")\n            else:\n                return f\"{NEON_YELLOW}Stochastic Oscillator:{RESET} No data available.\"\n        \n        # --- Ehlers Indicator Interpretations ---\n        if indicator_name == \"ehlers_stoch_rsi_vals\":\n            if isinstance(values, pd.DataFrame) and not values.empty and len(values) >= 1:\n                k = values['k'].iloc[-1]\n                d = values['d'].iloc[-1]\n                k_color = NEON_YELLOW\n                d_color = NEON_YELLOW\n                \n                if k < 20 and k > d:\n                    k_color = NEON_GREEN\n                elif k > 80 and k < d:\n                    k_color = NEON_RED\n                \n                return (f\"{NEON_PURPLE}Ehlers Stoch RSI:{RESET} K={k_color}{k:.2f}{RESET}, \"\n                        f\"D={d_color}{d:.2f}{RESET}\")\n            else:\n                return f\"{NEON_YELLOW}Ehlers Stoch RSI:{RESET} No data available.\"\n\n        # Convert single float values to list for consistent indexing if needed\n        if isinstance(values, (float, int)):\n            values = [values]\n        elif isinstance(values, dict):  # For 'mom' which is a dict\n            if indicator_name == \"mom\":\n                trend = values.get(\"trend\", \"N/A\")\n                strength = values.get(\"strength\", 0.0)\n                strength_color = NEON_BLUE\n                if strength > CONFIG[\"trend_strength_threshold\"]:\n                    strength_color = NEON_GREEN if trend == \"Uptrend\" else \\\n                                     NEON_RED if trend == \"Downtrend\" else NEON_YELLOW\n                return (f\"{NEON_PURPLE}Momentum Trend:{RESET} {trend} \"\n                        f\"(Strength: {strength_color}{strength:.2f}{RESET})\")\n            else:\n                return (f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} \"\n                        f\"Dictionary format not specifically interpreted.\")\n\n        # General interpretation for list-based indicators\n        last_value = values[-1] if isinstance(values, list) and values else \\\n                     values[0] if isinstance(values, list) else values\n\n        if indicator_name == \"rsi\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 70:\n                color = NEON_RED\n                status = \"Overbought\"\n            elif last_value < 30:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            return f\"{NEON_BLUE}RSI:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"mfi\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 80:\n                color = NEON_RED\n                status = \"Overbought\"\n            elif last_value < 20:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            return f\"{NEON_BLUE}MFI:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"cci\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 100:\n                color = NEON_RED\n                status = \"Overbought\"\n            elif last_value < -100:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            return f\"{NEON_BLUE}CCI:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"wr\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value < -80:\n                color = NEON_GREEN\n                status = \"Oversold\"\n            elif last_value > -20:\n                color = NEON_RED\n                status = \"Overbought\"\n            return f\"{NEON_BLUE}Williams %R:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"adx\":\n            color = NEON_YELLOW\n            status = \"Ranging\"\n            if last_value > 25:\n                color = NEON_GREEN\n                status = \"Trending\"\n            return f\"{NEON_BLUE}ADX:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"obv\":\n            status = \"Neutral\"\n            color = NEON_BLUE\n            if len(values) >= 2:\n                if values[-1] > values[-2]:\n                    color = NEON_GREEN\n                    status = \"Bullish\"\n                elif values[-1] < values[-2]:\n                    color = NEON_RED\n                    status = \"Bearish\"\n                return (f\"{NEON_BLUE}OBV:{RESET} {color}{values[-1]:.2f}{RESET} \"\n                        f\"({status})\")\n            else:\n                return (f\"{NEON_BLUE}OBV:{RESET} {color}{last_value:.2f}{RESET} \"\n                        f\"(Insufficient history for trend)\")\n        elif indicator_name == \"adi\":\n            status = \"Neutral\"\n            color = NEON_BLUE\n            if len(values) >= 2:\n                if values[-1] > values[-2]:\n                    color = NEON_GREEN\n                    status = \"Accumulation\"\n                elif values[-1] < values[-2]:\n                    color = NEON_RED\n                    status = \"Distribution\"\n                return (f\"{NEON_BLUE}ADI:{RESET} {color}{values[-1]:.2f}{RESET} \"\n                        f\"(Insufficient history for trend)\")\n            else:\n                return (f\"{NEON_BLUE}ADI:{RESET} {color}{last_value:.2f}{RESET} \"\n                        f\"(Insufficient history for trend)\")\n        elif indicator_name == \"sma_10\":\n            return f\"{NEON_YELLOW}SMA (10):{RESET} {NEON_BLUE}{last_value:.2f}{RESET}\"\n        elif indicator_name == \"psar\":\n            return f\"{NEON_BLUE}PSAR:{RESET} {NEON_YELLOW}{last_value:.4f}{RESET} (Last Value)\"\n        elif indicator_name == \"fve\":\n            color = NEON_BLUE\n            if last_value > 0: color = NEON_GREEN\n            elif last_value < 0: color = NEON_RED\n            return f\"{NEON_BLUE}FVE:{RESET} {color}{last_value:.2f}{RESET} (Last Value)\"\n        elif indicator_name == \"macd\":\n            # values for MACD are [macd_line, signal_line, histogram]\n            if len(values[-1]) == 3:\n                macd_line, signal_line, histogram = values[-1][0], values[-1][1], values[-1][2]\n                hist_color = NEON_YELLOW\n                if histogram > 0: hist_color = NEON_GREEN\n                elif histogram < 0: hist_color = NEON_RED\n                return (f\"{NEON_GREEN}MACD:{RESET} MACD={NEON_YELLOW}{macd_line:.2f}{RESET}, \"\n                        f\"Signal={NEON_YELLOW}{signal_line:.2f}{RESET}, \"\n                        f\"Histogram={hist_color}{histogram:.2f}{RESET}\")\n            else:\n                return f\"{NEON_RED}MACD:{RESET} Calculation issue.\"\n        elif indicator_name == \"ema_alignment\":\n            score = values # It's a single float, not a list\n            color = NEON_YELLOW\n            status = 'Neutral'\n            if score > 0:\n                color = NEON_GREEN\n                status = 'Bullish'\n            elif score < 0:\n                color = NEON_RED\n                status = 'Bearish'\n            return f\"{NEON_PURPLE}EMA Alignment:{RESET} Score={color}{score:.2f}{RESET} ({status})\"\n        \n        # --- Ehlers Indicator Interpretations (Cont.) ---\n        elif indicator_name == \"ehlers_fisher\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value > 1.5:\n                color = NEON_GREEN\n                status = \"Strong Bullish\"\n            elif last_value < -1.5:\n                color = NEON_RED\n                status = \"Strong Bearish\"\n            return f\"{NEON_PURPLE}Ehlers Fisher:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        elif indicator_name == \"ehlers_oma\":\n            return f\"{NEON_PURPLE}Ehlers OMA:{RESET} {NEON_BLUE}{last_value:.4f}{RESET}\"\n        elif indicator_name == \"ehlers_ssf\":\n            return f\"{NEON_PURPLE}Ehlers SSF:{RESET} {NEON_BLUE}{last_value:.4f}{RESET}\"\n        elif indicator_name == \"ehlers_ama\":\n            return f\"{NEON_PURPLE}Ehlers AMA:{RESET} {NEON_BLUE}{last_value:.4f}{RESET}\"\n        elif indicator_name == \"ehlers_cci_cycle\":\n            color = NEON_YELLOW\n            status = \"Neutral Cycle\"\n            if last_value > 0.5:\n                color = NEON_GREEN\n                status = \"Bullish Cycle Phase\"\n            elif last_value < -0.5:\n                color = NEON_RED\n                status = \"Bearish Cycle Phase\"\n            return (f\"{NEON_PURPLE}Ehlers Corr. Cycle:{RESET} {color}{last_value:.2f}{RESET} \"\n                    f\"({status})\")\n        elif indicator_name == \"ehlers_decycler\":\n            color = NEON_BLUE\n            if last_value > 0: color = NEON_GREEN\n            elif last_value < 0: color = NEON_RED\n            return (f\"{NEON_PURPLE}Ehlers Decycler:{RESET} {color}{last_value:.4f}{RESET} \"\n                    f\"(Trend Component)\")\n        elif indicator_name == \"ehlers_bandpass\":\n            color = NEON_BLUE\n            if abs(last_value) > 0.01:\n                color = NEON_YELLOW\n                status = \"Active Cycle\"\n            else:\n                status = \"Weak Cycle\"\n            return (f\"{NEON_PURPLE}Ehlers Bandpass:{RESET} {color}{last_value:.4f}{RESET} \"\n                    f\"({status})\")\n        elif indicator_name == \"ehlers_cog\":\n            color = NEON_YELLOW\n            status = \"Neutral\"\n            if last_value < -0.5:\n                color = NEON_GREEN\n                status = \"Bullish Turn\"\n            elif last_value > 0.5:\n                color = NEON_RED\n                status = \"Bearish Turn\"\n            return f\"{NEON_PURPLE}Ehlers COG:{RESET} {color}{last_value:.2f}{RESET} ({status})\"\n        else:\n            return (f\"{NEON_YELLOW}{indicator_name.upper()}:{RESET} \"\n                    f\"No specific interpretation available.\")\n    except (TypeError, IndexError, KeyError, ValueError, InvalidOperation) as e:\n        logger.error(f\"{NEON_RED}Error interpreting {indicator_name}: {e}. \"\n                     f\"Values: {values}{RESET}\")\n        return f\"{NEON_RED}{indicator_name.upper()}:{RESET} Interpretation error.\"\n\n\ndef main():\n    \"\"\"\n    Main function to run the trading analysis bot.\n    Handles user input, data fetching, analysis, and signal generation loop.\n    \"\"\"\n    if not API_KEY or not API_SECRET:\n        logger.error(f\"{NEON_RED} BYBIT_API_KEY and BYBIT_API_SECRET must be set in your .env file. {RESET}\")\n        return\n\n    symbol_input = input(f\"{NEON_BLUE} Enter trading symbol (e.g., BTCUSDT): {RESET}\").upper().strip()\n    symbol = symbol_input if symbol_input else \"BTCUSDT\"\n\n    interval_input = input(f\"{NEON_BLUE} Enter timeframe (e.g., {', '.join(VALID_INTERVALS)} \"\n                           f\"or press Enter for default {CONFIG['interval']}): {RESET}\").strip()\n    interval = interval_input if interval_input and interval_input in VALID_INTERVALS \\\n               else CONFIG[\"interval\"]\n\n    # Setup a dedicated logger for this symbol's activities\n    symbol_logger = setup_custom_logger(symbol)\n    symbol_logger.info(f\"{NEON_BLUE} Starting analysis for {symbol} with interval {interval}{RESET}\")\n\n    last_signal_time = 0.0\n    last_order_book_fetch_time = 0.0\n\n    while True:\n        try:\n            current_price = fetch_current_price(symbol, API_KEY, API_SECRET, symbol_logger)\n            if current_price is None:\n                symbol_logger.error(f\"{NEON_RED} Failed to fetch current price for {symbol}. \"\n                                    f\"Skipping cycle. {RESET}\")\n                time.sleep(CONFIG[\"retry_delay\"])\n                continue\n\n            df = fetch_klines(symbol, interval, API_KEY, API_SECRET, symbol_logger, limit=200)\n            if df.empty:\n                symbol_logger.error(f\"{NEON_RED} Failed to fetch Kline data for {symbol}. \"\n                                    f\"Skipping cycle. {RESET}\")\n                time.sleep(CONFIG[\"retry_delay\"])\n                continue\n\n            # Debounce order book fetching to reduce API calls\n            order_book_data = None\n            if time.time() - last_order_book_fetch_time >= CONFIG[\"order_book_debounce_s\"]:\n                order_book_data = fetch_order_book(symbol, API_KEY, API_SECRET, symbol_logger,\n                                                   limit=CONFIG[\"order_book_depth_to_check\"])\n                last_order_book_fetch_time = time.time()\n            else:\n                symbol_logger.debug(f\"{NEON_YELLOW} Order book fetch debounced. Next fetch in \"\n                                    f\"{CONFIG['order_book_debounce_s'] - (time.time() - last_order_book_fetch_time):.1f}s{RESET}\")\n\n            analyzer = TradingAnalyzer(df, CONFIG, symbol_logger, symbol, interval)\n            timestamp = datetime.now(TIMEZONE).strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n\n            # Perform analysis and log the current state of indicators\n            analyzer.analyze(current_price, timestamp, order_book_data)\n\n            # Generate trading signal based on the analysis\n            current_time_seconds = time.time()\n            signal, confidence, conditions_met, trade_levels = \\\n                analyzer.generate_trading_signal(current_price)\n\n            if signal and (current_time_seconds - last_signal_time >= CONFIG[\"signal_cooldown_s\"]):\n                symbol_logger.info(f\"\\n{NEON_PURPLE}--- TRADING SIGNAL TRIGGERED ---{RESET}\")\n                symbol_logger.info(f\"{NEON_BLUE} Signal:{RESET} {signal.upper()} \"\n                                   f\"(Confidence: {confidence:.2f})\")\n                symbol_logger.info(f\"{NEON_BLUE} Conditions Met:{RESET} \"\n                                   f\"{', '.join(conditions_met) if conditions_met else 'None'}\")\n                if trade_levels:\n                    symbol_logger.info(f\"{NEON_GREEN} Suggested Stop Loss:{RESET} \"\n                                       f\"{trade_levels.get('stop_loss'):.5f}\")\n                    symbol_logger.info(f\"{NEON_GREEN} Suggested Take Profit:{RESET} \"\n                                       f\"{trade_levels.get('take_profit'):.5f}\")\n                symbol_logger.info(f\"{NEON_YELLOW} --- Placeholder: Order placement logic would \"\n                                   f\"be here for {signal.upper()} signal ---{RESET}\")\n                last_signal_time = current_time_seconds\n\n            time.sleep(CONFIG[\"analysis_interval\"])\n\n        except requests.exceptions.RequestException as e:\n            symbol_logger.error(f\"{NEON_RED} Network or API communication error: {e}. \"\n                                f\"Retrying in {CONFIG['retry_delay']} seconds...{RESET}\")\n            time.sleep(CONFIG[\"retry_delay\"])\n        except KeyboardInterrupt:\n            symbol_logger.info(f\"{NEON_YELLOW} Analysis stopped by user. {RESET}\")\n            break\n        except Exception as e:\n            symbol_logger.exception(f\"{NEON_RED} An unexpected error occurred: {e}. \"\n                                    f\"Retrying in {CONFIG['retry_delay']} seconds...{RESET}\")\n            time.sleep(CONFIG[\"retry_delay\"])\n\n\nif __name__ == \"__main__\":\n    main()\n```"
messages:
- role: system
  content: |-
    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a trading bot for Bybit, performing technical analysis and generating trade signals. Key features include:

    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from a `config.json` file, allowing customization of intervals, indicator periods, and signal weights. It handles missing or corrupt config files by loading defaults.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets (e.g., "low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, along with confidence scores and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    The refactoring focused on improving logical flow, ensuring consistent data handling (especially with `Decimal`), and adjusting configuration parameters for clarity.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This Python code implements a Bybit trading bot focused on technical analysis.

    **Key Topics Discussed:**
    *   **API Interaction:** Securely fetches market data (klines, current price, order book) from Bybit API v5 with retry logic and error handling.
    *   **Configuration:** Loads settings from `config.json`, including intervals, indicator periods, and signal weights, with robust handling for missing/corrupt files.
    *   **Technical Analysis:** Calculates a wide range of indicators (EMA alignment, Momentum, CCI, Williams %R, MFI, ATR, RSI, Stoch RSI, Stochastic Oscillator, MACD, ADX, OBV, ADI, PSAR, FVE) and support/resistance levels (Fibonacci, Pivot Points).
    *   **Dynamic Weighting:** Selects indicator weight sets ("low\_volatility", "high\_volatility") based on current market volatility (ATR).
    *   **Signal Generation:** Combines indicator insights with configurable weights and thresholds to generate "buy" or "sell" signals, confidence scores, and suggested Stop Loss/Take Profit levels.
    *   **Logging & Visualization:** Uses `colorama` for colored terminal output and `logging` for detailed operational logs.

    **Important Decisions/Conclusions:**
    *   Refactoring focused on improving logical flow and ensuring consistent data handling using `Decimal` for precision.
    *   Configuration parameters were adjusted for clarity and robustness.

    **Action Items/Next Steps:**
    *   Implement actual order placement logic, as it's currently a placeholder.
    *   Further fine-tune indicator parameters and signal weights.
    *   Consider adding backtesting capabilities.

    **Unresolved Questions:**
    *   How to handle real-time order execution and position management.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    The user requested to color-code indicator values in the Python trading bot's output for better readability.

    **Key Changes Implemented:**
    *   The `interpret_indicator` function was significantly enhanced to apply `colorama` (NEON_GREEN, NEON_RED, NEON_YELLOW, NEON_BLUE) based on the indicator's value and its typical interpretation (e.g., overbought/oversold for RSI, MFI, CCI, Williams %R; trending/ranging for ADX; bullish/bearish for OBV, ADI, MACD histogram, Stochastic Oscillators).
    *   It now correctly handles `pd.DataFrame` inputs for indicators like Stochastic RSI and Stochastic Oscillator, interpreting their K and D lines for crossovers and overbought/oversold conditions.
    *   The `TradingAnalyzer.analyze` function was refactored to remove redundant manual printing of indicator interpretations, instead passing all relevant indicator values through the `interpret_indicator` function for consistent formatting and coloring.

    **Outcome:**
    The bot's console output now provides visually distinct and immediately interpretable indicator values, centralizing the coloring logic and improving overall readability.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    The discussion focused on integrating advanced Ehlers indicators into the existing Bybit trading bot.

    **Key Topics & Changes:**
    *   **Ehlers Indicator Integration:** Nine new Ehlers indicators (Fisher Transform, Stochastic RSI, Optimal MA, Super Smoother, Adaptive MA, Correlation Cycle, Decycler, Bandpass, Center of Gravity) were added to the `TradingAnalyzer` class.
    *   **Configuration:** `config.json` and `default_config` were updated to include enable/disable flags, specific periods, and placeholder signal weights for each new Ehlers indicator.
    *   **Calculations & Storage:** New private methods were created for each Ehlers indicator calculation, with robustness checks for data availability. Results are stored in `self.indicator_values`.
    *   **Interpretation & Output:** The `interpret_indicator` function was extended to provide color-coded, human-readable interpretations for the new Ehlers indicators.
    *   **Signal Generation:** Placeholder logic was added to `generate_trading_signal` to incorporate Ehlers indicators into the overall signal scoring.

    **Important Decisions/Conclusions:**
    *   Ehlers indicators are now part of the bot's analytical toolkit.
    *   Initial signal weighting for Ehlers indicators is set to placeholders, requiring user fine-tuning.

    **Action Items/Next Steps:**
    *   Install `scipy` (`pip install scipy`).
    *   **Crucially, fine-tune the signal generation logic and thresholds for each Ehlers indicator** based on backtesting and strategic goals.
    *   Monitor bot performance due to the added computational complexity of Ehlers filters.

    Provide a concise summary of the chat history:
    - Key topics discussed
    - Important decisions or conclusions
    - Action items or next steps
    - Unresolved questions
    This session focused on debugging and linting the Bybit trading bot to enhance its reliability and code quality.

    **Key Topics & Improvements:**
    *   **Precision:** Refined `Decimal` usage for critical financial calculations (prices, SL/TP, signal scores) to prevent floating-point errors, while retaining `float64` for performance in Pandas/NumPy where appropriate.
    *   **Ehlers Indicators:** Corrected mathematical logic and `NaN` handling for Ehlers Fisher Transform, Adaptive MA, and other Ehlers filters. Clarified simplified implementations (e.g., OMA, Bandpass).
    *   **Robustness:** Enhanced data sufficiency checks for indicator calculations, improved error handling for API requests and internal computations, and added `try-except` blocks for various exceptions.
    *   **Code Quality:** Applied linting (PEP 8) for improved readability, consistent spacing, variable naming, and line length.
    *   **General:** Added timeouts to API requests, improved logging messages, and refined the `interpret_indicator` function for better output.

    The outcome is a more robust, precise, and readable trading bot with corrected Ehlers indicator implementations.
