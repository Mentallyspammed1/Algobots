{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/bybit-api.ts"],"sourcesContent":["\n// Types\nexport type TickerInfo = {\n  lastPrice: string;\n  highPrice24h: string;\n  lowPrice24h: string;\n  turnover24h: string; // Volume in quote currency (USDT)\n  volume24h: string; // Volume in base currency (e.g., BTC)\n  price24hPcnt: string; // 24h price change percentage\n};\n\nexport type OrderBookEntry = [string, string]; // [price, size]\nexport type OrderBook = {\n  bids: OrderBookEntry[];\n  asks: OrderBookEntry[];\n  ts: string; // Orderbook timestamp\n};\n\nexport type RecentTrade = {\n  execId: string;\n  execTime: string | number;\n  price: string;\n  qty: string;\n  side: 'Buy' | 'Sell';\n  isBlockTrade?: boolean; // Whether it's a block trade\n};\n\nexport type KlineEntry = [\n  string, // Start time\n  string, // Open\n  string, // High\n  string, // Low\n  string, // Close\n  string, // Volume\n  string, // Turnover\n  string? // Optional: Confirm flag (1 if the kline is closed)\n];\n\n// Constants\nconst BYBIT_API_URL = 'https://api.bybit.com';\nexport const BYBIT_WEBSOCKET_URL = 'wss://stream.bybit.com/v5/public/spot';\nexport const DEFAULT_REQUEST_TIMEOUT = 10000; // 10 seconds\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\n\n// API Response Types\ninterface ApiResponse<T> {\n  retCode: number;\n  retMsg: string;\n  result: T;\n  time: number;\n}\n\n// Enhanced fetch function with retry logic and timeout\nasync function fetchFromBybit<T>(\n  endpoint: string, \n  params: Record<string, string> = {}, \n  options: RequestInit = {}\n): Promise<T | null> {\n  const url = new URL(endpoint, BYBIT_API_URL);\n  url.search = new URLSearchParams(params).toString();\n  \n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), DEFAULT_REQUEST_TIMEOUT);\n  \n  const fetchOptions: RequestInit = {\n    cache: 'no-store',\n    signal: options.signal || controller.signal, // Use provided signal or internal timeout signal\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    ...options\n  };\n\n  let retryCount = 0;\n  \n  while (retryCount <= MAX_RETRIES) {\n    try {\n      const response = await fetch(url.toString(), fetchOptions);\n      clearTimeout(timeoutId); // Clear timeout once response is received\n      \n      if (!response.ok) {\n        throw new Error(`Bybit API error: ${response.status} ${response.statusText}`);\n      }\n      \n      const data: ApiResponse<T> = await response.json();\n      \n      if (data.retCode !== 0) {\n        throw new Error(`Bybit API error: ${data.retMsg} (Code: ${data.retCode})`);\n      }\n      \n      return data.result;\n    } catch (error) {\n      clearTimeout(timeoutId);\n      \n      // Don't retry on abort errors or if we've reached max retries\n      if (error instanceof Error && error.name === 'AbortError') {\n        console.error(`Request to ${endpoint} timed out or was aborted`);\n        return null;\n      }\n      \n      if (retryCount === MAX_RETRIES) {\n        console.error(`Failed to fetch from Bybit endpoint ${endpoint} after ${MAX_RETRIES} retries:`, error);\n        return null;\n      }\n      \n      // Exponential backoff\n      const delay = RETRY_DELAY_MS * Math.pow(2, retryCount);\n      console.warn(`Retry ${retryCount + 1}/${MAX_RETRIES} for ${endpoint} in ${delay}ms`);\n      \n      await new Promise(resolve => setTimeout(resolve, delay));\n      retryCount++;\n    }\n  }\n  \n  return null;\n}\n\n// Get ticker information with enhanced error handling\nexport async function getTicker(symbol: string): Promise<TickerInfo | null> {\n  try {\n    const result = await fetchFromBybit<any>('/v5/market/tickers', { \n      category: 'spot', \n      symbol \n    });\n    \n    if (!result || !result.list || result.list.length === 0) {\n      console.warn(`No ticker data found for symbol: ${symbol}`);\n      return null;\n    }\n    \n    // Extract and validate the ticker data\n    const ticker = result.list[0];\n    \n    // Validate required fields\n    const requiredFields = ['lastPrice', 'highPrice24h', 'lowPrice24h', 'turnover24h', 'volume24h'];\n    for (const field of requiredFields) {\n      if (ticker[field] === undefined || ticker[field] === null) {\n        console.warn(`Missing required field ${field} in ticker data for ${symbol}`);\n        return null;\n      }\n    }\n    \n    return {\n      lastPrice: ticker.lastPrice,\n      highPrice24h: ticker.highPrice24h,\n      lowPrice24h: ticker.lowPrice24h,\n      turnover24h: ticker.turnover24h,\n      volume24h: ticker.volume24h,\n      price24hPcnt: ticker.price24hPcnt || '0',\n    };\n  } catch (error) {\n    console.error(`Error fetching ticker for ${symbol}:`, error);\n    return null;\n  }\n}\n\n// Get order book with timestamp and validation\nexport async function getOrderBook(symbol: string, limit: number = 20): Promise<OrderBook | null> {\n  try {\n    const result = await fetchFromBybit<any>('/v5/market/orderbook', { \n      category: 'spot', \n      symbol, \n      limit: limit.toString() \n    });\n    \n    if (!result) {\n      console.warn(`No orderbook data found for symbol: ${symbol}`);\n      return null;\n    }\n    \n    // Validate the orderbook structure\n    if (!result.b || !result.a || !Array.isArray(result.b) || !Array.isArray(result.a)) {\n      console.warn(`Invalid orderbook structure for symbol: ${symbol}`);\n      return null;\n    }\n    \n    // Ensure bids and asks are properly formatted\n    const bids = result.b.filter((entry: any) => \n      Array.isArray(entry) && entry.length === 2 && entry[0] && entry[1]\n    ) as OrderBookEntry[];\n    \n    const asks = result.a.filter((entry: any) => \n      Array.isArray(entry) && entry.length === 2 && entry[0] && entry[1]\n    ) as OrderBookEntry[];\n    \n    return {\n      bids,\n      asks,\n      ts: result.ts || Date.now().toString(),\n    };\n  } catch (error) {\n    console.error(`Error fetching orderbook for ${symbol}:`, error);\n    return null;\n  }\n}\n\n// Get recent trades with enhanced filtering\nexport async function getRecentTrades(\n  symbol: string, \n  limit: number = 30, \n  options: RequestInit = {}\n): Promise<RecentTrade[]> {\n  try {\n    const result = await fetchFromBybit<any>(\n      '/v5/market/recent-trade', \n      { \n        category: 'spot', \n        symbol, \n        limit: limit.toString() \n      }, \n      options\n    );\n    \n    if (!result || !result.list || !Array.isArray(result.list)) {\n      return [];\n    }\n    \n    // Filter and validate trade data\n    return result.list\n      .filter((trade: any) => {\n        return trade.execId && trade.execTime && trade.price && trade.qty && \n               (trade.side === 'Buy' || trade.side === 'Sell');\n      })\n      .map((trade: any) => ({\n        execId: trade.execId,\n        execTime: trade.execTime,\n        price: trade.price,\n        qty: trade.qty,\n        side: trade.side as 'Buy' | 'Sell',\n        isBlockTrade: trade.isBlockTrade || false,\n      }));\n  } catch (error) {\n    if (!(error instanceof Error && error.name === 'AbortError')) {\n      console.error(`Error fetching recent trades for ${symbol}:`, error);\n    }\n    return [];\n  }\n}\n\n// Get kline/candlestick data with interval mapping and validation\nexport async function getKline(\n  symbol: string, \n  interval: string, \n  limit: number = 100\n): Promise<KlineEntry[] | null> {\n  try {\n    // Map user-friendly intervals to Bybit format\n    const intervalMap: Record<string, string> = {\n      '1m': '1',\n      '5m': '5',\n      '15m': '15',\n      '30m': '30',\n      '1h': '60',\n      '2h': '120',\n      '4h': '240',\n      '6h': '360',\n      '12h': '720',\n      '1d': 'D',\n      '1w': 'W',\n      '1M': 'M',\n    };\n    \n    const bybitInterval = intervalMap[interval] || interval;\n    \n    const result = await fetchFromBybit<any>('/v5/market/kline', { \n      category: 'spot', \n      symbol, \n      interval: bybitInterval, \n      limit: limit.toString() \n    });\n    \n    if (!result || !result.list || !Array.isArray(result.list)) {\n      console.warn(`No kline data found for symbol: ${symbol} with interval: ${interval}`);\n      return null;\n    }\n    \n    // Validate and format kline entries\n    return result.list\n      .filter((entry: any) => {\n        return Array.isArray(entry) && entry.length >= 7 && \n               entry.every((val: any) => val !== null && val !== undefined);\n      })\n      .map((entry: any) => entry.slice(0, 7) as KlineEntry);\n  } catch (error) {\n    console.error(`Error fetching kline data for ${symbol} with interval ${interval}:`, error);\n    return null;\n  }\n}\n\n// New function to get multiple symbols data at once\nexport async function getTickers(symbols: string[]): Promise<Record<string, TickerInfo>> {\n  const results: Record<string, TickerInfo> = {};\n  \n  // Use Promise.allSettled to handle partial failures\n  const promises = symbols.map(async (symbol) => {\n    const ticker = await getTicker(symbol);\n    return { symbol, ticker };\n  });\n  \n  const settledResults = await Promise.allSettled(promises);\n  \n  settledResults.forEach((result) => {\n    if (result.status === 'fulfilled' && result.value.ticker) {\n      const { symbol, ticker } = result.value;\n      results[symbol] = ticker;\n    }\n  });\n  \n  return results;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/api/trades/route.ts"],"sourcesContent":["\nimport { NextResponse } from 'next/server';\nimport { getRecentTrades, type RecentTrade } from '@/lib/bybit-api';\nimport type { VolumePressureData } from '@/lib/actions';\n\nfunction calculateVolumePressure(trades: RecentTrade[]): VolumePressureData {\n    const emptyState = { buyVolume: 0, sellVolume: 0, totalVolume: 0, buyPercentage: 50, sellPercentage: 50 };\n    \n    if (!trades || trades.length === 0) {\n        return emptyState;\n    }\n\n    let buyVolume = 0;\n    let sellVolume = 0;\n\n    trades.forEach((trade: RecentTrade) => {\n        const volume = parseFloat(trade.qty);\n        if (isNaN(volume)) return;\n\n        if (trade.side === 'Buy') {\n            buyVolume += volume;\n        } else {\n            sellVolume += volume;\n        }\n    });\n\n    const totalVolume = buyVolume + sellVolume;\n    if (totalVolume === 0) {\n        return emptyState;\n    }\n\n    const buyPercentage = (buyVolume / totalVolume) * 100;\n    const sellPercentage = (sellVolume / totalVolume) * 100;\n\n    return {\n        buyVolume,\n        sellVolume,\n        totalVolume,\n        buyPercentage,\n        sellPercentage,\n    };\n}\n\n\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const symbol = searchParams.get('symbol');\n\n  if (!symbol) {\n    return NextResponse.json({ error: 'Symbol parameter is required' }, { status: 400 });\n  }\n\n  try {\n    const trades = await getRecentTrades(symbol);\n    const volumePressure = calculateVolumePressure(trades);\n    \n    return NextResponse.json({\n        trades,\n        volumePressure\n    });\n\n  } catch (error) {\n    console.error(`API Route Error for /api/trades?symbol=${symbol}:`, error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';\n    return NextResponse.json({ error: 'Failed to fetch trade data', details: errorMessage }, { status: 500 });\n  }\n}\n\n// Ensure dynamic rendering\nexport const dynamic = 'force-dynamic';\n"],"names":[],"mappings":";;;;AACA;AACA;;;AAGA,SAAS,wBAAwB,MAAqB;IAClD,MAAM,aAAa;QAAE,WAAW;QAAG,YAAY;QAAG,aAAa;QAAG,eAAe;QAAI,gBAAgB;IAAG;IAExG,IAAI,CAAC,UAAU,OAAO,MAAM,KAAK,GAAG;QAChC,OAAO;IACX;IAEA,IAAI,YAAY;IAChB,IAAI,aAAa;IAEjB,OAAO,OAAO,CAAC,CAAC;QACZ,MAAM,SAAS,WAAW,MAAM,GAAG;QACnC,IAAI,MAAM,SAAS;QAEnB,IAAI,MAAM,IAAI,KAAK,OAAO;YACtB,aAAa;QACjB,OAAO;YACH,cAAc;QAClB;IACJ;IAEA,MAAM,cAAc,YAAY;IAChC,IAAI,gBAAgB,GAAG;QACnB,OAAO;IACX;IAEA,MAAM,gBAAgB,AAAC,YAAY,cAAe;IAClD,MAAM,iBAAiB,AAAC,aAAa,cAAe;IAEpD,OAAO;QACH;QACA;QACA;QACA;QACA;IACJ;AACJ;AAGO,eAAe,IAAI,OAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,SAAS,aAAa,GAAG,CAAC;IAEhC,IAAI,CAAC,QAAQ;QACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA+B,GAAG;YAAE,QAAQ;QAAI;IACpF;IAEA,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,4HAAA,CAAA,kBAAe,AAAD,EAAE;QACrC,MAAM,iBAAiB,wBAAwB;QAE/C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACrB;YACA;QACJ;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,uCAAuC,EAAE,OAAO,CAAC,CAAC,EAAE;QACnE,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAA8B,SAAS;QAAa,GAAG;YAAE,QAAQ;QAAI;IACzG;AACF;AAGO,MAAM,UAAU","debugId":null}}]
}