name: Code Quality and Auto-Fix

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  analyze-and-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout @v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node @v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci
        npm install -g @google/generative-ai prettier

    - name: Determine changed files
      id: changed
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          git fetch origin main
          CHANGED=$(git diff --name-only origin/main...HEAD -- '*.js' '*.ts' '*.jsx' '*.tsx')
        else
          CHANGED=$(git ls-files '*.js' '*.ts' '*.jsx' '*.tsx')
        fi
        echo "changed_files<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGED" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Run linters and collect issues
      id: linting
      run: |
        npm run lint:all || true
        npm run eslint -- --format json --output-file eslint-issues.json || true

        echo "issues_summary<<EOF" >> $GITHUB_OUTPUT
        if [ -f eslint-issues.json ]; then
          cat eslint-issues.json
        fi
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Analyze code with Gemini
      id: gemini-analysis
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        node .github/scripts/analyze-with-gemini.js           --issues "${{ steps.linting.outputs.issues_summary }}"           --files "${{ steps.changed.outputs.changed_files }}"           --output analysis-results.json

    - name: Format code after AI fixes
      if: steps.gemini-analysis.outputs.has-fixes == 'true'
      run: |
        npx prettier --write .
        npm run fix:lint || true

    - name: Create or update auto-fix PR
      if: steps.gemini-analysis.outputs.has-fixes == 'true' && github.event.pull_request.head.repo.full_name == github.repository
      uses: peter-evans/create-pull-request @v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: "ü§ñ Auto-fix: Resolve code quality issues"
        title: "ü§ñ Auto-fix: Code quality improvements"
        body: |
          This PR automatically fixes code quality issues detected by:
          - ESLint + Stylelint
          - Gemini AI analysis

          ## Changes Summary
          ${{ steps.gemini-analysis.outputs.changes-summary }}

          ## Files Changed
          ${{ steps.gemini-analysis.outputs.files-changed }}
        branch: auto-fix/gemini-${{ github.run_id }}
        delete-branch: true
        labels: automated, ai-generated, code-quality

    - name: Create issue if auto-fix fails
      if: failure() && steps.gemini-analysis.outputs.has-fixes == 'true'
      uses: actions/github-script @v7
      with:
        script: |
          const fs = require('fs');
          const analysis = JSON.parse(fs.readFileSync('analysis-results.json', 'utf8'));
          github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `ü§ñ Code Quality Issues Detected (Auto-fix failed)`,
            body: `
              ### Issues Found:
              ${analysis.issues.map(issue => `- ${issue.description} (Line ${issue.line})`).join('n')}

              ### Suggested Fixes:
              ${analysis.suggestedFixes.map(fix => `**File:** ${fix.file}nFix: ${fix.description}`).join('nn')}
            `,
            labels: ['code-quality', 'ai-analysis', 'needs-review']
          });

    - name: Post analysis summary
      if: always()
      uses: actions/github-script @v7
      with:
        script: |
          const fs = require('fs');
          let analysis = { summary: 'No analysis results' };
          try {
            analysis = JSON.parse(fs.readFileSync('analysis-results.json', 'utf8'));
          } catch (e) {}

          const summary = `
            ## ü§ñ Code Quality Analysis Summary
            **Issues Found:** ${analysis.issues ? analysis.issues.length : 0}  
            **Files Analyzed:** ${analysis.filesAnalyzed || 0}  
            **Auto-fix Status:** ${analysis.autoFixApplied ? '‚úÖ Applied' : '‚ùå Not Applied'}  

            ### Summary
            ${analysis.summary || 'No summary available'}
          `;

          if (context.issue) {
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          } else {
            console.log(summary);
          }
