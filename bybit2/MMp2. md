I'll implement 25 significant improvements to enhance the market-making bot. Here's the upgraded version:

```python
"""
Enhanced Market Making Bot for Bybit Perpetual Contracts
Features 25 key improvements for performance, robustness, and intelligence.
"""

import asyncio
import os
import signal
import statistics
import time
from concurrent.futures import ThreadPoolExecutor
from contextlib import asynccontextmanager
from datetime import datetime, timedelta, timezone
from decimal import Decimal, ROUND_DOWN, ROUND_UP, getcontext
from enum import Enum
from typing import Any, AsyncGenerator, Dict, List, Optional, Tuple, cast

import aiohttp
import numpy as np
from colorama import Fore, Style
from filelock import FileLock, Timeout
from pydantic import BaseModel, ValidationError, validator
from pydantic.tools import parse_obj_as
from typing_extensions import Literal

# --- Constants ---
getcontext().prec = 8  # Decimal precision for financial calculations
API_KEY = os.getenv("BYBIT_API_KEY", "your_api_key")
API_SECRET = os.getenv("BYBIT_API_SECRET", "your_api_secret")
BASE_URL = "https://api.bybit.com/v5"
WS_URL = "wss://stream.bybit.com/v5/public/spot"
WS_PRIVATE_URL = "wss://stream.bybit.com/v5/private"
STATE_DIR = "bot_state"
HEARTBEAT_INTERVAL = 300  # 5 minutes
STATE_LOCK_TIMEOUT = 10  # seconds
MAX_RETRIES = 3
RETRY_DELAY = 1.5  # seconds (exponential backoff base)

# --- Improved Data Models ---
class OrderStatus(str, Enum):
    NEW = "New"
    PARTIALLY_FILLED = "PartiallyFilled"
    FILLED = "Filled"
    CANCELLED = "Cancelled"
    REJECTED = "Rejected"
    EXPIRED = "Expired"
    PENDING_CANCEL = "PendingCancel"
    UNTRIGGERED = "Untriggered"

class TradeSide(str, Enum):
    BUY = "Buy"
    SELL = "Sell"

class RiskLevel(str, Enum):
    NORMAL = "Normal"
    ELEVATED = "Elevated"
    HIGH = "High"
    CRITICAL = "Critical"

class MarketData(BaseModel):
    symbol: str
    best_bid: Decimal
    best_ask: Decimal
    bid_size: Decimal
    ask_size: Decimal
    mid_price: Decimal
    spread: Decimal
    timestamp: int
    volume_24h: Optional[Decimal] = None
    funding_rate: Optional[Decimal] = None
    open_interest: Optional[Decimal] = None
    
    @property
    def spread_bps(self) -> Decimal:
        """Calculate spread in basis points"""
        if self.mid_price <= 0:
            return Decimal('0')
        return (self.spread / self.mid_price) * Decimal('10000')

    @validator('mid_price', pre=True)
    def validate_mid_price(cls, v):
        if v <= 0:
            raise ValueError('Mid price must be positive')
        return Decimal(v)

class OrderData(BaseModel):
    order_id: str
    symbol: str
    side: TradeSide
    price: Decimal
    quantity: Decimal
    status: OrderStatus = OrderStatus.NEW
    filled_qty: Decimal = Decimal('0')
    avg_price: Decimal = Decimal('0')
    timestamp: float
    type: str = "Limit"
    reduce_only: bool = False
    post_only: bool = True
    client_order_id: Optional[str] = None
    last_update: datetime = datetime.now(timezone.utc)
    order_pnl: Decimal = Decimal('0')

    @property
    def remaining_qty(self) -> Decimal:
        return self.quantity - self.filled_qty

class RiskMetrics(BaseModel):
    max_position: Decimal
    initial_equity: Decimal
    current_position: Decimal = Decimal('0')
    realized_pnl: Decimal = Decimal('0')
    unrealized_pnl: Decimal = Decimal('0')
    daily_pnl: Decimal = Decimal('0')
    max_drawdown: Decimal = Decimal('0')
    var_95: Decimal = Decimal('0')  # Value at Risk (95%)
    avg_win: Decimal = Decimal('0')
    avg_loss: Decimal = Decimal('0')
    win_rate: Decimal = Decimal('0')
    equity: Decimal = Decimal('0')
    last_equity_update: datetime = datetime.now(timezone.utc)
    risk_level: RiskLevel = RiskLevel.NORMAL
    max_daily_loss: Decimal = Decimal('-0.05')  # 5% daily loss limit
    max_drawdown_limit: Decimal = Decimal('-0.10')  # 10% max drawdown

    @validator('equity', pre=True, always=True)
    def initialize_equity(cls, v, values):
        if 'initial_equity' in values and v is None:
            return values['initial_equity']
        return v or Decimal('0')

    def update_trade_stats(self, pnl: Decimal):
        """Update trading performance statistics"""
        if pnl > 0:
            self.avg_win = (self.avg_win * (self.win_count) + pnl) / (self.win_count + 1)
            self.win_count += 1
        elif pnl < 0:
            self.avg_loss = (self.avg_loss * (self.lose_count) + pnl) / (self.lose_count + 1)
            self.lose_count += 1
        
        self.win_rate = (self.win_count / (self.win_count + self.lose_count)) * 100 if (self.win_count + self.lose_count) > 0 else Decimal('0')

    @property
    def win_count(self) -> int:
        return getattr(self, '_win_count', 0)
    
    @win_count.setter
    def win_count(self, value: int):
        self._win_count = value

    @property
    def lose_count(self) -> int:
        return getattr(self, '_lose_count', 0)
    
    @lose_count.setter
    def lose_count(self, value: int):
        self._lose_count = value

    def update_equity_and_drawdown(self, new_equity: Decimal):
        """Update equity and calculate drawdown metrics"""
        self.equity = new_equity
        self.last_equity_update = datetime.now(timezone.utc)
        
        # Calculate daily PnL (simplified)
        if self.last_equity_update.hour == 0 and self.last_equity_update.minute == 0:
            self.daily_pnl = Decimal('0')
        else:
            self.daily_pnl = self.equity - (self.initial_equity + self.realized_pnl)
        
        # Check daily loss limit
        if self.daily_pnl < self.max_daily_loss * self.initial_equity:
            self.risk_level = RiskLevel.CRITICAL
            logger.critical("Daily loss limit breached! Entering CRITICAL risk state.")
        
        # Calculate max drawdown
        if new_equity < self.equity_peak:
            drawdown = (new_equity - self.equity_peak) / self.equity_peak
            self.max_drawdown = min(self.max_drawdown, drawdown)
            
            if self.max_drawdown < self.max_drawdown_limit:
                self.risk_level = RiskLevel.HIGH
        else:
            self.equity_peak = new_equity

    def calculate_var_95(self, returns: List[Decimal]):
        """Calculate Value at Risk (95% confidence)"""
        if not returns:
            return Decimal('0')
        sorted_returns = sorted(returns)
        var_index = int(len(returns) * 0.05)
        self.var_95 = sorted_returns[var_index] if var_index < len(returns) else sorted_returns[-1]

    def calculate_sharpe_ratio(self, risk_free_rate: Decimal = Decimal('0.01'), period: int = 252):
        """Calculate annualized Sharpe ratio"""
        if not hasattr(self, 'returns') or len(self.returns) < 2:
            return Decimal('0')
        excess_returns = [r - risk_free_rate/period for r in self.returns]
        return np.mean(excess_returns) / np.std(excess_returns) * np.sqrt(period)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with Decimal handling"""
        return {
            "max_position": str(self.max_position),
            "initial_equity": str(self.initial_equity),
            "current_position": str(self.current_position),
            "realized_pnl": str(self.realized_pnl),
            "unrealized_pnl": str(self.unrealized_pnl),
            "daily_pnl": str(self.daily_pnl),
            "max_drawdown": str(self.max_drawdown),
            "var_95": str(self.var_95),
            "avg_win": str(self.avg_win),
            "avg_loss": str(self.avg_loss),
            "win_rate": str(self.win_rate),
            "equity": str(self.equity),
            "win_count": self.win_count,
            "lose_count": self.lose_count
        }

# --- State Manager with File Locking ---
class StateManager:
    """Thread-safe state management with file locking and periodic snapshots"""
    def __init__(self, base_dir: str = STATE_DIR):
        self.base_dir = base_dir
        os.makedirs(base_dir, exist_ok=True)
        self.snapshots_dir = os.path.join(base_dir, "snapshots")
        os.makedirs(self.snapshots_dir, exist_ok=True)
        
    def _get_path(self, key: str) -> str:
        return os.path.join(self.base_dir, f"{key}.json")
    
    def _get_snapshot_path(self, key: str, timestamp: datetime) -> str:
        filename = f"{key}_{timestamp.strftime('%Y%m%d_%H%M%S')}.json"
        return os.path.join(self.snapshots_dir, filename)
    
    def save_state(self, key: str, data: Any):
        """Save state with file locking and automatic snapshots"""
        path = self._get_path(key)
        lock_path = f"{path}.lock"
        
        # Create file lock
        lock = FileLock(lock_path, timeout=STATE_LOCK_TIMEOUT)
        with lock:
            # Create snapshot before overwriting
            if os.path.exists(path):
                timestamp = datetime.now(timezone.utc)
                snapshot_path = self._get_snapshot_path(key, timestamp)
                os.rename(path, snapshot_path)
                
            # Save new state
            with open(path, 'w') as f:
                if isinstance(data, BaseModel):
                    f.write(data.json(indent=2))
                else:
                    f.write(str(data))
    
    def load_state(self, key: str, model: Any = None) -> Any:
        """Load state with file locking"""
        path = self._get_path(key)
        lock_path = f"{path}.lock"
        
        lock = FileLock(lock_path, timeout=STATE_LOCK_TIMEOUT)
        with lock:
            if not os.path.exists(path):
                return None
                
            with open(path, 'r') as f:
                content = f.read()
                
            if model and issubclass(model, BaseModel):
                return model.parse_raw(content)
            return content

# --- API Client with Enhanced Features ---
class APIClient:
    """Enhanced API client with retry mechanism, rate limiting, and performance monitoring"""
    def __init__(self, api_key: str, api_secret: str, base_url: str, 
                 ws_url: str, private_ws_url: str):
        self.api_key = api_key
        self.api_secret = api_secret
        self.base_url = base_url
        self.ws_url = ws_url
        self.private_ws_url = private_ws_url
        self.session = None
        self.ws = None
        self.private_ws = None
        self.rate_limit_remaining = 100
        self.rate_limit_reset = time.time()
        self.last_request_time = 0
        self.request_count = 0
        self.latency_metrics = []
        self.symbol_info_cache = {}
        self.performance_monitor = PerformanceMonitor()
        self.bot_instance = None  # Will be set by bot
        self.heartbeat_task = None
        self.is_connected = False
        
    @asynccontextmanager
    async def _get_session(self) -> AsyncGenerator[aiohttp.ClientSession, None]:
        """Context manager for API sessions"""
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession(
                headers={"Content-Type": "application/json"},
                timeout=aiohttp.ClientTimeout(total=30)
            )
        yield self.session
        
    async def _request(self, method: str, endpoint: str, **kwargs) -> Any:
        """Core API request method with retry logic, rate limiting, and latency tracking"""
        url = f"{self.base_url}{endpoint}"
        payload = kwargs.get('json', {})
        
        # Add API key and signature for authenticated endpoints
        if endpoint.startswith("/private"):
            timestamp = int(time.time() * 1000)
            payload.update({
                "api_key": self.api_key,
                "timestamp": timestamp,
                "recv_window": 5000
            })
            # Create signature
            sorted_params = "&".join([f"{k}={v}" for k, v in sorted(payload.items())])
            signature = self._generate_signature(f"{timestamp}{sorted_params}")
            payload["sign"] = signature
            
        # Rate limiting
        now = time.monotonic()
        elapsed = now - self.last_request_time
        if elapsed < 0.1:  # 100ms between requests
            await asyncio.sleep(0.1 - elapsed)
            
        # Retry loop with exponential backoff
        for attempt in range(MAX_RETRIES):
            try:
                start_time = time.perf_counter()
                
                async with self._get_session() as session:
                    response = await session.request(
                        method, url, json=payload, raise_for_status=True
                    )
                    
                # Record latency
                latency = time.perf_counter() - start_time
                self.latency_metrics.append(latency)
                if len(self.latency_metrics) > 1000:
                    self.latency_metrics.pop(0)
                    
                # Update rate limit tracking (Bybit uses header: 'x-ratelimit-remaining')
                self.rate_limit_remaining = int(response.headers.get('x-ratelimit-remaining', 100))
                self.rate_limit_reset = int(response.headers.get('x-ratelimit-reset', time.time() + 1))
                
                self.request_count += 1
                self.performance_monitor.record_metric('api_requests')
                
                data = await response.json()
                
                if data.get('retCode') != 0:
                    error_msg = data.get('retMsg', 'Unknown API error')
                    logger.warning(f"API error ({attempt+1}/{MAX_RETRIES}): {error_msg}")
                    if "ratelimit" in error_msg.lower():
                        reset_time = max(1, self.rate_limit_reset - time.time())
                        logger.warning(f"Rate limit exceeded. Retrying in {reset_time:.1f}s")
                        await asyncio.sleep(reset_time)
                        continue
                    return None
                return data
                
            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                logger.warning(f"Network error ({attempt+1}/{MAX_RETRIES}): {str(e)}")
                delay = RETRY_DELAY * (2 ** attempt) + random.uniform(0, 0.1)
                await asyncio.sleep(delay)
            except Exception as e:
                logger.error(f"Unexpected error: {str(e)}")
                break
                
        logger.error(f"Request failed after {MAX_RETRIES} attempts: {url}")
        return None

    def _generate_signature(self, data: str) -> str:
        """Generate HMAC signature for authenticated requests"""
        return hmac.new(
            self.api_secret.encode('utf-8'),
            data.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

    async def get_symbol_info(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Get symbol information with caching"""
        if symbol in self.symbol_info_cache:
            return self.symbol_info_cache[symbol]
            
        endpoint = f"/public/symbols?category=perpetual&symbol={symbol}"
        data = await self._request("GET", endpoint)
        if data and data.get('retCode') == 0:
            symbol_info = data['result']['list'][0]
            self.symbol_info_cache[symbol] = symbol_info
            return symbol_info
        return None

    async def fetch_market_data(self, symbol: str) -> Optional[MarketData]:
        """Fetch real-time market data"""
        endpoint = f"/public/tickers?category=perpetual&symbol={symbol}"
        data = await self._request("GET", endpoint)
        if data and data.get('retCode') == 0:
            ticker = data['result']['list'][0]
            return MarketData(
                symbol=symbol,
                best_bid=Decimal(ticker['bidPrice']),
                best_ask=Decimal(ticker['askPrice']),
                bid_size=Decimal(ticker['bidSz']),
                ask_size=Decimal(ticker['askSz']),
                mid_price=Decimal(ticker['midPrice']),
                spread=Decimal(ticker['askPrice']) - Decimal(ticker['bidPrice']),
                timestamp=ticker['t']
            )
        return None

    async def create_order(self, symbol: str, side: TradeSide, order_type: str, 
                          qty: Decimal, price: Optional[Decimal] = None, 
                          reduce_only: bool = False, post_only: bool = True) -> Optional[Dict[str, Any]]:
        """Place a new order"""
        endpoint = "/private/order/create"
        payload = {
            "category": "perpetual",
            "symbol": symbol,
            "side": side.value,
            "order_type": order_type,
            "qty": str(qty),
            "time_in_force": "GoodTillCancel",
            "reduce_only": reduce_only,
            "post_only": post_only
        }
        if price is not None:
            payload["price"] = str(price)
            
        return await self._request("POST", endpoint, json=payload)

    async def cancel_order(self, symbol: str, order_id: str) -> Optional[Dict[str, Any]]:
        """Cancel an existing order"""
        endpoint = "/private/order/cancel"
        payload = {
            "category": "perpetual",
            "symbol": symbol,
            "order_id": order_id
        }
        return await self._request("POST", endpoint, json=payload)

    async def get_open_orders(self, symbol: str) -> List[OrderData]:
        """Get all open orders for a symbol"""
        endpoint = "/private/order/list"
        payload = {
            "category": "perpetual",
            "symbol": symbol,
            "order_status": "New"
        }
        data = await self._request("GET", endpoint, json=payload)
        if data and data.get('retCode') == 0:
            orders = []
            for order_data in data['result']['list']:
                try:
                    order = OrderData(
                        order_id=order_data['orderId'],
                        symbol=symbol,
                        side=TradeSide(order_data['side']),
                        price=Decimal(order_data['price']),
                        quantity=Decimal(order_data['qty']),
                        status=OrderStatus(order_data['orderStatus']),
                        filled_qty=Decimal(order_data['cumExecQty']),
                        avg_price=Decimal(order_data['avgPrice']),
                        timestamp=order_data['createTime'],
                        type=order_data['orderType'],
                        reduce_only=order_data['reduceOnly'],
                        post_only=order_data['createType'] == "CreateByUser"
                    )
                    orders.append(order)
                except ValidationError as e:
                    logger.error(f"Error parsing order data: {e}")
            return orders
        return []

    async def get_positions(self, symbol: str) -> List[Dict[str, Any]]:
        """Get current positions"""
        endpoint = "/private/position/list"
        payload = {
            "category": "perpetual",
            "symbol": symbol
        }
        data = await self._request("GET", endpoint, json=payload)
        if data and data.get('retCode') == 0:
            return data['result']['list']
        return []

    async def connect_websockets(self):
        """Connect to public and private WebSocket streams"""
        # Public market data stream
        self.ws = await websockets.connect(
            self.ws_url,
            ping_interval=HEARTBEAT_INTERVAL,
            ping_timeout=30
        )
        await self.ws.send(json.dumps({
            "op": "subscribe",
            "args": [f"tickers.perpetual.{self.bot_instance.symbol}"]
        }))
        
        # Private order/trade updates
        self.private_ws = await websockets.connect(
            self.private_ws_url,
            ping_interval=HEARTBEAT_INTERVAL,
            ping_timeout=30
        )
        await self.private_ws.send(json.dumps({
            "op": "subscribe",
            "args": [
                f"execution:{self.bot_instance.symbol}",
                f"position:{self.bot_instance.symbol}",
                f"order:{self.bot_instance.symbol}"
            ]
        }))
        
        self.is_connected = True
        self.heartbeat_task = asyncio.create_task(self._monitor_heartbeat())

    async def _monitor_heartbeat(self):
        """Monitor WebSocket connections and reconnect if needed"""
        while self.is_connected:
            try:
                # Check public WS
                if self.ws and self.ws.open:
                    pong = await self.ws.ping()
                    await asyncio.wait_for(pong, timeout=10)
                else:
                    logger.warning("Public WebSocket disconnected. Reconnecting...")
                    await self.connect_websockets()
                    continue
                    
                # Check private WS
                if self.private_ws and self.private_ws.open:
                    pong = await self.private_ws.ping()
                    await asyncio.wait_for(pong, timeout=10)
                else:
                    logger.warning("Private WebSocket disconnected. Reconnecting...")
                    await self.connect_websockets()
                    continue
                    
                await asyncio.sleep(HEARTBEAT_INTERVAL // 2)
                
            except (asyncio.TimeoutError, websockets.ConnectionClosed) as e:
                logger.warning(f"Heartbeat check failed: {str(e)}. Reconnecting...")
                await self.connect_websockets()
            except Exception as e:
                logger.error(f"Unexpected error in heartbeat monitor: {str(e)}")
                await asyncio.sleep(5)

    async def listen_for_messages(self):
        """Listen for messages from WebSocket connections"""
        while self.is_connected:
            try:
                # Process public messages
                if self.ws and self.ws.open:
                    message = await self.ws.recv()
                    await self._process_public_message(message)
                
                # Process private messages
                if self.private_ws and self.private_ws.open:
                    message = await self.private_ws.recv()
                    await self._process_private_message(message)
                    
                await asyncio.sleep(0.01)  # Yield control
                
            except websockets.ConnectionClosed:
                logger.warning("WebSocket connection closed. Attempting to reconnect...")
                await self.connect_websockets()
                await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"Error processing WebSocket message: {str(e)}")
                await asyncio.sleep(1)

    async def _process_public_message(self, message: str):
        """Process public market data messages"""
        try:
            data = json.loads(message)
            if data.get('topic') == f"tickers.perpetual.{self.bot_instance.symbol}":
                await self.bot_instance.update_market_data_from_ws(data['data'][0])
        except (json.JSONDecodeError, KeyError) as e:
            logger.error(f"Error processing public message: {e}")

    async def _process_private_message(self, message: str):
        """Process private order/trade/position messages"""
        try:
            data = json.loads(message)
            topic = data.get('topic', '')
            
            if topic.startswith("execution:"):
                # Trade execution updates
                trade_data = data['data']
                # This would update order status and PnL
                # In a full implementation, we'd match to open orders
                logger.debug(f"Execution update: {trade_data}")
                
            elif topic.startswith("position:"):
                # Position updates
                position_data = data['data']
                # This would update the bot's position state
                logger.debug(f"Position update: {position_data}")
                
            elif topic.startswith("order:"):
                # Order status updates
                order_data = data['data']
                # Add to order update queue
                await self.bot_instance.order_update_queue.put(order_data)
                
        except (json.JSONDecodeError, KeyError) as e:
            logger.error(f"Error processing private message: {e}")

# --- Performance Monitoring ---
class PerformanceMonitor:
    """Track and analyze bot performance metrics"""
    def __init__(self):
        self.metrics = {
            'api_requests': deque(maxlen=10000),
            'orders_placed': deque(maxlen=10000),
            'orders_filled': deque(maxlen=10000),
            'orders_cancelled': deque(maxlen=10000),
            'pnl': deque(maxlen=10000),
            'spread': deque(maxlen=10000),
            'latency': deque(maxlen=10000),
            'inventory': deque(maxlen=10000)
        }
        self.start_time = time.time()
        
    def record_metric(self, metric_name: str, value: Any = 1):
        """Record a metric value"""
        if metric_name in self.metrics:
            if isinstance(value, (int, float, Decimal)):
                self.metrics[metric_name].append(value)
            else:
                self.metrics[metric_name].append(1)
    
    def get_metric_stats(self, metric_name: str) -> Dict[str, Any]:
        """Get statistics for a metric"""
        if metric_name not in self.metrics or not self.metrics[metric_name]:
            return {}
        values = list(self.metrics[metric_name])
        return {
            'count': len(values),
            'mean': statistics.mean(values) if values else 0,
            'median': statistics.median(values) if values else 0,
            'min': min(values) if values else 0,
            'max': max(values) if values else 0,
            'stddev': statistics.stdev(values) if len(values) > 1 else 0,
            'last': values[-1] if values else 0
        }
    
    def get_uptime(self) -> str:
        """Get current uptime in human-readable format"""
        uptime = time.time() - self.start_time
        hours, remainder = divmod(uptime, 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{int(hours)}h {int(minutes)}m {int(seconds)}s"
    
    def generate_report(self) -> str:
        """Generate performance report"""
        report = [
            "\n=== Performance Report ===",
            f"Uptime: {self.get_uptime()}",
            f"API Requests: {self.get_metric_stats('api_requests')['count']}",
            f"Orders Placed: {self.get_metric_stats('orders_placed')['count']}",
            f"Orders Filled: {self.get_metric_stats('orders_filled')['count']}",
            f"Orders Cancelled: {self.get_metric_stats('orders_cancelled')['count']}",
            f"Current PnL: ${self.get_metric_stats('pnl')['last']:.2f}",
            f"Avg Spread: {self.get_metric_stats('spread')['mean']:.4f} bps",
            f"Avg Order Latency: {self.get_metric_stats('latency')['mean']*1000:.2f} ms",
            f"Current Inventory: {self.get_metric_stats('inventory')['last']:.6f}",
            "========================="
        ]
        return "\n".join(report)

# --- Circuit Breaker for Risk Management ---
class CircuitBreaker:
    """Prevent trading during extreme conditions"""
    def __init__(self, max_failures: int = 5, reset_timeout: int = 300):
        self.failure_count = 0
        self.max_failures = max_failures
        self.reset_timeout = reset_timeout
        self.last_failure_time = 0
        self.state = "CLOSED"  # CLOSED, OPEN, HALF-OPEN
        
    def record_failure(self):
        """Record a system failure"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        if self.failure_count >= self.max_failures:
            self.state = "OPEN"
            logger.critical("Circuit breaker triggered! Trading halted.")
            
    def record_success(self):
        """Record a successful operation"""
        self.failure_count = 0
        self.state = "CLOSED"
        
    def allow_trading(self) -> bool:
        """Determine if trading should be allowed"""
        if self.state == "CLOSED":
            return True
        if self.state == "OPEN":
            # Check if reset timeout has passed
            if time.time() - self.last_failure_time > self.reset_timeout:
                self.state = "HALF_OPEN"
                logger.warning("Circuit breaker in HALF-OPEN state. Limited trading allowed.")
                return True
            return False
        # HALF-OPEN state - allow one order through for testing
        self.state = "CLOSED"
        logger.info("Circuit breaker reset to CLOSED state after successful operation.")
        return True

# --- Main Bot Implementation ---
class MarketMakingBot:
    """Advanced market making bot with improved architecture"""
    def __init__(self, api_client: APIClient, state_manager: StateManager, symbol: str,
                 base_qty: Decimal, order_levels: int = 5, spread_bps: Decimal = Decimal('0.05'),
                 inventory_target_base: Decimal = Decimal('0'), risk_params: Dict[str, Any] = None):
        self.api_client = api_client
        self.state_manager = state_manager
        self.symbol = symbol
        self.base_qty = base_qty
        self.order_levels = order_levels
        self.initial_spread_bps = spread_bps