/**
 * üåä WHALEWAVE PRO - TITAN EDITION (Final Optimized with Configurable WSS)
 * ----------------------------------------------------------------------
 * - FEATURE: Weighted Signal Scoring (WSS) parameters are now loaded from config.json.
 * - Robustness: All previous stability fixes are maintained.
 */

/**
 * üåä WHALEWAVE PRO - TITAN EDITION (Final Optimized with Configurable WSS)
 * ----------------------------------------------------------------------
 * - FEATURE: Weighted Signal Scoring (WSS) parameters are now loaded from config.json.
 * - Robustness: All previous stability fixes are maintained.
 * - NEW FEATURE: Trade History Tracker for Paper Trading.
 */

import axios from 'axios';
import chalk from 'chalk';
import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';
import fs from 'fs';
import { setTimeout } from 'timers/promises';
import { Decimal } from 'decimal.js';
import TradeHistory from './trade_history.js'; // Import TradeHistory

dotenv.config();

// --- ‚öôÔ∏è CONFIGURATION ---
const CONFIG_FILE = 'config.json';
const DEFAULTS = {
    symbol: 'BTCUSDT',
    interval: '3',
    trend_interval: '15',
    limit: 300,
    loop_delay: 15,
    gemini_model: 'gemini-1.5-flash',
    min_confidence: 0.60,
    paper_trading: {
        initial_balance: 1000.00,
        risk_percent: 1.0,
        leverage_cap: 10,
        fee: 0.00055
    },
    indicators: {
        // Standard Indicators
        rsi: 14, stoch_period: 14, stoch_k: 3, stoch_d: 3,
        cci_period: 14,
        macd_fast: 12, macd_slow: 26, macd_sig: 9,
        adx_period: 14,

        // Advanced Indicators
        mfi: 14, chop_period: 14, linreg_period: 20,
        bb_period: 20, bb_std: 2.0, kc_period: 20, kc_mult: 1.5,
        atr_period: 14, st_factor: 3.0, ce_period: 22, ce_mult: 3.0,
        
        // NEW: WSS Weighting Configuration
        wss_weights: {
            trend_mtf_weight: 2.0,
            trend_scalp_weight: 1.5,
            extreme_rsi_mfi_weight: 1.0,
            extreme_stoch_weight: 0.5,
            momentum_regime_weight: 1.0,
            squeeze_vol_weight: 0.5,
            action_threshold: 1.0
        }
    },
    orderbook: {
        depth: 50,
        wall_threshold: 5.0,
        support_resistance_levels: 5
    }
};

let config = DEFAULTS;
if (fs.existsSync(CONFIG_FILE)) {
    try {
        const userConfig = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf-8'));
        // Deep merge for indicators and wss_weights
        config = { 
            ...DEFAULTS, 
            ...userConfig, 
            indicators: { 
                ...DEFAULTS.indicators, 
                ...userConfig.indicators,
                wss_weights: {
                    ...DEFAULTS.indicators.wss_weights,
                    ...(userConfig.indicators ? userConfig.indicators.wss_weights : {})
                }
            }
        };
    } catch (e) {
        console.error(chalk.red("Config Error: Using defaults."));
    }
} else {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(DEFAULTS, null, 2));
}

Decimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_DOWN });

// --- üé® THEME ---
const NEON = {
    GREEN: chalk.hex('#39FF14'),
    RED: chalk.hex('#FF073A'),
    BLUE: chalk.hex('#00FFFF'),
    PURPLE: chalk.hex('#BC13FE'),
    YELLOW: chalk.hex('#FAED27'),
    ORANGE: chalk.hex('#FF9F00'),
    GRAY: chalk.hex('#666666'),
    BOLD: chalk.bold
};

// --- üìê ADVANCED TA LIBRARY (All functions stable) ---
class TA {
    static safeArr(len) { return new Array(Math.floor(len)).fill(0); }
    static wilders(data, period) {
        if (!data || data.length < period) return TA.safeArr(data.length);
        let result = TA.safeArr(data.length);
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        result[period - 1] = sum / period;
        const alpha = 1 / period;
        for (let i = period; i < data.length; i++) {
            result[i] = (data[i] * alpha) + (result[i - 1] * (1 - alpha));
        }
        return result;
    }
    static sma(data, period) {
        if (!data || data.length < period) return TA.safeArr(data.length);
        let result = [];
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        result.push(sum / period);
        for (let i = period; i < data.length; i++) {
            sum += data[i] - data[i - period];
            result.push(sum / period);
        }
        return TA.safeArr(period - 1).concat(result);
    }
    static ema(data, period) {
        if (!data || data.length === 0) return [];
        let result = TA.safeArr(data.length);
        const k = 2 / (period + 1);
        result[0] = data[0];
        for (let i = 1; i < data.length; i++) {
            result[i] = (data[i] * k) + (result[i - 1] * (1 - k));
        }
        return result;
    }
    static atr(highs, lows, closes, period) {
        let tr = [0];
        for (let i = 1; i < closes.length; i++) tr.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
        return this.wilders(tr, period);
    }
    static rsi(closes, period) {
        let gains = [0], losses = [0];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? Math.abs(diff) : 0);
        }
        const avgGain = this.wilders(gains, period);
        const avgLoss = this.wilders(losses, period);
        return closes.map((_, i) => avgLoss[i] === 0 ? 100 : 100 - (100 / (1 + avgGain[i] / avgLoss[i]))); 
    }
    static mfi(highs, lows, closes, volumes, period) {
        let posFlow = [], negFlow = [];
        for (let i = 0; i < closes.length; i++) {
            if (i === 0) { posFlow.push(0); negFlow.push(0); continue; }
            const tp = (highs[i] + lows[i] + closes[i]) / 3;
            const prevTp = (highs[i-1] + lows[i-1] + closes[i-1]) / 3;
            const raw = tp * volumes[i];
            if (tp > prevTp) { posFlow.push(raw); negFlow.push(0); }
            else if (tp < prevTp) { posFlow.push(0); negFlow.push(raw); }
            else { posFlow.push(0); negFlow.push(0); }
        }
        let result = TA.safeArr(closes.length);
        for (let i = period - 1; i < closes.length; i++) {
            let pSum = 0, nSum = 0;
            for (let j = 0; j < period; j++) {
                pSum += posFlow[i-j];
                nSum += negFlow[i-j];
            }
            if (nSum === 0) result[i] = 100;
            else result[i] = 100 - (100 / (1 + (pSum / nSum)));
        }
        return result;
    }
    static stoch(highs, lows, closes, period, kP, dP) {
        let rsi = TA.safeArr(closes.length);
        for (let i = period - 1; i < closes.length; i++) {
            const sliceH = highs.slice(i - period + 1, i + 1);
            const sliceL = lows.slice(i - period + 1, i + 1);
            const minL = Math.min(...sliceL);
            const maxH = Math.max(...sliceH);
            rsi[i] = (maxH - minL === 0) ? 0 : 100 * ((closes[i] - minL) / (maxH - minL));
        }
        const k = this.sma(rsi, kP);
        const d = this.sma(k, dP);
        return { k, d };
    }
    static cci(highs, lows, closes, period) {
        const tp = highs.map((h, i) => (h + lows[i] + closes[i]) / 3);
        const smaTp = this.sma(tp, period);
        let cci = TA.safeArr(closes.length);
        for (let i = period - 1; i < tp.length; i++) {
            let meanDev = 0;
            for (let j = 0; j < period; j++) meanDev += Math.abs(tp[i - j] - smaTp[i]);
            meanDev /= period;
            cci[i] = (meanDev === 0) ? 0 : (tp[i] - smaTp[i]) / (0.015 * meanDev);
        }
        return cci;
    }
    static macd(closes, fast, slow, sig) {
        const emaFast = this.ema(closes, fast);
        const emaSlow = this.ema(closes, slow);
        const line = emaFast.map((v, i) => v - emaSlow[i]);
        const signal = this.ema(line, sig);
        return { line, signal, hist: line.map((v, i) => v - signal[i]) };
    }
    static adx(highs, lows, closes, period) {
        let plusDM = [0], minusDM = [0];
        for (let i = 1; i < closes.length; i++) {
            const up = highs[i] - highs[i - 1];
            const down = lows[i - 1] - lows[i];
            plusDM.push(up > down && up > 0 ? up : 0);
            minusDM.push(down > up && down > 0 ? down : 0);
        }
        const sTR = this.wilders(this.atr(highs, lows, closes, 1), period);
        const sPlus = this.wilders(plusDM, period);
        const sMinus = this.wilders(minusDM, period);
        let dx = [];
        for (let i = 0; i < closes.length; i++) {
            const pDI = sTR[i] === 0 ? 0 : (sPlus[i] / sTR[i]) * 100;
            const mDI = sTR[i] === 0 ? 0 : (sMinus[i] / sTR[i]) * 100;
            const sum = pDI + mDI;
            dx.push(sum === 0 ? 0 : (Math.abs(pDI - mDI) / sum) * 100);
        }
        return this.wilders(dx, period);
    }
    static bollinger(closes, period, stdDev) {
        const sma = this.sma(closes, period);
        let upper = [], lower = [], middle = sma;
        for (let i = 0; i < closes.length; i++) {
            if (i < period - 1) { upper.push(0); lower.push(0); continue; }
            let sumSq = 0;
            for (let j = 0; j < period; j++) sumSq += Math.pow(closes[i - j] - sma[i], 2);
            const std = Math.sqrt(sumSq / period);
            upper.push(sma[i] + (std * stdDev));
            lower.push(sma[i] - (std * stdDev));
        }
        return { upper, middle, lower };
    }
    static keltner(highs, lows, closes, period, mult) {
        const ema = this.ema(closes, period);
        const atr = this.atr(highs, lows, closes, period);
        return {
            upper: ema.map((e, i) => e + atr[i] * mult),
            lower: ema.map((e, i) => e - atr[i] * mult),
            middle: ema
        };
    }
    static linReg(closes, period) {
        let slopes = TA.safeArr(closes.length), r2s = TA.safeArr(closes.length);
        let sumX = 0, sumX2 = 0;
        for (let i = 0; i < period; i++) { sumX += i; sumX2 += i * i; }
        for (let i = period - 1; i < closes.length; i++) {
            let sumY = 0, sumXY = 0, sumY2 = 0;
            const ySlice = [];
            for (let j = 0; j < period; j++) {
                const val = closes[i - (period - 1) + j];
                ySlice.push(val);
                sumY += val;
                sumXY += j * val;
                sumY2 += val * val;
            }
            const n = period;
            const num = (n * sumXY) - (sumX * sumY);
            const den = (n * sumX2) - (sumX * sumX);
            const slope = den === 0 ? 0 : num / den;
            const intercept = (sumY - slope * sumX) / n;
            let ssTot = 0, ssRes = 0;
            const yMean = sumY / n;
            for(let j=0; j<period; j++) {
                const y = ySlice[j];
                const yPred = slope * j + intercept;
                ssTot += Math.pow(y - yMean, 2);
                ssRes += Math.pow(y - yPred, 2);
            }
            slopes[i] = slope;
            r2s[i] = ssTot === 0 ? 0 : 1 - (ssRes / ssTot);
        }
        return { slope: slopes, r2: r2s };
    }
    static chop(highs, lows, closes, period) {
        let result = TA.safeArr(closes.length);
        let tr = [highs[0] - lows[0]]; 
        for(let i=1; i<closes.length; i++) tr.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i-1]), Math.abs(lows[i] - closes[i-1])));
        for (let i = period - 1; i < closes.length; i++) {
            let sumTr = 0, maxHi = -Infinity, minLo = Infinity;
            for (let j = 0; j < period; j++) {
                sumTr += tr[i - j];
                if (highs[i - j] > maxHi) maxHi = highs[i - j];
                if (lows[i - j] < minLo) minLo = lows[i - j];
            }
            const range = maxHi - minLo;
            result[i] = (range === 0 || sumTr === 0) ? 0 : 100 * (Math.log10(sumTr / range) / Math.log10(period));
        }
        return result;
    }
    static superTrend(highs, lows, closes, period, factor) {
        const atr = this.atr(highs, lows, closes, period);
        let direction = 1;
        let st = new Array(closes.length).fill(0);
        let upperBand = 0, lowerBand = 0;
        let prevLowerBand = 0, prevUpperBand = 0;
        for (let i = period - 1; i < closes.length; i++) {
            const currentATR = atr[i];
            const currentClose = closes[i];
            if (i === period - 1) {
                upperBand = currentClose + (factor * currentATR);
                lowerBand = currentClose - (factor * currentATR);
                st[i] = currentClose; 
                continue;
            }
            if (currentClose > prevUpperBand) { direction = 1; } 
            else if (currentClose < prevLowerBand) { direction = -1; }
            if (direction === 1) { 
                lowerBand = currentClose - (factor * currentATR);
                upperBand = prevLowerBand + (factor * currentATR); 
                st[i] = (currentClose > prevUpperBand) ? lowerBand : Math.max(lowerBand, prevUpperBand);
            } else { 
                upperBand = currentClose + (factor * currentATR);
                lowerBand = prevUpperBand - (factor * currentATR); 
                st[i] = (currentClose < prevLowerBand) ? upperBand : Math.min(upperBand, prevLowerBand);
            }
            prevUpperBand = upperBand;
            prevLowerBand = lowerBand;
        }
        const trend = st.map((val, i) => (val === 0 ? 0 : (closes[i] > val ? 1 : -1)));
        return { trend, value: st };
    }
    static chandelierExit(highs, lows, closes, period, mult) {
        const atr = this.atr(highs, lows, closes, period);
        let longStop = TA.safeArr(closes.length);
        let shortStop = TA.safeArr(closes.length);
        let longStopPrev = 0, shortStopPrev = 0;
        let trend = 1; 

        for (let i = period - 1; i < closes.length; i++) {
            const currentATR = atr[i];
            const currentHigh = highs[i];
            const currentLow = lows[i];
            const currentClose = closes[i];
            if (i === period - 1) {
                longStopPrev = currentHigh - (mult * currentATR);
                shortStopPrev = currentLow + (mult * currentATR);
                longStop[i] = longStopPrev;
                shortStop[i] = shortStopPrev;
                continue;
            }
            if (currentClose > shortStopPrev) { trend = 1; } 
            else if (currentClose < longStopPrev) { trend = -1; }
            if (trend === 1) { 
                longStopPrev = Math.max(currentHigh - (mult * currentATR), longStopPrev);
                shortStopPrev = currentClose - (mult * currentATR);
            } else { 
                shortStopPrev = Math.min(currentLow + (mult * currentATR), shortStopPrev);
                longStopPrev = currentClose + (mult * currentATR);
            }
            longStop[i] = longStopPrev;
            shortStop[i] = shortStopPrev;
        }
        
        let finalTrend = new Array(closes.length).fill(1);
        for (let i = 1; i < closes.length; i++) {
            if (closes[i] > shortStop[i] && closes[i] > longStop[i]) {
                finalTrend[i] = 1;
            } else if (closes[i] < longStop[i] && closes[i] < shortStop[i]) {
                finalTrend[i] = -1;
            } else {
                finalTrend[i] = finalTrend[i - 1];
            }
        }
        const value = longStop.map((ls, i) => finalTrend[i] === 1 ? ls : shortStop[i]);
        return { trend: finalTrend, value };
    }
    static findFVG(candles) {
        const len = candles.length;
        if (len < 5) return null; 
        const c1 = candles[len - 4];
        const c2 = candles[len - 3]; 
        const c3 = candles[len - 2]; 
        if (c2.c > c2.o && c3.l > c1.h) return { type: 'BULLISH', top: c3.l, bottom: c1.h, price: (c3.l + c1.h) / 2 };
        else if (c2.c < c2.o && c3.h < c1.l) return { type: 'BEARISH', top: c1.l, bottom: c3.h, price: (c1.l + c3.h) / 2 };
        return null;
    }
    static fibPivots(h, l, c) {
        const P = (h + l + c) / 3;
        const R = h - l;
        return {
            P,
            R1: P + 0.382 * R, R2: P + 0.618 * R, R3: P + R,
            S1: P - 0.382 * R, S2: P - 0.618 * R, S3: P - R
        };
    }
}

// --- üì° DATA PROVIDER ---
class DataProvider {
    constructor() {
        this.api = axios.create({ baseURL: 'https://api.bybit.com/v5/market', timeout: 8000 });
    }
    async fetchAll() {
        try {
            const [ticker, kline, klineMTF, ob, daily] = await Promise.all([
                this.api.get('/tickers', { params: { category: 'linear', symbol: config.symbol } }),
                this.api.get('/kline', { params: { category: 'linear', symbol: config.symbol, interval: config.interval, limit: config.limit } }),
                this.api.get('/kline', { params: { category: 'linear', symbol: config.symbol, interval: config.trend_interval, limit: 100 } }),
                this.api.get('/orderbook', { params: { category: 'linear', symbol: config.symbol, limit: config.orderbook.depth } }),
                this.api.get('/kline', { params: { category: 'linear', symbol: config.symbol, interval: 'D', limit: 2 } })
            ]);
            const parseC = (list) => list.reverse().map(c => ({ o: parseFloat(c[1]), h: parseFloat(c[2]), l: parseFloat(c[3]), c: parseFloat(c[4]), v: parseFloat(c[5]) }));
            
            if (!kline.data.result.list || !klineMTF.data.result.list || !daily.data.result.list || daily.data.result.list.length < 2) {
                 throw new Error("Missing critical kline or daily data from API.");
            }

            const prevDay = daily.data.result.list[1];

            return {
                price: parseFloat(ticker.data.result.list[0].lastPrice),
                candles: parseC(kline.data.result.list),
                candlesMTF: parseC(klineMTF.data.result.list),
                bids: ob.data.result.b.map(x => ({ p: parseFloat(x[0]), q: parseFloat(x[1]) })),
                asks: ob.data.result.a.map(x => ({ p: parseFloat(x[0]), q: parseFloat(x[1]) })),
                daily: { h: parseFloat(prevDay[2]), l: parseFloat(prevDay[3]), c: parseFloat(prevDay[4]) }
            };
        } catch (e) { console.warn(NEON.ORANGE(`[WARN] Data Fetch Fail: ${e.message}`)); return null; }
    }
}

// --- üí∞ PAPER EXCHANGE ---
class PaperExchange {
    constructor() {
        this.balance = new Decimal(config.paper_trading.initial_balance);
        this.startBal = this.balance;
        this.pos = null; 
        this.tradeHistory = new TradeHistory(); // Initialize TradeHistory
    }
    evaluate(priceVal, signal) {
        const price = new Decimal(priceVal);
        if (this.pos) {
            let close = false, reason = '';
            const timestamp = new Date().toISOString();
            const entryTimestamp = this.pos.entryTimestamp;

            if (this.pos.side === 'BUY') {
                if (price.lte(this.pos.sl)) { close = true; reason = 'SL Hit'; }
                else if (price.gte(this.pos.tp)) { close = true; reason = 'TP Hit'; }
            } else {
                if (price.gte(this.pos.sl)) { close = true; reason = 'SL Hit'; }
                else if (price.lte(this.pos.tp)) { close = true; reason = 'TP Hit'; }
            }
            if (close) {
                const rawPnl = this.pos.side === 'BUY' ? price.sub(this.pos.entry).mul(this.pos.qty) : this.pos.entry.sub(price).mul(this.pos.qty);
                const fee = price.mul(this.pos.qty).mul(config.paper_trading.fee);
                const netPnl = rawPnl.sub(fee);
                this.balance = this.balance.add(netPnl);

                // Record the closed trade
                const tradeRecord = {
                    id: this.tradeHistory.nextId++,
                    timestamp: timestamp,
                    entryTimestamp: entryTimestamp,
                    symbol: config.symbol,
                    side: this.pos.side,
                    entryPrice: this.pos.entry.toFixed(2),
                    exitPrice: price.toFixed(2),
                    quantity: this.pos.qty,
                    pnl: netPnl.toFixed(2),
                    pnlPercent: netPnl.div(this.pos.entry.mul(this.pos.qty)).mul(100).toFixed(2) + '%',
                    reason: reason,
                    fee: fee.toFixed(2)
                };
                this.tradeHistory.addTrade(tradeRecord);

                console.log(`${NEON.BOLD(reason)}! PnL: ${netPnl.gte(0) ? NEON.GREEN('
 + netPnl.toFixed(2)) : NEON.RED('
 + netPnl.toFixed(2))}`);
                this.pos = null;
            }
        } else if (signal.action !== 'HOLD' && signal.confidence >= config.min_confidence) {
            if (!signal.entry || !signal.sl || !signal.tp) return;
            try {
                const entry = new Decimal(signal.entry);
                const sl = new Decimal(signal.sl);
                const tp = new Decimal(signal.tp);
                const riskAmt = this.balance.mul(config.paper_trading.risk_percent / 100);
                const dist = entry.sub(sl).abs();
                if (dist.isZero()) return; 
                let qty = riskAmt.div(dist);
                const maxQty = this.balance.mul(config.paper_trading.leverage_cap).div(price);
                if (qty.gt(maxQty)) qty = maxQty;
                if (qty.mul(price).lt(10)) { console.log(NEON.GRAY("Trade value too low (<$10). Skipped.")); return; }
                
                const fee = price.mul(qty).mul(config.paper_trading.fee);
                this.balance = this.balance.sub(fee);
                
                this.pos = { side: signal.action, entry, qty, sl, tp, entryTimestamp: new Date().toISOString() };
                console.log(NEON.GREEN(`OPEN ${signal.action} @ ${entry.toFixed(2)} | Size: ${qty.toFixed(4)}`));
            } catch (e) { console.error(e.message); }
        }
    }
}

// --- üß† GEMINI BRAIN ---
class GeminiBrain {
    constructor() {
        const key = process.env.GEMINI_API_KEY;
        if (!key) { console.error("Missing GEMINI_API_KEY"); process.exit(1); }
        this.model = new GoogleGenerativeAI(key).getGenerativeModel({ model: config.gemini_model });
    }

    async analyze(ctx) {
        const prompt = `
        Act as an Institutional Algorithmic Scalper focused on high-probability reversals and breakouts.
        
        MARKET CONTEXT:
        - Current Price: ${ctx.price}
        - Scalp (3m) Metrics: RSI=${ctx.rsi}, MFI=${ctx.mfi}, Chop=${ctx.chop}
        - Trend Strength: LinReg Slope=${ctx.trend_angle}, R2=${ctx.trend_quality} | ADX=${ctx.adx}
        - Momentum Detail: Stoch K/D=${ctx.stoch_k}/${ctx.stoch_d}, CCI=${ctx.cci}, MACD Hist=${ctx.macd_hist}
        - Structure: MTF Trend=${ctx.trend_mtf}, FVG=${ctx.fvg ? ctx.fvg.type + ' @ ' + ctx.fvg.price.toFixed(2) : 'NONE'}
        - Volatility Check: Squeeze Active? ${ctx.squeeze ? 'YES (Explosion Imminent)' : 'NO'}
        - **Trend Confirmation:** Chandelier=${ctx.chandelierExit}, ST=${ctx.superTrend}
        - Order Flow: Approaching Buy Wall @ ${ctx.walls.buy || 'N/A'} | Approaching Sell Wall @ ${ctx.walls.sell || 'N/A'}
        - **Key Levels:** FibPivots: P=${ctx.fibs.P}, S1=${ctx.fibs.S1}, R1=${ctx.fibs.R1} | Orderbook S/R: ${ctx.sr_levels}
        - **Quantitative Bias Score (WSS):** ${ctx.wss} (Positive = Bullish, Negative = Bearish)

        DECISION REGIME (Must choose one based on Chop/ADX):
        1. MOMENTUM: Chop < 40 AND ADX > 25. Strategy: Trade in direction of WSS. Use FVG/Chande SL/TP.
        2. MEAN REVERSION: Chop > 60 OR ADX < 20. Strategy: Trade in direction of WSS ONLY if WSS >= 3.0 (Bullish) or WSS <= -3.0 (Bearish). Fade extreme RSI/Stoch/CCI levels using Fibs/Walls as entry/exit.
        3. NOISE/WAIT: Chop 40-60 OR WSS near zero. Strategy: HOLD.

        CRITICAL RULE: WSS score must align with the attempted trade action. (i.e., WSS >= 1.0 for BUY).

        OUTPUT VALID JSON ONLY: { "action": "BUY"|"SELL"|"HOLD", "confidence": 0.0-1.0, "entry": number, "sl": number, "tp": number, "reason": "string" }
        `;

        const WSS_THRESHOLD = config.indicators.wss_weights.action_threshold;

        try {
            const res = await this.model.generateContent(prompt);
            let text = res.response.text();
            const firstBrace = text.indexOf('{');
            const lastBrace = text.lastIndexOf('}');
            if (firstBrace >= 0 && lastBrace > firstBrace) {
                text = text.substring(firstBrace, lastBrace + 1);
            }
            const parsed = JSON.parse(text);
            
            // CRITICAL RULE IMPLEMENTATION (External Gate)
            if (parsed.action === 'BUY' && parsed.confidence > 0 && ctx.wss < WSS_THRESHOLD) {
                 return { action: "HOLD", confidence: 0, reason: `WSS (${ctx.wss}) did not meet minimum threshold (${WSS_THRESHOLD}) for BUY action.` };
            }
            if (parsed.action === 'SELL' && parsed.confidence > 0 && ctx.wss > -WSS_THRESHOLD) {
                 return { action: "HOLD", confidence: 0, reason: `WSS (${ctx.wss}) did not meet minimum threshold (-${WSS_THRESHOLD}) for SELL action.` };
            }

            if (parsed.action !== 'HOLD' && (typeof parsed.entry !== 'number' || typeof parsed.sl !== 'number' || typeof parsed.tp !== 'number')) {
                 return { action: "HOLD", confidence: 0, reason: "AI returned non-numeric SL/TP/Entry." };
            }
            return parsed;
        } catch (e) {
            return { action: "HOLD", confidence: 0, reason: `AI Communication/Parsing Failure: ${e.message}` };
        }
    }
}

// --- üõ†Ô∏è UTILITIES & INITIALIZATION ---
const dp = new DataProvider();
const ex = new PaperExchange();
const ai = new GeminiBrain();

const logger = {
    box: (title, lines) => {
        const border = NEON.GRAY('‚îÄ'.repeat(60));
        console.log(border);
        console.log(chalk.bgHex('#222')(NEON.PURPLE.bold(` ${title} `.padEnd(60))));
        console.log(border);
        lines.forEach(l => console.log(l));
        console.log(border);
    }
};

function getOrderbookLevels(bids, asks, currentClose, maxLevels) {
    const pricePoints = [...bids.map(b => b.p), ...asks.map(a => a.p)];
    const uniquePrices = [...new Set(pricePoints)].sort((a, b) => a - b);
    let potentialSR = [];
    for (const price of uniquePrices) {
        let bidVolAtPrice = bids.filter(b => b.p === price).reduce((s, b) => s + b.q, 0);
        let askVolAtPrice = asks.filter(a => a.p === price).reduce((s, a) => s + a.q, 0);
        if (bidVolAtPrice > askVolAtPrice * 2) potentialSR.push({ price, type: 'S' });
        else if (askVolAtPrice > bidVolAtPrice * 2) potentialSR.push({ price, type: 'R' });
    }
    const sortedByDist = potentialSR.sort((a, b) => Math.abs(a.price - currentClose) - Math.abs(b.price - currentClose));
    const supportLevels = sortedByDist.filter(p => p.type === 'S' && p.price < currentClose).slice(0, maxLevels).map(p => p.price.toFixed(2));
    const resistanceLevels = sortedByDist.filter(p => p.type === 'R' && p.price > currentClose).slice(0, maxLevels).map(p => p.price.toFixed(2));
    return { supportLevels, resistanceLevels };
}

// --- WSS Calculation ---
function calculateWSS(analysis) {
    const w = config.indicators.wss_weights;
    let score = 0;
    const last = analysis.closes.length - 1;

    // --- 1. Primary Trend (MTF) ---
    score += (analysis.trendMTF === 'BULLISH' ? w.trend_mtf_weight : -w.trend_mtf_weight);

    // --- 2. Scalp Trend Confluence ---
    if (analysis.st.trend[last] === 1) score += w.trend_scalp_weight; else score -= w.trend_scalp_weight;
    if (analysis.ce.trend[last] === 1) score += w.trend_scalp_weight; else score -= w.trend_scalp_weight;

    // --- 3. Momentum Extremes (Mean Reversion Bias) ---
    const rsi = analysis.rsi[last];
    const mfi = analysis.mfi[last];
    if (rsi < 30 || mfi < 30) score += w.extreme_rsi_mfi_weight; 
    if (rsi > 70 || mfi > 70) score -= w.extreme_rsi_mfi_weight;
    
    const stoch_k = analysis.stoch.k[last];
    const stoch_d = analysis.stoch.d[last];
    if (stoch_k < 20 && stoch_d < 20) score += w.extreme_stoch_weight;
    if (stoch_k > 80 && stoch_d > 80) score -= w.extreme_stoch_weight;

    // --- 4. Regime/Vol (Momentum Bias) ---
    const chop = analysis.chop[last];
    const adx = analysis.adx[last];
    if (chop < 40 && adx > 25) score += (analysis.reg.slope[last] > 0 ? w.momentum_regime_weight : -w.momentum_regime_weight);

    // --- 5. Volatility (Squeeze) ---
    if (analysis.isSqueeze) score += (analysis.trendMTF === 'BULLISH' ? w.squeeze_vol_weight : -w.squeeze_vol_weight); 
    
    return parseFloat(score.toFixed(2));
}

// Function to safely extract the final value of an indicator array/object
function getFinalValue(analysis, dataKey, precision = 2) {
    const last = analysis.closes.length - 1;
    const data = analysis[dataKey];
    
    if (Array.isArray(data)) {
        return data[last]?.toFixed(precision) || TA.safeArr(1)[0].toFixed(precision);
    } else if (data && typeof data === 'object' && data.hasOwnProperty('k')) {
        return { k: data.k[last]?.toFixed(0) || '0', d: data.d[last]?.toFixed(0) || '0' };
    } else if (data && typeof data === 'object' && data.hasOwnProperty('hist')) {
        return data.hist[last]?.toFixed(precision) || '0.0000';
    } else if (data && typeof data === 'object' && data.hasOwnProperty('trend')) {
        return data.trend[last] === 1 ? 'BULLISH' : 'BEARISH';
    } else if (data && typeof data === 'object' && data.hasOwnProperty('slope')) { // For linReg
        return { slope: data.slope[last]?.toFixed(precision) || '0.00', r2: data.r2[last]?.toFixed(precision) || '0.00' };
    }
    return 'N/A';
}

function buildContext(d, analysis) {
    const atrVal = analysis.atr[analysis.closes.length - 1] || 1; 
    const wallFilter = (wallPrice) => wallPrice !== null && Math.abs(d.price - wallPrice) < (atrVal * 3); 

    const sr = getOrderbookLevels(d.bids, d.asks, d.price, config.orderbook.support_resistance_levels);
    const srString = `S:[${sr.supportLevels.join(', ')}] R:[${sr.resistanceLevels.join(', ')}]`;

    const wss = calculateWSS(analysis);
    const linRegFinal = getFinalValue(analysis, 'reg', 4); // Get slope/r2

    return {
        symbol: d.price,
        price: d.price,
        // Standard
        rsi: getFinalValue(analysis, 'rsi', 2),
        stoch_k: getFinalValue(analysis, 'stoch').k,
        stoch_d: getFinalValue(analysis, 'stoch').d,
        cci: getFinalValue(analysis, 'cci', 2),
        macd_hist: getFinalValue(analysis, 'macd', 4),
        adx: getFinalValue(analysis, 'adx', 2),
        // Advanced
        mfi: getFinalValue(analysis, 'mfi', 2),
        chop: getFinalValue(analysis, 'chop', 2),
        trend_angle: linRegFinal.slope,
        trend_quality: linRegFinal.r2,
        trend_mtf: analysis.trendMTF,
        squeeze: analysis.isSqueeze,
        fvg: analysis.fvg,
        superTrend: getFinalValue(analysis, 'st'),
        chandelierExit: getFinalValue(analysis, 'ce'),
        // Levels
        walls: {
            buy: wallFilter(analysis.buyWall) ? analysis.buyWall : null,
            sell: wallFilter(analysis.sellWall) ? analysis.sellWall : null
        },
        fibs: analysis.fibs,
        sr_levels: srString,
        wss: wss
    };
}

// --- üîÑ MAIN EXECUTION LOOP ---
async function mainLoop() {
    try {
        const d = await dp.fetchAll();
        if (!d) { await setTimeout(5000); return mainLoop(); }

        const closes = d.candles.map(c => c.c);
        const highs = d.candles.map(c => c.h);
        const lows = d.candles.map(c => c.l);
        const volumes = d.candles.map(c => c.v);
        const mtfCloses = d.candlesMTF.map(c => c.c);

        // --- 1. Calculate All Indicators ---
        const rsi = TA.rsi(closes, config.indicators.rsi);
        const stoch = TA.stoch(highs, lows, closes, config.indicators.stoch_period, config.indicators.stoch_k, config.indicators.stoch_d);
        const cci = TA.cci(highs, lows, closes, config.indicators.cci_period);
        const macd = TA.macd(closes, config.indicators.macd_fast, config.indicators.macd_slow, config.indicators.macd_sig);
        const adx = TA.adx(highs, lows, closes, config.indicators.adx_period);

        const mfi = TA.mfi(highs, lows, closes, volumes, config.indicators.mfi);
        const chop = TA.chop(highs, lows, closes, config.indicators.chop_period);
        const reg = TA.linReg(closes, config.indicators.linreg_period);
        const bb = TA.bollinger(closes, config.indicators.bb_period, config.indicators.bb_std);
        const kc = TA.keltner(highs, lows, closes, config.indicators.kc_period, config.indicators.kc_mult);
        const atr = TA.atr(highs, lows, closes, config.indicators.atr_period);
        const fvg = TA.findFVG(d.candles);
        const st = TA.superTrend(highs, lows, closes, config.indicators.atr_period, config.indicators.st_factor);
        const ce = TA.chandelierExit(highs, lows, closes, config.indicators.ce_period, config.indicators.ce_mult);
        const fibs = TA.fibPivots(d.daily.h, d.daily.l, d.daily.c);
        
        // MTF Trend
        const mtfSma = TA.sma(mtfCloses, 20);
        const trendMTF = mtfCloses[mtfCloses.length-1] > mtfSma[mtfSma.length-1] ? "BULLISH" : "BEARISH";

        // --- 2. Advanced Logic Analysis ---
        const last = closes.length - 1;
        const isSqueeze = (bb.upper[last] < kc.upper[last]) && (bb.lower[last] > kc.lower[last]);

        // --- 3. Orderbook Wall Detection ---
        const avgBid = d.bids.reduce((s, b) => s + b.q, 0) / d.bids.length;
        const avgAsk = d.asks.reduce((s, a) => s + a.q, 0) / d.asks.length;
        const wallThresh = config.orderbook.wall_threshold;
        const buyWall = d.bids.find(b => b.q > avgBid * wallThresh);
        const sellWall = d.asks.find(a => a.q > avgAsk * wallThresh);

        const analysis = { closes, rsi, stoch, cci, macd, adx, mfi, chop, reg, atr, fvg, isSqueeze, buyWall: buyWall?.p, sellWall: sellWall?.p, trendMTF, st, ce, fibs };
        const ctx = buildContext(d, analysis);
        
        // --- 4. AI Signal & Execution ---
        console.clear();
        
        const regimeColor = ctx.chop > 60 ? NEON.BLUE : ctx.chop < 40 ? NEON.GREEN : NEON.GRAY;
        const regimeTxt = ctx.chop > 60 ? "MEAN REVERSION" : ctx.chop < 40 ? "MOMENTUM" : "NOISE/HOLD";
        const sqzTxt = isSqueeze ? NEON.RED("üî• ACTIVE") : NEON.GRAY("Inactive");
        
        logger.box(`WHALEWAVE TITAN | ${d.price.toFixed(2)}`, [
            `Regime: ${regimeColor(regimeTxt)} | MTF: ${ctx.trend_mtf === 'BULLISH' ? NEON.GREEN(ctx.trend_mtf) : NEON.RED(ctx.trend_mtf)} | WSS: ${ctx.wss}`,
            `RSI: ${ctx.rsi} | MFI: ${ctx.mfi} | Chop: ${ctx.chop} | ADX: ${ctx.adx}`,
            `Stoch: ${ctx.stoch_k}/${ctx.stoch_d} | CCI: ${ctx.cci} | MACD Hist: ${ctx.macd_hist}`,
            `ST: ${ctx.superTrend} | CE: ${ctx.chandelierExit} | Squeeze: ${sqzTxt}`,
            `FVG: ${ctx.fvg ? NEON.YELLOW(ctx.fvg.type + ' @ ' + ctx.fvg.price.toFixed(2)) : 'None'}`,
            `Key Levels: P=${ctx.fibs.P.toFixed(2)} | S1=${ctx.fibs.S1.toFixed(2)} | R1=${ctx.fibs.R1.toFixed(2)}`,
            `S/R: ${ctx.sr_levels}`
        ]);

        const sig = await ai.analyze(ctx);
        const col = sig.action === 'BUY' ? NEON.GREEN : sig.action === 'SELL' ? NEON.RED : NEON.GRAY;
        console.log(`SIGNAL: ${col(sig.action)} (${(sig.confidence * 100).toFixed(0)}%)`);
        console.log(chalk.dim(sig.reason));

        ex.evaluate(d.price, sig);
        
        if(ex.pos) {
            const curPnl = ex.pos.side==='BUY' ? new Decimal(d.price).sub(ex.pos.entry) : ex.pos.entry.sub(new Decimal(d.price));
            const pnlVal = curPnl.mul(ex.pos.qty);
            const pnlCol = pnlVal.gte(0) ? NEON.GREEN : NEON.RED;
            console.log(`${NEON.BLUE('POS:')} ${ex.pos.side} @ ${ex.pos.entry.toFixed(2)} | SL: ${ex.pos.sl.toFixed(2)} | TP: ${ex.pos.tp.toFixed(2)} | PnL: ${pnlCol(pnlVal.toFixed(2))}`);
        } else {
            console.log(`Balance: ${ex.balance.toFixed(2)}`);
        }

    } catch (error) {
        console.error(NEON.RED("\nFATAL LOOP ERROR (Script will attempt to restart):"));
        console.error(error);
    } finally {
        await setTimeout(config.loop_delay * 1000);
        mainLoop();
    }
}

// --- üõë SHUTDOWN HANDLERS ---
const shutdown = () => {
    console.log('\n');
    console.log(NEON.RED("üõë SHUTDOWN INITIATED..."));
    const pnl = ex.balance.sub(ex.startBal);
    const pnlColor = pnl.gte(0) ? NEON.GREEN : NEON.RED;
    // Use TradeHistory's displaySummary for a more detailed output
    ex.tradeHistory.displaySummary(); 
    console.log(`Final Balance: ${ex.balance.toFixed(2)}`);
    console.log(`Total PnL:     ${pnlColor('
 + pnl.toFixed(2))}\n`);
    console.log(`Active Pos:    ${ex.pos ? NEON.YELLOW('YES - Manual Exit Required') : NEON.GREEN('NO')}`);
    process.exit(0);
};
process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);

// --- START ---
console.log(NEON.BLUE("Booting WhaleWave Scalping Engine...")); 
mainLoop();
