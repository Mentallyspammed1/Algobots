const fs = require('fs');
const path = require('path');

// Define the file path
const filePath = 'whalewave1.4.js';

// Read the file content
let code = fs.readFileSync(filePath, 'utf-8');

// --- Apply Upgrades ---

// 1. Error Handling for axios and config
code = code.replace(
    'constructor() {',
    `constructor() {
                     if (typeof axios === 'undefined') throw new Error("axios is required but not loaded.");
                     if (typeof config === 'undefined') throw new Error("config is required but not loaded.");`
);
code = code.replace(
    'constructor() {',
    `constructor() {
                     if (typeof config === 'undefined') throw new Error("config is required.");
                     if (typeof Decimal === 'undefined') throw new Error("Decimal.js is required.");
                     if (typeof NEON === 'undefined') console.warn("NEON is not defined. Using default console colors.");`
);
code = code.replace(
    'constructor() {',
    `constructor() {
                     if (typeof GoogleGenerativeAI === 'undefined') throw new Error("GoogleGenerativeAI is required.");
                     if (typeof config === 'undefined') throw new Error("config is required.");
                     if (typeof NEON === 'undefined') console.warn("NEON is not defined. Using default console colors.");`
);

// 2. Improved fetchWithRetry Error Messages
code = code.replace(
    'console.error(`Fetch attempt ${attempt + 1}/${retries + 1} failed: ${error.message}`);',
    `console.error(\`Fetch attempt \\${attempt + 1}/\\${retries + 1} for ${this.api.defaults.baseURL}${url} failed: \\${error.message}\\`);`
);
code = code.replace(
    'console.error(`Failed to fetch ${url} after ${retries + 1} attempts.`);',
    `console.error(\`Failed to fetch ${this.api.defaults.baseURL}${url} after \\${retries + 1} attempts.\`);`
);

// 3. API Error Code Handling
code = code.replace(
    'if (response.data && response.data.retCode !== 0) {',
    `if (response.data && response.data.retCode !== 0) {                            throw new Error(\`API Error: \\${response.data.retMsg} (Code: \\${response.data.retCode})\`);
                                 }`
);

// 4. Candle Data Validation
code = code.replace(
    'return {',
    `// Validate fetched data structure before parsing
                     if (!ticker?.result?.list?.[0] || !kline?.result?.list || !klineMTF?.result?.list || !ob?.result?.b || !ob?.result?.a || !daily?.result?.list?.[1]) {
                         console.error("Incomplete data received from API.");
                         return null;
                     }

                     return {`
);

// 5. calculateWSS Robustness
code = code.replace(
    'function calculateWSS(analysis, currentPrice) {',
    `function calculateWSS(analysis, currentPrice) {
                     // Ensure config is available and has the necessary structure
                     if (typeof config === 'undefined' || !config.indicators || !config.indicators.wss_weights) {
                         console.error("Configuration for WSS weights is missing.");
                         return 0; // Return a neutral score or throw an error
                     }
                     const w = config.indicators.wss_weights;
                     let score = 0;
                     const last = analysis.closes.length - 1;

                     // Check if required analysis data exists and has enough points
                     if (!analysis || !analysis.closes || last < 0) {
                         console.error("Insufficient data for WSS calculation.");
                         return 0;
                     }

                     const { rsi, stoch, macd, reg, st, ce, fvg, divergence, buyWall, sellWall, atr } = analysis;

                     // --- Trend Score ---
                     let trendScore = 0;
                     // Higher weight for longer-term trend (MTF)
                     if (analysis.trendMTF) {
                         trendScore += (analysis.trendMTF === 'BULLISH' ? w.trend_mtf_weight : -w.trend_mtf_weight);
                     }
                     // Add weights for shorter-term trends (scalp)
                     if (st && st.trend && st.trend[last] !== undefined) {
                         trendScore += (st.trend[last] === 1 ? w.trend_scalp_weight : -w.trend_scalp_weight);
                     }
                     if (ce && ce.trend && ce.trend[last] !== undefined) {
                         trendScore += (ce.trend[last] === 1 ? w.trend_scalp_weight : -w.trend_scalp_weight);
                     }
                     // Multiply by regression slope (r2) for trend strength confirmation
                     if (reg && reg.r2 && reg.r2[last] !== undefined) {
                         trendScore *= reg.r2[last];
                     }
                     score += trendScore;

                     // --- Momentum Score ---
                     let momentumScore = 0;
                     const rsiVal = rsi && rsi[last] !== undefined ? rsi[last] : 50; // Default to 50 if RSI is missing
                     const stochK = stoch && stoch.k && stoch.k[last] !== undefined ? stoch.k[last] : 50; // Default to 50 if StochK is missing

                     // Normalize RSI momentum: higher score for oversold, lower for overbought
                     if (rsiVal < 50) momentumScore += (50 - rsiVal) / 50; else momentumScore -= (rsiVal - 50) / 50;
                     // Normalize Stochastic momentum
                     if (stochK < 50) momentumScore += (50 - stochK) / 50; else momentumScore -= (stochK - 50) / 50;

                     // Add MACD histogram weight
                     const macdHist = macd && macd.hist && macd.hist[last] !== undefined ? macd.hist[last] : 0;
                     if (macdHist > 0) momentumScore += w.macd_weight; else if (macdHist < 0) momentumScore -= w.macd_weight;

                     // Apply normalized momentum weight
                     score += momentumScore * w.momentum_normalized_weight;

                     // --- Structure Score ---
                     let structureScore = 0;
                     // Squeeze indicator: positive for bullish, negative for bearish
                     if (analysis.isSqueeze && analysis.isSqueeze[last]) {
                         structureScore += (analysis.trendMTF === 'BULLISH' ? w.squeeze_vol_weight : -w.squeeze_vol_weight);
                     }
                     // Divergence: positive for bullish, negative for bearish
                     if (divergence && divergence.includes('BULLISH')) structureScore += w.divergence_weight;
                     else if (divergence && divergence.includes('BEARISH')) structureScore -= w.divergence_weight;

                     const price = currentPrice;
                     const atrVal = atr && atr[last] !== undefined ? atr[last] : 1; // Default ATR to 1
                     // Fair Value Gap (FVG) analysis: reward for price interacting with FVG in trend direction
                     if (fvg && fvg.length > 0 && fvg[0].price) { // Assuming fvg is an array with the latest FVG at index 0
                         if (fvg[0].type === 'BULLISH' && price > fvg[0].bottom && price < fvg[0].top) structureScore += w.liquidity_grab_weight;
                         else if (fvg[0].type === 'BEARISH' && price < fvg[0].top && price > fvg[0].bottom) structureScore -= w.liquidity_grab_weight;
                     }
                     // Liquidity grab near buy/sell walls, adjusted by ATR
                     if (buyWall && (price - buyWall) < atrVal) structureScore += w.liquidity_grab_weight * 0.5;
                     else if (sellWall && (sellWall - price) < atrVal) structureScore -= w.liquidity_grab_weight * 0.5;
                     score += structureScore;

                     // --- Volatility Adjustment ---
                     const volatility = analysis.volatility && analysis.volatility[analysis.volatility.length - 1] !== undefined ? analysis.volatility[analysis.volatility.length - 1] : 0;
                     const avgVolatility = analysis.avgVolatility && analysis.avgVolatility[analysis.avgVolatility.length - 1] !== undefined ? analysis.avgVolatility[analysis.avgVolatility.length - 1] : 1; // Default to 1
                     const volRatio = avgVolatility === 0 ? 1 : volatility / avgVolatility; // Avoid division by zero

                     let finalScore = score;
                     // Reduce score in high volatility, increase in low volatility
                     if (volRatio > 1.5) finalScore *= (1 - w.volatility_weight);
                     else if (volRatio < 0.5) finalScore *= (1 + w.volatility_weight);

                     return parseFloat(finalScore.toFixed(2));
                 }`
);

// 6. EnhancedGeminiBrain Robustness
code = code.replace(
    'const key = process.env.GEMINI_API_KEY;',
    `const key = process.env.GEMINI_API_KEY;
                     if (!key) {
                         console.error("Missing GEMINI_API_KEY environment variable.");
                         process.exit(1); // Exit if API key is critical
                     }`
);
code = code.replace(
    'const text = res.response.text();',
    `const text = res.response.text();

                     // Clean up the response text to extract JSON
                     const jsonMatch = text.match(/\\{[\\s\\S]*\\}/);
                     if (!jsonMatch) {
                         console.error("Gemini AI response did not contain valid JSON:", text);
                         return { action: 'HOLD', strategy: 'AI_ERROR', confidence: 0, entry: 0, sl: 0, tp: 0, reason: 'Invalid AI response format' };
                     }

                     const signal = JSON.parse(jsonMatch[0]);

                     // Validate the parsed signal structure
                     if (!signal || typeof signal.action === 'undefined' || typeof signal.strategy === 'undefined' || typeof signal.confidence === 'undefined') {
                         console.error("Parsed signal is missing required fields:", signal);
                         return { action: 'HOLD', strategy: 'AI_ERROR', confidence: 0, entry: 0, sl: 0, tp: 0, reason: 'Invalid signal structure from AI' };
                     }

                     // Ensure numerical values are valid numbers, default to 0 if not
                     signal.confidence = typeof signal.confidence === 'number' && !isNaN(signal.confidence) ? signal.confidence : 0;
                     signal.entry = typeof signal.entry === 'number' && !isNaN(signal.entry) ? signal.entry : 0;
                     signal.sl = typeof signal.sl === 'number' && !isNaN(signal.sl) ? signal.sl : 0;
                     signal.tp = typeof signal.tp === 'number' && !isNaN(signal.tp) ? signal.tp : 0;

                     // Apply critical WSS filter
                     const wssThreshold = config.indicators.wss_weights.action_threshold;
                     if (signal.action === 'BUY' && ctx.wss < wssThreshold) {
                         signal.action = 'HOLD';
                         signal.reason = \`WSS (\${ctx.wss}) below BUY threshold (\${wssThreshold})\`;
                     } else if (signal.action === 'SELL' && ctx.wss > -wssThreshold) {
                         signal.action = 'HOLD';
                         signal.reason = \`WSS (\${ctx.wss}) above SELL threshold (\${-wssThreshold})\`;
                     }

                     // Add default reason if missing
                     if (!signal.reason) {
                         signal.reason = signal.action === 'HOLD' ? 'No clear signal or WSS filter applied.' : \`Strategy: \${signal.strategy}\`;
                     }

                     return signal;`
);
code = code.replace(
    `catch (error) {                                                        console.error("Error generating content from Gemini AI:", error);                                                               return { action: 'HOLD', strategy: 'AI_ERROR', confidence: 0, entry: 0, sl: 0, tp: 0, reason: \`Gemini API error: \${error.message}\` };                                                    }`,
    `catch (error) {                                                        console.error(\`Error generating content from Gemini AI:\`, error);                                                             return { action: 'HOLD', strategy: 'AI_ERROR', confidence: 0, entry: 0, sl: 0, tp: 0, reason: \`Gemini API error: \${error.message}\` };                                                    }`
);

// 7. TradingEngine Error Handling
code = code.replace(
    'await setTimeout(this.loopDelay);',
    `// ... (rest of the try block) ...
                                     } catch (error) {
                                        console.error(NEON.RED.bold(\`\\nüö® ENGINE ERROR: \${error.message}\`));
                                        console.error(error.stack); // Log the stack trace for debugging
                                        // Optionally, implement more robust error handling like restarting the engine
                                     }
                                    await setTimeout(this.loopDelay);`
);

// 8. calculateIndicators Promise.all
code = code.replace(
    'const [rsi, stoch, macd, adx, mfi, chop, reg, bb, kc, atr, fvg, vwap, st, ce, cci] = await Promise.all([',
    'const [rsi, stoch, macd, adx, mfi, chop, reg, bb, kc, atr, fvg, vwap, st, ce, cci] = await Promise.all(['
);
code = code.replace(
    'TA.rsi(c, config.indicators.rsi),',
    'TA.rsi(c, config.indicators.rsi),'
);

// 9. Removed unused TA methods (marketRegime and fibPivots) - NOTE: These were not found in the provided code, so this step is skipped.
// If they were present, the code would look something like this:
// code = code.replace(/TA\.marketRegime(.*)\s*,\s*/g, '');
// code = code.replace(/TA\.fibPivots(.*)\s*,\s*/g, '');

// 10. Colorization of vwap and trend_angle
code = code.replace(
    'if (key === \'macd_hist\' || key === \'trend_angle\') {',
    'if (key === \'macd_hist\') { // Keep existing colorization for macd_hist'
);
code = code.replace(
    'return NEON.CYAN(v.toFixed(2));',
    `if (key === 'vwap') {
             return NEON.CYAN(v.toFixed(4));
        }
        // Add specific colorization for trend_angle if it's not already handled
        if (key === 'trend_angle') {
             return this.colorizeValue(v, 'trend_angle'); // Re-use existing logic for trend_angle colorization
        }
        return NEON.CYAN(v.toFixed(2));`
);
code = code.replace(
    'console.log(`MTF Trend: ${trendCol(ctx.trend_mtf)} | Slope: ${this.colorizeValue(ctx.trend_angle, \'trend_angle\')} | ADX: ${this.colorizeValue(ctx.adx, \'adx\')}`);',
    `console.log(\`MTF Trend: \${trendCol(ctx.trend_mtf)} | Slope: \${this.colorizeValue(ctx.trend_angle, 'trend_angle')} | ADX: \${this.colorizeValue(ctx.adx, 'adx')}\`);`
);
code = code.replace(
    'console.log(`Divergence: ${divCol(ctx.divergence)} | FVG: ${ctx.fvg ? NEON.YELLOW(ctx.fvg.type) : \'None\'} | VWAP: ${this.colorizeValue(ctx.vwap, \'vwap\')}`);',
    `console.log(\`Divergence: \${divCol(ctx.divergence)} | FVG: \${ctx.fvg ? NEON.YELLOW(ctx.fvg.type) : 'None'} | VWAP: \${this.colorizeValue(ctx.vwap, 'vwap')}\`);`
);


// 11. Clearer Console Output
code = code.replace(
    'console.log(NEON.GREEN.bold("üöÄ WHALEWAVE TITAN v6.1 STARTED..."));',
    `console.clear();
                     console.log(NEON.GREEN.bold("üöÄ WHALEWAVE TITAN v6.1 STARTED..."));`
);

// Write the modified code back to the file
fs.writeFileSync(filePath, code, 'utf-8');

console.log('Upgrades applied successfully to whalewave1.4.js');
/**
 * üåä WHALEWAVE PRO - TITAN EDITION v6.1 (Bugfix & Final Polish)
 * ----------------------------------------------------------------------
 * - BUGFIX: Resolved 'NEON.CYAN is not a function' error.
 * - TUNING: Optimized parameters and WSS weights for 3m scalping profile.
 * - AESTHETICS: Full NEON colorization of all displayed metrics.
 */

import axios from 'axios';
import chalk from 'chalk';
import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';
import fs from 'fs';
import { setTimeout } from 'timers/promises';
import { Decimal } from 'decimal.js';

dotenv.config();

// --- ‚öôÔ∏è ENHANCED CONFIGURATION MANAGER (from v6.0) ---
class ConfigManager {
    static CONFIG_FILE = 'config.json';
    static DEFAULTS = {
        symbol: 'BTCUSDT', interval: '3', trend_interval: '15', limit: 300,
        loop_delay: 4, gemini_model: 'gemini-1.5-flash', min_confidence: 0.75,
        risk: { max_drawdown: 10.0, daily_loss_limit: 5.0, max_positions: 1, },
        paper_trading: { initial_balance: 1000.00, risk_percent: 2.0, leverage_cap: 10, fee: 0.00055, slippage: 0.0001 },
        indicators: {
            rsi: 10, stoch_period: 10, stoch_k: 3, stoch_d: 3, cci_period: 10,
            macd_fast: 12, macd_slow: 26, macd_sig: 9, adx_period: 14,
            mfi: 10, chop_period: 14, linreg_period: 15, vwap_period: 20,
            bb_period: 20, bb_std: 2.0, kc_period: 20, kc_mult: 1.5,
            atr_period: 14, st_factor: 2.5, ce_period: 22, ce_mult: 3.0,
            wss_weights: {
                trend_mtf_weight: 2.2, trend_scalp_weight: 1.2,
                momentum_normalized_weight: 1.8, macd_weight: 1.0,
                regime_weight: 0.8, squeeze_vol_weight: 1.0,
                liquidity_grab_weight: 1.5, divergence_weight: 2.5,
                volatility_weight: 0.5, action_threshold: 2.0
            }
        },
        orderbook: { depth: 50, wall_threshold: 3.0, sr_levels: 5 },
        api: { timeout: 8000, retries: 3, backoff_factor: 2 }
    };

    static load() {
        let config = { ...this.DEFAULTS };
        if (fs.existsSync(this.CONFIG_FILE)) {
            try {
                const userConfig = JSON.parse(fs.readFileSync(this.CONFIG_FILE, 'utf-8'));
                config = this.deepMerge(config, userConfig);
            } catch (e) { console.error(chalk.red(`Config Error: ${e.message}`)); }
        } else {
            fs.writeFileSync(this.CONFIG_FILE, JSON.stringify(this.DEFAULTS, null, 2));
        }
        return config;
    }

    static deepMerge(target, source) {
        const result = { ...target };
        for (const key in source) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                result[key] = this.deepMerge(result[key] || {}, source[key]);
            } else { result[key] = source[key]; }
        }
        return result;
    }
}

const config = ConfigManager.load();
Decimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_DOWN });

// --- üé® THEME MANAGER (CYAN ADDED) ---
const NEON = {
    GREEN: chalk.hex('#39FF14'), RED: chalk.hex('#FF073A'), BLUE: chalk.hex('#00AFFF'),
    CYAN: chalk.hex('#00FFFF'),
    PURPLE: chalk.hex('#BC1FE'), YELLOW: chalk.hex('#FAED27'), GRAY: chalk.hex('#666666'),
    ORANGE: chalk.hex('#FF9F00'), BOLD: chalk.bold,
    bg: (text) => chalk.bgHex('#222')(text)
};

// --- üìê COMPLETE TECHNICAL ANALYSIS LIBRARY (from v6.0) ---
class TA {
    static safeArr(len) { return new Array(Math.floor(len)).fill(0); }
    static getFinalValue(data, key, precision = 2) {
        if (!data.closes || data.closes.length === 0) return 'N/A';
        const last = data.closes.length - 1;
        const value = data[key];
        if (Array.isArray(value)) return value[last]?.toFixed(precision) || '0.00';
        if (typeof value === 'object') {
            if (value.k) return { k: value.k[last]?.toFixed(0), d: value.d[last]?.toFixed(0) };
            if (value.hist) return value.hist[last]?.toFixed(precision);
            if (value.slope) return { slope: value.slope[last]?.toFixed(precision), r2: value.r2[last]?.toFixed(precision) };
            if (value.trend) return value.trend[last] === 1 ? 'BULL' : 'BEAR';
        }
        return 'N/A';
    }
    static sma(data, period) {
        if (!data || data.length < period) return TA.safeArr(data.length);
        let result = []; let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        result.push(sum / period);
        for (let i = period; i < data.length; i++) { sum += data[i] - data[i - period]; result.push(sum / period); }
        return TA.safeArr(period - 1).concat(result);
    }
    static ema(data, period) {
        if (!data || data.length === 0) return [];
        let result = TA.safeArr(data.length);
        const k = 2 / (period + 1); result[0] = data[0];
        for (let i = 1; i < data.length; i++) result[i] = (data[i] * k) + (result[i - 1] * (1 - k));
        return result;
    }
    static wilders(data, period) {
        if (!data || data.length < period) return TA.safeArr(data.length);
        let result = TA.safeArr(data.length); let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        result[period - 1] = sum / period;
        const alpha = 1 / period;
        for (let i = period; i < data.length; i++) result[i] = (data[i] * alpha) + (result[i - 1] * (1 - alpha));
        return result;
    }

    static atr(highs, lows, closes, period) {
        let tr = [0];
        for (let i = 1; i < closes.length; i++) tr.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
        return this.wilders(tr, period);
    }
    static rsi(closes, period) {
        let gains = [0], losses = [0];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0); losses.push(diff < 0 ? Math.abs(diff) : 0);
        }
        const avgGain = this.wilders(gains, period);
        const avgLoss = this.wilders(losses, period);
        return closes.map((_, i) => avgLoss[i] === 0 ? 100 : 100 - (100 / (1 + avgGain[i] / avgLoss[i])));
    }
    static stoch(highs, lows, closes, period, kP, dP) {
        let rsi = TA.safeArr(closes.length);
        for (let i = period - 1; i < closes.length; i++) {
            const sliceH = highs.slice(i - period + 1, i + 1); const sliceL = lows.slice(i - period + 1, i + 1);
            const minL = Math.min(...sliceL); const maxH = Math.max(...sliceH);
            rsi[i] = (maxH - minL === 0) ? 0 : 100 * ((closes[i] - minL) / (maxH - minL));
        }
        const k = this.sma(rsi, kP); const d = this.sma(k, dP); return { k, d };
    }
    static macd(closes, fast, slow, sig) {
        const emaFast = this.ema(closes, fast); const emaSlow = this.ema(closes, slow);
        const line = emaFast.map((v, i) => v - emaSlow[i]); const signal = this.ema(line, sig);
        return { line, signal, hist: line.map((v, i) => v - signal[i]) };
    }
    static adx(highs, lows, closes, period) {
        let plusDM = [0], minusDM = [0];
        for (let i = 1; i < closes.length; i++) {
            const up = highs[i] - highs[i - 1]; const down = lows[i - 1] - lows[i];
            plusDM.push(up > down && up > 0 ? up : 0); minusDM.push(down > up && down > 0 ? down : 0);
        }
        const sTR = this.wilders(this.atr(highs, lows, closes, 1), period);
        const sPlus = this.wilders(plusDM, period); const sMinus = this.wilders(minusDM, period);
        let dx = [];
        for (let i = 0; i < closes.length; i++) {
            const pDI = sTR[i] === 0 ? 0 : (sPlus[i] / sTR[i]) * 100; const mDI = sTR[i] === 0 ? 0 : (sMinus[i] / sTR[i]) * 100;
            const sum = pDI + mDI;
            dx.push(sum === 0 ? 0 : (Math.abs(pDI - mDI) / sum) * 100);
        }
        return this.wilders(dx, period);
    }
    static mfi(h,l,c,v,p) {
        let posFlow = [], negFlow = [];
        for (let i = 0; i < c.length; i++) {
            if (i === 0) { posFlow.push(0); negFlow.push(0); continue; }
            const tp = (h[i] + l[i] + c[i]) / 3; const prevTp = (h[i-1] + l[i-1] + c[i-1]) / 3;
            const raw = tp * v[i];
            if (tp > prevTp) { posFlow.push(raw); negFlow.push(0); }
            else if (tp < prevTp) { posFlow.push(0); negFlow.push(raw); }
            else { posFlow.push(0); negFlow.push(0); }
        }
        let result = TA.safeArr(c.length);
        for (let i = p - 1; i < c.length; i++) {
            let pSum = 0, nSum = 0;
            for (let j = 0; j < p; j++) { pSum += posFlow[i-j]; nSum += negFlow[i-j]; }
            if (nSum === 0) result[i] = 100; else result[i] = 100 - (100 / (1 + (pSum / nSum)));
        }
        return result;
    }
    static chop(h, l, c, p) {
        let result = TA.safeArr(c.length);
        let tr = [h[0] - l[0]];
        for(let i=1; i<c.length; i++) tr.push(Math.max(h[i] - l[i], Math.abs(h[i] - c[i-1]), Math.abs(l[i] - c[i-1])));
        for (let i = p - 1; i < c.length; i++) {
            let sumTr = 0, maxHi = -Infinity, minLo = Infinity;
            for (let j = 0; j < p; j++) {
                sumTr += tr[i - j];
                if (h[i - j] > maxHi) maxHi = h[i - j];
                if (l[i - j] < minLo) minLo = l[i - j];
            }
            const range = maxHi - minLo;
            result[i] = (range === 0 || sumTr === 0) ? 0 : 100 * (Math.log10(sumTr / range) / Math.log10(p));
        }
        return result;
    }
    static cci(highs, lows, closes, period) {
        const tp = highs.map((h, i) => (h + lows[i] + closes[i]) / 3; const smaTp = this.sma(tp, period);
        let cci = TA.safeArr(closes.length);
        for (let i = period - 1; i < tp.length; i++) {
            let meanDev = 0; for (let j = 0; j < period; j++) meanDev += Math.abs(tp[i - j] - smaTp[i]);
            meanDev /= period;
            cci[i] = (meanDev === 0) ? 0 : (tp[i] - smaTp[i]) / (0.015 * meanDev);
        }
        return cci;
    }
    static linReg(closes, period) {
        let slopes = TA.safeArr(closes.length), r2s = TA.safeArr(closes.length);
        let sumX = 0, sumX2 = 0;
        for (let i = 0; i < period; i++) { sumX += i; sumX2 += i * i; }
        for (let i = period - 1; i < closes.length; i++) {
            let sumY = 0, sumXY = 0;
            const ySlice = [];
            for (let j = 0; j < period; j++) {
                const val = closes[i - (period - 1) + j]; ySlice.push(val); sumY += val; sumXY += j * val;
            }
            const n = period;
            const num = (n * sumXY) - (sumX * sumY);
            const den = (n * sumX2) - (sumX * sumX);
            const slope = den === 0 ? 0 : num / den;
            const intercept = (sumY - slope * sumX) / n;
            let ssTot = 0, ssRes = 0;
            const yMean = sumY / n;
            for(let j=0; j<period; j++) {
                const y = ySlice[j]; const yPred = slope * j + intercept;
                ssTot += Math.pow(y - yMean, 2); ssRes += Math.pow(y - yPred, 2);
            }
            slopes[i] = slope; r2s[i] = ssTot === 0 ? 0 : 1 - (ssRes / ssTot);
        }
        return { slope: slopes, r2: r2s };
    }
    static bollinger(closes, period, stdDev) {
        const sma = this.sma(closes, period);
        let upper = [], lower = [], middle = sma;
        for (let i = 0; i < closes.length; i++) {
            if (i < period - 1) { upper.push(0); lower.push(0); continue; }
            let sumSq = 0;
            for (let j = 0; j < period; j++) sumSq += Math.pow(closes[i] - sma[i], 2);
            const std = Math.sqrt(sumSq / period);
            upper.push(sma[i] + (std * stdDev)); lower.push(sma[i] - (std * stdDev));
        }
        return { upper, middle, lower };
    }
    static keltner(highs, lows, closes, period, mult) {
        const ema = this.ema(closes, period); const atr = this.atr(highs, lows, closes, period);
        return { upper: ema.map((e, i) => e + atr[i] * mult), lower: ema.map((e, i) => e - atr[i] * mult), middle: ema };
    }
    static superTrend(highs, lows, closes, period, factor) {
        const atr = this.atr(highs, lows, closes, period);
        let st = new Array(closes.length).fill(0); let trend = new Array(closes.length).fill(1);
        for (let i = period; i < closes.length; i++) {
            let up = (highs[i] + lows[i]) / 2 + factor * atr[i];
            let dn = (highs[i] + lows[i]) / 2 - factor * atr[i];
            if (i > 0) {
                const prevST = st[i-1];
                if (trend[i-1] === 1) { up = up; dn = Math.max(dn, prevST); } else { up = Math.min(up, prevST); dn = dn; }
            }
            if (closes[i] > up) trend[i] = 1; else if (closes[i] < dn) trend[i] = -1; else trend[i] = trend[i-1];
            st[i] = trend[i] === 1 ? dn : up;
        }
        return { trend, value: st };
    }
    static chandelierExit(highs, lows, closes, period, mult) {
        const atr = this.atr(highs, lows, closes, period);
        let longStop = TA.safeArr(closes.length); let shortStop = TA.safeArr(closes.length);
        let trend = new Array(closes.length).fill(1);
        for (let i = period; i < closes.length; i++) {
            const maxHigh = Math.max(...highs.slice(i - period + 1, i + 1));
            const minLow = Math.min(...lows.slice(i - period + 1, i + 1));
            longStop[i] = maxHigh - atr[i] * mult; shortStop[i] = minLow + atr[i] * mult;
            if (closes[i] > shortStop[i]) trend[i] = 1; else if (closes[i] < longStop[i]) trend[i] = -1; else trend[i] = trend[i-1];
        }
        return { trend, value: trend.map((t, i) => t === 1 ? longStop[i] : shortStop[i]) };
    }
    static vwap(h, l, c, v, p) {
        let vwap = TA.safeArr(c.length);
        for (let i = p - 1; i < c.length; i++) {
            let sumPV = 0, sumV = 0;
            for (let j = 0; j < p; j++) {
                const tp = (h[i-j] + l[i-j] + c[i-j]) / 3; sumPV += tp * v[i-j]; sumV += v[i-j];
            }
            vwap[i] = sumV === 0 ? 0 : sumPV / sumV;
        }
        return vwap;
    }
    static findFVG(candles) {
        const len = candles.length;
        if (len < 5) return null;
        const c1 = candles[len - 4]; const c2 = candles[len - 3]; const c3 = candles[len - 2];
        if (c2.c > c2.o && c3.l > c1.h) return { type: 'BULLISH', top: c3.l, bottom: c1.h, price: (c3.l + c1.h) / 2 };
        else if (c2.c < c2.o && c3.h < c1.l) return { type: 'BEARISH', top: c1.l, bottom: c3.h, price: (c1.l + c3.h) / 2 };
        return null;
    }
    static detectDivergence(closes, rsi, period = 5) {
        const len = closes.length;
        if (len < period * 2) return 'NONE';
        const priceHigh = Math.max(...closes.slice(len - period, len)); const rsiHigh = Math.max(...rsi.slice(len - period, len));
        const prevPriceHigh = Math.max(...closes.slice(len - period * 2, len - period)); const prevRsiHigh = Math.max(...rsi.slice(len - period * 2, len - period));
        if (priceHigh > prevPriceHigh && rsiHigh < prevRsiHigh) return 'BEARISH_REGULAR';
        const priceLow = Math.min(...closes.slice(len - period, len)); const rsiLow = Math.min(...rsi.slice(len - period, len));
        const prevPriceLow = Math.min(...closes.slice(len - period * 2, len - period)); const prevRsiLow = Math.min(...rsi.slice(len - period * 2, len - period));
        if (priceLow < prevPriceLow && rsiLow > prevRsiLow) return 'BULLISH_REGULAR';
        return 'NONE';
    }

    /**
     * Calculates the trend direction based on moving averages.
     * @param {number[]} closes - Array of closing prices.
     * @param {number} shortPeriod - The period for the short-term moving average.
     * @param {number} longPeriod - The period for the long-term moving average.
     * @returns {number} 1 for bullish, -1 for bearish, 0 for neutral.
     */
    static trendDirection(closes, shortPeriod, longPeriod) {
        if (closes.length < Math.max(shortPeriod, longPeriod)) {
            return 0; // Not enough data
        }
        const shortMA = TA.ema(closes, shortPeriod);
        const longMA = TA.ema(closes, longPeriod);

        const lastShortMA = shortMA[shortMA.length - 1];
        const lastLongMA = longMA[longMA.length - 1];

        if (lastShortMA > lastLongMA) return 1; // Bullish
        if (lastShortMA < lastLongMA) return -1; // Bearish
        return 0; // Neutral
    }

    /**
     * Calculates the slope of a linear regression line.
     * @param {number[]} y - The dependent variable (e.g., prices).
     * @param {number} n - The number of data points (period).
     * @returns {number} The slope of the regression line.
     */
    static regressionSlope(y, n) {
        if (y.length < n) return 0;
        const x = Array.from({ length: n }, (_, i) => i + 1); // Independent variable (time)
        const ySlice = y.slice(-n);

        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumX2 = 0;

        for (let i = 0; i < n; i++) {
            sumX += x[i];
            sumY += ySlice[i];
            sumXY += x[i] * ySlice[i];
            sumX2 += x[i] * x[i];
        }

        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return isNaN(slope) ? 0 : slope;
    }

    /**
     * Calculates the R-squared value for a linear regression.
     * @param {number[]} y - The dependent variable (e.g., prices).
     * @param {number} n - The number of data points (period).
     * @returns {number} The R-squared value.
     */
    static regressionR2(y, n) {
        if (y.length < n) return 0;
        const ySlice = y.slice(-n);
        const slope = TA.regressionSlope(ySlice, n);
        const x = Array.from({ length: n }, (_, i) => i + 1);

        let sumY = 0;
        for (let i = 0; i < n; i++) {
            sumY += ySlice[i];
        }
        const meanY = sumY / n;

        let ssRes = 0; // Sum of squares of residuals
        let ssTot = 0; // Total sum of squares

        for (let i = 0; i < n; i++) {
            const meanX = (n + 1) / 2;
            const intercept = meanY - slope * meanX;
            const predictedYLinear = intercept + slope * x[i];

            ssRes += Math.pow(ySlice[i] - predictedYLinear, 2);
            ssTot += Math.pow(ySlice[i] - meanY, 2);
        }

        if (ssTot === 0) return 1; // Avoid division by zero if all y values are the same
        const r2 = 1 - (ssRes / ssTot);
        return isNaN(r2) ? 0 : r2;
    }
    // Placeholder for marketRegime - needs implementation based on chosen logic
    static marketRegime(closes, volatility) {
        // Example: Simple regime based on volatility
        const lastVol = volatility[volatility.length - 1];
        const avgVolatility = TA.sma(volatility, 50);
        const avgVol = avgVolatility && avgVolatility.length > 50 ? avgVolatility[50] : 1; // Default to 1 if not enough data
        if (lastVol > avgVol * 1.5) return "HIGH_VOLATILITY";
        if (lastVol < avgVol * 0.5) return "LOW_VOLATILITY";
        return "NORMAL_VOLATILITY";
    }
    // Placeholder for fibPivots - needs implementation
    static fibPivots(high, low, close) {
        // This is a simplified example. Real pivot calculation is more complex.
        const p = (high + low + close) / 3;
        const r1 = (2 * p) - low;
        const s1 = (2 * p) - high;
        return { P: p, R1: r1, S1: s1 };
    }
     // Placeholder for historicalVolatility - needs implementation
    static historicalVolatility(closes) {
        const period = 20; // Example period
        if (closes.length < period) return TA.safeArr(closes.length);
        const logReturns = closes.map((c, i, arr) => i > 0 ? Math.log(c / arr[i-1]) : 0).slice(1);
        // Calculate standard deviation of log returns, then approximate annualized volatility
        const meanLogReturn = logReturns.reduce((a, b) => a + b, 0) / logReturns.length;
        const variance = logReturns.reduce((a, b) => a + Math.pow(b - meanLogReturn, 2), 0) / logReturns.length;
        const stdDev = Math.sqrt(variance);
        // Approximate annualized volatility (assuming daily data and ~252 trading days)
        const annualizedVolatility = stdDev * Math.sqrt(252);
        return TA.safeArr(period - 1).concat(new Array(logReturns.length).fill(annualizedVolatility)); // Return consistent length
    }
}


// --- üõ†Ô∏è UTILITIES & WSS CALCULATOR (from v5.0) ---

/**
 * Determines potential support and resistance levels from order book data.
 * @param {Array<{p: number, q: number}>} bids - Array of bid orders.
 * @param {Array<{p: number, q: number}>} asks - Array of ask orders.
 * @param {number} currentClose - The current closing price.
 * @param {number} maxLevels - The maximum number of support/resistance levels to return.
 * @returns {{supportLevels: string[], resistanceLevels: string[]}} An object containing arrays of support and resistance levels.
 */
function getOrderbookLevels(bids, asks, currentClose, maxLevels) {
    const pricePoints = [...bids.map(b => b.p), ...asks.map(a => a.p)];
    const uniquePrices = [...new Set(pricePoints)].sort((a, b) => a - b);
    let potentialSR = [];

    for (const price of uniquePrices) {
        let bidVolAtPrice = bids.filter(b => b.p === price).reduce((s, b) => s + b.q, 0);
        let askVolAtPrice = asks.filter(a => a.p === price).reduce((s, a) => s + a.q, 0);
        // Identify potential support if bid volume is significantly higher than ask volume
        if (bidVolAtPrice > askVolAtPrice * 2) potentialSR.push({ price, type: 'S' });
        // Identify potential resistance if ask volume is significantly higher than bid volume
        else if (askVolAtPrice > bidVolAtPrice * 2) potentialSR.push({ price, type: 'R' });
    }

    // Sort potential levels by their distance from the current close price
    const sortedByDist = potentialSR.sort((a, b) => Math.abs(a.price - currentClose) - Math.abs(b.price - currentClose));

    // Filter for support levels below the current close and take the top `maxLevels`
    const supportLevels = sortedByDist.filter(p => p.type === 'S' && p.price < currentClose).slice(0, maxLevels).map(p => p.price.toFixed(2));
    // Filter for resistance levels above the current close and take the top `maxLevels`
    const resistanceLevels = sortedByDist.filter(p => p.type === 'R' && p.price > currentClose).slice(0, maxLevels).map(p => p.price.toFixed(2));

    return { supportLevels, resistanceLevels };
}

/**
 * Calculates a Weighted Sentiment Score (WSS) based on various technical indicators.
 * @param {object} analysis - An object containing all calculated technical indicators.
 * @param {number} currentPrice - The current market price.
 * @returns {number} The calculated WSS.
 */
function calculateWSS(analysis, currentPrice) {
    // Ensure config is available and has the necessary structure
    if (typeof config === 'undefined' || !config.indicators || !config.indicators.wss_weights) {
        console.error("Configuration for WSS weights is missing.");
        return 0; // Return a neutral score or throw an error
    }
    const w = config.indicators.wss_weights;
    let score = 0;
    const last = analysis.closes.length - 1;

    // Check if required analysis data exists and has enough points
    if (!analysis || !analysis.closes || last < 0) {
        console.error("Insufficient data for WSS calculation.");
        return 0;
    }

    const { rsi, stoch, macd, reg, st, ce, fvg, divergence, buyWall, sellWall, atr } = analysis;

    // --- Trend Score ---
    let trendScore = 0;
    // Higher weight for longer-term trend (MTF)
    if (analysis.trendMTF) {
        trendScore += (analysis.trendMTF === 'BULLISH' ? w.trend_mtf_weight : -w.trend_mtf_weight);
    }
    // Add weights for shorter-term trends (scalp)
    if (st && st.trend && st.trend[last] !== undefined) {
        trendScore += (st.trend[last] === 1 ? w.trend_scalp_weight : -w.trend_scalp_weight);
    }
    if (ce && ce.trend && ce.trend[last] !== undefined) {
        trendScore += (ce.trend[last] === 1 ? w.trend_scalp_weight : -w.trend_scalp_weight);
    }
    // Multiply by regression slope (r2) for trend strength confirmation
    if (reg && reg.r2 && reg.r2[last] !== undefined) {
        trendScore *= reg.r2[last];
    }
    score += trendScore;

    // --- Momentum Score ---
    let momentumScore = 0;
    const rsiVal = rsi && rsi[last] !== undefined ? rsi[last] : 50; // Default to 50 if RSI is missing
    const stochK = stoch && stoch.k && stoch.k[last] !== undefined ? stoch.k[last] : 50; // Default to 50 if StochK is missing

    // Normalize RSI momentum: higher score for oversold, lower for overbought
    if (rsiVal < 50) momentumScore += (50 - rsiVal) / 50; else momentumScore -= (rsiVal - 50) / 50;
    // Normalize Stochastic momentum
    if (stochK < 50) momentumScore += (50 - stochK) / 50; else momentumScore -= (stochK - 50) / 50;

    // Add MACD histogram weight
    const macdHist = macd && macd.hist && macd.hist[last] !== undefined ? macd.hist[last] : 0;
    if (macdHist > 0) momentumScore += w.macd_weight; else if (macdHist < 0) momentumScore -= w.macd_weight;

    // Apply normalized momentum weight
    score += momentumScore * w.momentum_normalized_weight;

    // --- Structure Score ---
    let structureScore = 0;
    // Squeeze indicator: positive for bullish, negative for bearish
    if (analysis.isSqueeze && analysis.isSqueeze[last]) {
        structureScore += (analysis.trendMTF === 'BULLISH' ? w.squeeze_vol_weight : -w.squeeze_vol_weight);
    }
    // Divergence: positive for bullish, negative for bearish
    if (divergence && divergence.includes('BULLISH')) structureScore += w.divergence_weight;
    else if (divergence && divergence.includes('BEARISH')) structureScore -= w.divergence_weight;

    const price = currentPrice;
    const atrVal = atr && atr[last] !== undefined ? atr[last] : 1; // Default ATR to 1
    // Fair Value Gap (FVG) analysis: reward for price interacting with FVG in trend direction
    if (fvg && fvg.length > 0 && fvg[0].price) { // Assuming fvg is an array with the latest FVG at index 0
        if (fvg[0].type === 'BULLISH' && price > fvg[0].bottom && price < fvg[0].top) structureScore += w.liquidity_grab_weight;
        else if (fvg[0].type === 'BEARISH' && price < fvg[0].top && price > fvg[0].bottom) structureScore -= w.liquidity_grab_weight;
    }
    // Liquidity grab near buy/sell walls, adjusted by ATR
    if (buyWall && (price - buyWall) < atrVal) structureScore += w.liquidity_grab_weight * 0.5;
    else if (sellWall && (sellWall - price) < atrVal) structureScore -= w.liquidity_grab_weight * 0.5;
    score += structureScore;

    // --- Volatility Adjustment ---
    const volatility = analysis.volatility && analysis.volatility[analysis.volatility.length - 1] !== undefined ? analysis.volatility[analysis.volatility.length - 1] : 0;
    const avgVolatility = analysis.avgVolatility && analysis.avgVolatility[analysis.avgVolatility.length - 1] !== undefined ? analysis.avgVolatility[analysis.avgVolatility.length - 1] : 1; // Default to 1
    const volRatio = avgVolatility === 0 ? 1 : volatility / avgVolatility; // Avoid division by zero

    let finalScore = score;
    // Reduce score in high volatility, increase in low volatility
    if (volRatio > 1.5) finalScore *= (1 - w.volatility_weight);
    else if (volRatio < 0.5) finalScore *= (1 + w.volatility_weight);

    return parseFloat(finalScore.toFixed(2));
}

// --- üì° ENHANCED DATA PROVIDER (from v6.0) ---
class EnhancedDataProvider {
    constructor() {
        // Ensure axios is available
        if (typeof axios === 'undefined') {
            throw new Error("axios is required but not loaded.");
        }
        // Ensure config is available
        if (typeof config === 'undefined') {
            throw new Error("config is required but not loaded.");
        }
        this.api = axios.create({ baseURL: 'https://api.bybit.com/v5/market', timeout: config.api.timeout });
    }

    /**
     * Fetches data from the API with retry logic.
     * @param {string} url - The API endpoint URL.
     * @param {object} params - The request parameters.
     * @param {number} [retries=config.api.retries] - The number of retry attempts.
     * @returns {Promise<object>} The API response data.
     * @throws {Error} If fetching fails after all retries.
     */
    async fetchWithRetry(url, params, retries = config.api.retries) {
        for (let attempt = 0; attempt <= retries; attempt++) {
            try {
                const response = await this.api.get(url, { params });
                // Check for API errors in the response structure
                if (response.data && response.data.retCode !== 0) {
                    throw new Error(`API Error: ${response.data.retMsg} (Code: ${response.data.retCode})`);
                }
                return response.data;
            } catch (error) {
                console.error(`Fetch attempt ${attempt + 1}/${retries + 1} failed: ${error.message}`);
                if (attempt === retries) {
                    console.error(`Failed to fetch ${url} after ${retries + 1} attempts.`);
                    throw error; // Re-throw the last error
                }
                // Exponential backoff
                const delay = Math.pow(config.api.backoff_factor, attempt) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    /**
     * Fetches all necessary data for analysis.
     * @returns {Promise<object|null>} An object containing fetched data or null if fetching fails.
     */
    async fetchAll() {
        try {
            const [ticker, kline, klineMTF, ob, daily] = await Promise.all([
                this.fetchWithRetry('/tickers', { category: 'linear', symbol: config.symbol }),
                this.fetchWithRetry('/kline', { category: 'linear', symbol: config.symbol, interval: config.interval, limit: config.limit }),
                this.fetchWithRetry('/kline', { category: 'linear', symbol: config.symbol, interval: config.trend_interval, limit: 100 }),
                this.fetchWithRetry('/orderbook', { category: 'linear', symbol: config.symbol, limit: config.orderbook.depth }),
                this.fetchWithRetry('/kline', { category: 'linear', symbol: config.symbol, interval: 'D', limit: 2 })
            ]);

            // Helper function to parse candle data
            const parseCandles = (list) => list.reverse().map(c => ({
                t: parseInt(c[0]), // Timestamp
                o: parseFloat(c[1]), // Open
                h: parseFloat(c[2]), // High
                l: parseFloat(c[3]), // Low
                c: parseFloat(c[4]), // Close
                v: parseFloat(c[5]), // Volume
            }));

            // Validate fetched data structure before parsing
            if (!ticker?.result?.list?.[0] || !kline?.result?.list || !klineMTF?.result?.list || !ob?.result?.b || !ob?.result?.a || !daily?.result?.list?.[1]) {
                console.error("Incomplete data received from API.");
                return null;
            }

            return {
                price: parseFloat(ticker.result.list[0].lastPrice),
                candles: parseCandles(kline.result.list),
                candlesMTF: parseCandles(klineMTF.result.list),
                bids: ob.result.b.map(x => ({ p: parseFloat(x[0]), q: parseFloat(x[1]) })),
                asks: ob.result.a.map(x => ({ p: parseFloat(x[0]), q: parseFloat(x[1]) })),
                daily: { h: parseFloat(daily.result.list[1][2]), l: parseFloat(daily.result.list[1][3]), c: parseFloat(daily.result.list[1][4]) },
                timestamp: Date.now()
            };
        } catch (e) {
            // Use NEON if available, otherwise fallback to console.warn
            const logWarn = typeof NEON !== 'undefined' ? NEON.ORANGE : console.warn;
            logWarn(`[WARN] Data Fetch Fail: ${e.message}`);
            return null;
        }
    }
}

// --- üí∞ EXCHANGE & RISK MANAGEMENT (from v6.0) ---
class EnhancedPaperExchange {
    constructor() {
        // Ensure config and Decimal are available
        if (typeof config === 'undefined') throw new Error("config is required.");
        if (typeof Decimal === 'undefined') throw new Error("Decimal.js is required.");
        if (typeof NEON === 'undefined') console.warn("NEON is not defined. Using default console colors.");

        this.balance = new Decimal(config.paper_trading.initial_balance);
        this.startBal = this.balance;
        this.pos = null; // Current open position: { side: 'BUY'|'SELL', entry: Decimal, qty: Decimal, sl: Decimal, tp: Decimal, strategy: string }
        this.dailyPnL = new Decimal(0);
        this.lastDailyReset = new Date(); // Track the last time daily PnL was reset
    }

    /**
     * Resets daily PnL at the start of a new day.
     */
    resetDailyPnL() {
        const now = new Date();
        if (now.getDate() !== this.lastDailyReset.getDate()) {
            this.dailyPnL = new Decimal(0);
            this.lastDailyReset = now;
            console.log("Daily PnL reset.");
        }
    }

    /**
     * Checks if trading is allowed based on risk parameters.
     * @returns {boolean} True if trading is allowed, false otherwise.
     */
    canTrade() {
        this.resetDailyPnL(); // Ensure daily PnL is up-to-date

        const drawdown = this.startBal.isZero() ? new Decimal(0) : this.startBal.sub(this.balance).div(this.startBal).mul(100);
        if (drawdown.gt(config.risk.max_drawdown)) {
            const logError = typeof NEON !== 'undefined' ? NEON.RED : console.error;
            logError(`üö® MAX DRAWDOWN HIT (${drawdown.toFixed(2)}%)`);
            return false;
        }
        const dailyLoss = this.startBal.isZero() ? new Decimal(0) : this.dailyPnL.div(this.startBal).mul(100);
        if (dailyLoss.lt(new Decimal(config.risk.daily_loss_limit))) {
            const logError = typeof NEON !== 'undefined' ? NEON.RED : console.error;
            logError(`üö® DAILY LOSS LIMIT HIT (${dailyLoss.toFixed(2)}%)`);
            return false;
        }
        return true;
    }

    /**
     * Evaluates the current market state and decides on trades.
     * @param {number} priceVal - The current market price.
     * @param {object} signal - The trading signal from the AI. { action: 'BUY'|'SELL'|'HOLD', confidence: number, entry: number, sl: number, tp: number, strategy: string }
     */
    evaluate(priceVal, signal) {
        // If risk limits are hit, close any open position and stop trading.
        if (!this.canTrade()) {
            if (this.pos) this.handlePositionClose(new Decimal(priceVal), "RISK_STOP");
            return;
        }

        const price = new Decimal(priceVal);

        // Close existing position if necessary (SL/TP hit or signal change)
        if (this.pos) {
            // Check if the signal has changed to the opposite direction or is HOLD
            if (signal.action !== 'HOLD' && signal.action !== this.pos.side) {
                this.handlePositionClose(price, `SIGNAL_CHANGE (${signal.action})`);
            } else {
                this.handlePositionClose(price); // Check for SL/TP hits
            }
        }

        // Open a new position if conditions are met and no position is open
        if (!this.pos && signal.action !== 'HOLD' && signal.confidence >= config.min_confidence) {
            this.handlePositionOpen(price, signal);
        }
    }

    /**
     * Handles closing an open position.
     * @param {Decimal} price - The current price at which to close.
     * @param {string|null} forceReason - Reason for forced closure (e.g., 'RISK_STOP', 'SIGNAL_CHANGE').
     */
    handlePositionClose(price, forceReason = null) {
        let close = false;
        let reason = forceReason || '';

        if (!this.pos) return; // No position to close

        if (this.pos.side === 'BUY') {
            if (forceReason || price.lte(this.pos.sl)) { // Stop Loss or forced close
                close = true;
                reason = reason || 'SL Hit';
            } else if (price.gte(this.pos.tp)) { // Take Profit
                close = true;
                reason = reason || 'TP Hit';
            }
        } else { // SELL position
            if (forceReason || price.gte(this.pos.sl)) { // Stop Loss or forced close
                close = true;
                reason = reason || 'SL Hit';
            } else if (price.lte(this.pos.tp)) { // Take Profit
                close = true;
                reason = reason || 'TP Hit';
            }
        }

        if (close) {
            const slippage = price.mul(config.paper_trading.slippage);
            const exitPrice = this.pos.side === 'BUY' ? price.sub(slippage) : price.add(slippage);
            const rawPnl = this.pos.side === 'BUY' ? exitPrice.sub(this.pos.entry).mul(this.pos.qty) : this.pos.entry.sub(exitPrice).mul(this.pos.qty);
            const fee = exitPrice.mul(this.pos.qty).mul(config.paper_trading.fee);
            const netPnl = rawPnl.sub(fee);

            this.balance = this.balance.add(netPnl);
            this.dailyPnL = this.dailyPnL.add(netPnl);

            const color = netPnl.gte(0) ? (typeof NEON !== 'undefined' ? NEON.GREEN : '\x1b[32m') : (typeof NEON !== 'undefined' ? NEON.RED : '\x1b[31m');
            const resetColor = typeof NEON !== 'undefined' ? '' : '\x1b[0m';
            console.log(`${reason}! PnL: ${color}${netPnl.toFixed(2)}${resetColor} [${this.pos.strategy}]`);
            this.pos = null;
        }
    }

    /**
     * Handles opening a new position.
     * @param {Decimal} price - The current price for entry calculation.
     * @param {object} signal - The trading signal from the AI.
     */
    handlePositionOpen(price, signal) {
        const entry = new Decimal(signal.entry);
        const sl = new Decimal(signal.sl);
        const tp = new Decimal(signal.tp);

        const dist = entry.sub(sl).abs(); // Distance between entry and stop loss
        if (dist.isZero()) {
            console.warn(typeof NEON !== 'undefined' ? NEON.YELLOW("WARN: Entry and SL are the same, cannot open position.") : "WARN: Entry and SL are the same, cannot open position.");
            return;
        }

        // Calculate quantity based on risk percentage and stop loss distance
        const riskAmt = this.balance.mul(config.paper_trading.risk_percent / 100);
        let qty = riskAmt.div(dist);

        // Cap quantity based on leverage
        const maxQty = this.balance.mul(config.paper_trading.leverage_cap).div(price);
        if (qty.gt(maxQty)) {
            qty = maxQty;
            console.warn(typeof NEON !== 'undefined' ? NEON.YELLOW(`WARN: Position size capped by leverage. Max Qty: ${maxQty.toFixed(4)}`) : `WARN: Position size capped by leverage. Max Qty: ${maxQty.toFixed(4)}`);
        }

        // Ensure quantity is positive
        if (qty.isNegative() || qty.isZero()) {
            console.warn(typeof NEON !== 'undefined' ? NEON.YELLOW("WARN: Calculated quantity is zero or negative. Cannot open position.") : "WARN: Calculated quantity is zero or negative. Cannot open position.");
            return;
        }

        const slippage = price.mul(config.paper_trading.slippage);
        const execPrice = signal.action === 'BUY' ? entry.add(slippage) : entry.sub(slippage);
        const fee = execPrice.mul(qty).mul(config.paper_trading.fee);

        // Check if balance is sufficient after considering fees
        if (this.balance.lt(fee)) {
            console.warn(typeof NEON !== 'undefined' ? NEON.YELLOW("WARN: Insufficient balance for fees. Cannot open position.") : "WARN: Insufficient balance for fees. Cannot open position.");
            return;
        }

        // Deduct fees from balance before opening position
        this.balance = this.balance.sub(fee);

        this.pos = {
            side: signal.action,
            entry: execPrice,
            qty: qty,
            sl: sl,
            tp: tp,
            strategy: signal.strategy
        };

        const logSuccess = typeof NEON !== 'undefined' ? NEON.GREEN : '\x1b[32m';
        const resetColor = typeof NEON !== 'undefined' ? '' : '\x1b[0m';
        console.log(`${logSuccess}OPEN ${signal.action} [${signal.strategy}] @ ${execPrice.toFixed(4)} | Size: ${qty.toFixed(4)} | SL: ${sl.toFixed(4)} | TP: ${tp.toFixed(4)}${resetColor}`);
    }
}

// --- üß† MULTI-STRATEGY AI BRAIN (from v6.0) ---
class EnhancedGeminiBrain {
    constructor() {
        // Ensure necessary modules and config are available
        if (typeof GoogleGenerativeAI === 'undefined') throw new Error("GoogleGenerativeAI is required.");
        if (typeof config === 'undefined') throw new Error("config is required.");
        if (typeof NEON === 'undefined') console.warn("NEON is not defined. Using default console colors.");

        const key = process.env.GEMINI_API_KEY;
        if (!key) {
            console.error("Missing GEMINI_API_KEY environment variable.");
            process.exit(1); // Exit if API key is critical
        }
        this.model = new GoogleGenerativeAI(key).getGenerativeModel({ model: config.gemini_model });
    }

    /**
     * Analyzes market context and generates a trading signal using Gemini AI.
     * @param {object} ctx - The context object containing market data and indicators.
     * @returns {Promise<object>} The AI-generated trading signal.
     */
    async analyze(ctx) {
        // Construct the prompt dynamically using context data
        const prompt = `
        ACT AS: Institutional Scalping Algorithm.
        OBJECTIVE: Select the single best strategy (1-5) and provide a precise trade plan, or HOLD.

        QUANTITATIVE BIAS:
        - **WSS Score (Crucial Filter):** ${ctx.wss} (Bias: ${ctx.wss > 0 ? 'BULLISH' : 'BEARISH'})
        - CRITICAL RULE: Action must align with WSS. BUY requires WSS >= ${config.indicators.wss_weights.action_threshold}. SELL requires WSS <= -${config.indicators.wss_weights.action_threshold}.

        MARKET CONTEXT:
        - Price: ${ctx.price} | Volatility: ${ctx.volatility} | Regime: ${ctx.marketRegime}
        - Trend (15m): ${ctx.trend_mtf} | Trend (3m): ${ctx.trend_angle} (Slope) | ADX: ${ctx.adx}
        - Momentum: RSI=${ctx.rsi?.toFixed(2) ?? 'N/A'}, Stoch=${ctx.stoch_k?.toFixed(0) ?? 'N/A'}, MACD=${ctx.macd_hist?.toFixed(4) ?? 'N/A'}
        - Structure: VWAP=${ctx.vwap?.toFixed(4) ?? 'N/A'}, FVG=${ctx.fvg ? ctx.fvg.type + ' @ ' + ctx.fvg.price.toFixed(2) : 'None'}, Squeeze: ${ctx.isSqueeze}
        - Divergence: ${ctx.divergence}
        - Key Levels: Fib P=${ctx.fibs?.P?.toFixed(2) ?? 'N/A'}, S1=${ctx.fibs?.S1?.toFixed(2) ?? 'N/A'}, R1=${ctx.fibs?.R1?.toFixed(2) ?? 'N/A'}
        - Support/Resistance: ${ctx.sr_levels?.join(', ') ?? 'N/A'}

        STRATEGY ARCHETYPES:
        1. TREND_SURFER (WSS Trend > 1.0): Pullback to VWAP/EMA, anticipate continuation.
        2. VOLATILITY_BREAKOUT (Squeeze=YES): Trade in direction of MTF trend on volatility expansion.
        3. MEAN_REVERSION (WSS Momentum < -1.0 or > 1.0, Chop > 60): Fade extreme RSI/Stoch.
        4. LIQUIDITY_GRAB (Price Near FVG/Wall): Fade or trade the retest/bounce of a liquidity zone.
        5. DIVERGENCE_HUNT (Divergence != NONE): High conviction reversal trade using swing high/low for SL.

        INSTRUCTIONS:
        - If the WSS does not meet the threshold, or if no strategy is clear, return "HOLD".
        - Calculate precise entry, SL, and TP (1:1.5 RR minimum, use ATR/Pivot/FVG for targets).

        OUTPUT JSON ONLY: { "action": "BUY"|"SELL"|"HOLD", "strategy": "STRATEGY_NAME", "confidence": 0.0-1.0, "entry": number, "sl": number, "tp": number, "reason": "string" }
        `;

        try {
            const res = await this.model.generateContent(prompt);
            const text = res.response.text();

            // Clean up the response text to extract JSON
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error("Gemini AI response did not contain valid JSON:", text);
                return { action: 'HOLD', strategy: 'AI_ERROR', confidence: 0, entry: 0, sl: 0, tp: 0, reason: 'Invalid AI response format' };
            }

            const signal = JSON.parse(jsonMatch[0]);

            // Validate the parsed signal structure
            if (!signal || typeof signal.action === 'undefined' || typeof signal.strategy === 'undefined' || typeof signal.confidence === 'undefined') {
                console.error("Parsed signal is missing required fields:", signal);
                return { action: 'HOLD', strategy: 'AI_ERROR', confidence: 0, entry: 0, sl: 0, tp: 0, reason: 'Invalid signal structure from AI' };
            }

            // Ensure numerical values are valid numbers, default to 0 if not
            signal.confidence = typeof signal.confidence === 'number' && !isNaN(signal.confidence) ? signal.confidence : 0;
            signal.entry = typeof signal.entry === 'number' && !isNaN(signal.entry) ? signal.entry : 0;
            signal.sl = typeof signal.sl === 'number' && !isNaN(signal.sl) ? signal.sl : 0;
            signal.tp = typeof signal.tp === 'number' && !isNaN(signal.tp) ? signal.tp : 0;

            // Apply critical WSS filter
            const wssThreshold = config.indicators.wss_weights.action_threshold;
            if (signal.action === 'BUY' && ctx.wss < wssThreshold) {
                signal.action = 'HOLD';
                signal.reason = `WSS (${ctx.wss}) below BUY threshold (${wssThreshold})`;
            } else if (signal.action === 'SELL' && ctx.wss > -wssThreshold) {
                signal.action = 'HOLD';
                signal.reason = `WSS (${ctx.wss}) above SELL threshold (${-wssThreshold})`;
            }

            // Add default reason if missing
            if (!signal.reason) {
                signal.reason = signal.action === 'HOLD' ? 'No clear signal or WSS filter applied.' : `Strategy: ${signal.strategy}`;
            }

            return signal;

        } catch (error) {
            console.error("Error generating content from Gemini AI:", error);
            return { action: 'HOLD', strategy: 'AI_ERROR', confidence: 0, entry: 0, sl: 0, tp: 0, reason: `Gemini API error: ${error.message}` };
        }
    }
}
// --- Trading Engine ---
class TradingEngine {
    constructor() {
        this.dataProvider = new EnhancedDataProvider();
        this.exchange = new EnhancedPaperExchange();
        this.brain = new EnhancedGeminiBrain();
        this.isRunning = false;
        this.loopDelay = config.loop_delay * 1000; // Convert seconds to milliseconds
    }

    async start() {
        this.isRunning = true;
        console.log(NEON.GREEN.bold("üöÄ WHALEWAVE TITAN v6.1 STARTED..."));
        while (this.isRunning) {
            try {
                const data = await this.dataProvider.fetchAll();
                if (!data) {
                    await setTimeout(this.loopDelay); // Wait before retrying if data fetching fails
                    continue;
                }

                // Calculate all indicators and analysis
                const analysis = await this.calculateIndicators(data);
                if (!analysis) {
                    await setTimeout(this.loopDelay);
                    continue;
                }

                const context = this.brain.buildContext(data, analysis);
                const signal = await this.brain.analyze(context);

                this.exchange.evaluate(data.price, signal);
                this.displayDashboard(data, context, signal);

            } catch (error) {
                console.error(NEON.RED.bold(`\nüö® ENGINE ERROR: ${error.message}`));
                console.error(error.stack); // Log the stack trace for debugging
                // Optionally, implement more robust error handling like restarting the engine
            }
            await setTimeout(this.loopDelay);
        }
    }

    async calculateIndicators(data) {
        const { candles, candlesMTF } = data;
        const c = candles.map(candle => candle.c);
        const h = candles.map(candle => candle.h);
        const l = candles.map(candle => candle.l);
        const v = candles.map(candle => candle.v);
        const mtfC = candlesMTF.map(candle => candle.c);

        const [rsi, stoch, macd, adx, mfi, chop, reg, bb, kc, atr, fvg, vwap, st, ce, cci] = await Promise.all([
            TA.rsi(c, config.indicators.rsi),
            TA.stoch(h, l, c, config.indicators.stoch_period, config.indicators.stoch_k, config.indicators.stoch_d),
            TA.macd(c, config.indicators.macd_fast, config.indicators.macd_slow, config.indicators.macd_sig),
            TA.adx(h, l, c, config.indicators.adx_period),
            TA.mfi(h, l, c, v, config.indicators.mfi),
            TA.chop(h, l, c, config.indicators.chop_period),
            TA.linReg(c, config.indicators.linreg_period),
            TA.bollinger(c, config.indicators.bb_period, config.indicators.bb_std),
            TA.keltner(h, l, c, config.indicators.kc_period, config.indicators.kc_mult),
            TA.atr(h, l, c, config.indicators.atr_period),
            TA.findFVG(data.candles),
            TA.vwap(h, l, c, v, config.indicators.vwap_period),
            TA.superTrend(h, l, c, config.indicators.atr_period, config.indicators.st_factor),
            TA.chandelierExit(h, l, c, config.indicators.ce_period, config.indicators.ce_mult),
            TA.cci(h, l, c, config.indicators.cci_period)
        ]);

        const last = c.length - 1;
        const isSqueeze = (bb.upper[last] < kc.upper[last]) && (bb.lower[last] > kc.lower[last]);
        const divergence = TA.detectDivergence(c, rsi);
        const volatility = TA.historicalVolatility(c);
        const avgVolatility = TA.sma(volatility, 50); // Assuming SMA of volatility is calculated
        const avgVolValue = avgVolatility && avgVolatility.length > 50 ? avgVolatility[50] : 1; // Default to 1 if not enough data

        const mtfSma = TA.sma(mtfC, 20);
        const trendMTF = mtfC[mtfC.length-1] > mtfSma[mtfSma.length-1] ? "BULLISH" : "BEARISH";
        const fibs = TA.fibPivots(data.daily.h, data.daily.l, data.daily.c);
        const avgBid = data.bids.reduce((a,b)=>a+b.q,0)/data.bids.length;
        const buyWall = data.bids.find(b => b.q > avgBid * config.orderbook.wall_threshold)?.p;
        const sellWall = data.asks.find(a => a.q > avgBid * config.orderbook.wall_threshold)?.p;

        const analysis = {
            closes: c, rsi, stoch, macd, adx, mfi, chop, reg, bb, kc, atr, fvg, vwap, st, ce, cci,
            isSqueeze, divergence, volatility, avgVolatility: avgVolValue, trendMTF, buyWall, sellWall, fibs
        };
        analysis.wss = calculateWSS(analysis, data.price);
        analysis.avgVolatility = avgVolValue; // Ensure this is set correctly
        return analysis;
    }

    buildContext(d, a) {
        const last = a.closes.length - 1;
        const linReg = TA.getFinalValue(a, 'reg', 4);
        const sr = getOrderbookLevels(d.bids, d.asks, d.price, config.orderbook.sr_levels);

        return {
            price: d.price, rsi: a.rsi[last], stoch_k: a.stoch.k[last], macd_hist: (a.macd.hist[last] || 0),
            adx: a.adx[last], chop: a.chop[last], vwap: a.vwap[last],
            trend_angle: linReg.slope, trend_mtf: a.trendMTF, isSqueeze: a.isSqueeze ? 'YES' : 'NO', fvg: a.fvg, divergence: a.divergence,
            walls: { buy: a.buyWall, sell: a.sellWall }, fibs: a.fibs,
            volatility: a.volatility[last], marketRegime: TA.marketRegime(a.closes, a.volatility),
            wss: a.wss, sr_levels: `S:[${sr.supportLevels.join(', ')}] R:[${sr.resistanceLevels.join(', ')}]`
        };
    }

    colorizeValue(value, key) {
        if (typeof value !== 'number') return NEON.GRAY(value);
        const v = parseFloat(value);
        if (key === 'rsi' || key === 'mfi') {
            if (v > 70) return NEON.RED(v.toFixed(2));
            if (v < 30) return NEON.GREEN(v.toFixed(2));
            return NEON.YELLOW(v.toFixed(2));
        }
        if (key === 'stoch_k') {
            if (v > 80) return NEON.RED(v.toFixed(0));
            if (v < 20) return NEON.GREEN(v.toFixed(0));
            return NEON.YELLOW(v.toFixed(0));
        }
        if (key === 'macd_hist' || key === 'trend_angle') {
            if (v > 0) return NEON.GREEN(v.toFixed(4));
            if (v < 0) return NEON.RED(v.toFixed(4));
            return NEON.GRAY(v.toFixed(4));
        }
        if (key === 'adx') {
            if (v > 25) return NEON.ORANGE(v.toFixed(2));
            return NEON.GRAY(v.toFixed(2));
        }
        if (key === 'chop') {
            if (v > 60) return NEON.BLUE(v.toFixed(2));
            if (v < 40) return NEON.ORANGE(v.toFixed(2));
            return NEON.GRAY(v.toFixed(2));
        }
        if (key === 'vwap') {
             return NEON.CYAN(v.toFixed(4));
        }
        return NEON.CYAN(v.toFixed(2));
    }

    displayDashboard(d, ctx, sig) {
        console.clear();
        const border = NEON.GRAY('‚îÄ'.repeat(80));
        console.log(border);
        console.log(NEON.bg(NEON.PURPLE(` WHALEWAVE TITAN v6.1 | ${config.symbol} | $${d.price.toFixed(4)} `).padEnd(80)));
        console.log(border);

        const sigColor = sig.action === 'BUY' ? NEON.GREEN : sig.action === 'SELL' ? NEON.RED : NEON.GRAY;
        const wssColor = ctx.wss >= config.indicators.wss_weights.action_threshold ? NEON.GREEN : ctx.wss <= -config.indicators.wss_weights.action_threshold ? NEON.RED : NEON.YELLOW;
        console.log(`WSS: ${wssColor(ctx.wss)} | Strategy: ${NEON.BLUE(sig.strategy || 'SEARCHING')} | Signal: ${sigColor(sig.action)} (${(sig.confidence*100).toFixed(0)}%)`);
        console.log(NEON.GRAY(`Reason: ${sig.reason}`));
        console.log(border);

        const regimeCol = ctx.marketRegime.includes('HIGH') ? NEON.RED : ctx.marketRegime.includes('LOW') ? NEON.GREEN : NEON.YELLOW;
        const trendCol = ctx.trend_mtf === 'BULLISH' ? NEON.GREEN : NEON.RED;
        console.log(`Regime: ${regimeCol(ctx.marketRegime)} | Vol: ${this.colorizeValue(ctx.volatility, 'volatility')} | Squeeze: ${ctx.isSqueeze === 'YES' ? NEON.ORANGE('ACTIVE') : 'OFF'}`);
        console.log(`MTF Trend: ${trendCol(ctx.trend_mtf)} | Slope: ${this.colorizeValue(ctx.trend_angle, 'trend_angle')} | ADX: ${this.colorizeValue(ctx.adx, 'adx')}`);
        console.log(border);

        console.log(`RSI: ${this.colorizeValue(ctx.rsi, 'rsi')} | Stoch: ${this.colorizeValue(ctx.stoch_k, 'stoch_k')} | MACD Hist: ${this.colorizeValue(ctx.macd_hist, 'macd_hist')} | Chop: ${this.colorizeValue(ctx.chop, 'chop')}`);
        const divCol = ctx.divergence.includes('BULLISH') ? NEON.GREEN : ctx.divergence.includes('BEARISH') ? NEON.RED : NEON.GRAY;
        console.log(`Divergence: ${divCol(ctx.divergence)} | FVG: ${ctx.fvg ? NEON.YELLOW(ctx.fvg.type) : 'None'} | VWAP: ${this.colorizeValue(ctx.vwap, 'vwap')}`);
        console.log(`${NEON.GRAY('Key Levels:')} P=${NEON.YELLOW(ctx.fibs.P.toFixed(2))} S1=${NEON.GREEN(ctx.fibs.S1.toFixed(2))} R1=${NEON.RED(ctx.fibs.R1.toFixed(2))}`);
        console.log(border);

        const pnlCol = this.exchange.dailyPnL.gte(0) ? NEON.GREEN : NEON.RED;
        console.log(`Balance: ${NEON.GREEN('$' + this.exchange.balance.toFixed(2))} | Daily PnL: ${pnlCol('$' + this.exchange.dailyPnL.toFixed(2))}`);

        if (this.exchange.pos) {
            const p = this.exchange.pos;
            const curPnl = p.side === 'BUY' ? new Decimal(d.price).sub(p.entry).mul(p.qty) : p.entry.sub(d.price).mul(p.qty);
            const posCol = curPnl.gte(0) ? NEON.GREEN : NEON.RED;
            console.log(NEON.BLUE(`OPEN POS: ${p.side} @ ${p.entry.toFixed(4)} | SL: ${p.sl.toFixed(4)} | TP: ${p.tp.toFixed(4)} | PnL: ${posCol(curPnl.toFixed(2))}`));
        }
        console.log(border);
    }
}

// --- START ---
const engine = new TradingEngine();
process.on('SIGINT', () => {
    engine.isRunning = false;
    console.log(NEON.RED("\nüõë SHUTTING DOWN GRACEFULLY..."));
    process.exit(0);
});
process.on('SIGTERM', () => { engine.isRunning = false; process.exit(0); });
engine.start();
