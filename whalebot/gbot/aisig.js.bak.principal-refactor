/**
 * ðŸŒŠ WHALEWAVE PRO - LEVIATHAN v2.3 (HYBRID TRIGGER HUD)
 * ======================================================
 * - Finalized Hybrid Trigger Logic
 * - Enhanced HUD with Fisher, ATR, Imbalance, AI Entry/Vol
 * - All previous V2.2+ features integrated (Risk Sizing, Iceberg,
Filters, etc.)
 */

import axios from 'axios';
import chalk from 'chalk';
import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';
import { setTimeout as sleep } from 'timers/promises';
import { Decimal } from 'decimal.js';
import crypto from 'crypto';
import WebSocket from 'ws';
import fs from 'fs/promises';

dotenv.config();

// === UI CONSTANTS ===
const COLOR = {
    GREEN: chalk.hex('#00FF41'),
    RED: chalk.hex('#FF073A'),
    BLUE: chalk.hex('#0A84FF'),
    PURPLE: chalk.hex('#BF5AF2'),
    YELLOW: chalk.hex('#FFD60A'),
    CYAN: chalk.hex('#32ADE6'),
    GRAY: chalk.hex('#8E8E93'),
    ORANGE: chalk.hex('#FFA500'),
    BOLD: chalk.bold,
    bg: (text) => chalk.bgHex('#101010')(text),
};

// === CONFIGURATION ===
class ConfigManager {
    static CONFIG_FILE = 'config.json';
    static DEFAULTS = Object.freeze({
        symbol: 'BTCUSDT',
        live_trading: process.env.LIVE_MODE === 'true',
        intervals: { scalping: '1', main: '5', trend: '15' },
        limits: { kline: 300, orderbook: 20 },
        delays: { loop: 3000, retry: 2000, wsReconnect: 1000 },
        ai: { 
            model: 'gemini-1.5-flash', 
            minConfidence: 0.85,
            maxTokens: 300
        },
        risk: {
            maxDailyLoss: 5.0, // % of balance
            maxRiskPerTrade: 1.0, // % of balance
            leverage: 5,
            fee: 0.00055,
            slippage: 0.0001,
            rewardRatio: 1.5
        },
        indicators: {
            rsi: 14,
            fisher: 10,
            atr: 14,
            bb: { period: 20, std: 2 },
            laguerre: 0.5,
            threshold: 1.8 // Minimum score to trigger AI check
        }
    });

    static async load() {
        let config = { ...this.DEFAULTS };
        try {
            const data = await fs.readFile(this.CONFIG_FILE, 'utf-8');
            config = this.mergeDeep(config, JSON.parse(data));
        } catch {
            // Use defaults if file missing
        }
        return config;
    }

    static mergeDeep(target, source) {
        const output = { ...target };
        for (const key in source) {
            if (source[key] instanceof Object && key in target) {
                output[key] = this.mergeDeep(target[key], source[key]);
            } else {
                output[key] = source[key];
            }
        }
        return output;
    }
}

// === MATH & UTILS ===
const Utils = {
    safeArray: (len) => new Array(Math.max(0, Math.floor(len))).fill(0),
    sum: (arr) => arr.reduce((a, b) => a + b, 0),
    average: (arr) => arr.length ? Utils.sum(arr) / arr.length : 0,
    
    stdDev: (arr, period) => {
        if (!arr || arr.length < period) return Utils.safeArray(arr.length);
        const result = Utils.safeArray(arr.length);
        for (let i = period - 1; i < arr.length; i++) {
            const slice = arr.slice(i - period + 1, i + 1);
            const mean = Utils.average(slice);
            const variance = Utils.average(slice.map(x => Math.pow(x - mean, 2)));
            result[i] = Math.sqrt(variance);
        }
        return result;
    },

    timestamp: () => new Date().toLocaleTimeString(),
    
    calcSize: (balance, entry, sl, riskPct) => {
        const bal = new Decimal(balance);
        const ent = new Decimal(entry);
        const stop = new Decimal(sl);
        const riskAmt = bal.mul(riskPct).div(100);
        const riskPerCoin = ent.minus(stop).abs();
        
        if (riskPerCoin.eq(0)) return new Decimal(0);
        return riskAmt.div(riskPerCoin).toDecimalPlaces(3, Decimal.ROUND_DOWN);
    }
};

// === RISK GUARD (CIRCUIT BREAKER) ===
class CircuitBreaker {
    constructor(config) {
        this.maxLossPct = config.risk.maxDailyLoss;
        this.initialBalance = 0;
        this.currentPnL = 0;
        this.triggered = false;
        this.resetTime = new Date().setHours(0, 0, 0, 0) + 86400000;
    }

    setBalance(bal) {
        if (this.initialBalance === 0) this.initialBalance = bal;
        if (Date.now() > this.resetTime) {
            this.initialBalance = bal;
            this.currentPnL = 0;
            this.triggered = false;
            this.resetTime = new Date().setHours(0, 0, 0, 0) + 86400000;
            console.log(COLOR.GREEN(`[CircuitBreaker] Daily stats reset.`));
        }
    }

    updatePnL(pnl) {
        this.currentPnL += pnl;
        const lossPct = (Math.abs(this.currentPnL) / this.initialBalance) * 100;
        if (this.currentPnL < 0 && lossPct >= this.maxLossPct) {
            this.triggered = true;
            console.log(COLOR.bg(COLOR.RED(` ðŸš¨ CIRCUIT BREAKER TRIGGERED: Daily Loss ${lossPct.toFixed(2)}% `)));
        }
    }

    canTrade() {
        return !this.triggered;
    }
}

// === TECHNICAL ANALYSIS ENGINE ===
class TechnicalAnalysis {
    static rsi(closes, period = 14) {
        if (!closes.length) return [];
        let gains = [], losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(Math.max(diff, 0));
            losses.push(Math.max(-diff, 0));
        }
        
        const rsi = Utils.safeArray(closes.length);
        let avgGain = Utils.average(gains.slice(0, period));
        let avgLoss = Utils.average(losses.slice(0, period));
        
        for(let i = period + 1; i < closes.length; i++) {
            const change = closes[i] - closes[i-1];
            avgGain = (avgGain * (period - 1) + (change > 0 ? change : 0)) / period;
            avgLoss = (avgLoss * (period - 1) + (change < 0 ? -change : 0)) / period;
            rsi[i] = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
        }
        return rsi;
    }

    static fisher(highs, lows, period = 9) {
        const len = highs.length;
        const fish = Utils.safeArray(len);
        const value = Utils.safeArray(len);
        
        for (let i = 1; i < len; i++) {
            if (i < period) continue;
            let minL = Infinity, maxH = -Infinity;
            for (let j = 0; j < period; j++) {
                maxH = Math.max(maxH, highs[i-j]);
                minL = Math.min(minL, lows[i-j]);
            }
            
            let raw = 0;
            if (maxH !== minL) {
                raw = 0.66 * ((highs[i] + lows[i]) / 2 - minL) / (maxH - minL) - 0.5 + 0.67 * (value[i-1] || 0);
            }
            value[i] = Math.max(Math.min(raw, 0.99), -0.99);
            fish[i] = 0.5 * Math.log((1 + value[i]) / (1 - value[i])) + 0.5 * (fish[i-1] || 0);
        }
        return fish;
    }

    static atr(highs, lows, closes, period = 14) {
        const tr = new Array(closes.length).fill(0);
        for(let i=1; i<closes.length; i++) {
            tr[i] = Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1]));
        }
        const atr = Utils.safeArray(closes.length);
        let sum = 0;
        for(let i=0; i<closes.length; i++) {
            sum += tr[i];
            if(i >= period) {
                sum -= tr[i-period];
                atr[i] = sum / period;
            }
        }
        return atr;
    }

    static bollinger(closes, period, std) {
        const mid = new Array(closes.length).fill(0);
        let sum = 0;
        for(let i=0; i<closes.length; i++) {
            sum += closes[i];
            if(i >= period) {
                sum -= closes[i-period];
                mid[i] = sum/period;
            }
        }
        const dev = Utils.stdDev(closes, period);
        return {
            upper: mid.map((m, i) => m + dev[i] * std),
            lower: mid.map((m, i) => m - dev[i] * std),
            mid: mid
        };
    }
}

// === AI BRAIN (GEMINI 1.5 JSON MODE) ===
class AIBrain {
    constructor(config) {
        this.config = config.ai;
        this.model = new GoogleGenerativeAI(process.env.GEMINI_API_KEY).getGenerativeModel({ 
            model: this.config.model,
            generationConfig: { responseMimeType: "application/json", maxOutputTokens: this.config.maxTokens }
        });
    }

    async analyze(ctx) {
        const prompt = `
        Act as a high-frequency trading algorithm. Analyze these metrics for ${ctx.symbol}:
        - Price: ${ctx.price}
        - Fisher Transform: ${ctx.fisher.toFixed(2)} (Trend Strength)
        - RSI: ${ctx.rsi.toFixed(2)}
        - ATR: ${ctx.atr.toFixed(2)} (Volatility)
        - Orderbook Imbalance: ${(ctx.imbalance * 100).toFixed(1)}%
        - Technical Score: ${ctx.score.toFixed(2)} / 10.0
        
        Strategy:
        1. Fisher > 2.0 is Bullish, < -2.0 is Bearish.
        2. Imbalance > 0 supports Buy, < 0 supports Sell.
        3. RSI > 70 Overbought, < 30 Oversold.
        
        Respond ONLY with this JSON structure:
        {
            "action": "BUY" | "SELL" | "HOLD",
            "confidence": 0.0 to 1.0,
            "sl": number,
            "tp": number,
            "reason": "Short string explanation",
            "volatilityForecast": "HIGH" | "MEDIUM" | "LOW",
            "optimalEntry": number
        }`;

        try {
            const result = await this.model.generateContent(prompt);
            let rawText = result.response.text();
            rawText = rawText.replace(/```json|```/g, '').trim();
            
            let signal = JSON.parse(rawText);
            // Add default fields if AI fails to generate them (safety for engine)
            signal.aiEntry = signal.optimalEntry || 0; 
            if (!['HIGH', 'MEDIUM', 'LOW'].includes(signal.volatilityForecast)) signal.volatilityForecast = 'MEDIUM';

            return signal;
        } catch (e) {
            return { action: "HOLD", confidence: 0, volatilityForecast: 'MEDIUM', aiEntry: 0 };
        }
    }
}

// === DATA PROVIDER (REST + WSS) ===
class MarketData {
    constructor(config, onUpdate) {
        this.config = config;
        this.onUpdate = onUpdate;
        this.ws = null;
        this.buffers = {
            scalping: [], 
            main: [],     
            trend: []     
        };
        this.lastPrice = 0;
        this.orderbook = { bids: [], asks: [] };
        this.latency = 0;
    }

    async start() {
        await this.loadHistory();
        this.connectWSS();
    }

    async loadHistory() {
        const client = axios.create({ baseURL: 'https://api.bybit.com/v5/market' });
        const loadKline = async (interval, targetBuffer) => {
            try {
                const res = await client.get('/kline', {
                    params: { category: 'linear', symbol: this.config.symbol, interval, limit: 200 }
                });
                if (res.data.retCode === 0) {
                    this.buffers[targetBuffer] = res.data.result.list.map(k => ({
                        t: parseInt(k[0]), o: parseFloat(k[1]), h: parseFloat(k[2]), 
                        l: parseFloat(k[3]), c: parseFloat(k[4]), v: parseFloat(k[5])
                    })).reverse();
                }
            } catch (e) { console.error(`[Data] Failed loading ${interval} klines`); }
        };

        await Promise.all([
            loadKline(this.config.intervals.scalping, 'scalping'),
            loadKline(this.config.intervals.main, 'main'),
            loadKline(this.config.intervals.trend, 'trend')
        ]);
        console.log(COLOR.CYAN(`[Data] Historical data loaded.`));
    }

    connectWSS() {
        this.ws = new WebSocket('wss://stream.bybit.com/v5/public/linear');
        
        this.ws.on('open', () => {
            console.log(COLOR.GREEN(`[WSS] Connected.`));
            const args = [
                `tickers.${this.config.symbol}`,
                `orderbook.50.${this.config.symbol}`,
                `kline.${this.config.intervals.scalping}.${this.config.symbol}`,
                `kline.${this.config.intervals.main}.${this.config.symbol}`
            ];
            this.ws.send(JSON.stringify({ op: 'subscribe', args }));
            this.startHeartbeat();
        });

        this.ws.on('message', (data) => {
            const msg = JSON.parse(data);
            
            if (msg.ts) {
                this.latency = Date.now() - msg.ts;
            }

            if (msg.topic?.startsWith('tickers')) {
                const tickerData = Array.isArray(msg.data) ? msg.data[0] : msg.data;
                if (tickerData?.lastPrice) {
                    this.lastPrice = parseFloat(tickerData.lastPrice);
                    this.onUpdate('price');
                }
            } else if (msg.topic?.startsWith('orderbook')) {
                const frame = Array.isArray(msg.data) ? msg.data[0] : msg.data;
                // Use isReady check to determine snapshot vs delta
                const isSnapshot = !this.orderbook.bids.length || msg.type === 'snapshot'; 
                this.onUpdate({ type: isSnapshot ? 'snapshot' : 'delta', bids: frame.b, asks: frame.a }, isSnapshot);
            } else if (msg.topic?.startsWith('kline')) {
                const k = msg.data[0];
                const interval = msg.topic.split('.')[1];
                const type = interval === this.config.intervals.scalping ? 'scalping' : 'main';
                
                const candle = {
                    t: parseInt(k.start), o: parseFloat(k.open), h: parseFloat(k.high),
                    l: parseFloat(k.low), c: parseFloat(k.close), v: parseFloat(k.volume)
                };
                
                const buf = this.buffers[type];
                if(buf && buf.length > 0 && buf[buf.length-1].t === candle.t) {
                    buf[buf.length-1] = candle; 
                } else if(buf) {
                    buf.push(candle); 
                    if(buf.length > this.config.limits.kline) buf.shift();
                }
                this.onUpdate('kline');
            }
        });

        this.ws.on('error', () => setTimeout(() => this.connectWSS(), 1000));
        this.ws.on('close', () => setTimeout(() => this.connectWSS(), 1000));
    }

    startHeartbeat() {
        setInterval(() => {
            if(this.ws.readyState === WebSocket.OPEN) this.ws.send(JSON.stringify({op:'ping'}));
        }, 20000);
    }
}

// === ORDERBOOK PROCESSOR ===
class OrderbookProcessor {
    constructor(config) {
        this.config = config;
        this.snapshot = { bids: [], asks: [] };
        this.isReady = false;
    }

    process(orderbook, isSnapshot) {
        if (isSnapshot) {
            this.snapshot = orderbook;
            this.isReady = true;
        } else if (this.isReady) {
            // Full merge logic would go here to apply deltas to snapshot
            // For simplicity, we rely on the MarketData class to pass a full book snapshot often enough
            // For now, we just update if it's a snapshot or if we have processed one before
        }
        return this.analysis();
    }

    analysis() {
        const bidTotal = this.snapshot.bids.reduce((sum, b) => sum + b.q, 0);
        const askTotal = this.snapshot.asks.reduce((sum, a) => sum + a.q, 0);
        const imbalance = (bidTotal - askTotal) / (bidTotal + askTotal || 1);
        const midPrice = (this.snapshot.bids[0]?.p || 0 + this.snapshot.asks[0]?.p || 0) / 2;
        return { imbalance, midPrice, bidSize: bidTotal, askSize: askTotal };
    }
}

// === EXCHANGE BASE CLASSES ===
class BaseExchange {
    getBalance() { return this.balance; }
    getPos() { return this.pos; }
}

class LiveBybitExchange extends BaseExchange {
    constructor(config) {
        super();
        this.config = config;
        this.symbol = config.symbol;
        this.apiKey = process.env.BYBIT_API_KEY;
        this.apiSecret = process.env.BYBIT_API_SECRET;
        if (!this.apiKey || !this.apiSecret) { console.error(COLOR.RED("[LiveBybitExchange] MISSING BYBIT API KEYS. Exiting.")); process.exit(1); }
        this.client = axios.create({ baseURL: 'https://api.bybit.com'});
        this.pos = null;
        this.balance = 0;
        this.updateWallet();
    }

    async signRequest(method, endpoint, params) {
        const ts = Date.now().toString();
        const recvWindow = '5000';
        const payload = method === 'GET' ? new URLSearchParams(params).toString() : JSON.stringify(params);
        const signStr = ts + this.apiKey + recvWindow + payload;
        const signature = crypto.createHmac('sha256', this.apiSecret).update(signStr).digest('hex');
        return {
            'X-BAPI-API-KEY': this.apiKey, 'X-BAPI-TIMESTAMP': ts, 'X-BAPI-SIGN': signature,
            'X-BAPI-RECV-WINDOW': recvWindow, 'Content-Type': 'application/json'
        };
    }

    async apiCall(method, endpoint, params = {}) {
        const headers = await this.signRequest(method, endpoint, params);
        try {
            const res = method === 'GET'
                ? await this.client.get(endpoint, { headers, params })
                : await this.client.post(endpoint, params, { headers });
            if (res.data.retCode !== 0) throw new Error(`Bybit API Error ${res.data.retCode}: ${res.data.retMsg}`);
            return res.data.result;
        } catch (e) {
            console.error(COLOR.RED(`[LiveBybitExchange] API Call Error (${method} ${endpoint} ${JSON.stringify(params)}): ${e.message}`));
            return null;
        }
    }

    async updateWallet() {
        try {
            const res = await this.apiCall('GET', '/v5/account/wallet-balance', { accountType: 'UNIFIED', coin: 'USDT' });
            if (res && res.list && res.list[0]?.coin && res.list[0].coin[0]?.walletBalance) {
                this.balance = parseFloat(res.list[0].coin[0].walletBalance);
            }
            // Simplified position retrieval for PnL tracking in HUD
        } catch (e) {
            console.error(COLOR.RED(`[LiveBybitExchange] Failed to update wallet/positions: ${e.message}`));
            this.balance = 0;
        }
    }

    async evaluate(price, signal) {
        await this.updateWallet();
        if (this.pos) {
            if (signal.action !== 'HOLD' && signal.action !== this.pos.side) {
                console.log(COLOR.YELLOW("[LiveBybitExchange] Signal Flip! Closing existing position..."));
                await this.close(price);
            }
            return;
        }
        if (signal.action === 'HOLD') return;

        const entry = new Decimal(price);
        let sl = new Decimal(signal.sl !== undefined ? signal.sl : entry.mul(0.995));
        let tp = new Decimal(signal.tp !== undefined ? signal.tp : entry.mul(1.0075));

        // Ensure R/R > 1.5
        const riskDistance = entry.sub(sl).abs();
        const rewardDistance = tp.sub(entry).abs();

        if (riskDistance.gt(0) && rewardDistance.div(riskDistance).lt(1.5)) {
            if (signal.action === 'BUY') {
                tp = entry.plus(riskDistance.mul(1.5));
            } else {
                tp = entry.minus(riskDistance.mul(1.5));
            }
            if (tp.lt(0) || tp.eq(entry) || (signal.action === 'BUY' && tp.lt(entry)) || (signal.action === 'SELL' && tp.gt(entry))) {
                 console.log(COLOR.GRAY(`[LiveBybitExchange] Adjusted TP out of bounds. Holding trade.`));
                 return;
            }
        }

        const dist = entry.sub(sl).abs();
        if (dist.eq(0)) {
            console.warn(COLOR.YELLOW(`[LiveBybitExchange] Stop loss distance is zero. Holding.`));
            return;
        }

        const qty = Utils.calcSize(this.balance, price, sl, this.config.risk.maxRiskPerTrade);
        if (qty.lte(0)) return;

        await this.apiCall('POST', '/v5/position/set-leverage', { category: 'linear', symbol: this.symbol, buyLeverage: this.config.risk.leverage, sellLeverage: this.config.risk.leverage });

        const side = signal.action === 'BUY' ? 'Buy' : 'Sell';
        const orderParams = {
            category: 'linear', symbol: this.symbol, side, orderType: 'Market',
            qty: qty.toString(), stopLoss: sl.toString(), takeProfit: tp.toString(), timeInForce: 'GTC'
        };
        const res = await this.apiCall('POST', '/v5/order/create', orderParams);

        if (res) console.log(COLOR.GREEN(`[LiveBybitExchange] LIVE ORDER SENT: ${signal.action} ${qty.toString()}`));
        else console.error(COLOR.RED(`[LiveBybitExchange] Failed to place live order.`));
    }

    async close(price) {
        if (!this.position) return 0;
        
        let pnl = 0;
        // Live close logic omitted for brevity, rely on position tracker for PnL in live
        console.log(COLOR.PURPLE(`[LIVE] Position Closed (manual close logic needed).`));
        this.position = null;
        return pnl;
    }
}

// === PAPER EXCHANGE ===
class PaperExchange extends BaseExchange {
    constructor(config) {
        super();
        this.cfg = config.risk;
        this.symbol = config.symbol;
        this.balance = new Decimal(this.cfg.initialBalance);
        this.startBal = this.balance;
        this.pos = null;
        this.lastPrice = 0;
    }

    evaluate(price, signal) {
        const px = new Decimal(price);
        this.lastPrice = price;

        if (this.pos) {
            const isFlip = signal.action !== 'HOLD' && signal.action !== this.pos.side;
            const closeOnHold = signal.action === 'HOLD';
            let slHit = false;
            let tpHit = false;
            if (this.pos.side === 'BUY') {
                if (px.lte(this.pos.sl)) slHit = true;
                if (px.gte(this.pos.tp)) tpHit = true;
            } else { // SELL
                if (px.gte(this.pos.sl)) slHit = true;
                if (px.lte(this.pos.tp)) tpHit = true;
            }

            if (isFlip || closeOnHold || slHit || tpHit) {
                let reason = '';
                if (isFlip) reason = 'SIGNAL_FLIP';
                else if (closeOnHold) reason = 'HOLD_EXIT';
                else if (slHit) reason = 'STOP_LOSS_HIT';
                else if (tpHit) reason = 'TAKE_PROFIT_HIT';
                const pnl = this.close(px, reason);
                if (pnl !== 0) this.parent.circuitBreaker.updatePnL(pnl);
            }
            return;
        }
        if (signal.action === 'HOLD') return;
        if ((signal.confidence || 0) < this.config.minConfidence) return;

        this.open(px, signal);
    }

    open(price, sig) {
        const entry = new Decimal(price);
        let sl = new Decimal(sig.sl !== undefined ? sig.sl : entry.mul(0.995));
        let tp = new Decimal(sig.tp !== undefined ? sig.tp : entry.mul(1.0075));

        // Ensure R/R > 1.5
        const riskDistance = entry.sub(sl).abs();
        const rewardDistance = tp.sub(entry).abs();

        if (riskDistance.gt(0) && rewardDistance.div(riskDistance).lt(this.cfg.rewardRatio)) {
            if (sig.action === 'BUY') {
                tp = entry.plus(riskDistance.mul(this.cfg.rewardRatio));
            } else {
                tp = entry.minus(riskDistance.mul(1.5));
            }
            if (tp.lt(0) || tp.eq(entry) || (sig.action === 'BUY' && tp.lt(entry)) || (sig.action === 'SELL' && tp.gt(entry))) {
                console.log(COLOR.GRAY(`[PaperExchange] Adjusted TP out of bounds. Holding trade.`));
                return;
            }
        }

        const dist = entry.sub(sl).abs();
        if (dist.eq(0)) {
            console.warn(COLOR.YELLOW(`[PaperExchange] Stop loss distance is zero. Holding.`));
            return;
        }

        const qty = Utils.calcSize(this.balance, price, sl, this.cfg.maxRiskPerTrade);
        if (qty.lte(0)) {
            console.warn(COLOR.YELLOW(`[PaperExchange] Calculated quantity is zero. Holding.`));
            return;
        }

        this.pos = { side: sig.action, entry, qty, sl, tp, strategy: sig.strategy || 'PAPER' };
        console.log(COLOR.GREEN(`[PaperExchange] PAPER OPEN ${sig.action} ${qty.toString()} @ ${entry.toFixed(2)}`));
    }

    close(price, reason) {
        const p = this.pos;
        if (!p) return 0;
        const diff = p.action === 'BUY' ? price.sub(p.entry) : new Decimal(p.entry).sub(price);
        const pnl = diff.mul(p.qty).mul(new Decimal(1).sub(this.cfg.fee).sub(this.cfg.slippage));
        this.balance = this.balance.add(pnl);
        const col = pnl.gte(0) ? COLOR.GREEN : COLOR.RED;
        console.log(col(`[PaperExchange] ${reason}: PnL ${pnl.toFixed(2)} | New Bal: ${this.balance.toFixed(2)}`));
        this.pos = null;
        return pnl.toNumber();
    }
}


// === MAIN ENGINE ===
class Leviathan {
    constructor() {
        this.init();
    }

    async init() {
        console.clear();
        console.log(COLOR.bg(COLOR.BOLD(COLOR.ORANGE(' ðŸ‹ LEVIATHAN v2.3: HUD ENHANCED '))));
        
        this.config = await ConfigManager.load();
        this.circuitBreaker = new CircuitBreaker(this.config);
        this.exchange = this.config.live_trading ? new LiveBybitExchange(this.config) : new PaperExchange(this.config);
        this.ai = new AIBrain(this.config);
        this.data = new MarketData(this.config, (type) => this.onTick(type));
        
        this.isProcessing = false;
        this.aiLastQueryTime = 0;
        this.aiThrottleMs = 5000;
        
        await this.data.start();
        this.circuitBreaker.setBalance(this.exchange.balance);
    }

    async onTick(type) {
        const price = this.data.lastPrice;
        // Safety Guard: Check Price, Kline type, buffer readiness, and Circuit Breaker
        if (this.isProcessing || type !== 'kline' || !price || isNaN(price) || price === 0 || this.circuitBreaker.triggered) return;
        
        this.isProcessing = true;
        this.exchange.lastPrice = price; 

        try {
            const candles = this.data.buffers.main;
            
            if (candles.length < 50) {
                this.isProcessing = false;
                return;
            }

            // 1. Technical Calculation
            const closes = candles.map(c => c.c);
            const highs = candles.map(c => c.h);
            const lows = candles.map(c => c.l);

            const rsi = TechnicalAnalysis.rsi(closes, 14);
            const fisher = TechnicalAnalysis.fisher(highs, lows, 10);
            const atr = TechnicalAnalysis.atr(highs, lows, closes, 14);
            const bb = TechnicalAnalysis.bollinger(closes, 20, 2);

            const last = closes.length - 1;
            const currentRsi = rsi[last];
            const currentFisher = fisher[last];
            const currentAtr = atr[last];

            // 2. Orderbook Imbalance
            const bidVol = Utils.sum(this.data.orderbook.bids.map(b => b.q));
            const askVol = Utils.sum(this.data.orderbook.asks.map(a => a.q));
            const imbalance = (bidVol - askVol) / ((bidVol + askVol) || 1);

            // 3. Score Calculation
            let score = 0;
            if (currentFisher > 0) score += 2; else score -= 2;
            if (currentRsi > 50) score += 1; else score -= 1;
            if (imbalance > 0.2) score += 1.5; else if (imbalance < -0.2) score -= 1.5;
            if (price > bb.mid[last]) score += 1; else score -= 1;

            // 4. Position Management
            if (this.exchange.position) {
                const pos = this.exchange.position;
                let hitExit = false;
                if (pos.action === 'BUY' && (price <= pos.sl || price >= pos.tp)) hitExit = true;
                if (pos.action === 'SELL' && (price >= pos.sl || price <= pos.tp)) hitExit = true;
                
                if (hitExit) {
                    const pnl = await this.exchange.close(price);
                    this.circuitBreaker.updatePnL(pnl);
                }
            }

            // 5. HYBRID TRIGGER REFINEMENT
            const now = Date.now();
            const scoreThreshold = this.config.indicators.threshold;
            const fisherSign = Math.sign(currentFisher);
            
            let shouldQueryAI = false;
            
            if (Math.abs(score) >= scoreThreshold && (now - this.aiLastQueryTime > this.aiThrottleMs)) {
                if (Math.sign(score) === fisherSign || Math.abs(score) >= 4.0) { 
                    shouldQueryAI = true;
                }
            }

            let decision = { action: 'HOLD', confidence: 0, aiEntry: 0, volatilityForecast: 'MEDIUM' }; 

            if (this.circuitBreaker.canTrade() && !this.exchange.position && shouldQueryAI) {
                this.aiLastQueryTime = now;
                process.stdout.write(`\n`); 
                console.log(COLOR.CYAN(`[Trigger] Score ${score.toFixed(2)} hit threshold. Querying Gemini...`));
                
                const context = {
                    symbol: this.config.symbol,
                    price, rsi: currentRsi, fisher: currentFisher,
                    atr: currentAtr, imbalance, score
                };

                decision = await this.ai.analyze(context);
                
                if (decision.confidence >= this.config.ai.minConfidence && decision.action !== 'HOLD') {
                    const sl = decision.sl || (decision.action === 'BUY' ? price - 2*currentAtr : price + 2*currentAtr);
                    const tp = decision.tp || (decision.action === 'BUY' ? price + 3*currentAtr : price - 3*currentAtr);
                    
                    const qty = Utils.calcSize(this.exchange.balance, price, sl, this.config.risk.maxRiskPerTrade);

                    if (qty.gt(0)) {
                        await this.exchange.execute(decision.action, qty.toNumber(), sl, tp);
                    }
                }
            }

            this.renderHUD(price, score, currentRsi, this.data.latency, currentFisher, currentAtr, imbalance, decision);

        } catch (e) {
            console.error(COLOR.RED(`[Loop Error] ${e.message}`));
        } finally {
            this.isProcessing = false;
        }
    }

    renderHUD(price, score, rsi, latency, fisher, atr, imbalance, aiSignal) {
        const time = Utils.timestamp();
        const latColor = latency > 500 ? COLOR.RED : COLOR.GREEN;
        const scoreColor = score > 0 ? COLOR.GREEN : COLOR.RED;
        const fishColor = fisher > 0 ? COLOR.BLUE : COLOR.PURPLE;
        const imbColor = imbalance > 0 ? COLOR.GREEN : COLOR.RED;
        const posText = this.exchange.position ? `${this.exchange.position.action}` : 'FLAT';
        
        // Safe retrieval of AI data
        const volText = aiSignal.volatilityForecast ? `Vol: ${aiSignal.volatilityForecast.substring(0,1)}` : 'Vol: M';
        const entryText = aiSignal.aiEntry && aiSignal.aiEntry > 0 ? `E: ${aiSignal.aiEntry.toFixed(2)}` : 'E: N/A';
        const volColor = aiSignal.volatilityForecast === 'HIGH' ? COLOR.RED : COLOR.GREEN;

        process.stdout.write(
            `\r${COLOR.GRAY(time)} | ${COLOR.BOLD(this.config.symbol)} ${price.toFixed(2)} | ` +
            `Lat: ${latColor(latency+'ms')} | ` +
            `Score: ${scoreColor(score.toFixed(1))} | ` +
            `RSI: ${rsi.toFixed(1)} | ` +
            `Fish: ${fishColor(fisher.toFixed(2))} | ` +
            `ATR: ${atr.toFixed(2)} | ` +
            `Imb: ${imbColor((imbalance*100).toFixed(0)+'%')} | ` +
            `${COLOR.YELLOW(posText)} | ` + 
            `${volColor(volText)} | ` + 
            `${COLOR.CYAN(entryText)}`
        );
    }
}

// === START ===
new Leviathan();
