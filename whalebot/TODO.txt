# TODO List for wb.py Improvements

This document outlines potential improvements for the `wb.py` trading bot, focusing on enhancing its weighted scoring system, robustness, and clarity.

## 1. Enhance Weighted Scoring System

The current weighted scoring system combines various indicator signals. These improvements aim to make the scoring more robust, transparent, and adaptable.

### 1.1 Implement Hysteresis and Cooldown for Signal Switching

**Problem:** The bot can experience whipsaws (frequent BUY/SELL/HOLD switches) if the signal score hovers around the `signal_score_threshold`. This can lead to overtrading and losses.

**Solution:** Introduce hysteresis (a band around the threshold) and a cooldown period after a signal is issued. This prevents rapid signal changes and ensures a minimum time between trades.

**Current State:**
- `signal_score_threshold` is used for direct comparison.
- No explicit cooldown or hysteresis.

**Proposed Changes:**
- Add `cooldown_sec` and `hysteresis_ratio` to `config.json`.
- Modify `TradingAnalyzer.generate_trading_signal` to incorporate this logic.

**Code Snippet (config.json update - already done in previous step):**
```json
{
    // ... other config ...
    "signal_score_threshold": 2.0,
    "cooldown_sec": 60,
    "hysteresis_ratio": 0.85,
    // ... other config ...
}
```

**Code Snippet (TradingAnalyzer.generate_trading_signal modification):**
```python
# In TradingAnalyzer.__init__
self._last_signal_ts = 0 # Initialize last signal timestamp
self._last_signal_score = 0.0 # Initialize last signal score

# In TradingAnalyzer.generate_trading_signal
# ... (existing signal calculation logic) ...

        # --- Final Signal Determination with Hysteresis and Cooldown ---
        threshold = self.config["signal_score_threshold"]
        cooldown_sec = self.config["cooldown_sec"]
        hysteresis_ratio = self.config["hysteresis_ratio"]

        final_signal = "HOLD"
        now_ts = int(time.time())

        # Apply hysteresis
        # If current score is within hysteresis band of previous signal, maintain previous signal
        # This prevents rapid flips around the threshold
        if self._last_signal_score > 0 and signal_score < threshold * hysteresis_ratio:
            # If previous was BUY and current score drops but is still within hysteresis, keep BUY
            # (This logic needs careful consideration based on desired behavior)
            pass # For simplicity, we'll apply hysteresis on the final decision below

        is_strong_buy = signal_score >= threshold
        is_strong_sell = signal_score <= -threshold

        # Apply hysteresis to prevent immediate flip-flops
        if self._last_signal_score > 0 and signal_score > -threshold * hysteresis_ratio and not is_strong_buy:
            # If previously BUY, and current score is not a strong SELL, and not a strong BUY, hold previous BUY
            final_signal = "BUY"
        elif self._last_signal_score < 0 and signal_score < threshold * hysteresis_ratio and not is_strong_sell:
            # If previously SELL, and current score is not a strong BUY, and not a strong SELL, hold previous SELL
            final_signal = "SELL"
        elif is_strong_buy:
            final_signal = "BUY"
        elif is_strong_sell:
            final_signal = "SELL"

        # Apply cooldown period
        if final_signal != "HOLD":
            if now_ts - self._last_signal_ts < cooldown_sec:
                self.logger.info(f"{NEON_YELLOW}Signal '{final_signal}' ignored due to cooldown ({cooldown_sec - (now_ts - self._last_signal_ts)}s remaining).{RESET}")
                final_signal = "HOLD"
            else:
                self._last_signal_ts = now_ts # Update timestamp only if signal is issued

        # Update last signal score for next iteration's hysteresis
        self._last_signal_score = signal_score

        self.logger.info(f"{NEON_YELLOW}Raw Signal Score: {signal_score:.2f}, Final Signal: {final_signal}{RESET}")
        return final_signal, signal_score
```

### 1.2 Implement Normalization for Indicator Contributions

**Problem:** Different indicators produce values on different scales. Directly adding their weighted values can lead to indicators with larger value ranges disproportionately influencing the total score, even if their weight is low.

**Solution:** Normalize individual indicator scores to a consistent range (e.g., -1 to +1) before applying weights. This ensures that weights accurately reflect the desired influence of each indicator.

**Current State:**
- Indicator contributions are `weight * raw_indicator_value` or `weight * factor`.

**Proposed Changes:**
- For indicators with a clear range (RSI, StochRSI, CCI, WR, MFI), apply a normalization formula.
- For others, ensure their contribution is already scaled appropriately or define a scaling factor.

**Code Snippet (Example for RSI in `generate_trading_signal`):**
```python
# In TradingAnalyzer.generate_trading_signal, within the RSI block:
            # RSI
            if active_indicators.get("rsi", False):
                rsi = self._get_indicator_value("RSI")
                if not pd.isna(rsi):
                    # Normalize RSI to a -1 to +1 scale
                    # -1 for 0 RSI (strong oversold), +1 for 100 RSI (strong overbought)
                    normalized_rsi = (rsi - 50) / 50
                    # Apply weight to normalized score
                    signal_score += normalized_rsi * weights.get("momentum_rsi_stoch_cci_wr_mfi", 0) * 0.5 # Adjust factor as needed
                    # Example breakdown logging (see next section)
                    # signal_breakdown["RSI"] = normalized_rsi * weights.get("momentum_rsi_stoch_cci_wr_mfi", 0) * 0.5
```

### 1.3 Implement Logging of Individual Contributions

**Problem:** The current logging only shows the final `signal_score`. It's difficult to debug or understand why a particular signal was generated without seeing the contribution of each indicator.

**Solution:** Store the contribution of each indicator to the `signal_score` in a dictionary and log this breakdown.

**Current State:**
- Only `signal_score` is logged.

**Proposed Changes:**
- Initialize a `signal_breakdown` dictionary in `generate_trading_signal`.
- Add each indicator's weighted contribution to this dictionary.
- Modify `display_indicator_values_and_price` to accept and display this breakdown.

**Code Snippet (TradingAnalyzer.generate_trading_signal modification):**
```python
# In TradingAnalyzer.generate_trading_signal
        signal_score = 0.0
        signal_breakdown = {} # New: Dictionary to store individual contributions

        # ... (inside each indicator's scoring block) ...
        # Example for EMA Alignment:
        # if ema_short > ema_long:
        #     contrib = weights.get("ema_alignment", 0)
        #     signal_score += contrib
        #     signal_breakdown["EMA_Alignment"] = contrib # Store contribution
        # elif ema_short < ema_long:
        #     contrib = -weights.get("ema_alignment", 0)
        #     signal_score += contrib
        #     signal_breakdown["EMA_Alignment"] = contrib # Store contribution

        # ... (at the end of generate_trading_signal) ...
        # Pass signal_breakdown to display function
        # display_indicator_values_and_price(config, logger, current_price, df, orderbook_data, mtf_trends, signal_breakdown)
        return final_signal, signal_score, signal_breakdown # Return breakdown as well
```

**Code Snippet (display_indicator_values_and_price modification):**
```python
# In display_indicator_values_and_price function signature:
def display_indicator_values_and_price(
    config: dict[str, Any],
    logger: logging.Logger,
    current_price: Decimal,
    df: pd.DataFrame,
    orderbook_data: dict | None,
    mtf_trends: dict[str, str],
    signal_breakdown: dict | None = None # New parameter
) -> None:
    # ... (existing display logic) ...

    if signal_breakdown:
        logger.info(f"{NEON_CYAN}--- Signal Score Breakdown ---{RESET}")
        # Sort by absolute contribution for better readability
        sorted_breakdown = sorted(signal_breakdown.items(), key=lambda item: abs(item[1]), reverse=True)
        for indicator, contribution in sorted_breakdown:
            color = (Fore.GREEN if contribution > 0 else (Fore.RED if contribution < 0 else Fore.YELLOW))
            logger.info(f"  {color}{indicator:<25}: {contribution: .2f}{RESET}")

    # ... (rest of the function) ...
```

## 2. General Code Improvements

### 2.1 Centralize Indicator Calculation Calls

**Problem:** Indicator calculation calls are scattered throughout `TradingAnalyzer._calculate_all_indicators`. This makes it harder to manage and ensure consistency (e.g., `_safe_calculate` usage).

**Solution:** Create a more centralized and standardized way to call indicator functions, perhaps using a dictionary mapping indicator names to their calculation functions and required parameters.

**Current State:**
```python
        # SMA
        if cfg["indicators"].get("sma_10", False):
            self.df["SMA_10"] = self._safe_calculate(
                lambda: self.df["close"].rolling(window=isd["sma_short_period"]).mean(),
                "SMA_10",
                min_data_points=isd["sma_short_period"],
            )
            # ...
```

**Proposed Changes (Conceptual):**
```python
# In TradingAnalyzer._calculate_all_indicators
        indicator_map = {
            "SMA_10": {"func": self._calculate_sma, "args": {"period": isd["sma_short_period"]}, "min_data": isd["sma_short_period"]},
            "RSI": {"func": self.calculate_rsi, "args": {"period": isd["rsi_period"]}, "min_data": isd["rsi_period"] + 1},
            # ... define for all indicators
        }

        for ind_name, ind_info in indicator_map.items():
            if cfg["indicators"].get(ind_name.lower(), False): # Assuming config keys are lowercase
                result = self._safe_calculate(ind_info["func"], ind_name, ind_info["min_data"], **ind_info["args"])
                if result is not None:
                    # Assign result to self.df and self.indicator_values based on type (Series, tuple)
                    if isinstance(result, pd.Series):
                        self.df[ind_name] = result
                        self.indicator_values[ind_name] = result.iloc[-1]
                    elif isinstance(result, tuple):
                        # Handle multiple return values (e.g., StochRSI_K, StochRSI_D)
                        # This would require a more sophisticated mapping or a dedicated handler for tuples
                        pass
```

### 2.2 Improve Error Handling and Logging Consistency

**Problem:** Error logging is sometimes inconsistent (e.g., `logger.error` vs. `logger.warning`, varying message formats).

**Solution:** Standardize error messages and ensure appropriate logging levels are used. Use f-strings consistently for logging.

**Current State (Example):**
```python
            self.logger.warning(
                f"{NEON_YELLOW}Calculated stop loss distance is zero or negative. Cannot determine order size.{RESET}"
            )
```

**Proposed Changes (Conceptual):**
```python
            self.logger.warning(f"[{self.symbol}] Calculated stop loss distance is zero or negative. Cannot determine order size.")
            # Use f-strings and consistent formatting without colorama codes directly in the message string.
            # Colorama should be handled by the logger's formatter if desired.
```

### 2.3 Refactor `_get_mtf_trend`

**Problem:** The `_get_mtf_trend` function creates a new `TradingAnalyzer` instance inside a loop, which is inefficient.

**Solution:** Pass the necessary data (e.g., `df`, `config`, `logger`, `symbol`) to a static helper function or a pre-initialized `TradingAnalyzer` instance if possible, to avoid repeated object creation.

**Current State:**
```python
        if indicator_type == "ehlers_supertrend":
            temp_analyzer = TradingAnalyzer(
                higher_tf_df, self.config, self.logger, self.symbol
            )
            st_result = temp_analyzer.calculate_ehlers_supertrend(
                period=self.indicator_settings["ehlers_slow_period"],
                multiplier=self.indicator_settings["ehlers_slow_multiplier"],
            )
```

**Proposed Changes (Conceptual):**
```python
# Option 1: Make calculate_ehlers_supertrend a static method or move to a utility module
# In TradingAnalyzer._get_mtf_trend
        if indicator_type == "ehlers_supertrend":
            st_result = TradingAnalyzer.calculate_ehlers_supertrend_static( # New static method
                higher_tf_df,
                period=self.indicator_settings["ehlers_slow_period"],
                multiplier=self.indicator_settings["ehlers_slow_multiplier"],
                logger=self.logger, # Pass logger if needed for internal logging
                symbol=self.symbol # Pass symbol for logging context
            )

# Option 2: Pass a pre-initialized analyzer if context allows (less likely for MTF)
```

This `TODO.txt` provides a structured plan for improving `wb.py`.
