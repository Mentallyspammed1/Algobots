\n/**\n * ðŸŒŠ WHALEWAVE PRO - TITAN EDITION v6.1 (Integrated Engine - MONOLITHIC)\n * ----------------------------------------------------------------------\n * - FIXED: All configuration and TA helper logic is now fully self-contained\n *          to avoid module import mismatches.\n */\n\nimport axios from \'axios\';\nimport chalk from \'chalk\';\nimport { GoogleGenerativeAI } from \'@google/generative-ai\';\nimport dotenv from \'dotenv\';\nimport fs from \'fs\';\nimport { setTimeout } from \'timers/promises\';\nimport { Decimal } from \'decimal.js\';\nimport {\n    safeArr, safeGetFinalValue, wilders, sma, ema, atr, rsi, stoch, macd, adx, mfi,\n    chop, cci, linReg, bollinger, keltner, superTrend, chandelierExit, vwap,\n    findFVG, detectDivergence, historicalVolatility, marketRegime,\n    fibPivots, getOrderbookLevels, getFibonacciPivotsAsSR, getHistoricalHighLowSR, combineAndFilterSR,\n    calculateZlema, ehlersSuperTrendCross // Import newly added functions\n} from \'./indicators.js\'; // Import indicators\n\ndotenv.config();\n\n// --- âš™ï¸ CONFIG LOADER (Reading from config.json) ---\nlet config = {};\ntry {\n    const configContent = fs.readFileSync(\'config.json\', \'utf-8\');\n    config = JSON.parse(configContent);\n} catch (e) { console.error(chalk.red(`[CRITICAL] Could not load config.json: ${e.message}`)); process.exit(1); }\nDecimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_DOWN });\n\n// --- ðŸŽ¨ THEME MANAGER ---\nconst NEON = {\n    GREEN: chalk.hex(\'#39FF14\'), RED: chalk.hex(\'#FF073A\'), BLUE: chalk.hex(\'#00AFFF\'),\n    CYAN: chalk.hex(\'#00FFFF\'), PURPLE: chalk.hex(\'#BC13FE\'), YELLOW: chalk.hex(\'#FAED27\'),\n    GRAY: chalk.hex(\'#666666\'), ORANGE: chalk.hex(\'#FF9F00\'), BOLD: chalk.bold,\n    bg: (text) => chalk.bgHex(\'#222\')(text)\n};\n\n// --- ðŸ“¡ ENHANCED DATA PROVIDER ---\nclass EnhancedDataProvider {\n    constructor() { this.api = axios.create({ baseURL: \'https://api.bybit.com/v5/market\', timeout: config.api.timeout }); }\n    async fetchWithRetry(url, params, retries = config.api.retries) {\n        for (let attempt = 0; attempt <= retries; attempt++) {\n            try { return (await this.api.get(url, { params })).data; }\n            catch (error) { if (attempt === retries) throw error; await setTimeout(Math.pow(config.api.backoff_factor, attempt) * 1000); }\n        }\n    }\n    async fetchAll() {\n        try {\n            const [ticker, kline, klineMTF, ob, daily] = await Promise.all([\n                this.fetchWithRetry(\'/tickers\', { category: \'linear\', symbol: config.symbol }),\n                this.fetchWithRetry(\'/kline\', { category: \'linear\', symbol: config.symbol, interval: config.interval, limit: config.limit }),\n                this.fetchWithRetry(\'/kline\', { category: \'linear\', symbol: config.symbol, interval: config.trend_interval, limit: 100 }),\n                this.fetchWithRetry(\'/orderbook\', { category: \'linear\', symbol: config.symbol, limit: config.orderbook.depth }),\n                this.fetchWithRetry(\'/kline\', { category: \'linear\', symbol: config.symbol, interval: \'D\', limit: 2 })\n            ]);\n            const parseC = (list) => list.reverse().map(c => ({ o: parseFloat(c[1]), h: parseFloat(c[2]), l: parseFloat(c[3]), c: parseFloat(c[4]), v: parseFloat(c[5]), t: parseInt(c[0]) }));\n            \n            return {\n                price: parseFloat(ticker.result.list[0].lastPrice), candles: parseC(kline.result.list), candlesMTF: parseC(klineMTF.result.list),\n                bids: ob.result.b.map(x => ({ p: parseFloat(x[0]), q: parseFloat(x[1]) })), asks: ob.result.a.map(x => ({ p: parseFloat(x[0]), q: parseFloat(x[1]) })),\n                daily: { h: parseFloat(daily.result.list[1][2]), l: parseFloat(daily.result.list[1][3]), c: parseFloat(daily.result.list[1][4]) },\n                timestamp: Date.now()\n            };\n        } catch (e) { console.warn(NEON.ORANGE(`[WARN] Data Fetch Fail: ${e.message}`)); return null; }\n    }\n}\n\n// --- ðŸ’° EXCHANGE & RISK MANAGEMENT ---\nclass EnhancedPaperExchange {\n    constructor() { \n        this.balance = new Decimal(config.paper_trading.initial_balance); this.startBal = this.balance;\n        this.pos = null; this.dailyPnL = new Decimal(0);\n    }\n    canTrade() {\n        const drawdown = this.startBal.sub(this.balance).div(this.startBal).mul(100);\n        if (drawdown.gt(config.risk.max_drawdown)) { console.log(NEON.RED(`ðŸš¨ MAX DRAWDOWN HIT`)); return false; }\n        const dailyLoss = this.dailyPnL.div(this.startBal).mul(100);\n        if (dailyLoss.lt(-config.risk.daily_loss_limit)) { console.log(NEON.RED(`ðŸš¨ DAILY LOSS LIMIT HIT`)); return false; }\n        return true;\n    }\n    evaluate(priceVal, signal) {\n        if (!this.canTrade()) { if (this.pos) this.handlePositionClose(new Decimal(priceVal), "RISK_STOP"); return; }\n        const price = new Decimal(priceVal);\n        if (this.pos) this.handlePositionClose(price);\n        if (!this.pos && signal.action !== \'HOLD\' && signal.confidence >= config.min_confidence) { this.handlePositionOpen(price, signal); }\n    }\n    handlePositionClose(price, forceReason = null) {\n        let close = false, reason = forceReason || \'\';\n        if (this.pos.side === \'BUY\') { if (forceReason || price.lte(this.pos.sl)) { close = true; reason = reason || \'SL Hit\'; } else if (price.gte(this.pos.tp)) { close = true; reason = reason || \'TP Hit\'; } } else { if (forceReason || price.gte(this.pos.sl)) { close = true; reason = reason || \'SL Hit\'; } else if (price.lte(this.pos.tp)) { close = true; reason = reason || \'TP Hit\'; } }\n        if (close) {\n            const slippage = price.mul(config.paper_trading.slippage);\n            const exitPrice = this.pos.side === \'BUY\' ? price.sub(slippage) : price.add(slippage);\n            const rawPnl = this.pos.side === \'BUY\' ? exitPrice.sub(this.pos.entry).mul(this.pos.qty) : this.pos.entry.sub(exitPrice).mul(this.pos.qty);\n            const fee = exitPrice.mul(this.pos.qty).mul(config.paper_trading.fee);\n            const netPnl = rawPnl.sub(fee);\n            this.balance = this.balance.add(netPnl); this.dailyPnL = this.dailyPnL.add(netPnl);\n            const color = netPnl.gte(0) ? NEON.GREEN : NEON.RED;\n            console.log(`${NEON.BOLD(reason)}! PnL: ${color(netPnl.toFixed(2))} [${this.pos.strategy}]`);\n            this.pos = null;\n        }\n    }\n    handlePositionOpen(price, signal) {\n        const entry = new Decimal(signal.entry); const sl = new Decimal(signal.sl); const tp = new Decimal(signal.tp);\n        const dist = entry.sub(sl).abs(); if (dist.isZero()) return;\n        const riskAmt = this.balance.mul(config.paper_trading.risk_percent / 100);\n        let qty = riskAmt.div(dist);\n        const maxQty = this.balance.mul(config.paper_trading.leverage_cap).div(price);\n        if (qty.gt(maxQty)) qty = maxQty;\n        const slippage = price.mul(config.paper_trading.slippage);\n        const execPrice = signal.action === \'BUY\' ? entry.add(slippage) : entry.sub(slippage);\n        const fee = execPrice.mul(qty).mul(config.paper_trading.fee);\n        this.balance = this.balance.sub(fee);\n        this.pos = { side: signal.action, entry: execPrice, qty: qty, sl: sl, tp: tp, strategy: signal.strategy };\n        console.log(NEON.GREEN(`OPEN ${signal.action} [${signal.strategy}] @ ${execPrice.toFixed(4)} | Size: ${qty.toFixed(4)}`));\n    }\n}\n\n// --- ðŸ§  MULTI-STRATEGY AI BRAIN ---\nclass EnhancedGeminiBrain {\n    constructor() {\n        const key = process.env.GEMINI_API_KEY;\n        if (!key) { console.error(\'Missing GEMINI_API_KEY\'); process.exit(1); }\n        this.model = new GoogleGenerativeAI(key).getGenerativeModel({ model: config.gemini_model });\n    }\n\n    async analyze(ctx) {\n        const prompt = `\n        ACT AS: Institutional Scalping Algorithm.\n        OBJECTIVE: Select the single best strategy (1-5) and provide a precise trade plan, or HOLD.\n\n        QUANTITATIVE BIAS:\n        - **WSS Score (Crucial Filter):** ${ctx.wss} (Bias: ${ctx.wss > 0 ? \'BULLISH\' : \'BEARISH\'})\n        - CRITICAL RULE: Action must align with WSS. BUY requires WSS >= ${config.indicators.wss_weights.action_threshold}. SELL requires WSS <= -${config.indicators.wss_weights.action_threshold}.\n\n        MARKET CONTEXT:\n        - Price: ${ctx.price} | Volatility: ${ctx.volatility.toFixed(4)} | Regime: ${ctx.marketRegime}\n        - Trend (15m): ${ctx.trend_mtf} | Trend (3m): ${ctx.trend_angle.slope.toFixed(4)} (Slope) | ADX: ${ctx.adx.toFixed(2)}\n        - Momentum: RSI=${ctx.rsi.toFixed(2)}, Stoch=${ctx.stoch_k.toFixed(0)}, MACD=${ctx.macd_hist.toFixed(4)}\n        - Structure: VWAP=${ctx.vwap.toFixed(4)}, FVG=${ctx.fvg ? ctx.fvg.type + \' @ \' + ctx.fvg.price.toFixed(2) : \'None\'}, Squeeze: ${ctx.isSqueeze}\n        - Divergence: ${ctx.divergence}\n        - Key Levels: Fib P=${ctx.fibs.P.toFixed(2)}, S1=${ctx.fibs.S1.toFixed(2)}, R1=${ctx.fibs.R1.toFixed(2)}\n        - Support/Resistance: ${ctx.sr_levels}\n\n        STRATEGY ARCHETYPES:\n        1. TREND_SURFER (WSS Trend > 1.0): Pullback to VWAP/EMA, anticipate continuation.\n        2. VOLATILITY_BREAKOUT (Squeeze=YES): Trade in direction of MTF trend on volatility expansion.\n        3. MEAN_REVERSION (WSS Momentum < -1.0 or > 1.0, Chop > 60): Fade extreme RSI/Stoch.\n        4. LIQUIDITY_GRAB (Price Near FVG/Wall): Fade or trade the retest/bounce of a liquidity zone.\n        5. DIVERGENCE_HUNT (Divergence != NONE): High conviction reversal trade using swing high/low for SL.\n\n        INSTRUCTIONS:\n        - If the WSS does not meet the threshold, or if no strategy is clear, return "HOLD".\n        - Calculate precise entry, SL, and TP (1:1.5 RR minimum, use ATR/Pivot/FVG for targets).\n\n        OUTPUT JSON ONLY: { "action": "BUY"|"SELL"|"HOLD", "strategy": "STRATEGY_NAME", "confidence": 0.0-1.0, "entry": number, "sl": number, "tp": number, "reason": "string" }\n        \`;\n\n        try {\n            const res = await this.model.generateContent(prompt);\n            const text = res.response.text().replace(/```json|```/g, \'\').trim();\n            const start = text.indexOf(\'{\');\n            const end = text.lastIndexOf(\'}\');\n            if (start === -1 || end === -1) throw new Error("Invalid JSON: AI response error");\n            return JSON.parse(text.substring(start, end + 1));\n        } catch (e) {\n            return { action: "HOLD", confidence: 0, reason: `AI Comms Failure: ${e.message}` };\n        }\n    }\n}\n\n// --- ðŸ”„ MAIN TRADING ENGINE ---\nclass TradingEngine {\n    constructor() {\n        this.dataProvider = new EnhancedDataProvider();\n        this.exchange = new EnhancedPaperExchange();\n        this.ai = new EnhancedGeminiBrain();\n        this.isRunning = true;\n        this.lastData = null; \n        this.dashboardClient = axios.create({ baseURL: \'http://localhost:\' + (process.env.PORT || 3000) });\n    }\n\n    async start() {\n        console.log(NEON.bg(NEON.PURPLE(` ðŸš€ WHALEWAVE TITAN v6.1 STARTING... `)));\n        \n        while (this.isRunning) {\n            try {\n                const data = await this.dataProvider.fetchAll();\n                this.lastData = data;\n                if (!data) { await setTimeout(config.loop_delay * 1000); continue; }\n\n                const analysis = await this.performAnalysis(data);\n                const context = this.buildContext(data, analysis);\n                const signal = await this.ai.analyze(context);\n\n                this.exchange.evaluate(data.price, signal);\n                \n                // PUSH data to the dashboard\n                this.pushDashboardData(data, context, signal);\n\n            } catch (e) { console.error(NEON.RED(`Loop Critical Error: ${e.message}`)); }\n            await setTimeout(config.loop_delay * 1000);\n        }\n    }\n\n    async performAnalysis(data) {\n        const c = data.candles.map(x => x.c); const h = data.candles.map(x => x.h);\n        const l = data.candles.map(x => x.l); const v = data.candles.map(x => x.v);\n        const mtfC = data.candlesMTF.map(x => x.c);\n\n        // Parallel Calculation (Full Suite)\n        const [rsi, stoch, macd, adx, mfi, chop, reg, bb, kc, atr, fvg, vwap, st, ce, cci] = await Promise.all([\n            rsi(c, config.indicators.rsi), stoch(h, l, c, config.indicators.stoch_period, config.indicators.stoch_k, config.indicators.stoch_d), \n            macd(c, config.indicators.macd_fast, config.indicators.macd_slow, config.indicators.macd_sig), adx(h, l, c, config.indicators.adx_period),\n            mfi(h, l, c, v, config.indicators.mfi), chop(h, l, c, config.indicators.chop_period),\n            linReg(c, config.indicators.linreg_period), bollinger(c, config.indicators.bb_period, config.indicators.bb_std),\n            keltner(h, l, c, config.indicators.kc_period, config.indicators.kc_mult), atr(h, l, c, config.indicators.atr_period),\n            findFVG(data.candles), vwap(h, l, c, v, config.indicators.vwap_period),\n            superTrend(h, l, c, config.indicators.atr_period, config.indicators.st_factor),\n            chandelierExit(h, l, c, config.indicators.ce_period, config.indicators.ce_mult),\n            cci(h, l, c, config.indicators.cci_period)\n        ]);\n\n        const last = c.length - 1;\n        const isSqueeze = (bb.upper[last] < kc.upper[last]) && (bb.lower[last] > kc.lower[last]);\n        const divergence = detectDivergence(c, rsi);\n        const volatility = historicalVolatility(c);\n        const avgVolatility = sma(volatility, 50);\n        const mtfSma = sma(mtfC, 20);\n        const trendMTF = mtfC[mtfC.length-1] > mtfSma[mtfSma.length-1] ? "BULLISH" : "BEARISH";\n        const fibs = fibPivots(data.daily.h, data.daily.l, data.daily.c);\n\n        // Walls\n        const avgBid = data.bids.reduce((a,b)=>a+b.q,0)/data.bids.length;\n        const buyWall = data.bids.find(b => b.q > avgBid * config.orderbook.wall_threshold)?.p;\n        const sellWall = data.asks.find(a => a.q > avgBid * config.orderbook.wall_threshold)?.p;\n\n        const analysis = { \n            closes: c, rsi, stoch, macd, adx, mfi, chop, reg, bb, kc, atr, fvg, vwap, st, ce, cci,\n            isSqueeze, divergence, volatility, avgVolatility, trendMTF, buyWall, sellWall, fibs\n        };\n        analysis.wss = calculateWSS(analysis, data.price);\n        analysis.avgVolatility = avgVolatility;\n        return analysis;\n    }\n\n    buildContext(d, a) {\n        const last = a.closes.length - 1;\n        const linReg = safeGetFinalValue(a, \'reg\', 4);\n        \n        // Calculate S/R levels from multiple sources\n        const orderBookSR = getOrderbookLevels(d.bids, d.asks, d.price, config.orderbook.sr_levels);\n        const fibPivotSR = getFibonacciPivotsAsSR(a.fibs);\n        const historicalSR = getHistoricalHighLowSR(d.candles.map(c => c.h), d.candles.map(c => c.l), d.price, 50, config.orderbook.sr_levels); // Use last 50 candles for historical SR\n\n        const combinedSR = combineAndFilterSR(\n            d.price, \n            config.orderbook.sr_levels, \n            5, // Proximity threshold in percent (e.g., 5% of current price)\n            orderBookSR, \n            fibPivotSR, \n            historicalSR\n        );\n\n        return {\n            price: d.price, rsi: a.rsi[last], stoch_k: a.stoch.k[last], macd_hist: (a.macd.hist[last] || 0),\n            adx: a.adx[last], chop: a.chop[last], vwap: a.vwap[last],\n            trend_angle: linReg, trend_mtf: a.trendMTF, isSqueeze: a.isSqueeze ? \'YES\' : \'NO\', fvg: a.fvg, divergence: a.divergence,\n            walls: { buy: a.buyWall, sell: a.sellWall }, fibs: a.fibs,\n            volatility: a.volatility[last], marketRegime: marketRegime(a.closes, a.volatility),\n            wss: a.wss, \n            sr_levels: `S:[${combinedSR.supportLevels.join(\', \')}] R:[${combinedSR.resistanceLevels.join(\', \')}]`\n        };\n    }\n    \n    // --- Dashboard Data Push ---\n    async pushDashboardData(data, context, signal) {\n        const p = this.exchange.pos;\n        const curPnl = p ? (p.side === \'BUY\' ? new Decimal(data.price).sub(p.entry).mul(p.qty) : p.entry.sub(data.price).mul(p.qty)) : new Decimal(0);\n        \n        const dashboardData = {\n            price: data.price.toFixed(4),\n            wss: context.wss.toFixed(2),\n            wss_action: signal.action,\n            wss_confidence: signal.confidence,\n            ai_reason: signal.reason,\n            acc_balance: this.exchange.balance.toFixed(2),\n            daily_pnl: this.exchange.dailyPnL.toFixed(2),\n            pos_active: !!p,\n            pos_side: p?.side,\n            pos_entry: p?.entry.toFixed(4),\n            pos_sl: p?.sl.toFixed(4),\n            pos_tp: p?.tp.toFixed(4),\n            pos_pnl: curPnl.toFixed(2),\n            indicators: {\n                rsi: context.rsi.toFixed(2),\n                adx: context.adx.toFixed(2),\n                stoch_k: context.stoch_k.toFixed(0),\n                chop: context.chop.toFixed(2),\n                fvg: context.fvg ? context.fvg.type : \'None\',\n                trend_mtf: context.trend_mtf,\n                regime: context.marketRegime\n            }\n        };\n\n        try { await this.dashboardClient.post(\'/api/dashboard\', dashboardData); } \n        catch (e) { /* Error handling for failed push to dashboard */ }\n    }\n}\n\n// --- START ---\nconst engine = new TradingEngine();\nprocess.on(\'SIGINT\', () => { \n    engine.isRunning = false; \n    console.log(NEON.RED("\\nðŸ›‘ SHUTTING DOWN GRACEFULLY...")); \n    if(engine.lastData) engine.exchange.handlePositionClose(new Decimal(engine.lastData.price), "SHUTDOWN");\n    process.exit(0); \n});\nprocess.on(\'SIGTERM\', () => { engine.isRunning = false; process.exit(0); });\nengine.start();\n
