<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Pro Trading Terminal</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #0a0a1a;
            --secondary-bg: #13132b;
            --tertiary-bg: #1a1a3a;
            --quaternary-bg: #22224a;
            --primary-text: #e0e0ff;
            --secondary-text: #a0a0ff;
            --accent-cyan: #00ffff;
            --accent-green: #00ff88;
            --accent-pink: #ff0088;
            --accent-orange: #ff8800;
            --accent-purple: #8800ff;
            --border-color: #4444aa;
            --success-color: #00ff88;
            --danger-color: #ff0088;
            --warning-color: #ffaa00;
            --chart-background: #181830;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            background: linear-gradient(135deg, var(--primary-bg) 0%, var(--secondary-bg) 100%);
            color: var(--primary-text);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        .container {
            max-width: 1800px;
            margin: 15px auto;
            background-color: var(--secondary-bg);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(68, 68, 170, 0.2);
            border: 2px solid var(--border-color);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px var(--accent-cyan), 0 0 20px var(--accent-cyan);
            margin-bottom: 25px;
            font-size: 2.5em;
            font-weight: 700;
            letter-spacing: 1px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px var(--accent-cyan), 0 0 20px var(--accent-cyan); }
            to { text-shadow: 0 0 15px var(--accent-cyan), 0 0 30px var(--accent-cyan); }
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: linear-gradient(135deg, var(--quaternary-bg) 0%, var(--tertiary-bg) 100%);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        label {
            margin-bottom: 5px;
            font-size: 0.85em;
            color: var(--secondary-text);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="number"],
        select,
        input[type="text"] {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: linear-gradient(135deg, var(--tertiary-bg) 0%, rgba(26, 26, 58, 0.8) 100%);
            color: var(--primary-text);
            font-size: 1em;
            min-width: 120px;
            transition: all 0.3s ease;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type="number"]:focus,
        select:focus,
        input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 10px var(--accent-cyan), inset 0 1px 3px rgba(0, 0, 0, 0.3);
            border-color: var(--accent-cyan);
            transform: translateY(-1px);
        }

        .symbol-search-container {
            position: relative;
            grid-column: span 2;
        }

        #symbolSearch {
            width: 100%;
            padding: 12px;
            padding-left: 40px;
            font-size: 1.1em;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text);
            pointer-events: none;
            z-index: 1;
        }

        .symbol-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: var(--tertiary-bg);
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 8px 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .symbol-dropdown.active {
            display: block;
        }

        .symbol-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(68, 68, 170, 0.1);
        }

        .symbol-item:hover {
            background: rgba(0, 255, 255, 0.1);
            padding-left: 20px;
        }

        .symbol-item.selected {
            background: rgba(0, 255, 255, 0.2);
            font-weight: bold;
        }

        .symbol-info {
            font-size: 0.8em;
            color: var(--secondary-text);
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--accent-pink) 0%, #cc0066 100%);
            color: var(--primary-text);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 0, 136, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            grid-column: span 2;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(135deg, #cc0066 0%, var(--accent-pink) 100%);
            box-shadow: 0 6px 20px rgba(255, 0, 136, 0.5);
            transform: translateY(-2px);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(255, 0, 136, 0.3);
        }

        button:disabled {
            background: linear-gradient(135deg, #5f5f5f 0%, #3f3f3f 100%);
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.7;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .action-button {
            padding: 8px 16px;
            font-size: 0.9em;
            grid-column: span 1;
        }

        #chartContainer {
            position: relative;
            height: 70vh;
            min-height: 500px;
            width: 100%;
            background: var(--chart-background);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            border: 2px solid var(--border-color);
            margin-bottom: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3), inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        #chartCanvas {
            max-height: 100%;
            max-width: 100%;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 26, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 10px;
            display: none;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--accent-cyan);
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--accent-cyan);
            font-size: 1.2em;
            text-shadow: 0 0 10px var(--accent-cyan);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .message {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-size: 1.05em;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .error-message {
            background: linear-gradient(135deg, rgba(255, 0, 136, 0.2) 0%, rgba(255, 0, 136, 0.1) 100%);
            border: 1px solid var(--danger-color);
            color: var(--danger-color);
            box-shadow: 0 0 10px rgba(255, 0, 136, 0.3);
        }

        .success-message {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 255, 136, 0.1) 100%);
            border: 1px solid var(--success-color);
            color: var(--success-color);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .warning-message {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.2) 0%, rgba(255, 170, 0, 0.1) 100%);
            border: 1px solid var(--warning-color);
            color: var(--warning-color);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        .ticker-info {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, var(--tertiary-bg) 0%, rgba(26, 26, 58, 0.8) 100%);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .ticker-info:hover {
            box-shadow: 0 6px 25px rgba(68, 68, 170, 0.4);
            transform: translateY(-2px);
        }

        .ticker-info h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: var(--accent-cyan);
            text-align: center;
            font-size: 1.4em;
            text-shadow: 0 0 5px var(--accent-cyan);
        }
        
        .live-price-box {
            background: linear-gradient(135deg, var(--quaternary-bg) 0%, var(--tertiary-bg) 100%);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .live-price-box .price-value {
            font-size: 2.5em;
            font-weight: bold;
            color: var(--accent-green);
            text-shadow: 0 0 10px var(--accent-green);
            transition: color 0.5s ease-in-out;
        }
        
        .live-price-box .last-update {
            font-size: 0.8em;
            color: var(--secondary-text);
            margin-top: 5px;
        }

        .ticker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .ticker-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            background: linear-gradient(135deg, rgba(34, 34, 74, 0.5) 0%, rgba(26, 26, 58, 0.5) 100%);
            border-radius: 8px;
            border: 1px solid rgba(68, 68, 170, 0.3);
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .ticker-item:hover {
            background: linear-gradient(135deg, rgba(34, 34, 74, 0.7) 0%, rgba(26, 26, 58, 0.7) 100%);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(68, 68, 170, 0.3);
        }

        .ticker-label {
            font-size: 0.75em;
            color: var(--secondary-text);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ticker-value {
            font-weight: bold;
            font-size: 1.2em;
            transition: all 0.3s ease;
        }

        .ticker-value.positive {
            color: var(--accent-green);
            text-shadow: 0 0 5px var(--accent-green);
        }

        .ticker-value.negative {
            color: var(--accent-pink);
            text-shadow: 0 0 5px var(--accent-pink);
        }

        .indicator-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, var(--quaternary-bg) 0%, var(--tertiary-bg) 100%);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .indicator-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(26, 26, 58, 0.5);
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .indicator-toggle:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        .indicator-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-cyan);
        }

        .indicator-toggle label {
            cursor: pointer;
            margin: 0;
            color: var(--primary-text);
            font-size: 0.9em;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--tertiary-bg) 0%, rgba(26, 26, 58, 0.8) 100%);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid var(--border-color);
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(68, 68, 170, 0.4);
        }

        .stat-title {
            color: var(--secondary-text);
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--primary-text);
            text-shadow: 0 0 5px rgba(224, 224, 255, 0.5);
            transition: color 0.5s ease;
        }
        
        .stat-value.positive { color: var(--accent-green); }
        .stat-value.negative { color: var(--accent-pink); }
        .stat-value.neutral { color: var(--secondary-text); }


        .tab-container {
            margin-top: 25px;
        }

        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            background: rgba(26, 26, 58, 0.5);
            border-radius: 10px;
            padding: 5px;
            flex-wrap: wrap;
        }

        .tab-button {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            background: transparent;
            color: var(--primary-text);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        .tab-button:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        .tab-button.active {
            background: linear-gradient(135deg, var(--accent-cyan) 0%, var(--accent-purple) 100%);
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0, 255, 255, 0.3);
        }

        .tab-content {
            display: none;
            padding: 20px;
            background: linear-gradient(135deg, var(--tertiary-bg) 0%, rgba(26, 26, 58, 0.8) 100%);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            animation: fadeIn 0.5s ease-out;
        }

        .tab-content.active {
            display: block;
        }
        
        #signals-tab .signals-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #signals-tab .signal-item {
            background: rgba(34, 34, 74, 0.5);
            border-radius: 6px;
            padding: 10px;
            border-left: 3px solid;
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px;
        }

        #signals-tab .signal-item.buy {
            border-color: var(--accent-green);
        }
        
        #signals-tab .signal-item.sell {
            border-color: var(--accent-pink);
        }
        
        #signals-tab .signal-item .signal-info {
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        #signals-tab .signal-item .signal-time {
            font-size: 0.8em;
            color: var(--secondary-text);
            display: block;
            margin-top: 4px;
        }
        
        #signals-tab .signal-strength {
            font-weight: bold;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            white-space: nowrap;
        }
        
        #gemini-analysis-tab .stat-card {
            background: linear-gradient(135deg, rgba(0, 100, 150, 0.1) 0%, rgba(0, 255, 255, 0.1) 100%);
            border-color: var(--accent-cyan);
        }
        #gemini-analysis-tab .stat-card .stat-title { color: var(--accent-cyan); }
        #gemini-analysis-tab .stat-card .stat-value { font-size: 1.1em; font-weight: normal; text-align: left; }
        #gemini-analysis-tab .stat-card .stat-value p { margin-bottom: 1em; }
        #gemini-analysis-tab .stat-card .stat-value strong { color: var(--accent-green); }
        #gemini-analysis-tab .stat-card .stat-value em { color: var(--accent-pink); font-style: normal;}

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .preset-button {
            padding: 10px;
            background: linear-gradient(135deg, var(--tertiary-bg) 0%, rgba(26, 26, 58, 0.8) 100%);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--primary-text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .preset-button:hover {
            background: linear-gradient(135deg, var(--accent-purple) 0%, var(--accent-cyan) 100%);
            box-shadow: 0 4px 15px rgba(136, 0, 255, 0.4);
            transform: translateY(-2px);
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 350px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .notification {
            background: linear-gradient(135deg, var(--tertiary-bg) 0%, rgba(26, 26, 58, 0.95) 100%);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            animation: slideInRight 0.3s ease-out;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--accent-cyan);
            animation: progressBar 3s linear forwards;
        }

        @keyframes progressBar {
            from { width: 100%; }
            to { width: 0%; }
        }

        .notification.success .notification-progress { background: var(--success-color); }
        .notification.error .notification-progress { background: var(--danger-color); }
        .notification.warning .notification-progress { background: var(--warning-color); }

        .notification.success { border-color: var(--success-color); }
        .notification.error { border-color: var(--danger-color); }
        .notification.warning { border-color: var(--warning-color); }
        .notification.info { border-color: var(--accent-cyan); }


        .notification-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--primary-text);
        }
        .notification.success .notification-title { color: var(--success-color); }
        .notification.error .notification-title { color: var(--danger-color); }
        .notification.warning .notification-title { color: var(--warning-color); }
        .notification.info .notification-title { color: var(--accent-cyan); }


        .notification-message {
            font-size: 0.9em;
            color: var(--secondary-text);
        }

        @media (max-width: 1200px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            h1 {
                font-size: 2em;
            }
            #chartContainer {
                min-height: 400px;
            }
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            
            .symbol-search-container {
                grid-column: span 1;
            }
            
            button {
                grid-column: span 1;
            }
            
            .ticker-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .indicator-controls {
                grid-template-columns: 1fr;
            }
            .tab-buttons {
                flex-direction: column;
                gap: 8px;
            }
            .tab-button {
                width: 100%;
            }
            #chartContainer {
                height: 50vh;
                min-height: 400px;
            }
            
            .stats-container {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8em;
            }
            
            .controls {
                padding: 10px;
            }
            
            .ticker-grid {
                grid-template-columns: 1fr;
            }

            .notification-container {
                max-width: 90%;
                right: 10px;
                left: 10px;
                align-items: center;
            }
            .notification {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="notification-container" id="notificationContainer"></div>
    
    <div class="container">
        <h1>🚀 Bybit Pro Trading Terminal 📊</h1>

        <div class="message error-message" id="errorMessage"></div>
        <div class="message success-message" id="successMessage"></div>
        <div class="message warning-message" id="warningMessage"></div>
        
        <div class="live-price-box">
            <div class="price-value" id="livePrice">-</div>
            <div class="last-update">Last Updated: <span id="lastUpdate">-</span></div>
        </div>

        <div class="controls">
            <div class="symbol-search-container">
                <label for="symbolSearch">Search Symbol:</label>
                <div style="position: relative;">
                    <span class="search-icon">🔍</span>
                    <input type="text" id="symbolSearch" placeholder="Type to search (e.g., BTC, ETH)..." autocomplete="off">
                    <div class="symbol-dropdown" id="symbolDropdown"></div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="intervalSelect">Interval:</label>
                <select id="intervalSelect">
                    <option value="1">1m</option>
                    <option value="5">5m</option>
                    <option value="15">15m</option>
                    <option value="30">30m</option>
                    <option value="60">1h</option>
                    <option value="240">4h</option>
                    <option value="D" selected>1D</option>
                    <option value="W">1W</option>
                    <option value="M">1M</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="limit">Data Points:</label>
                <input type="number" id="limit" value="200" min="50" max="1000" step="50">
            </div>
            
            <div class="control-group">
                <label for="atrPeriod">ATR Period:</label>
                <input type="number" id="atrPeriod" value="14" min="5" max="50">
            </div>
            
            <div class="control-group">
                <label for="rsiPeriod">RSI Period:</label>
                <input type="number" id="rsiPeriod" value="14" min="5" max="50">
            </div>
            
            <div class="control-group">
                <label for="emaPeriod">EMA Period:</label>
                <input type="number" id="emaPeriod" value="20" min="5" max="200">
            </div>

            <div class="control-group">
                <label for="stPeriod">Supertrend Period:</label>
                <input type="number" id="stPeriod" value="10" min="5" max="50">
            </div>
            
            <div class="control-group">
                <label for="stMultiplier">ST Multiplier:</label>
                <input type="number" id="stMultiplier" value="3" step="0.5" min="1" max="10">
            </div>
            
            <button id="fetchDataButton">📈 Load Chart</button>
            <button id="autoRefreshButton" class="action-button">🔄 Go Live</button>
        </div>

        <div class="action-buttons">
            <button class="action-button preset-button" data-preset="scalping">⚡ Scalping</button>
            <button class="action-button preset-button" data-preset="daytrading">☀️ Day Trading</button>
            <button class="action-button preset-button" data-preset="swing">🌊 Swing</button>
            <button class="action-button preset-button" data-preset="position">🎯 Position</button>
            <button class="action-button" id="saveSettingsButton">💾 Save Settings</button>
            <button class="action-button" id="resetButton">🔄 Reset</button>
        </div>

        <div class="indicator-controls">
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleVolume" checked>
                <label for="toggleVolume">Volume</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleSupertrend" checked>
                <label for="toggleSupertrend">Supertrend</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleBollinger" checked>
                <label for="toggleBollinger">Bollinger Bands</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleSMA" checked>
                <label for="toggleSMA">SMA</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleEMA" checked>
                <label for="toggleEMA">EMA</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleRSI" checked>
                <label for="toggleRSI">RSI</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleMACD" checked>
                <label for="toggleMACD">MACD</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleSignals" checked>
                <label for="toggleSignals">Buy/Sell Signals</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleStochastic">
                <label for="toggleStochastic">Stochastic</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleVWAP">
                <label for="toggleVWAP">VWAP</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="togglePSAR">
                <label for="togglePSAR">PSAR</label>
            </div>
            <div class="indicator-toggle">
                <input type="checkbox" id="toggleIchimoku">
                <label for="toggleIchimoku">Ichimoku</label>
            </div>
        </div>

        <div id="chartContainer">
            <canvas id="chartCanvas"></canvas>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
                <div class="loading-text" id="loadingText">Loading...</div>
            </div>
        </div>

        <div class="ticker-info" id="tickerInfo" style="display: none;">
            <h3 id="tickerTitle">Market Information</h3>
            <div class="ticker-grid">
                <div class="ticker-item">
                    <span class="ticker-label">Last Price</span>
                    <span id="tickerLastPrice" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">24h Change</span>
                    <span id="tickerPriceChange" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">24h Change %</span>
                    <span id="tickerPriceChangePercent" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">24h High</span>
                    <span id="tickerHigh24h" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">24h Low</span>
                    <span id="tickerLow24h" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">24h Volume</span>
                    <span id="tickerVolume24h" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">Bid Price</span>
                    <span id="tickerBidPrice" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">Ask Price</span>
                    <span id="tickerAskPrice" class="ticker-value">-</span>
                </div>
                <div class="ticker-item">
                    <span class="ticker-label">Spread</span>
                    <span id="tickerSpread" class="ticker-value">-</span>
                </div>
            </div>
        </div>

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="analysis">Technical Analysis</button>
                <button class="tab-button" data-tab="signals">Trading Signals</button>
                <button class="tab-button" data-tab="statistics">Statistics</button>
                <button class="tab-button" data-tab="gemini-analysis">Gemini Analysis</button>
            </div>
            
            <div class="tab-content active" id="analysis-tab">
                <div class="stats-container">
                    <div class="stat-card">
                        <div class="stat-title">Trend Direction</div>
                        <div class="stat-value" id="trendDirection">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">RSI Status</div>
                        <div class="stat-value" id="rsiStatus">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Volume Trend</div>
                        <div class="stat-value" id="volumeTrend">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Volatility</div>
                        <div class="stat-value" id="volatility">-</div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="signals-tab">
                <div id="signalsContent">
                    <p>Loading trading signals...</p>
                </div>
            </div>
            
            <div class="tab-content" id="statistics-tab">
                <div class="stats-container">
                    <div class="stat-card">
                        <div class="stat-title">Average Volume</div>
                        <div class="stat-value" id="avgVolume">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Price Range</div>
                        <div class="stat-value" id="priceRange">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Support Level</div>
                        <div class="stat-value" id="supportLevel">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-title">Resistance Level</div>
                        <div class="stat-value" id="resistanceLevel">-</div>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="gemini-analysis-tab">
                <div class="stat-card">
                    <div class="stat-title">Gemini AI Insights</div>
                    <div class="stat-value" id="geminiAnalysisResult">
                        <p>Select a symbol and load chart data to get AI-powered insights.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>

    <script>
        const BACKEND_API_URL = 'http://127.0.0.1:5000';

        class TradingTerminal {
            constructor() {
                this.BYBIT_API_BASE = 'https://api.bybit.com/v5/market/';
                this.BYBIT_WS_BASE = 'wss://stream.bybit.com/v5/public/spot';
                this.chart = null;
                this.symbols = [];
                this.currentSymbol = '';
                this.chartData = [];
                this.websocket = null;
                this.symbolCache = new Map();
                this.settings = this.loadSettings();
                this.currentInterval = 'D';
                this.isLive = false;
                this.geminiAnalysisTimeout = null;
                this.lastPriceColorChangeTimeout = null;
                this.init();
            }

            async init() {
                this.setupEventListeners();
                await this.loadSymbols();
                this.applySettings();
                this.showNotification('Trading Terminal Ready!', 'info');
            }

            setupEventListeners() {
                const symbolSearch = document.getElementById('symbolSearch');
                const symbolDropdown = document.getElementById('symbolDropdown');
                
                symbolSearch.addEventListener('input', () => this.handleSymbolSearch(symbolSearch.value));
                
                symbolSearch.addEventListener('focus', () => {
                    if (this.symbols.length > 0 && symbolSearch.value.length > 0) {
                        this.showSymbolDropdown();
                    }
                });
                
                document.addEventListener('click', (e) => {
                    if (!symbolSearch.contains(e.target) && !symbolDropdown.contains(e.target)) {
                        symbolDropdown.classList.remove('active');
                    }
                });

                document.getElementById('fetchDataButton').addEventListener('click', () => this.fetchDataAndRenderChart());
                document.getElementById('autoRefreshButton').addEventListener('click', () => this.toggleLiveUpdates());
                document.getElementById('saveSettingsButton').addEventListener('click', () => this.saveSettings());
                document.getElementById('resetButton').addEventListener('click', () => this.resetSettings());

                document.querySelectorAll('.preset-button').forEach(btn => {
                    btn.addEventListener('click', (e) => this.applyPreset(e.target.dataset.preset));
                });

                document.querySelectorAll('.indicator-toggle input').forEach(toggle => {
                    toggle.addEventListener('change', () => this.updateChart());
                });

                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.addEventListener('click', (e) => this.switchTab(e.target.dataset.tab));
                });
            }

            async loadSymbols() {
                this.showLoading('Loading available symbols...');
                const cacheKey = 'symbols_cache';
                const cached = this.getFromCache(cacheKey);
                
                if (cached) {
                    this.symbols = cached;
                    this.populateSymbolDropdown();
                    this.hideLoading();
                    return;
                }

                try {
                    const response = await fetch(`${this.BYBIT_API_BASE}instruments-info?category=spot`);
                    const data = await response.json();

                    if (data.retCode !== 0) {
                        throw new Error(data.retMsg || 'Failed to fetch symbols');
                    }

                    this.symbols = data.result.list
                        .filter(item => item.status === 'Trading' && item.quoteCoin === 'USDT')
                        .map(item => ({
                            symbol: item.symbol,
                            baseCoin: item.baseCoin,
                            quoteCoin: item.quoteCoin
                        }))
                        .sort((a, b) => {
                            const priority = ['BTC', 'ETH', 'BNB', 'SOL', 'XRP', 'USDT'];
                            const aIndex = priority.indexOf(a.baseCoin);
                            const bIndex = priority.indexOf(b.baseCoin);
                            if (aIndex !== -1 && bIndex === -1) return -1;
                            if (aIndex === -1 && bIndex !== -1) return 1;
                            if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                            return a.symbol.localeCompare(b.symbol);
                        });

                    this.setCache(cacheKey, this.symbols, 3600000);
                    this.populateSymbolDropdown();
                    
                    const defaultSymbolFromSettings = this.settings.symbol;
                    const defaultSymbol = this.symbols.find(s => s.symbol === defaultSymbolFromSettings) || 
                                          this.symbols.find(s => s.symbol === 'BTCUSDT') || 
                                          (this.symbols.length > 0 ? this.symbols[0] : null);
                    
                    if (defaultSymbol) {
                        this.selectSymbol(defaultSymbol.symbol);
                    }

                } catch (error) {
                    this.showError(`Failed to load symbols: ${error.message}`);
                } finally {
                    this.hideLoading();
                }
            }

            populateSymbolDropdown(filter = '') {
                const dropdown = document.getElementById('symbolDropdown');
                if (this.symbols.length === 0) {
                    dropdown.innerHTML = '<li>No symbols loaded</li>';
                    return;
                }

                const filtered = filter 
                    ? this.symbols.filter(s => 
                        s.symbol.toLowerCase().includes(filter.toLowerCase()) ||
                        s.baseCoin.toLowerCase().includes(filter.toLowerCase())
                      ).slice(0, 50)
                    : this.symbols.slice(0, 20);

                if (filtered.length === 0) {
                    dropdown.innerHTML = '<li>No matching symbols found</li>';
                } else {
                    dropdown.innerHTML = filtered.map(s => `
                        <div class="symbol-item ${s.symbol === this.currentSymbol ? 'selected' : ''}" 
                             data-symbol="${s.symbol}">
                            <span>${s.symbol}</span>
                            <span class="symbol-info">${s.baseCoin}/${s.quoteCoin}</span>
                        </div>
                    `).join('');
                }

                dropdown.querySelectorAll('.symbol-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.selectSymbol(item.dataset.symbol);
                        dropdown.classList.remove('active');
                    });
                });
            }

            handleSymbolSearch(value) {
                this.populateSymbolDropdown(value);
                const symbolSearch = document.getElementById('symbolSearch');
                if (this.symbols.length > 0) {
                    if (value.length > 0 || symbolSearch === document.activeElement) {
                        this.showSymbolDropdown();
                    } else {
                        document.getElementById('symbolDropdown').classList.remove('active');
                    }
                } else {
                    document.getElementById('symbolDropdown').classList.remove('active');
                }
            }

            showSymbolDropdown() {
                document.getElementById('symbolDropdown').classList.add('active');
            }

            selectSymbol(symbol) {
                if (this.currentSymbol === symbol) return;

                this.currentSymbol = symbol;
                document.getElementById('symbolSearch').value = symbol;
                this.updateTickerInfo(symbol);
                this.disconnectWebSocket();
                this.resetChartAndAnalysis();
                this.showNotification(`Symbol set to: ${symbol}`, 'info');
                
                if (document.getElementById('gemini-analysis-tab').classList.contains('active')) {
                    this.displayGeminiAnalysis("Loading new data for analysis...");
                }
            }

            async updateTickerInfo(symbol) {
                if (!symbol) return;
                document.getElementById('tickerInfo').style.display = 'block';
                document.getElementById('tickerTitle').textContent = `${symbol} Market Information`;
                try {
                    const response = await fetch(`${this.BYBIT_API_BASE}tickers?category=spot&symbol=${symbol}`);
                    const data = await response.json();
                    if (data.retCode === 0 && data.result.list && data.result.list.length > 0) {
                        const ticker = data.result.list[0];
                        this.displayTickerInfo(ticker);
                    } else {
                        this.showWarning(`Could not fetch ticker info for ${symbol}: ${data.retMsg}`);
                    }
                } catch (error) {
                    console.error('Error fetching ticker:', error);
                    this.showError(`Failed to fetch ticker info for ${symbol}.`);
                }
            }

            displayTickerInfo(ticker) {
                const price = parseFloat(ticker.lastPrice);
                const change24h = parseFloat(ticker.price24hPcnt);
                const bid = parseFloat(ticker.bid1Price);
                const ask = parseFloat(ticker.ask1Price);
                const spread = ask - bid;
                const spreadPercent = (spread / price * 100).toFixed(3);
                
                this.updateLivePriceDisplay(price);

                document.getElementById('tickerLastPrice').textContent = this.formatPrice(price);
                document.getElementById('tickerBidPrice').textContent = this.formatPrice(bid);
                document.getElementById('tickerAskPrice').textContent = this.formatPrice(ask);
                document.getElementById('tickerSpread').textContent = `${this.formatPrice(spread)} (${spreadPercent}%)`;
                
                const priceChangeValue = price * change24h / 100;
                const priceChangeEl = document.getElementById('tickerPriceChange');
                priceChangeEl.textContent = this.formatPrice(priceChangeValue);
                priceChangeEl.className = `ticker-value ${change24h >= 0 ? 'positive' : 'negative'}`;
                
                const priceChangePercentEl = document.getElementById('tickerPriceChangePercent');
                priceChangePercentEl.textContent = `${change24h.toFixed(2)}%`;
                priceChangePercentEl.className = `ticker-value ${change24h >= 0 ? 'positive' : 'negative'}`;
                
                document.getElementById('tickerHigh24h').textContent = this.formatPrice(parseFloat(ticker.highPrice24h));
                document.getElementById('tickerLow24h').textContent = this.formatPrice(parseFloat(ticker.lowPrice24h));
                document.getElementById('tickerVolume24h').textContent = this.formatVolume(parseFloat(ticker.volume24h));
            }

            async fetchDataAndRenderChart() {
                if (!this.currentSymbol) {
                    this.showWarning('Please select a symbol first.');
                    return;
                }

                this.showLoading(`Loading chart data for ${this.currentSymbol}...`);
                this.disconnectWebSocket();
                this.isLive = false;
                document.getElementById('autoRefreshButton').textContent = '🔄 Go Live';
                document.getElementById('autoRefreshButton').style.background = 'linear-gradient(135deg, var(--accent-pink) 0%, #cc0066 100%)';

                const interval = document.getElementById('intervalSelect').value;
                const limit = parseInt(document.getElementById('limit').value);
                this.currentInterval = interval;

                try {
                    const url = `${this.BYBIT_API_BASE}kline?category=spot&symbol=${this.currentSymbol}&interval=${interval}&limit=${limit}`;
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.retCode !== 0) {
                        throw new Error(data.retMsg || 'Failed to fetch chart data');
                    }

                    this.chartData = data.result.list.map(item => ({
                        time: parseInt(item[0]),
                        open: parseFloat(item[1]),
                        high: parseFloat(item[2]),
                        low: parseFloat(item[3]),
                        close: parseFloat(item[4]),
                        volume: parseFloat(item[5])
                    })).reverse();

                    if (this.chartData.length === 0) {
                        throw new Error('No data available for this symbol and interval.');
                    }

                    this.renderChart(this.chartData);
                    this.updateAnalysis(this.chartData);
                    this.updateSignals(this.chartData);
                    this.updateStatistics(this.chartData);
                    
                    if (document.getElementById('gemini-analysis-tab').classList.contains('active')) {
                        this.requestGeminiAnalysis();
                    }

                    this.showNotification('Chart loaded successfully', 'success');
                } catch (error) {
                    console.error('Chart loading error:', error);
                    this.showError(`Failed to load chart: ${error.message}`);
                    this.resetChartAndAnalysis();
                } finally {
                    this.hideLoading();
                }
            }
            
            toggleLiveUpdates() {
                const button = document.getElementById('autoRefreshButton');
                this.isLive = !this.isLive;

                if (this.isLive) {
                    this.connectWebSocket();
                    button.textContent = '🔴 Live Now';
                    button.style.background = 'linear-gradient(135deg, var(--accent-green) 0%, #00aa44 100%)';
                    this.showNotification('Live updates enabled', 'success');
                } else {
                    this.disconnectWebSocket();
                    button.textContent = '🔄 Go Live';
                    button.style.background = 'linear-gradient(135deg, var(--accent-pink) 0%, #cc0066 100%)';
                    this.showNotification('Live updates disabled', 'warning');
                }
            }
            
            connectWebSocket() {
                if (!this.currentSymbol) {
                    this.showWarning("Cannot connect to WebSocket: No symbol selected.");
                    this.isLive = false;
                    return;
                }
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    return;
                }
                
                this.disconnectWebSocket();

                const symbol = this.currentSymbol.toLowerCase();
                const interval = document.getElementById('intervalSelect').value;
                const wsUrl = `${this.BYBIT_WS_BASE}`;
                
                this.websocket = new WebSocket(wsUrl);
                
                this.websocket.onopen = () => {
                    const subscribeMessage = {
                        "op": "subscribe",
                        "args": [
                            `tickers.${symbol}`,
                            `kline.${interval}.${symbol}`
                        ]
                    };
                    this.websocket.send(JSON.stringify(subscribeMessage));
                    this.showNotification('Connected to live data stream.', 'success');
                };

                this.websocket.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        if (msg.topic && msg.data) {
                            const dataArray = Array.isArray(msg.data) ? msg.data : [msg.data];
                            
                            if (msg.topic.includes('tickers')) {
                                const ticker = dataArray[0];
                                if (ticker && ticker.lastPrice) {
                                    this.updateLivePriceDisplay(parseFloat(ticker.lastPrice));
                                }
                            } else if (msg.topic.includes('kline')) {
                                const kline = dataArray[0];
                                if (kline && kline.timestamp) {
                                    const newCandle = {
                                        time: parseInt(kline.timestamp),
                                        open: parseFloat(kline.open),
                                        high: Math.max(parseFloat(kline.high), parseFloat(kline.open), parseFloat(kline.close)),
                                        low: Math.min(parseFloat(kline.low), parseFloat(kline.open), parseFloat(kline.close)),
                                        close: parseFloat(kline.close),
                                        volume: parseFloat(kline.volume)
                                    };
                                    
                                    const lastKlineTime = this.chartData.length > 0 ? this.chartData[this.chartData.length - 1].time : 0;
                                    
                                    if (newCandle.time > lastKlineTime) {
                                        if (this.chartData.length >= parseInt(document.getElementById('limit').value)) {
                                            this.chartData.shift();
                                        }
                                        this.chartData.push(newCandle);
                                        this.updateChart();
                                    } else if (newCandle.time === lastKlineTime) {
                                        const lastCandle = this.chartData[this.chartData.length - 1];
                                        lastCandle.open = newCandle.open;
                                        lastCandle.high = newCandle.high;
                                        lastCandle.low = newCandle.low;
                                        lastCandle.close = newCandle.close;
                                        lastCandle.volume = newCandle.volume;
                                        this.updateChart();
                                    }
                                    
                                    if (document.getElementById('gemini-analysis-tab').classList.contains('active')) {
                                        if (this.geminiAnalysisTimeout) clearTimeout(this.geminiAnalysisTimeout);
                                        this.geminiAnalysisTimeout = setTimeout(() => this.requestGeminiAnalysis(), 5000);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error("Error processing WebSocket message:", e, event.data);
                    }
                };
                
                this.websocket.onerror = (error) => {
                    console.error('WebSocket Error:', error);
                    this.showError('WebSocket connection error. Retrying in 5s...');
                    this.disconnectWebSocket();
                    setTimeout(() => this.connectWebSocket(), 5000);
                };

                this.websocket.onclose = () => {
                    this.showWarning('WebSocket connection closed.', 'warning');
                    if (this.isLive) {
                        this.showWarning('Attempting to reconnect WebSocket...');
                        setTimeout(() => this.connectWebSocket(), 5000);
                    }
                };
            }
            
            disconnectWebSocket() {
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }
            }

            updateLivePriceDisplay(price) {
                const livePriceEl = document.getElementById('livePrice');
                const lastUpdateEl = document.getElementById('lastUpdate');
                
                const currentPrice = parseFloat(livePriceEl.textContent);
                
                if (!isNaN(currentPrice) && price !== currentPrice) {
                    livePriceEl.style.color = price > currentPrice ? 'var(--accent-green)' : 'var(--accent-pink)';
                    if (this.lastPriceColorChangeTimeout) clearTimeout(this.lastPriceColorChangeTimeout);
                    this.lastPriceColorChangeTimeout = setTimeout(() => {
                        livePriceEl.style.color = 'var(--accent-green)';
                    }, 1000);
                } else if (isNaN(currentPrice)) {
                    livePriceEl.style.color = 'var(--accent-green)';
                }
                
                livePriceEl.textContent = this.formatPrice(price);
                lastUpdateEl.textContent = this.formatTime(Date.now());
            }

            renderChart(klines) {
                const indicators = this.calculateAllIndicators(klines);
                
                const candlestickData = klines.map(d => ({
                    x: d.time,
                    o: d.open,
                    h: d.high,
                    l: d.low,
                    c: d.close
                }));

                const volumeData = klines.map(d => ({
                    x: d.time,
                    y: d.volume,
                    color: d.close >= d.open ? 'rgba(0, 255, 136, 0.6)' : 'rgba(255, 0, 136, 0.6)' 
                }));

                if (this.chart) {
                    this.chart.destroy();
                }

                const ctx = document.getElementById('chartCanvas').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'candlestick',
                    data: {
                        datasets: this.createDatasets(candlestickData, volumeData, indicators, klines)
                    },
                    options: this.getChartOptions()
                });
            }

            updateChart() {
                if (this.chart && this.chartData.length > 0) {
                    const indicators = this.calculateAllIndicators(this.chartData);
                    const candlestickData = this.chartData.map(d => ({
                        x: d.time, o: d.open, h: d.high, l: d.low, c: d.close
                    }));
                    const volumeData = this.chartData.map(d => ({
                        x: d.time, y: d.volume, color: d.close >= d.open ? 'rgba(0, 255, 136, 0.6)' : 'rgba(255, 0, 136, 0.6)' 
                    }));

                    this.chart.data.datasets = this.createDatasets(candlestickData, volumeData, indicators, this.chartData);
                    this.chart.options = this.getChartOptions();
                    this.chart.update();
                    this.updateAnalysis(this.chartData);
                    this.updateSignals(this.chartData);
                    this.updateStatistics(this.chartData);
                }
            }

            createDatasets(candlestickData, volumeData, indicators, klines) {
                const datasets = [
                    {
                        label: 'Price',
                        data: candlestickData,
                        borderColor: (context) => {
                            const i = context.dataIndex;
                            if (!klines[i]) return '#e0e0ff';
                            return klines[i].close >= klines[i].open ? 'var(--success-color)' : 'var(--danger-color)';
                        },
                        borderWidth: 1,
                        color: {
                            up: 'var(--success-color)',
                            down: 'var(--danger-color)',
                            unchanged: '#8888ff'
                        },
                        yAxisID: 'price',
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    {
                        label: 'Volume',
                        data: volumeData,
                        backgroundColor: (context) => context.dataset.color,
                        yAxisID: 'volume',
                        hidden: !document.getElementById('toggleVolume').checked,
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat('en-US').format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                ];

                if (document.getElementById('toggleSMA').checked && indicators.sma) {
                    datasets.push({
                        label: 'SMA',
                        data: indicators.sma.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-orange)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                }
                if (document.getElementById('toggleEMA').checked && indicators.ema) {
                    datasets.push({
                        label: 'EMA',
                        data: indicators.ema.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-purple)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                }
                if (document.getElementById('toggleRSI').checked && indicators.rsi) {
                    datasets.push({
                        label: 'RSI',
                        data: indicators.rsi.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-cyan)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'rsi'
                    });
                }
                if (document.getElementById('toggleMACD').checked && indicators.macd) {
                    datasets.push({
                        label: 'MACD Line',
                        data: indicators.macd.macdLine.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-cyan)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'macd'
                    });
                    datasets.push({
                        label: 'MACD Signal',
                        data: indicators.macd.signalLine.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-pink)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'macd'
                    });
                    datasets.push({
                        label: 'MACD Histogram',
                        data: indicators.macd.histogram.map((value, i) => ({ x: klines[i].time, y: value })),
                        type: 'bar',
                        backgroundColor: (context) => {
                            const value = context.dataset.data[context.dataIndex].y;
                            return value >= 0 ? 'rgba(0, 255, 136, 0.6)' : 'rgba(255, 0, 136, 0.6)';
                        },
                        yAxisID: 'macd'
                    });
                }
                if (document.getElementById('toggleBollinger').checked && indicators.bollinger) {
                    datasets.push({
                        label: 'BB Upper',
                        data: indicators.bollinger.upper.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'rgba(255, 170, 0, 0.5)',
                        borderWidth: 1,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                    datasets.push({
                        label: 'BB Middle',
                        data: indicators.bollinger.middle.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'rgba(255, 170, 0, 0.3)',
                        borderWidth: 1,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                    datasets.push({
                        label: 'BB Lower',
                        data: indicators.bollinger.lower.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'rgba(255, 170, 0, 0.5)',
                        borderWidth: 1,
                        fill: '-1',
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                }
                if (document.getElementById('toggleSupertrend').checked && indicators.supertrend) {
                    datasets.push({
                        label: 'Supertrend',
                        data: indicators.supertrend.line.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: (context) => {
                            const i = context.dataIndex;
                            return indicators.supertrend.trend[i] ? 'var(--success-color)' : 'var(--danger-color)';
                        },
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                }
                if (document.getElementById('toggleVWAP').checked && indicators.vwap) {
                    datasets.push({
                        label: 'VWAP',
                        data: indicators.vwap.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-orange)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                }
                if (document.getElementById('togglePSAR').checked && indicators.psar) {
                    datasets.push({
                        label: 'PSAR',
                        data: indicators.psar.map((value, i) => ({ x: klines[i].time, y: value })),
                        backgroundColor: (context) => {
                            const i = context.dataIndex;
                            const psarValue = indicators.psar[i];
                            const closePrice = klines[i].close;
                            return psarValue < closePrice ? 'var(--success-color)' : 'var(--danger-color)';
                        },
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        showLine: false,
                        yAxisID: 'price'
                    });
                }
                if (document.getElementById('toggleIchimoku').checked && indicators.ichimoku) {
                    datasets.push({
                        label: 'Ichimoku Tenkan-sen',
                        data: indicators.ichimoku.tenkan.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-cyan)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                    datasets.push({
                        label: 'Ichimoku Kijun-sen',
                        data: indicators.ichimoku.kijun.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-purple)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                    datasets.push({
                        label: 'Ichimoku Senkou A',
                        data: indicators.ichimoku.senkouA.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'rgba(0, 255, 136, 0.3)',
                        backgroundColor: 'rgba(0, 255, 136, 0.3)',
                        borderWidth: 1,
                        fill: '-1',
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                    datasets.push({
                        label: 'Ichimoku Senkou B',
                        data: indicators.ichimoku.senkouB.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'rgba(255, 0, 136, 0.3)',
                        backgroundColor: 'rgba(255, 0, 136, 0.3)',
                        borderWidth: 1,
                        fill: '-2',
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                    datasets.push({
                        label: 'Ichimoku Chikou Span',
                        data: indicators.ichimoku.chikou.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--secondary-text)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'price'
                    });
                }
                if (document.getElementById('toggleStochastic').checked && indicators.stochastic) {
                    datasets.push({
                        label: 'Stochastic %K',
                        data: indicators.stochastic.k.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-green)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'stoch'
                    });
                    datasets.push({
                        label: 'Stochastic %D',
                        data: indicators.stochastic.d.map((value, i) => ({ x: klines[i].time, y: value })),
                        borderColor: 'var(--accent-pink)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'stoch'
                    });
                }

                if (document.getElementById('toggleSignals').checked && indicators.signals) {
                    const buySignals = indicators.signals.filter(s => s.direction === 'buy').map(s => ({ x: s.time, y: s.price }));
                    const sellSignals = indicators.signals.filter(s => s.direction === 'sell').map(s => ({ x: s.time, y: s.price }));

                    datasets.push({
                        label: 'Buy Signals',
                        data: buySignals,
                        backgroundColor: 'var(--success-color)',
                        borderColor: 'var(--success-color)',
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        showLine: false,
                        yAxisID: 'price'
                    });
                    datasets.push({
                        label: 'Sell Signals',
                        data: sellSignals,
                        backgroundColor: 'var(--danger-color)',
                        borderColor: 'var(--danger-color)',
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        showLine: false,
                        yAxisID: 'price'
                    });
                }

                return datasets;
            }

            getChartOptions() {
                const scales = {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            tooltipFormat: 'MMM dd, yyyy HH:mm:ss',
                            displayFormats: {
                                minute: 'HH:mm',
                                hour: 'HH:mm',
                                day: 'MMM dd',
                                week: 'MMM dd',
                                month: 'MMM dd'
                            }
                        },
                        grid: { color: 'rgba(68, 68, 170, 0.2)' },
                        ticks: {
                            color: 'var(--primary-text)',
                            autoSkip: true,
                            maxTicksLimit: 10
                        }
                    },
                    price: {
                        position: 'left',
                        grid: { color: 'rgba(68, 68, 170, 0.2)' },
                        ticks: {
                            color: 'var(--primary-text)',
                            autoSkip: true,
                            maxTicksLimit: 10
                        },
                        title: {
                            display: true,
                            text: 'Price',
                            color: 'var(--secondary-text)',
                            font: { size: 12 }
                        }
                    },
                    volume: {
                        position: 'right',
                        grid: { display: false },
                        ticks: {
                            color: 'var(--primary-text)',
                            callback: function(value) {
                                if (value >= 1000000) return value / 1000000 + 'M';
                                if (value >= 1000) return value / 1000 + 'K';
                                return value;
                            }
                        },
                        title: {
                            display: true,
                            text: 'Volume',
                            color: 'var(--secondary-text)',
                            font: { size: 12 }
                        },
                        display: document.getElementById('toggleVolume').checked
                    }
                };

                if (document.getElementById('toggleRSI').checked) {
                    scales.rsi = {
                        type: 'linear',
                        position: 'right',
                        grid: { color: 'rgba(68, 68, 170, 0.2)' },
                        ticks: {
                            min: 0,
                            max: 100,
                            color: 'var(--primary-text)',
                            stepSize: 20
                        },
                        title: {
                            display: true,
                            text: 'RSI',
                            color: 'var(--secondary-text)',
                            font: { size: 12 }
                        }
                    };
                }
                if (document.getElementById('toggleMACD').checked) {
                    scales.macd = {
                        type: 'linear',
                        position: 'right',
                        grid: { color: 'rgba(68, 68, 170, 0.2)' },
                        ticks: {
                            color: 'var(--primary-text)',
                            callback: function(value) {
                                if (value >= 1000000) return value / 1000000 + 'M';
                                if (value >= 1000) return value / 1000 + 'K';
                                return value;
                            }
                        },
                        title: {
                            display: true,
                            text: 'MACD',
                            color: 'var(--secondary-text)',
                            font: { size: 12 }
                        }
                    };
                }
                if (document.getElementById('toggleStochastic').checked) {
                    scales.stoch = {
                        type: 'linear',
                        position: 'right',
                        grid: { color: 'rgba(68, 68, 170, 0.2)' },
                        ticks: {
                            min: 0,
                            max: 100,
                            color: 'var(--primary-text)',
                            stepSize: 20
                        },
                        title: {
                            display: true,
                            text: 'Stochastic',
                            color: 'var(--secondary-text)',
                            font: { size: 12 }
                        }
                    };
                }

                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 500,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'var(--primary-text)',
                                font: { size: 12 },
                                usePointStyle: true,
                                padding: 20
                            },
                            position: 'top',
                            align: 'start'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    if (!tooltipItems || tooltipItems.length === 0) return '';
                                    const timestamp = tooltipItems[0].parsed.x;
                                    return moment(timestamp).format('YYYY-MM-DD HH:mm:ss');
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.parsed.y;
                                    if (value !== null) {
                                        if (context.dataset.label === 'Volume') {
                                            label += new Intl.NumberFormat('en-US').format(value);
                                        } else if (context.dataset.label.includes('Price') || context.dataset.label.includes('BB') || context.dataset.label.includes('Ichimoku') || context.dataset.label.includes('SMA') || context.dataset.label.includes('EMA') || context.dataset.label.includes('VWAP') || context.dataset.label.includes('PSAR')) {
                                            label += value.toFixed(4);
                                        } else if (context.dataset.label === 'RSI' || context.dataset.label.includes('Stochastic')) {
                                            label += value.toFixed(2);
                                        } else if (context.dataset.label.includes('MACD')) {
                                            label += value.toFixed(4);
                                        } else {
                                            label += value;
                                        }
                                    }
                                    return label;
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                threshold: 5
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                                speed: 0.1
                            }
                        }
                    },
                    scales: scales,
                    hover: {
                        mode: 'nearest',
                        intersect: true
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    layout: {
                        padding: {
                            top: 30,
                            right: 15,
                            bottom: 10,
                            left: 15
                        }
                    }
                };
            }

            calculateAllIndicators(klines) {
                const indicators = {};
                const data = klines.map(k => ({ time: k.time, open: k.open, high: k.high, low: k.low, close: k.close, volume: k.volume }));

                const emaPeriod = parseInt(document.getElementById('emaPeriod').value);
                const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
                const stPeriod = parseInt(document.getElementById('stPeriod').value);
                const stMultiplier = parseFloat(document.getElementById('stMultiplier').value);

                if (document.getElementById('toggleSMA').checked) {
                    indicators.sma = this.calculateSMA(data, emaPeriod);
                }
                if (document.getElementById('toggleEMA').checked) {
                    indicators.ema = this.calculateEMA(data, emaPeriod);
                }
                if (document.getElementById('toggleRSI').checked) {
                    indicators.rsi = this.calculateRSI(data, rsiPeriod);
                }
                if (document.getElementById('toggleMACD').checked) {
                    indicators.macd = this.calculateMACD(data);
                }
                if (document.getElementById('toggleBollinger').checked) {
                    indicators.bollinger = this.calculateBollingerBands(data, emaPeriod, 2);
                }
                if (document.getElementById('toggleSupertrend').checked) {
                    const atr = this.calculateATR(data, stPeriod);
                    indicators.supertrend = this.calculateSupertrend(data, atr, stMultiplier, stPeriod);
                }
                if (document.getElementById('toggleVWAP').checked) {
                    indicators.vwap = this.calculateVWAP(data);
                }
                if (document.getElementById('togglePSAR').checked) {
                    indicators.psar = this.calculatePSAR(data);
                }
                if (document.getElementById('toggleIchimoku').checked) {
                    indicators.ichimoku = this.calculateIchimoku(data);
                }
                if (document.getElementById('toggleStochastic').checked) {
                    indicators.stochastic = this.calculateStochasticRSI(data);
                }
                if (document.getElementById('toggleSignals').checked) {
                    indicators.signals = this.generateSignals(data, indicators);
                }

                return indicators;
            }

            calculateSMA(data, period) {
                const sma = new Array(data.length).fill(null);
                for (let i = 0; i < data.length; i++) {
                    if (i < period - 1) continue;
                    const sum = data.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val.close, 0);
                    sma[i] = sum / period;
                }
                return sma;
            }

            calculateEMA(data, period) {
                const ema = new Array(data.length).fill(null);
                let sum = 0;
                for(let i=0; i<period; i++) {
                    sum += data[i].close;
                }
                ema[period - 1] = sum / period;
                const multiplier = 2 / (period + 1);
                for (let i = period; i < data.length; i++) {
                    ema[i] = (data[i].close - ema[i - 1]) * multiplier + ema[i - 1];
                }
                return ema;
            }

            calculateRSI(data, period) {
                const rsi = new Array(data.length).fill(null);
                let avgGain = 0;
                let avgLoss = 0;

                for (let i = 1; i < data.length; i++) {
                    const diff = data[i].close - data[i - 1].close;
                    const gain = Math.max(0, diff);
                    const loss = Math.max(0, -diff);

                    if (i <= period) {
                        avgGain += gain;
                        avgLoss += loss;
                        if (i === period) {
                            avgGain /= period;
                            avgLoss /= period;
                        }
                    } else {
                        avgGain = (avgGain * (period - 1) + gain) / period;
                        avgLoss = (avgLoss * (period - 1) + loss) / period;
                    }

                    if (i >= period) {
                        const rs = avgLoss === 0 ? (avgGain === 0 ? 0 : Infinity) : avgGain / avgLoss;
                        rsi[i] = 100 - (100 / (1 + rs));
                    }
                }
                return rsi;
            }

            calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
                const macdLine = new Array(data.length).fill(null);
                const signalLine = new Array(data.length).fill(null);
                const histogram = new Array(data.length).fill(null);

                const emaFast = this.calculateEMA(data, fastPeriod);
                const emaSlow = this.calculateEMA(data, slowPeriod);

                for (let i = 0; i < data.length; i++) {
                    if (emaFast[i] !== null && emaSlow[i] !== null) {
                        macdLine[i] = emaFast[i] - emaSlow[i];
                    }
                }

                const macdDataForSignal = macdLine.map(val => ({ close: val }));
                const signalLineValues = this.calculateEMA(macdDataForSignal, signalPeriod);
                
                for (let i = 0; i < data.length; i++) {
                    signalLine[i] = signalLineValues[i];
                    if (macdLine[i] !== null && signalLine[i] !== null) {
                        histogram[i] = macdLine[i] - signalLine[i];
                    }
                }

                return { macdLine, signalLine, histogram };
            }

            calculateBollingerBands(data, period, stdDev) {
                const upper = new Array(data.length).fill(null);
                const middle = new Array(data.length).fill(null);
                const lower = new Array(data.length).fill(null);

                const sma = this.calculateSMA(data, period);
                
                for (let i = 0; i < data.length; i++) {
                    if (sma[i] === null) continue;
                    middle[i] = sma[i];

                    if (i >= period - 1) {
                        const stdDevValues = data.slice(i - period + 1, i + 1).map(d => d.close);
                        const variance = stdDevValues.reduce((acc, val) => acc + Math.pow(val - sma[i], 2), 0) / period;
                        const standardDeviation = Math.sqrt(variance);

                        upper[i] = sma[i] + stdDev * standardDeviation;
                        lower[i] = sma[i] - stdDev * standardDeviation;
                    }
                }
                return { upper, middle, lower };
            }

            calculateATR(data, period) {
                const atr = new Array(data.length).fill(null);
                let sumTR = 0;

                for (let i = 1; i < data.length; i++) {
                    const highLow = data[i].high - data[i].low;
                    const highClose = Math.abs(data[i].high - data[i - 1].close);
                    const lowClose = Math.abs(data[i].low - data[i - 1].close);
                    const TR = Math.max(highLow, highClose, lowClose);

                    if (i < period) {
                        sumTR += TR;
                    } else if (i === period) {
                        sumTR += TR;
                        atr[i] = sumTR / period;
                    } else {
                        atr[i] = ((atr[i - 1] * (period - 1)) + TR) / period;
                    }
                }
                return atr;
            }

            calculateSupertrend(data, atr, multiplier, period) {
                const line = new Array(data.length).fill(null);
                const trend = new Array(data.length).fill(true);

                if (atr.length < period || atr[period - 1] === null) return { line: line, trend: trend };

                let upperBand = null;
                let lowerBand = null;
                let prevTrend = true;

                for (let i = period; i < data.length; i++) {
                    if (atr[i] === null) continue;

                    const hl2 = (data[i].high + data[i].low) / 2;
                    const up = hl2 - multiplier * atr[i];
                    const down = hl2 + multiplier * atr[i];

                    if (i === period) { // Initialize for the first actual Supertrend calculation point
                        upperBand = up;
                        lowerBand = down;
                        if (data[i].close <= lowerBand) prevTrend = false;
                        else if (data[i].close >= upperBand) prevTrend = true;
                    } else {
                        if (prevTrend) {
                            lowerBand = Math.max(down, line[i-1]);
                            upperBand = up; // This should be updated on current candle
                            if (data[i].close < lowerBand) {
                                prevTrend = false;
                                upperBand = hl2 + multiplier * atr[i]; // New upper band for downtrend
                            }
                        } else {
                            upperBand = Math.min(up, line[i-1]);
                            lowerBand = down; // This should be updated on current candle
                            if (data[i].close > upperBand) {
                                prevTrend = true;
                                lowerBand = hl2 - multiplier * atr[i]; // New lower band for uptrend
                            }
                        }
                    }
                    
                    trend[i] = prevTrend;
                    line[i] = prevTrend ? lowerBand : upperBand;
                }
                return { line, trend };
            }

            calculateVWAP(data) {
                const vwap = new Array(data.length).fill(null);
                let cumulativeTP = 0;
                let cumulativeVolume = 0;

                for (let i = 0; i < data.length; i++) {
                    const typicalPrice = (data[i].high + data[i].low + data[i].close) / 3;
                    cumulativeTP += typicalPrice * data[i].volume;
                    cumulativeVolume += data[i].volume;
                    if (cumulativeVolume > 0) {
                        vwap[i] = cumulativeTP / cumulativeVolume;
                    }
                }
                return vwap;
            }

            calculatePSAR(data, initialAF = 0.02, incrementAF = 0.02, maxAF = 0.2) {
                const psar = new Array(data.length).fill(null);
                if (data.length < 2) return psar;

                let ep = data[0].high;
                let af = initialAF;
                let trend = 1; // 1 for uptrend, -1 for downtrend
                psar[0] = data[0].close; // Or some other initial value, this is a simplification

                for (let i = 1; i < data.length; i++) {
                    let currentPSAR = psar[i - 1] + af * (ep - psar[i - 1]) * trend;

                    // Check for reversal
                    let reversed = false;
                    if (trend === 1) { // Current uptrend
                        if (data[i].low < currentPSAR) {
                            trend = -1;
                            currentPSAR = ep;
                            ep = data[i].low;
                            af = initialAF;
                            reversed = true;
                        } else {
                            if (data[i].high > ep) {
                                ep = data[i].high;
                                af = Math.min(af + incrementAF, maxAF);
                            }
                        }
                    } else { // Current downtrend
                        if (data[i].high > currentPSAR) {
                            trend = 1;
                            currentPSAR = ep;
                            ep = data[i].high;
                            af = initialAF;
                            reversed = true;
                        } else {
                            if (data[i].low < ep) {
                                ep = data[i].low;
                                af = Math.min(af + incrementAF, maxAF);
                            }
                        }
                    }
                    
                    // Ensure PSAR doesn't cross current price (common rule)
                    if (!reversed) {
                        if (trend === 1 && currentPSAR > data[i].low) {
                            currentPSAR = data[i].low;
                        } else if (trend === -1 && currentPSAR < data[i].high) {
                            currentPSAR = data[i].high;
                        }
                    }
                    psar[i] = currentPSAR;
                }
                return psar;
            }

            calculateIchimoku(data, tenkanPeriod = 9, kijunPeriod = 26, senkouPeriod = 52, chikouLag = 26) {
                const ichimoku = {
                    tenkan: new Array(data.length).fill(null),
                    kijun: new Array(data.length).fill(null),
                    senkouA: new Array(data.length).fill(null),
                    senkouB: new Array(data.length).fill(null),
                    chikou: new Array(data.length).fill(null)
                };

                if (data.length < senkouPeriod) return ichimoku;

                const calculatePeriodHighLow = (period, index) => {
                    const start = Math.max(0, index - period + 1);
                    const window = data.slice(start, index + 1);
                    if (window.length === 0) return { high: null, low: null };
                    const high = Math.max(...window.map(k => k.high));
                    const low = Math.min(...window.map(k => k.low));
                    return { high, low };
                };

                for (let i = 0; i < data.length; i++) {
                    if (i >= tenkanPeriod - 1) {
                        const { high, low } = calculatePeriodHighLow(tenkanPeriod, i);
                        if (high !== null && low !== null) ichimoku.tenkan[i] = (high + low) / 2;
                    }
                    if (i >= kijunPeriod - 1) {
                        const { high, low } = calculatePeriodHighLow(kijunPeriod, i);
                        if (high !== null && low !== null) ichimoku.kijun[i] = (high + low) / 2;
                    }
                    
                    if (ichimoku.tenkan[i] !== null && ichimoku.kijun[i] !== null) {
                        const senkouAValue = (ichimoku.tenkan[i] + ichimoku.kijun[i]) / 2;
                        if (i + kijunPeriod < data.length) { 
                            ichimoku.senkouA[i + kijunPeriod] = senkouAValue;
                        }
                    }

                    if (i >= senkouPeriod - 1) {
                        const { high, low } = calculatePeriodHighLow(senkouPeriod, i);
                        if (high !== null && low !== null) {
                            const senkouBValue = (high + low) / 2;
                            if (i + kijunPeriod < data.length) {
                                ichimoku.senkouB[i + kijunPeriod] = senkouBValue;
                            }
                        }
                    }
                    
                    if (i >= chikouLag) {
                        ichimoku.chikou[i - chikouLag] = data[i].close;
                    }
                }
                return ichimoku;
            }

            calculateStochasticRSI(data, rsiPeriod = 14, stochPeriod = 14, smoothPeriod = 3) {
                const rsiValues = this.calculateRSI(data, rsiPeriod);
                const k = new Array(data.length).fill(null);
                const d = new Array(data.length).fill(null);

                for (let i = 0; i < data.length; i++) {
                    if (rsiValues[i] === null || i < rsiPeriod + stochPeriod - 2) continue;

                    const rsiSlice = rsiValues.slice(i - stochPeriod + 1, i + 1).filter(v => v !== null);
                    if (rsiSlice.length < stochPeriod) continue;

                    const highestRSI = Math.max(...rsiSlice);
                    const lowestRSI = Math.min(...rsiSlice);
                    
                    if (highestRSI - lowestRSI === 0) {
                        k[i] = 50;
                    } else {
                        k[i] = ((rsiValues[i] - lowestRSI) / (highestRSI - lowestRSI)) * 100;
                    }
                }

                const kSmoothed = this.calculateSMA(k.map(val => ({ close: val })), smoothPeriod);
                const dSmoothed = this.calculateSMA(kSmoothed.map((val) => ({ close: val })), smoothPeriod);

                return { k: kSmoothed, d: dSmoothed };
            }

            generateSignals(data, indicators) {
                const signals = [];
                const { rsi, stochastic, supertrend, ichimoku, macd, bollinger } = indicators;
                const lastKline = data[data.length - 1];
                const prevKline = data.length > 1 ? data[data.length - 2] : null;

                if (!lastKline || !prevKline) return signals;

                if (stochastic && stochastic.k && stochastic.d) {
                    const lastK = stochastic.k[stochastic.k.length - 1];
                    const lastD = stochastic.d[stochastic.d.length - 1];
                    const prevK = stochastic.k.length > 1 ? stochastic.k[stochastic.k.length - 2] : null;
                    const prevD = stochastic.d.length > 1 ? stochastic.d[stochastic.d.length - 2] : null;

                    if (lastK !== null && lastD !== null && prevK !== null && prevD !== null) {
                        const oversoldThreshold = 20;
                        const overboughtThreshold = 80;

                        if (lastK > lastD && prevK <= prevD && lastK < oversoldThreshold) {
                            signals.push({ type: 'Stochastic RSI', strength: 75, direction: 'buy', price: lastKline.close, time: lastKline.time });
                        }
                        else if (lastK < lastD && prevK >= prevD && lastK > overboughtThreshold) {
                            signals.push({ type: 'Stochastic RSI', strength: 75, direction: 'sell', price: lastKline.close, time: lastKline.time });
                        }
                    }
                }

                if (supertrend && supertrend.line && supertrend.trend) {
                    const lastTrend = supertrend.trend[supertrend.trend.length - 1];
                    const prevTrend = supertrend.trend.length > 1 ? supertrend.trend[supertrend.trend.length - 2] : null;
                    
                    if (lastTrend !== null && prevTrend !== null) {
                        if (lastTrend && !prevTrend) {
                            signals.push({ type: 'Supertrend', strength: 80, direction: 'buy', price: lastKline.close, time: lastKline.time });
                        } else if (!lastTrend && prevTrend) {
                            signals.push({ type: 'Supertrend', strength: 80, direction: 'sell', price: lastKline.close, time: lastKline.time });
                        }
                    }
                }
                
                if (ichimoku && ichimoku.senkouA && ichimoku.senkouB && ichimoku.chikou) {
                    const lastSenkouA = ichimoku.senkouA[ichimoku.senkouA.length - 1];
                    const lastSenkouB = ichimoku.senkouB[ichimoku.senkouB.length - 1];
                    const lastChikou = ichimoku.chikou[ichimoku.chikou.length - 1];
                    const lastClose = lastKline.close;

                    if (lastSenkouA !== null && lastSenkouB !== null && lastChikou !== null) {
                        const cloudTop = Math.max(lastSenkouA, lastSenkouB);
                        const cloudBottom = Math.min(lastSenkouA, lastSenkouB);

                        if (lastClose > cloudTop && lastChikou > lastClose) {
                            signals.push({ type: 'Ichimoku Cloud', strength: 70, direction: 'buy', price: lastKline.close, time: lastKline.time });
                        }
                        else if (lastClose < cloudBottom && lastChikou < lastClose) {
                            signals.push({ type: 'Ichimoku Cloud', strength: 70, direction: 'sell', price: lastKline.close, time: lastKline.time });
                        }
                    }
                }

                if (macd && macd.macdLine && macd.signalLine) {
                    const lastMACD = macd.macdLine[macd.macdLine.length - 1];
                    const lastSignal = macd.signalLine[macd.signalLine.length - 1];
                    const prevMACD = macd.macdLine.length > 1 ? macd.macdLine[macd.macdLine.length - 2] : null;
                    const prevSignal = macd.signalLine.length > 1 ? macd.signalLine[macd.signalLine.length - 2] : null;

                    if (lastMACD !== null && lastSignal !== null && prevMACD !== null && prevSignal !== null) {
                        if (lastMACD > lastSignal && prevMACD <= prevSignal) {
                            signals.push({ type: 'MACD Crossover', strength: 60, direction: 'buy', price: lastKline.close, time: lastKline.time });
                        }
                        else if (lastMACD < lastSignal && prevMACD >= prevSignal) {
                            signals.push({ type: 'MACD Crossover', strength: 60, direction: 'sell', price: lastKline.close, time: lastKline.time });
                        }
                    }
                }

                if (rsi) {
                    const lastRSI = rsi[rsi.length - 1];
                    if (lastRSI !== null) {
                        const oversoldRSI = 30;
                        const overboughtRSI = 70;
                        if (lastRSI < oversoldRSI) {
                            signals.push({ type: 'RSI', strength: Math.max(0, oversoldRSI - lastRSI) * 1.5, direction: 'buy', price: lastKline.close, time: lastKline.time });
                        } else if (lastRSI > overboughtRSI) {
                            signals.push({ type: 'RSI', strength: Math.max(0, lastRSI - overboughtRSI) * 1.5, direction: 'sell', price: lastKline.close, time: lastKline.time });
                        }
                    }
                }

                if (bollinger && bollinger.upper && bollinger.lower) {
                    const lastClose = lastKline.close;
                    const lastUpperBB = bollinger.upper[bollinger.upper.length - 1];
                    const lastLowerBB = bollinger.lower[bollinger.lower.length - 1];

                    if (lastUpperBB !== null && lastLowerBB !== null) {
                        if (lastClose > lastUpperBB) {
                            signals.push({ type: 'Bollinger Band', strength: 50, direction: 'sell', price: lastKline.close, time: lastKline.time });
                        }
                        else if (lastClose < lastLowerBB) {
                            signals.push({ type: 'Bollinger Band', strength: 50, direction: 'buy', price: lastKline.close, time: lastKline.time });
                        }
                    }
                }

                return signals;
            }

            updateAnalysis(klines) {
                const indicators = this.calculateAllIndicators(klines);
                const { trendDirection, rsiStatus, volumeTrend, volatility } = this.getAnalysisMetrics(klines, indicators);

                document.getElementById('trendDirection').textContent = trendDirection;
                document.getElementById('rsiStatus').textContent = rsiStatus;
                document.getElementById('volumeTrend').textContent = volumeTrend;
                document.getElementById('volatility').textContent = volatility;
            }

            getAnalysisMetrics(klines, indicators) {
                let trendDirection = 'Neutral';
                let rsiStatus = '-';
                let volumeTrend = 'Neutral';
                let volatility = '-';

                if (indicators.rsi && indicators.rsi.length > 0) {
                    const lastRSI = indicators.rsi[indicators.rsi.length - 1];
                    if (lastRSI !== null) {
                        rsiStatus = lastRSI < 30 ? 'Oversold' : (lastRSI > 70 ? 'Overbought' : 'Neutral');
                    }
                }

                if (klines.length > 1) {
                    const priceChange = klines[klines.length - 1].close - klines[klines.length - 2].close;
                    trendDirection = priceChange > 0 ? 'Uptrend' : (priceChange < 0 ? 'Downtrend' : 'Sideways');
                }

                if (klines.length > 0) {
                    const volumes = klines.map(k => k.volume);
                    const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                    const lastVolume = klines[klines.length - 1].volume;
                    volumeTrend = lastVolume > avgVolume * 1.2 ? 'High' : (lastVolume < avgVolume * 0.8 ? 'Low' : 'Average');
                }

                if (indicators.atr && indicators.atr.length > 0) {
                    const lastATR = indicators.atr[indicators.atr.length - 1];
                    if (lastATR !== null) {
                        volatility = lastATR.toFixed(4);
                    }
                }

                return { trendDirection, rsiStatus, volumeTrend, volatility };
            }

            updateSignals(klines) {
                const indicators = this.calculateAllIndicators(klines);
                const signals = indicators.signals || [];
                const signalsContent = document.getElementById('signalsContent');
                
                if (signals.length === 0) {
                    signalsContent.innerHTML = '<p>No trading signals detected.</p>';
                    return;
                }

                const sortedSignals = signals.sort((a, b) => b.time - a.time); // Sort by time, most recent first

                signalsContent.innerHTML = '<div class="signals-list">';
                sortedSignals.forEach(signal => {
                    const signalItem = document.createElement('div');
                    signalItem.className = `signal-item ${signal.direction}`;
                    signalItem.innerHTML = `
                        <div class="signal-info">
                            <strong>${signal.type}</strong> Signal<br>
                            <span class="signal-time">${this.formatTime(signal.time)}</span>
                        </div>
                        <div class="signal-strength">${signal.direction.toUpperCase()} (${signal.strength.toFixed(0)}%)</div>
                    `;
                    signalsContent.appendChild(signalItem);
                });
                signalsContent.innerHTML += '</div>';
            }

            updateStatistics(klines) {
                if (klines.length === 0) return;

                const volumes = klines.map(k => k.volume);
                const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                const minPrice = Math.min(...klines.map(k => k.low));
                const maxPrice = Math.max(...klines.map(k => k.high));
                const priceRange = maxPrice - minPrice;

                const supportLevel = minPrice.toFixed(4);
                const resistanceLevel = maxPrice.toFixed(4);

                document.getElementById('avgVolume').textContent = this.formatVolume(avgVolume);
                document.getElementById('priceRange').textContent = this.formatPrice(priceRange);
                document.getElementById('supportLevel').textContent = this.formatPrice(supportLevel);
                document.getElementById('resistanceLevel').textContent = this.formatPrice(resistanceLevel);
            }

            async requestGeminiAnalysis() {
                if (!this.currentSymbol || this.chartData.length === 0) {
                    this.displayGeminiAnalysis("Select a symbol and load chart data to get AI insights.");
                    return;
                }

                this.displayGeminiAnalysis("Analyzing data with Gemini AI...");
                const interval = document.getElementById('intervalSelect').value;
                const indicators = this.calculateAllIndicators(this.chartData);

                try {
                    const response = await fetch(`${BACKEND_API_URL}/analyze`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            symbol: this.currentSymbol,
                            interval: interval,
                            klines: this.chartData,
                            indicators: indicators,
                            signals: indicators.signals || []
                        }),
                    });

                    const result = await response.json();

                    if (response.ok) {
                        this.displayGeminiAnalysis(result.analysis);
                    } else {
                        throw new Error(result.error || `HTTP error! status: ${response.status}`);
                    }
                } catch (error) {
                    console.error('Gemini analysis error:', error);
                    this.displayGeminiAnalysis(`Error fetching Gemini analysis: ${error.message}`);
                    this.showError(`Failed to get Gemini analysis: ${error.message}`);
                }
            }

            displayGeminiAnalysis(text) {
                const geminiResultEl = document.getElementById('geminiAnalysisResult');
                geminiResultEl.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                                             .replace(/\*(.*?)\*/g, '<em>$1</em>')
                                             .replace(/\n/g, '<br>');
            }

            loadSettings() {
                const settings = localStorage.getItem('tradingTerminalSettings');
                return settings ? JSON.parse(settings) : {
                    symbol: 'BTCUSDT',
                    interval: 'D',
                    limit: 200,
                    atrPeriod: 14,
                    rsiPeriod: 14,
                    emaPeriod: 20,
                    stPeriod: 10,
                    stMultiplier: 3,
                    indicators: {
                        toggleVolume: true, toggleSupertrend: true, toggleBollinger: true, toggleSMA: true, toggleEMA: true,
                        toggleRSI: true, toggleMACD: true, toggleSignals: true, toggleStochastic: false, toggleVWAP: false, togglePSAR: false, toggleIchimoku: false
                    }
                };
            }

            saveSettings() {
                this.settings.symbol = this.currentSymbol;
                this.settings.interval = document.getElementById('intervalSelect').value;
                this.settings.limit = parseInt(document.getElementById('limit').value);
                this.settings.atrPeriod = parseInt(document.getElementById('atrPeriod').value);
                this.settings.rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
                this.settings.emaPeriod = parseInt(document.getElementById('emaPeriod').value);
                this.settings.stPeriod = parseInt(document.getElementById('stPeriod').value);
                this.settings.stMultiplier = parseFloat(document.getElementById('stMultiplier').value);
                
                this.settings.indicators = {};
                document.querySelectorAll('.indicator-toggle input').forEach(toggle => {
                    this.settings.indicators[toggle.id] = toggle.checked;
                });

                localStorage.setItem('tradingTerminalSettings', JSON.stringify(this.settings));
                this.showNotification('Settings saved!', 'success');
            }

            applySettings() {
                document.getElementById('symbolSearch').value = this.settings.symbol || 'BTCUSDT';
                this.currentSymbol = this.settings.symbol || 'BTCUSDT';
                document.getElementById('intervalSelect').value = this.settings.interval || 'D';
                document.getElementById('limit').value = this.settings.limit || 200;
                document.getElementById('atrPeriod').value = this.settings.atrPeriod || 14;
                document.getElementById('rsiPeriod').value = this.settings.rsiPeriod || 14;
                document.getElementById('emaPeriod').value = this.settings.emaPeriod || 20;
                document.getElementById('stPeriod').value = this.settings.stPeriod || 10;
                document.getElementById('stMultiplier').value = this.settings.stMultiplier || 3;

                for (const [id, checked] of Object.entries(this.settings.indicators)) {
                    const toggle = document.getElementById(id);
                    if (toggle) {
                        toggle.checked = checked;
                    }
                }
            }

            resetSettings() {
                if (confirm('Are you sure you want to reset all settings to default?')) {
                    localStorage.removeItem('tradingTerminalSettings');
                    this.settings = this.loadSettings();
                    this.applySettings();
                    this.showNotification('Settings reset to default.', 'warning');
                }
            }

            applyPreset(preset) {
                let newSettings = { ...this.settings };
                switch (preset) {
                    case 'scalping':
                        newSettings = { ...newSettings, interval: '5', limit: 100, emaPeriod: 10, rsiPeriod: 10, stPeriod: 10, stMultiplier: 2, indicators: { ...newSettings.indicators, toggleVolume: true, toggleSMA: false, toggleEMA: true, toggleRSI: true, toggleMACD: false, toggleBollinger: false, toggleSupertrend: true, toggleSignals: true, toggleStochastic: true, toggleVWAP: false, togglePSAR: false, toggleIchimoku: false } };
                        break;
                    case 'daytrading':
                        newSettings = { ...newSettings, interval: '60', limit: 200, emaPeriod: 20, rsiPeriod: 14, stPeriod: 10, stMultiplier: 3, indicators: { ...newSettings.indicators, toggleVolume: true, toggleSMA: true, toggleEMA: true, toggleRSI: true, toggleMACD: true, toggleBollinger: true, toggleSupertrend: false, toggleSignals: true, toggleStochastic: false, toggleVWAP: true, togglePSAR: false, toggleIchimoku: false } };
                        break;
                    case 'swing':
                        newSettings = { ...newSettings, interval: 'D', limit: 150, emaPeriod: 50, rsiPeriod: 14, stPeriod: 10, stMultiplier: 3, indicators: { ...newSettings.indicators, toggleVolume: true, toggleSMA: true, toggleEMA: true, toggleRSI: true, toggleMACD: true, toggleBollinger: true, toggleSupertrend: true, toggleSignals: true, toggleStochastic: false, toggleVWAP: false, togglePSAR: true, toggleIchimoku: true } };
                        break;
                    case 'position':
                        newSettings = { ...newSettings, interval: 'D', limit: 100, emaPeriod: 50, rsiPeriod: 14, stPeriod: 10, stMultiplier: 3, indicators: { ...newSettings.indicators, toggleVolume: false, toggleSMA: false, toggleEMA: false, toggleRSI: true, toggleMACD: false, toggleBollinger: false, toggleSupertrend: false, toggleSignals: false, toggleStochastic: false, toggleVWAP: false, togglePSAR: false, toggleIchimoku: true } };
                        break;
                }
                this.settings = newSettings;
                this.applySettings();
                this.showNotification(`Preset '${preset}' applied.`, 'info');
                this.fetchDataAndRenderChart();
            }

            formatPrice(price) {
                if (price === null || isNaN(price)) return '-';
                if (Math.abs(price) >= 1000) return price.toFixed(2);
                if (Math.abs(price) >= 100) return price.toFixed(3);
                if (Math.abs(price) >= 1) return price.toFixed(4);
                return price.toFixed(6);
            }

            formatVolume(volume) {
                if (volume === null || isNaN(volume)) return '-';
                if (volume >= 1e9) return (volume / 1e9).toFixed(2) + 'B';
                if (volume >= 1e6) return (volume / 1e6).toFixed(2) + 'M';
                if (volume >= 1e3) return (volume / 1e3).toFixed(2) + 'K';
                return volume.toFixed(0);
            }

            formatTime(timestamp) {
                return moment(timestamp).format('YYYY-MM-DD HH:mm:ss');
            }

            showLoading(text = 'Loading...') {
                document.getElementById('loadingText').textContent = text;
                document.getElementById('loadingOverlay').classList.add('active');
            }

            hideLoading() {
                document.getElementById('loadingOverlay').classList.remove('active');
            }

            showNotification(message, type = 'info', duration = 3000) {
                const container = document.getElementById('notificationContainer');
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                const title = type.charAt(0).toUpperCase() + type.slice(1);
                
                notification.innerHTML = `
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                    <div class="notification-progress" style="animation-duration: ${duration}ms;"></div>
                `;
                container.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    notification.addEventListener('transitionend', () => notification.remove());
                }, duration);
            }

            showError(message) {
                this.showNotification(message, 'error');
            }

            showSuccess(message) {
                this.showNotification(message, 'success');
            }

            showWarning(message) {
                this.showNotification(message, 'warning');
            }

            resetChartAndAnalysis() {
                this.chartData = [];
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = null;
                }
                const canvas = document.getElementById('chartCanvas');
                if (canvas) {
                    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                }
                document.getElementById('geminiAnalysisResult').innerHTML = "<p>Select a symbol and load chart data to get AI insights.</p>";
                document.getElementById('trendDirection').textContent = '-';
                document.getElementById('rsiStatus').textContent = '-';
                document.getElementById('volumeTrend').textContent = '-';
                document.getElementById('volatility').textContent = '-';
                document.getElementById('avgVolume').textContent = '-';
                document.getElementById('priceRange').textContent = '-';
                document.getElementById('supportLevel').textContent = '-';
                document.getElementById('resistanceLevel').textContent = '-';
                document.getElementById('signalsContent').innerHTML = '<p>Loading trading signals...</p>';
            }

            switchTab(tabId) {
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');

                if (tabId === 'gemini-analysis' && this.currentSymbol && this.chartData.length > 0) {
                    this.requestGeminiAnalysis();
                }
            }

            setCache(key, data, ttl) {
                const now = new Date().getTime();
                const item = {
                    value: data,
                    expiry: now + ttl,
                };
                localStorage.setItem(key, JSON.stringify(item));
            }

            getFromCache(key) {
                const itemStr = localStorage.getItem(key);
                if (!itemStr) {
                    return null;
                }
                const item = JSON.parse(itemStr);
                const now = new Date().getTime();
                if (now > item.expiry) {
                    localStorage.removeItem(key);
                    return null;
                }
                return item.value;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new TradingTerminal();
        });
    </script>
</body>
</html>
