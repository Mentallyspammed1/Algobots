<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bybit V5 Order Book & Gemini Algo Trading - Linear Advanced</title>

  <!-- UI & libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>

  <!-- GenAI import map (Google Gemini) -->
  <script type="importmap">
  {
    "imports": {
      "@google/genai": "https://esm.sh/@google/genai@^1.5.1"
    }
  }
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap');
    :root {
      --bg-primary: #0d0d20;
      --text-primary: #e0e0ff;
      --neon-green: #39ff14;
      --neon-orange: #ffae42;
      --neon-red: #ff2079;
      --neon-cyan: #00f2ea;
      --neon-purple: #c500f2;
    }
    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }
    h1, h2 {
      font-family: 'Roboto Mono', monospace;
      text-shadow: 0 0 5px var(--neon-cyan), 0 0 10px var(--neon-cyan);
      border-bottom: 1px solid rgba(0, 242, 234, 0.3);
    }
    .section {
      background-color: #1a1a3a;
      border: 1px solid rgba(0, 242, 234, 0.4);
      box-shadow: inset 0 0 8px rgba(0, 242, 234, 0.2);
    }
    button, .btn {
      background-color: transparent;
      color: var(--neon-cyan);
      border: 2px solid var(--neon-cyan);
      box-shadow: 0 0 8px rgba(0, 242, 234, 0.5);
      transition: all 0.3s ease;
    }
    button:hover, .btn:hover {
      background-color: var(--neon-cyan);
      color: var(--bg-primary);
      box-shadow: 0 0 12px var(--neon-cyan);
    }
    input, textarea, select {
      background-color: var(--bg-primary);
      border: 1px solid rgba(0, 242, 234, 0.4);
      color: var(--text-primary);
      font-family: 'Roboto Mono', monospace;
    }
    #orderBookChart {
      max-height: 400px;
      width: 100% !important;
      height: 100% !important;
    }
    #dataOutput, #geminiOutput, #orderOutput, #keyStatus, #advancedOrderBookOutput, #tpSlStatus, #tradingModeDisplay, #connectionStatus {
      font-family: 'Roboto Mono', monospace;
    }
    ::-webkit-scrollbar { width: 10px; }
    ::-webkit-scrollbar-track { background: #1a1a3a; border-radius: 5px; }
    ::-webkit-scrollbar-thumb { background: var(--neon-cyan); border-radius: 5px; }
    .loading-spinner {
        border: 4px solid rgba(0, 242, 234, 0.1);
        border-top: 4px solid var(--neon-cyan);
        border-radius: 50%;
        width: 1.5em;
        height: 1.5em;
        animation: spin 1s linear infinite;
        display: inline-block;
        vertical-align: middle;
        margin-right: 0.5em;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .ws-status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
        vertical-align: middle;
    }
    .ws-status-indicator.connected { background-color: var(--neon-green); box-shadow: 0 0 5px var(--neon-green), 0 0 10px var(--neon-green); }
    .ws-status-indicator.connecting { background-color: var(--neon-orange); box-shadow: 0 0 5px var(--neon-orange), 0 0 10px var(--neon-orange); animation: pulse 1.5s infinite; }
    .ws-status-indicator.disconnected { background-color: var(--neon-red); box-shadow: 0 0 5px var(--neon-red), 0 0 10px var(--neon-red); }

    @keyframes pulse {
        0% { opacity: 0.5; }
        50% { opacity: 1; }
        100% { opacity: 0.5; }
    }
  </style>
</head>
<body class="min-h-screen p-6 flex flex-col items-center">
  <div class="container mx-auto p-4 max-w-4xl">
    <h1 class="text-center text-4xl sm:text-5xl font-bold text-[#00f2ea] pb-2 mb-8 border-b-2 border-cyan-400">
      Bybit Algo Trading Bot - Linear Advanced
    </h1>

    <!-- API Key and Configuration Section -->
    <div class="section p-6 rounded-lg mb-8 space-y-4">
      <h2 class="text-2xl font-bold text-[#00f2ea] pb-2 border-b border-cyan-400">Configuration</h2>
      <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
        <div class="space-y-2">
          <label for="geminiApiKeyUser" class="block font-medium">Google Gemini API Key:</label>
          <input type="password" id="geminiApiKeyUser" placeholder="Google Gemini API Key" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
        </div>
        <div class="space-y-2">
          <label for="bybitTradingApiKey" class="block font-medium">Bybit Trading API Key:</label>
          <input type="password" id="bybitTradingApiKey" placeholder="Bybit Trading API Key" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
        </div>
        <div class="space-y-2">
          <label for="bybitTradingApiSecret" class="block font-medium">Bybit Trading API Secret:</label>
          <input type="password" id="bybitTradingApiSecret" placeholder="Bybit Trading API Secret" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
        </div>
      </div>

      <!-- TP/SL Settings -->
      <div class="mt-4 grid grid-cols-3 gap-4">
        <div>
          <label for="tpPctInput" class="block font-medium">Take Profit % (LONG):</label>
          <input id="tpPctInput" type="number" step="0.1" value="2" min="0.1" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
        </div>
        <div>
          <label for="slPctInput" class="block font-medium">Stop Loss % (LONG):</label>
          <input id="slPctInput" type="number" step="0.1" value="1" min="0.1" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500" />
        </div>
        <div class="flex items-end">
          <label class="inline-flex items-center">
            <input id="tpSlEnabled" type="checkbox" checked class="form-checkbox h-5 w-5 bg-bg-primary border-cyan-400 text-neon-cyan focus:ring-neon-cyan" />
            <span class="ml-2">TP/SL Enabled</span>
          </label>
        </div>
      </div>
      <div class="mt-2 text-sm" id="tpSlStatus">TP/SL Status: Initializing...</div>

      <div class="mt-4 grid grid-cols-2 gap-4">
        <div>
          <label for="maxPositionContracts" class="block font-medium">Max Position (Contracts):</label>
          <input type="number" id="maxPositionContracts" value="0.01" step="0.001" min="0.001" class="px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500 w-full">
        </div>
        <div>
          <label for="impactQtyContracts" class="block font-medium">Impact Qty (Contracts) for Est. Price Move:</label>
          <input type="number" id="impactQtyContracts" value="0.01" step="0.001" min="0.001" class="px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500 w-full" />
        </div>
      </div>

      <div class="flex justify-between items-center mt-4">
        <button id="saveApiKeysBtn" class="px-6 py-2 rounded-full font-bold text-lg">Save API Keys</button>
        <div id="keyStatus" class="text-sm">Please save your API keys.</div>
      </div>
      <div class="mt-2 text-sm">Trading Mode: <span id="tradingModeDisplay" class="font-bold text-neon-cyan"></span></div>
    </div>

    <!-- Market Data & Status -->
    <div class="section p-6 rounded-lg mb-8 space-y-4">
      <h2 class="text-2xl font-bold text-[#00f2ea] pb-2 border-b border-cyan-400">Market Data & Status</h2>
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-center">
        <div>
          <label for="symbolSelect" class="block font-medium">Trading Symbol (USDT Linear):</label>
          <select id="symbolSelect" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500"></select>
        </div>
        <div class="text-center sm:text-left">
          <button id="connectWsBtn" class="px-6 py-2 rounded-full font-bold text-lg mr-2">Connect</button>
          <button id="subscribeWsBtn" class="px-6 py-2 rounded-full font-bold text-lg">Subscribe</button>
        </div>
      </div>
      <div class="flex flex-col sm:flex-row sm:space-x-4 space-y-4 sm:space-y-0 items-center justify-between mt-4">
        <div class="flex-1">
          <button id="unsubscribeWsBtn" class="px-6 py-2 rounded-full font-bold text-lg">Unsubscribe</button>
        </div>
        <div class="flex-1">
          <div class="font-medium">Connection Status:</div>
          <div id="connectionStatus" class="text-sm font-mono whitespace-pre-wrap mt-1">
            <span id="wsStatusIndicator" class="ws-status-indicator disconnected"></span>Disconnected.
          </div>
        </div>
      </div>

      <div class="mt-4">
        <h3 class="text-lg font-bold text-[#00f2ea]">Real-time Order Book</h3>
        <div id="dataOutput" class="text-sm font-mono whitespace-pre-wrap p-3 mt-2 rounded-md border border-cyan-400/30 overflow-x-auto bg-[#0d0d20] h-48">Waiting for data...</div>
      </div>

      <div class="mt-4">
        <canvas id="orderBookChart"></canvas>
      </div>

      <!-- Advanced Orderbook Analysis -->
      <div class="mt-6 section p-4 rounded-lg">
        <h3 class="text-lg font-bold text-[#00f2ea] pb-2 border-b border-cyan-400">Advanced Orderbook Analysis</h3>
        <div id="advancedOrderBookOutput" class="text-sm font-mono whitespace-pre-wrap p-3 bg-[#0d0d20] rounded-md border border-cyan-400/30"></div>
        <div class="flex justify-between items-center mt-2">
          <div class="font-medium">Mid Price:</div>
          <div id="midPriceDisplay" class="text-lg font-semibold text-cyan-400">0.0000</div>
        </div>
      </div>
    </div>

    <!-- Gemini Analysis & Orders -->
    <div class="section p-6 rounded-lg mb-8 space-y-4">
      <h2 class="text-2xl font-bold text-[#00f2ea] pb-2 border-b border-cyan-400">Gemini Analysis & Orders</h2>

      <div class="flex items-center space-x-2">
        <span class="font-medium">Current Position (<span id="baseCoinDisplay">BTC</span> Contracts):</span>
        <span id="currentPositionDisplay" class="font-bold text-xl text-neon-cyan">0.00000</span>
      </div>
      <div class="flex items-center space-x-2">
        <span class="font-medium">Unrealised PnL:</span>
        <span id="unrealisedPnlDisplay" class="font-bold text-xl text-neon-cyan">0.00 USDT</span>
      </div>
      <div class="flex items-center space-x-2">
        <span class="font-medium">Entry Price:</span>
        <span id="entryPriceDisplay" class="font-bold text-xl text-neon-cyan">0.00 USDT</span>
      </div>

      <div class="grid grid-cols-3 gap-4 mt-2">
        <div>
          <label for="timeframeSelect" class="block font-medium">Analysis Timeframe:</label>
          <select id="timeframeSelect" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500">
            <option value="realtime">Real-time L1 (Default)</option>
            <option value="5m">Last 5 Minutes</option>
            <option value="15m">Last 15 Minutes</option>
            <option value="1h">Last 1 Hour</option>
          </select>
        </div>
        <div class="col-span-2">
          <label for="geminiPrompt" class="block font-medium">Gemini Prompt (optional):</label>
          <textarea id="geminiPrompt" placeholder="Optional: Enter a custom prompt for Gemini." rows="2" class="w-full px-4 py-2 rounded-md border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-500"></textarea>
        </div>
      </div>

      <button id="analyzeBtn" class="w-full px-6 py-3 rounded-full font-bold text-lg">Analyze & Get Signal</button>

      <div id="geminiOutput" class="text-sm font-mono whitespace-pre-wrap p-3 mt-4 rounded-md border border-cyan-400/30 bg-[#0d0d20] overflow-y-auto max-h-48">No analysis yet...</div>

      <div class="mt-4">
        <h3 class="text-lg font-bold text-[#00f2ea] pb-2 border-b border-cyan-400">Automated Orders Log</h3>
        <div id="orderOutput" class="text-sm font-mono whitespace-pre-wrap p-3 mt-2 rounded-md border border-cyan-400/30 overflow-y-auto max-h-48 bg-[#0d0d20]">No orders placed...</div>
      </div>
    </div>

  </div>

  <script type="module">
    import { GoogleGenAI } from "@google/genai";

    // --- Simple Event Emitter ---
    class EventEmitter {
      constructor() {
        this.events = {};
      }
      on(event, listener) {
        if (!this.events[event]) {
          this.events[event] = [];
        }
        this.events[event].push(listener);
      }
      emit(event, ...args) {
        if (this.events[event]) {
          this.events[event].forEach(listener => listener(...args));
        }
      }
    }

    // --- Constants & Config ---
    const CONSTANTS = {
      IS_TESTNET: true,
      BYBIT_WEBSOCKET_URL: 'wss://stream.bybit.com/v5/public/linear',
      BYBIT_BASE_API_URL: 'https://api-testnet.bybit.com',
      GEMINI_MODEL_NAME: 'gemini-1.5-flash', // Updated to a stable model
      DEFAULT_MAX_POSITION_CONTRACTS: 0.01,
      POSITION_BUFFER: 0.000001, // Very small buffer for float precision
      ORDER_COOLDOWN_MS: 3000,
      API_COOLDOWN_MS: 500, // Bybit general API rate limit is typically 10-20 req/s for v5
      MAX_ORDERBOOK_HISTORY_MS: 65 * 60 * 1000,
      MAX_ORDERBOOK_HISTORY_LENGTH: 1000,
      ORDERBOOK_DEPTH_N: 5,
      TP_SL_CHECK_INTERVAL_MS: 3000,
      API_POSITION_FETCH_INTERVAL_MS: 10000,
      RECONNECT_INITIAL_DELAY: 5000,
      MAX_RECONNECT_DELAY: 30000,
      API_RECV_WINDOW: '10000',
      NEON_GREEN: '#39ff14',
      NEON_ORANGE: '#ffae42',
      NEON_RED: '#ff2079',
      NEON_CYAN: '#00f2ea',
      NEON_PURPLE: '#c500f2',
    };

    // --- Helper Functions ---
    function roundToStep(value, step) {
      if (step === 0) return value;
      return Math.round(value / step) * step;
    }

    // --- DOM Element References ---
    const DOM_ELEMENTS = {
      geminiApiKeyUser: document.getElementById('geminiApiKeyUser'),
      bybitTradingApiKey: document.getElementById('bybitTradingApiKey'),
      bybitTradingApiSecret: document.getElementById('bybitTradingApiSecret'),
      maxPositionContracts: document.getElementById('maxPositionContracts'),
      impactQtyContracts: document.getElementById('impactQtyContracts'),
      tpPctInput: document.getElementById('tpPctInput'),
      slPctInput: document.getElementById('slPctInput'),
      tpSlEnabled: document.getElementById('tpSlEnabled'),
      tpSlStatus: document.getElementById('tpSlStatus'),
      keyStatus: document.getElementById('keyStatus'),
      tradingModeDisplay: document.getElementById('tradingModeDisplay'),
      symbolSelect: document.getElementById('symbolSelect'),
      connectionStatus: document.getElementById('connectionStatus'),
      wsStatusIndicator: document.getElementById('wsStatusIndicator'),
      dataOutput: document.getElementById('dataOutput'),
      orderBookChart: document.getElementById('orderBookChart'),
      advancedOrderBookOutput: document.getElementById('advancedOrderBookOutput'),
      midPriceDisplay: document.getElementById('midPriceDisplay'),
      baseCoinDisplay: document.getElementById('baseCoinDisplay'),
      currentPositionDisplay: document.getElementById('currentPositionDisplay'),
      unrealisedPnlDisplay: document.getElementById('unrealisedPnlDisplay'),
      entryPriceDisplay: document.getElementById('entryPriceDisplay'),
      timeframeSelect: document.getElementById('timeframeSelect'),
      geminiPrompt: document.getElementById('geminiPrompt'),
      analyzeBtn: document.getElementById('analyzeBtn'),
      saveApiKeysBtn: document.getElementById('saveApiKeysBtn'),
      connectWsBtn: document.getElementById('connectWsBtn'),
      subscribeWsBtn: document.getElementById('subscribeWsBtn'),
      unsubscribeWsBtn: document.getElementById('unsubscribeWsBtn'),
      geminiOutput: document.getElementById('geminiOutput'),
      orderOutput: document.getElementById('orderOutput'),
    };

    // --- UIManager ---
    class UIManager extends EventEmitter {
      constructor(domElements, constants) {
        super();
        this.dom = domElements;
        this.constants = constants;
        this.orderBookChartInstance = null;
        this.currentQuoteCoin = 'USDT';
        this.currentBaseCoin = 'BTC';
      }

      init() {
        this.dom.saveApiKeysBtn.addEventListener('click', () => this.emit('saveApiKeys'));
        this.dom.connectWsBtn.addEventListener('click', () => this.emit('connectWebSocket'));
        this.dom.subscribeWsBtn.addEventListener('click', () => this.emit('subscribeOrderBook'));
        this.dom.unsubscribeWsBtn.addEventListener('click', () => this.emit('unsubscribeOrderBook'));
        this.dom.analyzeBtn.addEventListener('click', () => this.emit('analyzeWithGemini'));

        this.dom.symbolSelect.addEventListener('change', (event) => this.emit('symbolChanged', event.target.value));
        this.dom.tpPctInput.addEventListener('input', () => this.emit('tpSlConfigChanged'));
        this.dom.slPctInput.addEventListener('input', () => this.emit('tpSlConfigChanged'));
        this.dom.tpSlEnabled.addEventListener('change', () => this.emit('tpSlConfigChanged'));
        this.dom.maxPositionContracts.addEventListener('input', () => this.emit('configChanged', 'maxPositionContracts', this.dom.maxPositionContracts.value));
        this.dom.impactQtyContracts.addEventListener('input', () => this.emit('configChanged', 'impactQtyContracts', this.dom.impactQtyContracts.value));

        this.initializeOrderBookChart();
      }

      logToOutput(message, area, color, element) {
        const timestamp = new Date().toLocaleTimeString();
        const text = `[${timestamp}] [${area}] ${message}`.trim();
        const targetElement = element || this.dom.orderOutput; // Default to orderOutput
        if (targetElement) {
          const div = document.createElement('div');
          div.style.color = color;
          div.innerHTML = text.replace(/\n/g, '<br>');
          if (targetElement.id === 'dataOutput' || targetElement.id === 'advancedOrderBookOutput') {
            targetElement.innerHTML = div.innerHTML; // Overwrite for real-time data
          } else {
            targetElement.insertBefore(div, targetElement.firstChild); // Prepend for logs
            if (targetElement.children.length > 100) targetElement.removeChild(targetElement.lastChild); // Cap log size
          }
        }
        console.log(`%c${text}`, `color: ${color};`);
      }

      setLoading(elementId, isLoading, originalText = 'Submit') {
        const btn = document.getElementById(elementId);
        if (!btn) return;
        if (isLoading) {
          btn.disabled = true;
          btn.innerHTML = `<span class="loading-spinner"></span>${originalText.replace('Analyze', 'Analyzing...').replace('Save API Keys', 'Saving...')}`;
        } else {
          btn.disabled = false;
          btn.innerHTML = originalText;
        }
      }

      updateConnectionStatus(status, message) {
        this.dom.connectionStatus.innerHTML = `<span id="wsStatusIndicator" class="ws-status-indicator ${status}"></span>${message}`;
      }

      updateTradingMode(isTestnet) {
        this.dom.tradingModeDisplay.textContent = isTestnet ? 'Testnet' : 'Mainnet';
      }

      populateSymbols(symbols, currentSymbol) {
        this.dom.symbolSelect.innerHTML = '';
        if (symbols.length === 0) {
          this.dom.symbolSelect.innerHTML = '<option value="">No symbols found</option>';
          this.dom.symbolSelect.disabled = true;
          return;
        }
        symbols.forEach(symbol => {
          const option = document.createElement('option');
          option.value = symbol;
          option.textContent = symbol;
          this.dom.symbolSelect.appendChild(option);
        });
        this.dom.symbolSelect.value = currentSymbol;
        this.dom.symbolSelect.disabled = false;
      }

      updateSymbolLabels(baseCoin, quoteCoin) {
        this.currentBaseCoin = baseCoin;
        this.currentQuoteCoin = quoteCoin;
        this.dom.baseCoinDisplay.textContent = baseCoin;
        this.dom.maxPositionContracts.previousElementSibling.textContent = `Max Position (${baseCoin} Contracts):`;
        this.dom.impactQtyContracts.previousElementSibling.textContent = `Impact Qty (${baseCoin} Contracts) for Est. Price Move:`;
        if (this.orderBookChartInstance) {
          this.orderBookChartInstance.options.scales.y.title.text = `Price (${quoteCoin})`;
          this.orderBookChartInstance.options.scales.y1.title.text = `Quantity (${baseCoin} Contracts)`;
          this.orderBookChartInstance.update();
        }
      }

      clearOrderBookUI() {
        this.dom.dataOutput.textContent = 'Waiting for data...';
        this.dom.advancedOrderBookOutput.textContent = '';
        this.dom.midPriceDisplay.textContent = '0.0000';
        if (this.orderBookChartInstance) {
          this.orderBookChartInstance.data.datasets[0].data = [0, 0];
          this.orderBookChartInstance.data.datasets[1].data = [0, 0];
          this.orderBookChartInstance.update();
        }
      }

      initializeOrderBookChart() {
        if (!this.dom.orderBookChart) return;
        if (this.orderBookChartInstance) this.orderBookChartInstance.destroy();

        const chartConfig = {
          type: 'bar',
          data: {
            labels: ['Best Bid', 'Best Ask'],
            datasets: [
              {
                label: 'Price (USDT)',
                data: [0, 0],
                backgroundColor: [this.constants.NEON_GREEN, this.constants.NEON_RED],
                borderColor: [this.constants.NEON_CYAN, this.constants.NEON_PURPLE],
                borderWidth: 2,
                barThickness: 50,
              },
              {
                label: 'Quantity (Contracts)',
                data: [0, 0],
                backgroundColor: ['rgba(57, 255, 20, 0.5)', 'rgba(255, 32, 121, 0.5)'],
                borderColor: [this.constants.NEON_GREEN, this.constants.NEON_RED],
                borderWidth: 1,
                barThickness: 50,
                yAxisID: 'y1'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 150 },
            scales: {
              y: {
                type: 'linear',
                display: true,
                position: 'left',
                beginAtZero: false,
                title: { display: true, text: `Price (${this.currentQuoteCoin})`, color: this.constants.NEON_CYAN },
                ticks: { color: this.constants.NEON_CYAN, font: { family: "'Roboto Mono', monospace" } },
                grid: { color: 'rgba(0, 242, 234, 0.2)' }
              },
              y1: {
                type: 'linear',
                display: true,
                position: 'right',
                beginAtZero: true,
                title: { display: true, text: `Quantity (${this.currentBaseCoin} Contracts)`, color: this.constants.NEON_ORANGE },
                ticks: { color: this.constants.NEON_ORANGE, font: { family: "'Roboto Mono', monospace" } },
                grid: { drawOnChartArea: false }
              },
              x: {
                ticks: { color: this.constants.NEON_CYAN, font: { family: "'Roboto Mono', monospace", weight: 'bold' } },
                grid: { display: false }
              }
            },
            plugins: {
              legend: { labels: { color: this.constants.NEON_CYAN, font: { family: "'Roboto Mono', monospace" } } },
              tooltip: {
                enabled: true,
                backgroundColor: 'rgba(0,0,0,0.85)',
                titleColor: this.constants.NEON_CYAN,
                bodyColor: '#e0e0ff',
                borderColor: this.constants.NEON_PURPLE,
                borderWidth: 1,
                padding: 10,
                callbacks: {
                  label: (ctx) => {
                    let label = ctx.dataset.label || '';
                    if (label) label += ': ';
                    if (ctx.parsed.y !== null) {
                      if (ctx.dataset.label.startsWith('Price')) {
                        return label + new Intl.NumberFormat('en-US', { style: 'currency', currency: this.currentQuoteCoin }).format(ctx.parsed.y);
                      } else {
                        return label + ctx.parsed.y.toFixed(5) + ` ${this.currentBaseCoin}`;
                      }
                    }
                    return label;
                  }
                }
              }
            }
          }
        };
        this.orderBookChartInstance = new Chart(this.dom.orderBookChart, chartConfig);
      }

      updateL1Data(bidPrice, bidQty, askPrice, askQty, updateId, symbol) {
        const spread = askPrice - bidPrice;
        const spreadPercentage = (spread / askPrice) * 100;

        this.dom.dataOutput.innerHTML =
          `Symbol: <span class="text-cyan-400">${symbol}</span> (Update ID: ${updateId})<br>` +
          `Best Bid: <span class="text-green-400">$${bidPrice.toFixed(2)}</span> (Qty: <span class="text-green-400">${bidQty.toFixed(4)} ${this.currentBaseCoin}</span>)<br>` +
          `Best Ask: <span class="text-red-400">$${askPrice.toFixed(2)}</span> (Qty: <span class="text-red-400">${askQty.toFixed(4)} ${this.currentBaseCoin}</span>)<br>` +
          `Spread: <span class="text-orange-400">$${spread.toFixed(2)} (${spreadPercentage.toFixed(3)}%)</span>`;
      }

      updateOrderBookChart(bestBidPrice, bestBidQty, bestAskPrice, bestAskQty) {
        if (!this.orderBookChartInstance) return;
        this.orderBookChartInstance.data.datasets[0].data = [bestBidPrice, bestAskPrice];
        this.orderBookChartInstance.data.datasets[1].data = [bestBidQty, bestAskQty];
        this.orderBookChartInstance.update();
      }

      updateAdvancedDisplay(stats) {
        if (!stats) return;
        const html = [];
        html.push(`<strong>Top ${this.constants.ORDERBOOK_DEPTH_N} Bid Depth:</strong> ${stats.sumBidQty?.toFixed(4)} ${this.currentBaseCoin} | <strong>Ask Depth:</strong> ${stats.sumAskQty?.toFixed(4)} ${this.currentBaseCoin}`);
        html.push(`<br><strong>Order Book Imbalance:</strong> <span style="color:${stats.imbalancePct > 0 ? this.constants.NEON_GREEN : this.constants.NEON_RED};">${stats.imbalancePct?.toFixed(2)}%</span>`);
        html.push(`<br><strong>Bid VWAP:</strong> $${stats.vwapBid?.toFixed(2) ?? '0.00'} | <strong>Ask VWAP:</strong> $${stats.vwapAsk?.toFixed(2) ?? '0.00'}`);
        html.push(`<br><strong>Liquidity Gap (Bid):</strong> $${stats.gapBid?.toFixed(2) ?? '0.00'} | <strong>Gap (Ask):</strong> $${stats.gapAsk?.toFixed(2) ?? '0.00'}`);
        html.push(`<br><strong>Est. Buy Price for ${stats.impactQty?.toFixed(4)} ${this.currentBaseCoin} Contracts:</strong> $${stats.estBuyPriceForImpact?.toFixed(2) ?? '0.00'}`);
        html.push(`<br><strong>Est. Sell Price for ${stats.impactQty?.toFixed(4)} ${this.currentBaseCoin} Contracts:</strong> $${stats.estSellPriceForImpact?.toFixed(2) ?? '0.00'}`);
        this.dom.advancedOrderBookOutput.innerHTML = html.join('');
        this.dom.midPriceDisplay.textContent = `$${stats.midPrice?.toFixed(4) ?? '0.0000'}`;
      }

      updatePositionDisplay(qty, entryPrice, pnl) {
        this.dom.currentPositionDisplay.textContent = qty.toFixed(5);
        this.dom.currentPositionDisplay.style.color =
          qty > this.constants.POSITION_BUFFER ? this.constants.NEON_GREEN : this.constants.NEON_CYAN;

        this.dom.entryPriceDisplay.textContent = entryPrice > 0 ? `$${entryPrice.toFixed(2)}` : '0.00 USDT';

        const pnlColor = pnl > 0 ? this.constants.NEON_GREEN : (pnl < 0 ? this.constants.NEON_RED : this.constants.NEON_CYAN);
        this.dom.unrealisedPnlDisplay.textContent = `${pnl.toFixed(2)} USDT`;
        this.dom.unrealisedPnlDisplay.style.color = pnlColor;
      }

      updateTpSlStatus(config, activeTrade) {
        let statusText = `TP/SL ${config.enabled ? 'Enabled' : 'Disabled'} | TP ${(config.tpPct * 100).toFixed(1)}%, SL ${(config.slPct * 100).toFixed(1)}%`;
        if (activeTrade) {
          statusText += ` | Active: Entry $${activeTrade.entryPrice.toFixed(2)}, TP $${activeTrade.tpPrice.toFixed(2)}, SL $${activeTrade.slPrice.toFixed(2)} (Qty: ${activeTrade.remainingQty.toFixed(4)} ${this.currentBaseCoin})`;
        } else {
          statusText += ` | No active trade.`;
        }
        this.dom.tpSlStatus.textContent = statusText;
      }
    }

    // --- BybitClient ---
    class BybitClient extends EventEmitter {
      constructor(constants) {
        super();
        this.constants = constants;
        this.apiKey = '';
        this.apiSecret = '';
        this.lastApiCallTime = 0;
        this.instrumentInfo = {}; // Stores instrument details like qtyStep
      }

      setApiKeys(apiKey, apiSecret) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.emit('log', 'API keys loaded.', 'Config', this.constants.NEON_GREEN, DOM_ELEMENTS.keyStatus);
      }

      async apiCall(method, endpoint, params = {}, isPrivate = true, category = 'linear') {
        if (Date.now() - this.lastApiCallTime < this.constants.API_COOLDOWN_MS) {
          this.emit('log', `API cooldown active. Please wait.`, 'API Call', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          return null;
        }

        const url = `${this.constants.BYBIT_BASE_API_URL}${endpoint}`;
        const timestamp = Date.now().toString();
        const recvWindow = this.constants.API_RECV_WINDOW;

        let headers = {
          'Content-Type': 'application/json',
          'X-BAPI-TIMESTAMP': timestamp,
          'X-BAPI-RECV-WINDOW': recvWindow,
        };

        let requestParams = { ...params };

        if (endpoint.includes('/v5/market/instruments-info') || endpoint.includes('/v5/order/create') || endpoint.includes('/v5/position/list')) {
          requestParams.category = category;
        }

        if (isPrivate) {
          if (!this.apiKey || !this.apiSecret) {
            this.emit('log', 'Bybit API Key/Secret not set for private call.', 'API Call', this.constants.NEON_RED, DOM_ELEMENTS.orderOutput);
            return null;
          }
          headers['X-BAPI-API-KEY'] = this.apiKey;

          let signaturePayload;
          let queryString = '';
          let requestBody = '';

          if (method === 'GET' || method === 'DELETE') {
            queryString = new URLSearchParams(requestParams).toString();
            signaturePayload = `${timestamp}${this.apiKey}${recvWindow}${queryString}`;
          } else if (method === 'POST') {
            requestBody = JSON.stringify(requestParams);
            signaturePayload = `${timestamp}${this.apiKey}${recvWindow}${requestBody}`;
          }

          headers['X-BAPI-SIGN'] = CryptoJS.HmacSHA256(signaturePayload, this.apiSecret).toString(CryptoJS.enc.Hex);
        }

        try {
          const response = await axios({ method, url, headers, data: method === 'POST' ? requestBody : undefined, params: method === 'GET' ? requestParams : undefined });
          this.lastApiCallTime = Date.now();
          return response.data;
        } catch (error) {
          const errMsg = error.response?.data?.retMsg || error.message;
          this.emit('log', `Bybit API Error (${method} ${endpoint}): ${errMsg}`, 'API Call', this.constants.NEON_RED, DOM_ELEMENTS.orderOutput);
          console.error('Bybit API Error:', error.response ? error.response.data : error.message);
          return null;
        }
      }

      async getInstrumentInfo(symbol, category = 'linear') {
        if (this.instrumentInfo[symbol]) return this.instrumentInfo[symbol];

        const response = await this.apiCall('GET', '/v5/market/instruments-info', { symbol, category }, false);
        if (response && response.retCode === 0 && response.result.list && response.result.list.length > 0) {
          this.instrumentInfo[symbol] = response.result.list[0];
          return this.instrumentInfo[symbol];
        }
        return null;
      }

      async getAvailableSymbols(category = 'linear') {
        const response = await this.apiCall('GET', '/v5/market/instruments-info', { status: 'Trading', category }, false);
        if (response && response.retCode === 0 && response.result.list) {
          return response.result.list
            .filter(item => item.quoteCoin === 'USDT' && item.status === 'Trading')
            .map(item => item.symbol)
            .sort();
        }
        return [];
      }

      async createOrder(params) {
        return this.apiCall('POST', '/v5/order/create', params, true, 'linear');
      }

      async getPosition(symbol, category = 'linear') {
        return this.apiCall('GET', '/v5/position/list', { symbol, category }, true, 'linear');
      }
    }

    // --- WebSocketManager ---
    class WebSocketManager extends EventEmitter {
      constructor(wsUrl, constants) {
        super();
        this.wsUrl = wsUrl;
        this.constants = constants;
        this.ws = null;
        this.pingInterval = null;
        this.reconnectAttempts = 0;
        this.currentSubscription = null;
      }

      connect() {
        if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
          this.emit('log', 'WebSocket is already connected or connecting.', 'WS Status', this.constants.NEON_ORANGE, DOM_ELEMENTS.connectionStatus);
          return;
        }

        this.ws = new WebSocket(this.wsUrl);
        this.emit('log', 'Connecting to Bybit WebSocket...', 'WS Status', this.constants.NEON_CYAN, DOM_ELEMENTS.connectionStatus);
        this.emit('status', 'connecting', 'Connecting...');

        this.ws.onopen = () => {
          this.emit('log', 'Connected to Bybit WebSocket!', 'WS Status', this.constants.NEON_GREEN, DOM_ELEMENTS.connectionStatus);
          this.emit('status', 'connected', 'Connected');
          this.reconnectAttempts = 0;
          this.sendPing();
          if (this.pingInterval) clearInterval(this.pingInterval);
          this.pingInterval = setInterval(() => this.sendPing(), 20000);
          if (this.currentSubscription) {
            this.subscribe(this.currentSubscription); // Re-subscribe to active topic
          }
        };

        this.ws.onmessage = (evt) => this.handleMessage(evt);
        this.ws.onerror = (err) => {
          this.emit('log', 'WebSocket error. Check console.', 'WS Status', this.constants.NEON_RED, DOM_ELEMENTS.connectionStatus);
          console.error('WebSocket Error:', err);
        };
        this.ws.onclose = () => {
          this.emit('log', 'WebSocket disconnected. Attempting to reconnect...', 'WS Status', this.constants.NEON_RED, DOM_ELEMENTS.connectionStatus);
          this.emit('status', 'disconnected', 'Disconnected. Reconnecting...');
          this.ws = null;
          if (this.pingInterval) clearInterval(this.pingInterval);
          this.pingInterval = null;

          const delay = Math.min(this.constants.RECONNECT_INITIAL_DELAY * Math.pow(2, this.reconnectAttempts), this.constants.MAX_RECONNECT_DELAY);
          this.reconnectAttempts++;
          setTimeout(() => this.connect(), delay);
          this.emit('log', `Reconnecting in ${delay / 1000}s (Attempt ${this.reconnectAttempts})...`, 'WS Status', this.constants.NEON_CYAN, DOM_ELEMENTS.connectionStatus);
        };
      }

      disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws = null;
          if (this.pingInterval) clearInterval(this.pingInterval);
          this.pingInterval = null;
          this.reconnectAttempts = 0; // Reset attempts
          this.emit('log', 'WebSocket manually disconnected.', 'WS Status', this.constants.NEON_CYAN, DOM_ELEMENTS.connectionStatus);
          this.emit('status', 'disconnected', 'Disconnected.');
        }
      }

      sendPing() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({ op: 'ping' }));
        }
      }

      subscribe(topic) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          this.emit('log', 'WebSocket not connected. Please connect first.', 'WS Status', this.constants.NEON_ORANGE, DOM_ELEMENTS.connectionStatus);
          return;
        }
        if (this.currentSubscription === topic) {
            this.emit('log', `Already subscribed to ${topic}.`, 'WS Status', this.constants.NEON_ORANGE, DOM_ELEMENTS.connectionStatus);
            return;
        }
        if (this.currentSubscription) {
            this.unsubscribe(this.currentSubscription); // Unsubscribe from old topic first
        }

        const msg = { op: 'subscribe', args: [topic] };
        this.ws.send(JSON.stringify(msg));
        this.currentSubscription = topic;
        this.emit('log', `Subscribing to ${topic}...`, 'WS Status', this.constants.NEON_CYAN, DOM_ELEMENTS.connectionStatus);
      }

      unsubscribe(topic) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          this.emit('log', 'WebSocket not connected.', 'WS Status', this.constants.NEON_ORANGE, DOM_ELEMENTS.connectionStatus);
          return;
        }
        const msg = { op: 'unsubscribe', args: [topic] };
        this.ws.send(JSON.stringify(msg));
        this.emit('log', `Unsubscribing from ${topic}...`, 'WS Status', this.constants.NEON_CYAN, DOM_ELEMENTS.connectionStatus);
        if (this.currentSubscription === topic) {
          this.currentSubscription = null;
        }
      }

      handleMessage(event) {
        try {
          const message = JSON.parse(event.data);
          if (message.op === 'pong') return;
          if (message.op === 'subscribe' || message.op === 'unsubscribe') {
            const status = message.success ? 'Success' : 'Failed';
            this.emit('log', `Subscription ${status}: ${message.ret_msg || message.req_id}`, 'WS Status', message.success ? this.constants.NEON_GREEN : this.constants.NEON_RED, DOM_ELEMENTS.connectionStatus);
            return;
          }

          if (message.topic && message.topic.startsWith('orderbook.1.')) {
            this.emit('orderBookUpdate', message.data);
          }
        } catch (error) {
          this.emit('log', 'Error processing WebSocket message. Check console.', 'WS Data', this.constants.NEON_RED, DOM_ELEMENTS.dataOutput);
          console.error('WebSocket Message Error:', error);
        }
      }
    }

    // --- OrderBookManager ---
    class OrderBookManager extends EventEmitter {
      constructor(constants) {
        super();
        this.constants = constants;
        this.latestOrderBook = null;
        this.orderBookHistory = [];
        this.currentSymbol = '';
      }

      setSymbol(symbol) {
        if (this.currentSymbol !== symbol) {
          this.currentSymbol = symbol;
          this.latestOrderBook = null;
          this.orderBookHistory.length = 0;
          this.emit('log', `Order book data cleared for new symbol: ${symbol}`, 'OrderBook', this.constants.NEON_CYAN);
          this.emit('cleared');
        }
      }

      updateOrderBookData(data) {
        if (!data?.b?.[0] || !data?.a?.[0] || data.s !== this.currentSymbol) {
          // Ignore data for other symbols or invalid data
          return;
        }
        this.latestOrderBook = data;

        const bestBidPrice = parseFloat(data.b[0][0]);
        const bestBidQty = parseFloat(data.b[0][1]);
        const bestAskPrice = parseFloat(data.a[0][0]);
        const bestAskQty = parseFloat(data.a[0][1]);

        const now = Date.now();
        this.orderBookHistory.push({ ts: now, bidPrice: bestBidPrice, bidQty: bestBidQty, askPrice: bestAskPrice, askQty: bestAskQty, raw: data });
        this.pruneHistory();

        const advancedStats = this.computeAdvancedOrderBookStats(data);
        this.emit('updated', {
          bestBidPrice, bestBidQty, bestAskPrice, bestAskQty,
          updateId: data.u, symbol: data.s, advancedStats
        });
      }

      pruneHistory() {
        const now = Date.now();
        while (this.orderBookHistory.length > 0 && now - this.orderBookHistory[0].ts > this.constants.MAX_ORDERBOOK_HISTORY_MS) {
          this.orderBookHistory.shift();
        }
        if (this.orderBookHistory.length > this.constants.MAX_ORDERBOOK_HISTORY_LENGTH) {
          this.orderBookHistory.splice(0, this.orderBookHistory.length - this.constants.MAX_ORDERBOOK_HISTORY_LENGTH);
        }
      }

      computeAdvancedOrderBookStats(data) {
        const bids = data?.b?.slice(0, this.constants.ORDERBOOK_DEPTH_N) || [];
        const asks = data?.a?.slice(0, this.constants.ORDERBOOK_DEPTH_N) || [];

        const depthBid = bids.map(([price, qty]) => ({ price: parseFloat(price), qty: parseFloat(qty) }));
        const depthAsk = asks.map(([price, qty]) => ({ price: parseFloat(price), qty: parseFloat(qty) }));

        const bestBid = depthBid[0]?.price ?? 0;
        const bestAsk = depthAsk[0]?.price ?? 0;

        const sumBidQty = depthBid.reduce((s, d) => s + (d.qty || 0), 0);
        const sumAskQty = depthAsk.reduce((s, d) => s + (d.qty || 0), 0);

        const totalDepthQty = sumBidQty + sumAskQty;
        const imbalancePct = totalDepthQty > 0 ? ((sumBidQty - sumAskQty) / totalDepthQty) * 100 : 0;

        const vwapBid = sumBidQty > 0
          ? depthBid.reduce((acc, d) => acc + d.price * d.qty, 0) / sumBidQty
          : 0;
        const vwapAsk = sumAskQty > 0
          ? depthAsk.reduce((acc, d) => acc + d.price * d.qty, 0) / sumAskQty
          : 0;

        const secondBestBid = depthBid[1]?.price ?? bestBid;
        const secondBestAsk = depthAsk[1]?.price ?? bestAsk;
        const gapBid = bestBid - secondBestBid;
        const gapAsk = secondBestAsk - bestAsk;

        const impactQty = parseFloat(DOM_ELEMENTS.impactQtyContracts.value) || this.constants.DEFAULT_MAX_POSITION_CONTRACTS;
        const estBuyPriceForImpact = this.estimatePriceForQty(impactQty, depthAsk, bestAsk);
        const estSellPriceForImpact = this.estimatePriceForQty(impactQty, depthBid, bestBid);

        const midPrice = (bestBid && bestAsk) ? (bestBid + bestAsk) / 2 : 0;

        return {
          bestBid, bestAsk, sumBidQty, sumAskQty,
          imbalancePct, vwapBid, vwapAsk,
          gapBid, gapAsk, midPrice,
          estBuyPriceForImpact, estSellPriceForImpact, impactQty
        };
      }

      estimatePriceForQty(qtyNeeded, depthLevels, fallbackBestPrice) {
        if (!qtyNeeded || qtyNeeded <= 0 || !depthLevels || depthLevels.length === 0) return fallbackBestPrice;

        let remainingQty = qtyNeeded;
        let costAccumulator = 0;
        let qtyFilled = 0;

        for (const level of depthLevels) {
          const price = level.price;
          const availableQty = level.qty;

          if (remainingQty <= 0) break;

          if (remainingQty <= availableQty) {
            costAccumulator += price * remainingQty;
            qtyFilled += remainingQty;
            remainingQty = 0;
          } else {
            costAccumulator += price * availableQty;
            qtyFilled += availableQty;
            remainingQty -= availableQty;
          }
        }

        if (remainingQty > 0) {
          if (qtyFilled > 0) {
            const lastPriceInDepth = depthLevels[depthLevels.length - 1].price;
            costAccumulator += lastPriceInDepth * remainingQty;
            qtyFilled += remainingQty;
          } else {
            costAccumulator = fallbackBestPrice * qtyNeeded;
            qtyFilled = qtyNeeded;
          }
        }
        return qtyFilled > 0 ? costAccumulator / qtyFilled : fallbackBestPrice;
      }

      getHistoricalOrderBookSummary(timeframeMinutes) {
        if (this.orderBookHistory.length === 0) return "No historical data available.";
        const now = Date.now();
        const startTime = now - timeframeMinutes * 60 * 1000;
        const relevant = this.orderBookHistory.filter(d => d.ts >= startTime);
        if (relevant.length < 2) return `Insufficient historical data for the last ${timeframeMinutes} minutes (found ${relevant.length} points). Using latest L1 data instead.`;

        const first = relevant[0];
        const last = relevant[relevant.length - 1];
        const midIndex = Math.floor(relevant.length / 2);
        const middle = relevant[midIndex];
        const priceChangeBid = (((last.bidPrice - first.bidPrice) / first.bidPrice) * 100).toFixed(2);
        const priceChangeAsk = (((last.askPrice - first.askPrice) / first.askPrice) * 100).toFixed(2);

        return `Summary for last ${timeframeMinutes} minutes (${relevant.length} data points):
Initial: Bid $${first.bidPrice.toFixed(2)} (Qty ${first.bidQty.toFixed(4)}), Ask $${first.askPrice.toFixed(2)} (Qty ${first.askQty.toFixed(4)})
Middle:  Bid $${middle.bidPrice.toFixed(2)} (Qty ${middle.bidQty.toFixed(4)}), Ask $${middle.askPrice.toFixed(2)} (Qty ${middle.askQty.toFixed(4)})
Current: Bid $${last.bidPrice.toFixed(2)} (Qty ${last.bidQty.toFixed(4)}), Ask $${last.askPrice.toFixed(2)} (Qty ${last.askQty.toFixed(4)})
Bid Price Change: ${priceChangeBid}%, Ask Price Change: ${priceChangeAsk}%`;
      }
    }

    // --- TradeManager ---
    class TradeManager extends EventEmitter {
      constructor(bybitClient, orderBookManager, constants) {
        super();
        this.bybitClient = bybitClient;
        this.orderBookManager = orderBookManager;
        this.constants = constants;

        this.currentSymbol = '';
        this.currentPositionQty = 0.0;
        this.currentEntryPrice = 0.0;
        this.currentUnrealisedPnl = 0.0;
        this.instrumentInfo = null; // Stores qtyStep etc. for current symbol

        this.tpSlConfig = {
          enabled: true,
          tpPct: 0.02,
          slPct: 0.01,
          activeTrade: null
        };
        this.positionFetchInterval = null;
        this.tpSlCheckInterval = null;
        this.lastOrderSentTime = 0;
      }

      setSymbol(symbol) {
        if (this.currentSymbol !== symbol) {
          this.currentSymbol = symbol;
          this.currentPositionQty = 0.0;
          this.currentEntryPrice = 0.0;
          this.currentUnrealisedPnl = 0.0;
          this.instrumentInfo = null;
          this.tpSlConfig.activeTrade = null; // Clear active trade on symbol change
          this.saveTpSlState();
          this.emit('positionUpdated', this.currentPositionQty, this.currentEntryPrice, this.currentUnrealisedPnl);
          this.emit('tpSlConfigUpdated', this.tpSlConfig, this.tpSlConfig.activeTrade);
          this.fetchInstrumentInfo(); // Fetch for new symbol
          this.fetchCurrentPosition(); // Fetch for new symbol immediately
        }
      }

      startPositionFetching() {
        if (this.positionFetchInterval) clearInterval(this.positionFetchInterval);
        this.positionFetchInterval = setInterval(() => this.fetchCurrentPosition(), this.constants.API_POSITION_FETCH_INTERVAL_MS);
      }

      startTpSlChecking() {
        if (this.tpSlCheckInterval) clearInterval(this.tpSlCheckInterval);
        this.tpSlCheckInterval = setInterval(() => this.checkTpSlAndExecute(), this.constants.TP_SL_CHECK_INTERVAL_MS);
      }

      async fetchInstrumentInfo() {
        if (!this.currentSymbol) return;
        this.instrumentInfo = await this.bybitClient.getInstrumentInfo(this.currentSymbol);
        if (!this.instrumentInfo) {
            this.emit('log', `Failed to fetch instrument info for ${this.currentSymbol}. Order quantity rounding might be inaccurate.`, 'Trade Manager', this.constants.NEON_ORANGE);
        }
      }

      async fetchCurrentPosition() {
        if (!this.bybitClient.apiKey || !this.bybitClient.apiSecret || !this.currentSymbol) {
          return;
        }

        const response = await this.bybitClient.getPosition(this.currentSymbol);

        if (response && response.retCode === 0 && response.result.list && response.result.list.length > 0) {
          const position = response.result.list[0];
          this.currentPositionQty = parseFloat(position.size);
          this.currentEntryPrice = parseFloat(position.avgPrice);
          this.currentUnrealisedPnl = parseFloat(position.unrealisedPnl);

          if (this.currentPositionQty > this.constants.POSITION_BUFFER && !this.tpSlConfig.activeTrade) {
            this.emit('log', `Detected open position for ${this.currentSymbol}. Initializing client-side TP/SL.`, 'Position', this.constants.NEON_CYAN, DOM_ELEMENTS.orderOutput);
            this.onBuyOrderFilled(this.currentPositionQty, this.currentEntryPrice);
          }
        } else {
          this.currentPositionQty = 0.0;
          this.currentEntryPrice = 0.0;
          this.currentUnrealisedPnl = 0.0;
          if (this.tpSlConfig.activeTrade) {
            this.emit('log', `Position closed. Clearing active TP/SL trade for ${this.currentSymbol}.`, 'TP/SL', this.constants.NEON_CYAN, DOM_ELEMENTS.orderOutput);
            this.tpSlConfig.activeTrade = null;
            this.saveTpSlState();
          }
        }
        this.emit('positionUpdated', this.currentPositionQty, this.currentEntryPrice, this.currentUnrealisedPnl);
        this.emit('tpSlConfigUpdated', this.tpSlConfig, this.tpSlConfig.activeTrade);
      }

      setTpSlConfig(tpPct, slPct, enabled) {
        this.tpSlConfig.enabled = enabled;
        this.tpSlConfig.tpPct = isNaN(tpPct / 100) ? 0.02 : (tpPct / 100);
        this.tpSlConfig.slPct = isNaN(slPct / 100) ? 0.01 : (slPct / 100);
        this.emit('tpSlConfigUpdated', this.tpSlConfig, this.tpSlConfig.activeTrade);
        this.saveTpSlState();
      }

      loadTpSlState() {
        const savedTrade = localStorage.getItem('activeTrade');
        if (savedTrade) {
          this.tpSlConfig.activeTrade = JSON.parse(savedTrade);
          if (this.tpSlConfig.activeTrade && this.tpSlConfig.activeTrade.symbol !== this.currentSymbol) {
            this.tpSlConfig.activeTrade = null;
          } else {
            this.emit('log', 'Active trade state loaded from local storage.', 'TP/SL', this.constants.NEON_GREEN, DOM_ELEMENTS.tpSlStatus);
          }
        }
      }

      saveTpSlState() {
        if (this.tpSlConfig.activeTrade) {
          localStorage.setItem('activeTrade', JSON.stringify(this.tpSlConfig.activeTrade));
        } else {
          localStorage.removeItem('activeTrade');
        }
      }

      onBuyOrderFilled(adjustedQuantity, entryPrice) {
        if (!this.tpSlConfig.enabled) return;
        if (this.tpSlConfig.activeTrade && this.tpSlConfig.activeTrade.symbol === this.currentSymbol) {
          this.emit('log', 'TP/SL already managing an active trade for this symbol. Not setting new TP/SL for this buy.', 'TP/SL', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          return;
        }

        const tpPrice = entryPrice * (1 + this.tpSlConfig.tpPct);
        const slPrice = entryPrice * (1 - this.tpSlConfig.slPct);

        this.tpSlConfig.activeTrade = {
          tradeId: `TRADE_${Date.now()}`,
          symbol: this.currentSymbol,
          direction: 'LONG', // Hardcoded for LONG as per current requirements
          entryPrice: entryPrice,
          tpPrice: tpPrice,
          slPrice: slPrice,
          remainingQty: adjustedQuantity
        };
        this.saveTpSlState();
        this.emit('log', `TP/SL Opened (LONG): Entry $${entryPrice.toFixed(5)} | TP $${tpPrice.toFixed(5)} | SL $${slPrice.toFixed(5)} | Qty ${adjustedQuantity.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts`, 'TP/SL', this.constants.NEON_GREEN, DOM_ELEMENTS.orderOutput);
        this.emit('tpSlConfigUpdated', this.tpSlConfig, this.tpSlConfig.activeTrade);
      }

      checkTpSlAndExecute() {
        if (!this.tpSlConfig.enabled || !this.tpSlConfig.activeTrade || this.tpSlConfig.activeTrade.symbol !== this.currentSymbol) return;

        const latestOrderBook = this.orderBookManager.latestOrderBook;
        const bestBid = latestOrderBook?.b?.[0]?.[0] ? parseFloat(latestOrderBook.b[0][0]) : null;
        const bestAsk = latestOrderBook?.a?.[0]?.[0] ? parseFloat(latestOrderBook.a[0][0]) : null;
        if (bestBid == null || bestAsk == null) return;
        const mid = (bestBid + bestAsk) / 2;

        const trade = this.tpSlConfig.activeTrade;

        if (this.currentPositionQty <= this.constants.POSITION_BUFFER) {
          if (trade.remainingQty > this.constants.POSITION_BUFFER) {
            this.emit('log', `Actual position is zero. Clearing TP/SL for this symbol.`, 'TP/SL', this.constants.NEON_CYAN, DOM_ELEMENTS.orderOutput);
          }
          this.tpSlConfig.activeTrade = null;
          this.saveTpSlState();
          this.emit('tpSlConfigUpdated', this.tpSlConfig, this.tpSlConfig.activeTrade);
          return;
        } else {
          trade.remainingQty = this.currentPositionQty;
        }

        if (mid >= trade.tpPrice) {
          this.emit('log', `TP Reached! Closing LONG ${trade.remainingQty.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts at mid $${mid.toFixed(5)}`, 'TP/SL', this.constants.NEON_GREEN, DOM_ELEMENTS.orderOutput);
          this.placeAutomatedOrder('SELL', trade.remainingQty);
          this.tpSlConfig.activeTrade = null;
          this.saveTpSlState();
          this.emit('tpSlConfigUpdated', this.tpSlConfig, this.tpSlConfig.activeTrade);
          return;
        }

        if (mid <= trade.slPrice) {
          this.emit('log', `SL Triggered! Closing LONG ${trade.remainingQty.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts at mid $${mid.toFixed(5)}`, 'TP/SL', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          this.placeAutomatedOrder('SELL', trade.remainingQty);
          this.tpSlConfig.activeTrade = null;
          this.saveTpSlState();
          this.emit('tpSlConfigUpdated', this.tpSlConfig, this.tpSlConfig.activeTrade);
        }
      }

      async placeAutomatedOrder(side, quantity) {
        if (Date.now() - this.lastOrderSentTime < this.constants.ORDER_COOLDOWN_MS) {
          const remaining = ((this.constants.ORDER_COOLDOWN_MS - (Date.now() - this.lastOrderSentTime)) / 1000).toFixed(1);
          this.emit('log', `Order cooldown active. Wait ${remaining}s.`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          return;
        }

        if (!this.bybitClient.apiKey || !this.bybitClient.apiSecret) {
          this.emit('log', 'Bybit API Key or Secret not set. Cannot place order.', 'Order Output', this.constants.NEON_RED, DOM_ELEMENTS.orderOutput);
          return;
        }
        if (!this.currentSymbol || this.currentSymbol === '') {
          this.emit('log', 'No trading symbol selected. Cannot place order.', 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          return;
        }
        if (!this.orderBookManager.latestOrderBook || !this.orderBookManager.latestOrderBook.a || !this.orderBookManager.latestOrderBook.b) {
          this.emit('log', 'No latest order book data available. Order cancelled.', 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          return;
        }
        if (!this.instrumentInfo) {
            this.emit('log', `Instrument info for ${this.currentSymbol} not loaded. Cannot place order.`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
            return;
        }

        const maxPos = parseFloat(DOM_ELEMENTS.maxPositionContracts.value) || this.constants.DEFAULT_MAX_POSITION_CONTRACTS;
        let adjustedQuantity = quantity;

        if (side === 'BUY') {
          const remainingCapacity = maxPos - this.currentPositionQty;
          if (remainingCapacity <= this.constants.POSITION_BUFFER) {
            this.emit('log', `BUY order cancelled: Max position of ${maxPos.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts reached (Current: ${this.currentPositionQty.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts).`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
            return;
          }
          adjustedQuantity = Math.min(quantity, remainingCapacity);
          if (adjustedQuantity < quantity) {
            this.emit('log', `BUY order quantity ${quantity.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts adjusted to ${adjustedQuantity.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts due to max position limit.`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          }
        } else if (side === 'SELL') {
          if (this.currentPositionQty <= this.constants.POSITION_BUFFER) {
            this.emit('log', `SELL order cancelled: No ${this.currentSymbol.slice(0, -4)} Contracts position to sell.`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
            return;
          }
          adjustedQuantity = Math.min(quantity, this.currentPositionQty);
          if (adjustedQuantity < quantity) {
            this.emit('log', `SELL order quantity ${quantity.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts adjusted to ${adjustedQuantity.toFixed(5)} ${this.currentSymbol.slice(0, -4)} Contracts to match current position.`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          }
        }

        if (adjustedQuantity <= this.constants.POSITION_BUFFER) {
          this.emit('log', `Order for ${side} results in negligible effective quantity after adjustments. Order cancelled.`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          return;
        }

        // Round quantity to lotSizeFilter.qtyStep
        const qtyStep = parseFloat(this.instrumentInfo.lotSizeFilter.qtyStep);
        adjustedQuantity = roundToStep(adjustedQuantity, qtyStep);
        if (adjustedQuantity <= 0) {
            this.emit('log', `Adjusted quantity for ${side} order became zero after rounding to ${qtyStep}. Order cancelled.`, 'Order Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
            return;
        }

        const orderParams = {
          category: 'linear',
          symbol: this.currentSymbol,
          side: side,
          orderType: 'Market',
          qty: adjustedQuantity.toFixed(qtyStep.toString().split('.')[1]?.length || 0), // Use precision from qtyStep
          orderLinkId: `geminiBot_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`,
        };

        this.emit('log', `Placing ${side} order for ${orderParams.qty} ${this.currentSymbol.slice(0, -4)} Contracts on ${this.currentSymbol}...`, 'Order Output', this.constants.NEON_CYAN, DOM_ELEMENTS.orderOutput);

        const response = await this.bybitClient.createOrder(orderParams);

        if (response && response.retCode === 0) {
          const orderId = response.result?.orderId;
          this.emit('log', `${side} Order Placed Successfully! Order ID: ${orderId}, Qty: ${orderParams.qty} ${this.currentSymbol.slice(0, -4)} Contracts.`, "Order Output", this.constants.NEON_GREEN, DOM_ELEMENTS.orderOutput);
          this.lastOrderSentTime = Date.now();
          if (side === 'BUY') {
            const entryPrice = this.orderBookManager.latestOrderBook?.a?.[0]?.[0] ? parseFloat(this.orderBookManager.latestOrderBook.a[0][0]) : 0;
            this.onBuyOrderFilled(adjustedQuantity, entryPrice);
          }
          this.fetchCurrentPosition();
        } else {
          this.emit('log', `Bybit Order failed: ${response?.retMsg || 'Unknown error'}`, "Order Output", this.constants.NEON_RED, DOM_ELEMENTS.orderOutput);
        }
      }
    }

    // --- GeminiAI ---
    class GeminiAI extends EventEmitter {
      constructor(constants) {
        super();
        this.constants = constants;
        this.ai = null;
        this.apiKey = '';
      }

      setApiKey(apiKey) {
        this.apiKey = apiKey;
        if (this.apiKey) {
          this.ai = new GoogleGenAI({ apiKey: this.apiKey });
          this.emit('log', 'Gemini API Key loaded.', 'Config', this.constants.NEON_GREEN, DOM_ELEMENTS.keyStatus);
        } else {
          this.ai = null;
          this.emit('log', 'Gemini API Key not found. Analysis disabled.', 'Config', this.constants.NEON_ORANGE, DOM_ELEMENTS.keyStatus);
        }
      }

      async analyze(promptData, userPrompt, currentSymbol) {
        if (!this.ai) {
          this.emit('log', "Gemini client not initialized. Check API Key.", "Gemini Output", this.constants.NEON_RED, DOM_ELEMENTS.geminiOutput);
          return null;
        }

        const defaultPrompt = `You are an expert crypto trading bot. Provide a trading signal for ${currentSymbol} (Linear Perpetual) based on the provided order book data, historical context, advanced analytics (imbalance, price impact), current position (contracts), PnL, and maximum position limits.
        
        Your response MUST be in the format: [ACTION QUANTITY Contracts].
        - ACTION can be 'BUY', 'SELL', or 'HOLD'.
        - QUANTITY must be a floating-point number representing contracts. If ACTION is 'HOLD', QUANTITY should be 0.
        - Prioritize capital preservation.
        - If buying, ensure QUANTITY does not exceed available capacity within max position.
        - If selling, ensure QUANTITY does not exceed current position.
        
        Example responses:
        [BUY 0.005 Contracts]
        [SELL 0.002 Contracts]
        [HOLD 0 Contracts]
        
        Do not include any other text, explanations, or code blocks (like ```json, ```python, ```math). Only the bracketed signal.`;

        const fullPrompt = `${promptData}\nInstruction: ${userPrompt || defaultPrompt}`;
        this.emit('log', `Prompt sent to Gemini:\n${fullPrompt}`, 'Gemini Output', this.constants.NEON_CYAN, DOM_ELEMENTS.geminiOutput);

        try {
          const response = await this.ai.getGenerativeModel({ model: this.constants.GEMINI_MODEL_NAME }).generateContent(fullPrompt);
          const signal = response.text;
          this.emit('log', `Gemini Signal Received: ${signal}`, 'Gemini Output', this.constants.NEON_GREEN, DOM_ELEMENTS.geminiOutput);
          return this.parseSignal(signal);
        } catch (error) {
          this.emit('log', `Gemini API Error: ${error?.message || 'Unknown error'}`, 'Gemini Output', this.constants.NEON_RED, DOM_ELEMENTS.geminiOutput);
          console.error('Gemini API Error:', error);
          return null;
        }
      }

      parseSignal(signalText) {
        const cleaned = (signalText || '')
          .replace(/```[\s\S]*?```/g, '')
          .trim();

        let action = null;
        let quantity = null;

        const match = cleaned.match(/\[(BUY|SELL|HOLD)\s+([\d.]+)\s*Contracts\]/i);

        if (match) {
          action = match[1].toUpperCase();
          quantity = parseFloat(match[2]);
        }

        if (!action || isNaN(quantity) || quantity < 0) {
          this.emit('log', `Invalid signal format from Gemini: "${signalText}". Expected [ACTION QUANTITY Contracts].`, "Gemini Parser", this.constants.NEON_ORANGE, DOM_ELEMENTS.orderOutput);
          return null;
        }
        return { action, quantity };
      }
    }

    // --- Main Application Class ---
    class App {
      constructor() {
        this.constants = CONSTANTS;
        this.ui = new UIManager(DOM_ELEMENTS, this.constants);
        this.bybitClient = new BybitClient(this.constants);
        this.wsManager = new WebSocketManager(this.constants.BYBIT_WEBSOCKET_URL, this.constants);
        this.orderBookManager = new OrderBookManager(this.constants);
        this.tradeManager = new TradeManager(this.bybitClient, this.orderBookManager, this.constants);
        this.geminiAI = new GeminiAI(this.constants);

        this.currentSymbol = localStorage.getItem('lastSelectedSymbol') || 'BTCUSDT';
        this.availableSymbols = [];

        this.setupEventListeners();
        this.initialize();
      }

      setupEventListeners() {
        // UI Events
        this.ui.on('saveApiKeys', () => this.saveApiKeys());
        this.ui.on('connectWebSocket', () => this.wsManager.connect());
        this.ui.on('subscribeOrderBook', () => this.subscribeToOrderBook());
        this.ui.on('unsubscribeOrderBook', () => this.wsManager.unsubscribe(`orderbook.1.${this.currentSymbol}`));
        this.ui.on('analyzeWithGemini', () => this.analyzeWithGemini());
        this.ui.on('symbolChanged', (newSymbol) => this.handleSymbolChange(newSymbol));
        this.ui.on('tpSlConfigChanged', () => this.updateTpSlFromUI());
        this.ui.on('configChanged', (key, value) => localStorage.setItem(key, value));

        // BybitClient Events
        this.bybitClient.on('log', (...args) => this.ui.logToOutput(...args));

        // WebSocketManager Events
        this.wsManager.on('log', (...args) => this.ui.logToOutput(...args));
        this.wsManager.on('status', (status, message) => this.ui.updateConnectionStatus(status, message));
        this.wsManager.on('orderBookUpdate', (data) => this.orderBookManager.updateOrderBookData(data));

        // OrderBookManager Events
        this.orderBookManager.on('log', (...args) => this.ui.logToOutput(...args));
        this.orderBookManager.on('updated', (data) => {
          this.ui.updateL1Data(data.bestBidPrice, data.bestBidQty, data.bestAskPrice, data.bestAskQty, data.updateId, data.symbol);
          this.ui.updateOrderBookChart(data.bestBidPrice, data.bestBidQty, data.bestAskPrice, data.bestAskQty);
          this.ui.updateAdvancedDisplay(data.advancedStats);
        });
        this.orderBookManager.on('cleared', () => this.ui.clearOrderBookUI());

        // TradeManager Events
        this.tradeManager.on('log', (...args) => this.ui.logToOutput(...args));
        this.tradeManager.on('positionUpdated', (qty, entryPrice, pnl) => this.ui.updatePositionDisplay(qty, entryPrice, pnl));
        this.tradeManager.on('tpSlConfigUpdated', (config, activeTrade) => this.ui.updateTpSlStatus(config, activeTrade));

        // GeminiAI Events
        this.geminiAI.on('log', (...args) => this.ui.logToOutput(...args));
      }

      async initialize() {
        this.ui.init();
        this.ui.updateTradingMode(this.constants.IS_TESTNET);
        this.loadApiKeysFromLocalStorage();
        this.geminiAI.setApiKey(DOM_ELEMENTS.geminiApiKeyUser.value);
        this.bybitClient.setApiKeys(DOM_ELEMENTS.bybitTradingApiKey.value, DOM_ELEMENTS.bybitTradingApiSecret.value);

        this.tradeManager.loadTpSlState();
        this.updateTpSlFromUI(); // Sync TP/SL UI config and update status
        this.tradeManager.startPositionFetching();
        this.tradeManager.startTpSlChecking();

        await this.fetchAndPopulateSymbols();
        this.orderBookManager.setSymbol(this.currentSymbol);
        this.tradeManager.setSymbol(this.currentSymbol);
        this.updateSymbolDerivedState();
        this.tradeManager.fetchCurrentPosition();
      }

      loadApiKeysFromLocalStorage() {
        DOM_ELEMENTS.geminiApiKeyUser.value = localStorage.getItem('geminiApiKeyUser') || '';
        DOM_ELEMENTS.bybitTradingApiKey.value = localStorage.getItem('bybitTradingApiKey') || '';
        DOM_ELEMENTS.bybitTradingApiSecret.value = localStorage.getItem('bybitTradingApiSecret') || '';
        DOM_ELEMENTS.maxPositionContracts.value = localStorage.getItem('maxPositionContracts') || this.constants.DEFAULT_MAX_POSITION_CONTRACTS;
        DOM_ELEMENTS.impactQtyContracts.value = localStorage.getItem('impactQtyContracts') || this.constants.DEFAULT_MAX_POSITION_CONTRACTS;

        DOM_ELEMENTS.tpPctInput.value = localStorage.getItem('tpPct') || (this.constants.tpPct * 100).toFixed(1);
        DOM_ELEMENTS.slPctInput.value = localStorage.getItem('slPct') || (this.constants.slPct * 100).toFixed(1);
        DOM_ELEMENTS.tpSlEnabled.checked = localStorage.getItem('tpSlEnabled') === 'true';

        this.ui.logToOutput('API keys & config loaded from local storage.', 'Config', this.constants.NEON_CYAN, DOM_ELEMENTS.keyStatus);
      }

      saveApiKeys() {
        this.ui.setLoading('saveApiKeysBtn', true, 'Save API Keys');
        const maxPos = parseFloat(DOM_ELEMENTS.maxPositionContracts.value);
        const impactQty = parseFloat(DOM_ELEMENTS.impactQtyContracts.value);

        if (isNaN(maxPos) || maxPos <= 0 || isNaN(impactQty) || impactQty <= 0) {
          this.ui.logToOutput('Invalid Max Position or Impact Quantity. Must be positive numbers.', 'Config', this.constants.NEON_RED, DOM_ELEMENTS.keyStatus);
          this.ui.setLoading('saveApiKeysBtn', false, 'Save API Keys');
          return;
        }

        localStorage.setItem('geminiApiKeyUser', DOM_ELEMENTS.geminiApiKeyUser.value);
        localStorage.setItem('bybitTradingApiKey', DOM_ELEMENTS.bybitTradingApiKey.value);
        localStorage.setItem('bybitTradingApiSecret', DOM_ELEMENTS.bybitTradingApiSecret.value);
        localStorage.setItem('maxPositionContracts', maxPos);
        localStorage.setItem('impactQtyContracts', impactQty);

        localStorage.setItem('tpPct', DOM_ELEMENTS.tpPctInput.value);
        localStorage.setItem('slPct', DOM_ELEMENTS.slPctInput.value);
        localStorage.setItem('tpSlEnabled', DOM_ELEMENTS.tpSlEnabled.checked);

        this.bybitClient.setApiKeys(DOM_ELEMENTS.bybitTradingApiKey.value, DOM_ELEMENTS.bybitTradingApiSecret.value);
        this.geminiAI.setApiKey(DOM_ELEMENTS.geminiApiKeyUser.value);
        this.updateTpSlFromUI();
        this.ui.logToOutput(`API keys and config saved!`, 'Config', this.constants.NEON_GREEN, DOM_ELEMENTS.keyStatus);
        this.ui.setLoading('saveApiKeysBtn', false, 'Save API Keys');
      }

      async fetchAndPopulateSymbols() {
        DOM_ELEMENTS.symbolSelect.innerHTML = '<option value="">Loading symbols...</option>';
        DOM_ELEMENTS.symbolSelect.disabled = true;

        this.availableSymbols = await this.bybitClient.getAvailableSymbols();

        if (this.availableSymbols.length > 0) {
          this.ui.populateSymbols(this.availableSymbols, this.currentSymbol);
          if (!this.availableSymbols.includes(this.currentSymbol)) {
            this.currentSymbol = this.availableSymbols[0];
            localStorage.setItem('lastSelectedSymbol', this.currentSymbol);
            DOM_ELEMENTS.symbolSelect.value = this.currentSymbol;
          }
          this.ui.logToOutput(`Loaded ${this.availableSymbols.length} USDT linear symbols.`, 'Symbol Loader', this.constants.NEON_GREEN, DOM_ELEMENTS.keyStatus);
        } else {
          this.ui.logToOutput('Failed to load symbols from Bybit API. Check console for details.', 'Symbol Loader', this.constants.NEON_RED, DOM_ELEMENTS.keyStatus);
          DOM_ELEMENTS.symbolSelect.innerHTML = '<option value="">Error loading symbols</option>';
        }
        DOM_ELEMENTS.symbolSelect.disabled = false;
      }

      handleSymbolChange(newSymbol) {
        if (newSymbol === this.currentSymbol) return;

        this.ui.logToOutput(`Changing symbol from ${this.currentSymbol} to ${newSymbol}...`, 'Symbol Change', this.constants.NEON_CYAN, DOM_ELEMENTS.connectionStatus);

        this.wsManager.unsubscribe(`orderbook.1.${this.currentSymbol}`);
        this.currentSymbol = newSymbol;
        localStorage.setItem('lastSelectedSymbol', this.currentSymbol);
        this.updateSymbolDerivedState();

        this.orderBookManager.setSymbol(this.currentSymbol);
        this.tradeManager.setSymbol(this.currentSymbol);

        if (this.wsManager.ws && this.wsManager.ws.readyState === WebSocket.OPEN) {
          this.subscribeToOrderBook();
        }
      }

      updateSymbolDerivedState() {
        const match = this.currentSymbol.match(/^([A-Z]+)(USDT)$/);
        let baseCoin = 'UNKNOWN';
        let quoteCoin = 'USDT';
        if (match) {
          baseCoin = match[1];
          quoteCoin = match[2];
        } else {
          const baseMatch = this.currentSymbol.match(/^([A-Z]+)/);
          baseCoin = baseMatch ? baseMatch[1] : 'UNKNOWN';
        }
        this.ui.updateSymbolLabels(baseCoin, quoteCoin);
      }

      subscribeToOrderBook() {
        if (!this.currentSymbol || this.currentSymbol === '') {
          this.ui.logToOutput('No trading symbol selected.', 'WS Status', this.constants.NEON_ORANGE, DOM_ELEMENTS.connectionStatus);
          return;
        }
        this.wsManager.subscribe(`orderbook.1.${this.currentSymbol}`);
      }

      updateTpSlFromUI() {
        const tp = parseFloat(DOM_ELEMENTS.tpPctInput.value);
        const sl = parseFloat(DOM_ELEMENTS.slPctInput.value);
        const enabled = DOM_ELEMENTS.tpSlEnabled.checked;
        this.tradeManager.setTpSlConfig(tp, sl, enabled);
      }

      async analyzeWithGemini() {
        if (!this.geminiAI.ai) {
          this.ui.logToOutput("Gemini client not initialized. Check API Key.", "Gemini Output", this.constants.NEON_RED, DOM_ELEMENTS.geminiOutput);
          return;
        }
        if (!this.orderBookManager.latestOrderBook) {
          this.ui.logToOutput('No live order book data to analyze.', 'Gemini Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.geminiOutput);
          return;
        }
        if (!this.currentSymbol || this.currentSymbol === '') {
          this.ui.logToOutput('No trading symbol selected.', 'Gemini Output', this.constants.NEON_ORANGE, DOM_ELEMENTS.geminiOutput);
          return;
        }

        this.ui.setLoading('analyzeBtn', true, 'Analyze & Get Signal');

        const maxPos = parseFloat(DOM_ELEMENTS.maxPositionContracts.value) || this.constants.DEFAULT_MAX_POSITION_CONTRACTS;
        const bestBidPrice = parseFloat(this.orderBookManager.latestOrderBook.b[0][0]);
        const bestBidQty = parseFloat(this.orderBookManager.latestOrderBook.b[0][1]);
        const bestAskPrice = parseFloat(this.orderBookManager.latestOrderBook.a[0][0]);
        const bestAskQty = parseFloat(this.orderBookManager.latestOrderBook.a[0][1]);
        const advancedStats = this.orderBookManager.computeAdvancedOrderBookStats(this.orderBookManager.latestOrderBook);

        let promptData = `Current ${this.currentSymbol} Linear Perpetual Order Book L1 Data:
Best Bid: $${bestBidPrice.toFixed(2)} (Quantity: ${bestBidQty.toFixed(4)} Contracts)
Best Ask: $${bestAskPrice.toFixed(2)} (Quantity: ${bestAskQty.toFixed(4)} Contracts)
Current Position (${this.ui.currentBaseCoin} Contracts): ${this.tradeManager.currentPositionQty.toFixed(5)}
Current Entry Price: $${this.tradeManager.currentEntryPrice.toFixed(2)}
Unrealised PnL: ${this.tradeManager.currentUnrealisedPnl.toFixed(2)}
Maximum Allowed Position (${this.ui.currentBaseCoin} Contracts): ${maxPos.toFixed(5)}
Mid Price: $${advancedStats.midPrice.toFixed(4)}
Order Book Imbalance (Top ${this.constants.ORDERBOOK_DEPTH_N}): ${advancedStats.imbalancePct.toFixed(2)}%
Estimated Buy Price for ${advancedStats.impactQty.toFixed(4)} Contracts: $${advancedStats.estBuyPriceForImpact.toFixed(2)}
Estimated Sell Price for ${advancedStats.impactQty.toFixed(4)} Contracts: $${advancedStats.estSellPriceForImpact.toFixed(2)}
`;

        const selectedTimeframe = DOM_ELEMENTS.timeframeSelect.value;
        if (selectedTimeframe !== "realtime") {
          const minutes = parseInt(selectedTimeframe.replace('m', '').replace('h', '')) * (selectedTimeframe.includes('h') ? 60 : 1);
          promptData += `\nHistorical Context (${selectedTimeframe}):\n${this.orderBookManager.getHistoricalOrderBookSummary(minutes)}\n`;
        }

        const userPrompt = DOM_ELEMENTS.geminiPrompt.value.trim();

        const signal = await this.geminiAI.analyze(promptData, userPrompt, this.currentSymbol);

        if (signal) {
          if (signal.action === 'BUY' || signal.action === 'SELL') {
            this.tradeManager.placeAutomatedOrder(signal.action, signal.quantity);
          } else if (signal.action === 'HOLD') {
            this.ui.logToOutput(`Gemini signal: HOLD. No order placed.`, 'Gemini Parser', this.constants.NEON_CYAN, DOM_ELEMENTS.orderOutput);
          }
        }
        this.ui.setLoading('analyzeBtn', false, 'Analyze & Get Signal');
      }
    }

    // Initialize the App when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      new App();
      window.addEventListener('resize', () => {
        // Handle chart resize if needed, UIManager will have the instance
      });
    });
  </script>
</body>
</html>
