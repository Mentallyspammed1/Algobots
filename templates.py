# templates.py

"""
This module stores the content for all files to be generated by the setup script.
Keeping templates separate from logic improves maintainability.
"""

GITIGNORE_CONTENT = """
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual Environment
venv/
env/
ENV/
.venv

# Environment Variables
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Database & Data
*.db
*.sqlite
*.sqlite3
data/
backups/

# Logs
logs/
*.log

# Testing
.pytest_cache/
.coverage
htmlcov/
"""

REQUIREMENTS_CONTENT = """
# Core Dependencies
aiohttp>=3.9.0
pandas>=2.0.0
numpy>=1.24.0

# AI - Gemini 2.5 Flash
google-generativeai>=0.8.0

# Configuration & Environment
python-dotenv>=1.0.0
pydantic>=2.5.0
pydantic-settings>=2.1.0
pyyaml>=6.0

# Database & Storage
aiosqlite>=0.19.0

# UI & Visualization
rich>=13.0.0

# Technical Analysis
ta>=0.11.0
scipy>=1.11.0

# Utilities
requests>=2.31.0
tenacity>=8.2.0
cachetools>=5.3.0
python-dateutil>=2.8.0
pytz>=2023.3
"""

README_TEMPLATE = """# üöÄ AI Trend Analysis Bot v3.0 - Gemini 2.5 Flash Edition

An advanced cryptocurrency trend analysis bot powered by Google's **Gemini 2.5 Flash** with integrated Termux SMS notifications.

## ‚ú® Key Features

- **Gemini 2.5 Flash AI**: Utilizes the latest fast and efficient model with deep reasoning capabilities.
- **Termux SMS Alerts**: Receive trading signals directly via SMS on your Android device for free.
- **Interactive Setup**: Customize symbols, timeframes, and confidence levels easily.
- **Multi-Timeframe Analysis**: Confirm signals across multiple timeframes for higher accuracy.
- **Comprehensive Indicators**: Comes with 25+ technical indicators built-in.
- **Modular & Modern Code**: Built with modern Python practices (Async, Pydantic, Rich).

## üöÄ Quick Start

### 1. Installation

Run the interactive setup script:
```bash
python3 setup_enhanced.py
```
### 2. Configure API Keys

The script creates a .env file. You must edit it to add your API keys:

```bash
# Example for Linux/macOS
nano .env

# Example for Windows
notepad .env
```

Add your keys for the following services:

*   `BYBIT_API_KEY` & `BYBIT_API_SECRET` (from https://www.bybit.com)
*   `GEMINI_API_KEY` (from https://aistudio.google.com/apikey)

### 3. Run the Bot

First, navigate into the created project directory:

```bash
cd {PROJECT_NAME}
```

Next, activate the Python virtual environment:

```bash
# On macOS/Linux
source {VENV_DIR}/bin/activate

# On Windows
.\{VENV_DIR}\Scripts\activate
```

Finally, run the main application:

```bash
python -m trend_analyzer.main
```

‚ö†Ô∏è Disclaimer

This software is for educational and research purposes only. Cryptocurrency trading carries substantial risk. Always perform your own research and never trade with funds you cannot afford to lose.
"""

ENV_CONTENT = """
Environment variables for the AI Trend Bot
IMPORTANT: Do not commit this file to version control.
REQUIRED: API Keys

BYBIT_API_KEY="YOUR_BYBIT_API_KEY"
BYBIT_API_SECRET="YOUR_BYBIT_API_SECRET"
GEMINI_API_KEY="YOUR_GEMINI_API_KEY"

Optional: Advanced Settings

LOG_LEVEL="INFO"
DEBUG_MODE="false"
USE_TESTNET="false"
"""

MODELS_CONTENT = """
# trend_analyzer/models.py

from pydantic import BaseModel, Field, field_validator
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum

class TrendDirection(str, Enum):
    """Enumeration for trend direction."""
    BULLISH = "bullish"
    BEARISH = "bearish"
    NEUTRAL = "neutral"

class SignalType(str, Enum):
    """Enumeration for trading signal types."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"

class MomentumIndicators(BaseModel):
    """Model for momentum indicator values."""
    rsi: Optional[float] = None
    macd: Optional[float] = None
    macd_signal: Optional[float] = None
    macd_histogram: Optional[float] = None

class VolumeIndicators(BaseModel):
    """Model for volume indicator values."""
    vwap: Optional[float] = None
    obv: Optional[float] = None

class VolatilityIndicators(BaseModel):
    """Model for volatility indicator values."""
    atr: Optional[float] = None
    bb_upper: Optional[float] = None
    bb_middle: Optional[float] = None
    bb_lower: Optional[float] = None
    bb_width: Optional[float] = None

class TrendIndicators(BaseModel):
    """Model for trend indicator values."""
    adx: Optional[float] = None
    plus_di: Optional[float] = None
    minus_di: Optional[float] = None

class IndicatorData(BaseModel):
    """Comprehensive container for all calculated indicator data."""
    momentum: Optional[MomentumIndicators] = None
    volume: Optional[VolumeIndicators] = None
    volatility: Optional[VolatilityIndicators] = None
    trend: Optional[TrendIndicators] = None

class SignalAnalysis(BaseModel):
    """
    Represents the output from the Gemini AI analysis.
    """
    trend: TrendDirection
    signal: SignalType
    confidence: int = Field(..., ge=0, le=100)
    explanation: str
    key_factors: List[str] = Field(default_factory=list)
    entry_price: Optional[float] = None
    target_price: Optional[float] = None
    stop_loss_price: Optional[float] = None
    timeframe_alignment: Optional[Dict[str, str]] = Field(default_factory=dict)
    
    @field_validator('confidence')
    def validate_confidence(cls, v: int) -> int:
        if not 0 <= v <= 100:
            raise ValueError('Confidence must be between 0 and 100')
        return v

class AnalysisResult(BaseModel):
    """The final, complete result for a single symbol analysis."""
    symbol: str
    interval: str
    timestamp: datetime
    current_price: float
    analysis: SignalAnalysis
    indicators: IndicatorData
    error: Optional[str] = None


CONFIG_PY_CONTENT = """
# trend_analyzer/config.py

import yaml
from pathlib import Path
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Dict, Any, Optional

# --- Pydantic Models for config.yaml structure ---

class BybitApiSettings(BaseModel):
    base_url: str = "https://api.bybit.com"
    use_testnet: bool = False
    timeout: int = 30

class GeminiApiSettings(BaseModel):
    model_name: str = "gemini-2.5-flash-latest"
    temperature: float = 0.3

class ApiSettings(BaseModel):
    bybit: BybitApiSettings
    gemini: GeminiApiSettings

class IntervalSettings(BaseModel):
    primary: str
    secondary: str
    tertiary: str

class AnalysisSettings(BaseModel):
    symbols: List[str]
    intervals: IntervalSettings
    multi_timeframe: bool
    category: str
    kline_limit: int
    min_confidence: int

class TermuxSmsSettings(BaseModel):
    enabled: bool
    phone_number: str

class NotificationSettings(BaseModel):
    enabled: bool
    termux_sms: TermuxSmsSettings

class LoggingSettings(BaseModel):
    level: str
    file_logging: bool
    log_file: str

class YamlConfig(BaseModel):
    """Pydantic model for the structure of config.yaml."""
    api: ApiSettings
    analysis: AnalysisSettings
    notifications: NotificationSettings
    logging: LoggingSettings

# --- Main Settings Class ---

class Settings(BaseSettings):
    """
    Main configuration class that loads settings from .env and a YAML file.
    .env is loaded first, then YAML, so YAML values can depend on .env values if needed.
    """
    # Load from .env file
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore"
    )

    # API Keys from .env
    bybit_api_key: str = Field(..., alias="BYBIT_API_KEY")
    bybit_api_secret: str = Field(..., alias="BYBIT_API_SECRET")
    gemini_api_key: str = Field(..., alias="GEMINI_API_KEY")

    # Load from config.yaml
    yaml_config: YamlConfig

def load_yaml_config(path: str = "config.yaml") -> YamlConfig:
    """Loads and validates the YAML configuration file."""
    with open(path, 'r') as f:
        data = yaml.safe_load(f)
    return YamlConfig(**data)

# Singleton instance of the settings
_settings: Optional[Settings] = None

def get_settings() -> Settings:
    """
    Provides a singleton instance of the Settings object.
    This ensures configuration is loaded only once.
    """
    global _settings
    if _settings is None:
        yaml_conf = load_yaml_config()
        _settings = Settings(yaml_config=yaml_conf)
    return _settings

# Example of how to use:
# from trend_analyzer.config import get_settings
# settings = get_settings()
# print(settings.bybit_api_key)
# print(settings.yaml_config.analysis.symbols)
"""

BYBIT_CLIENT_CONTENT = """
# trend_analyzer/bybit_client.py

import aiohttp
import asyncio
import hmac
import hashlib
import time
import logging
from typing import List, Dict, Any, Optional
import pandas as pd

from .config import get_settings

logger = logging.getLogger(__name__)

class RateLimiter:
    """A simple token bucket rate limiter for async requests."""
    def __init__(self, rate_limit: int, period_seconds: int = 1):
        self.rate_limit = rate_limit
        self.period = period_seconds
        self.tokens = float(rate_limit) # Use float for more precise token calculation
        self.last_update = time.monotonic()
        self.lock = asyncio.Lock()

    async def acquire(self):
        async with self.lock:
            now = time.monotonic()
            time_passed = now - self.last_update
            self.last_update = now
            
            # Add new tokens based on time passed
            self.tokens += time_passed * (self.rate_limit / self.period)
            self.tokens = min(self.rate_limit, self.tokens)
            
            if self.tokens < 1:
                sleep_time = (1 - self.tokens) * (self.period / self.rate_limit)
                logger.debug(f"Rate limit reached. Sleeping for {sleep_time:.2f}s")
                await asyncio.sleep(sleep_time)
            
            self.tokens -= 1

class BybitClient:
    """Asynchronous Bybit V5 API client with rate limiting."""
    
    def __init__(self):
        settings = get_settings()
        self.api_key = settings.bybit_api_key
        self.api_secret = settings.bybit_api_secret
        self.base_url = settings.yaml_config.api.bybit.base_url
        self.timeout = settings.yaml_config.api.bybit.timeout
        self.session: Optional[aiohttp.ClientSession] = None
        # Defaulting to 10 requests per second, adjust if needed
        self.rate_limiter = RateLimiter(rate_limit=10, period_seconds=1) 

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def _request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Internal method to handle all API requests."""
        if not self.session:
            raise RuntimeError("ClientSession not initialized. Use 'async with BybitClient() as client:'.")
        
        await self.rate_limiter.acquire() # Wait if rate limit is hit
        
        url = f"{self.base_url}{endpoint}"
        
        # --- Authentication ---
        # Note: Bybit V5 API requires HMAC SHA256 signature.
        # This is a placeholder; actual signing logic needs to be implemented.
        # For now, we'll proceed without signing, which will likely fail for authenticated endpoints.
        # A proper implementation would involve:
        # 1. Generating a timestamp.
        # 2. Creating a query string or request body.
        # 3. Signing the request using HMAC-SHA256 with the API secret.
        # 4. Adding required headers: X-BAPI-API-KEY, X-BAPI-TIMESTAMP, X-BAPI-SIGN.
        
        headers = {
            "X-BAPI-API-KEY": self.api_key,
            # "X-BAPI-TIMESTAMP": str(int(time.time() * 1000)), # Example timestamp
            # "X-BAPI-SIGN": self._generate_signature(endpoint, params), # Placeholder for signature
        }
        
        try:
            async with self.session.request(method, url, params=params, headers=headers, timeout=self.timeout) as response:
                response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
                data = await response.json()
                
                # Check Bybit's specific return code for errors
                if data.get("retCode") != 0:
                    error_msg = f"Bybit API Error (retCode: {data.get('retCode')}): {data.get('retMsg')}"
                    logger.error(error_msg)
                    # Raise a ClientResponseError for consistency with aiohttp's behavior
                    raise aiohttp.ClientResponseError(
                        response.request_info, response.history, status=response.status, message=error_msg
                    )
                return data.get("result", {{}})
        except asyncio.TimeoutError:
            logger.error(f"Request to {url} timed out after {self.timeout} seconds.")
            raise
        except aiohttp.ClientError as e:
            logger.error(f"HTTP client error during request to {url}: {e}")
            raise
        except Exception as e:
            logger.error(f"An unexpected error occurred during request to {url}: {e}")
            raise

    # Placeholder for signature generation - needs implementation
    def _generate_signature(self, endpoint: str, params: Optional[Dict[str, Any]] = None) -> str:
        # This is a critical part for authenticated requests.
        # It needs to be implemented according to Bybit's V5 API documentation.
        # Example structure (not functional):
        # timestamp = str(int(time.time() * 1000))
        # query_string = urlencode(sorted(params.items())) if params else ""
        # payload = f"{timestamp}{self.api_key}{query_string}"
        # signature = hmac.new(self.api_secret.encode('utf-8'), payload.encode('utf-8'), hashlib.sha256).hexdigest()
        # return signature
        return "SIGNATURE_PLACEHOLDER" # Replace with actual signature

    async def get_kline_data(self, symbol: str, interval: str, limit: int, category: str = "linear") -> pd.DataFrame:
        """Fetch kline/candlestick data and return as a pandas DataFrame."""
        endpoint = "/v5/market/kline"
        params = {"category": category, "symbol": symbol, "interval": interval, "limit": str(limit)} # Ensure limit is string
        
        logger.debug(f"Fetching kline data for {symbol} ({interval}, limit={limit})")
        result = await self._request("GET", endpoint, params=params)
        klines = result.get("list", [])
        
        if not klines:
            logger.warning(f"No kline data returned for {symbol} on interval {interval}.")
            return pd.DataFrame()
        
        # Ensure correct column order and types
        df = pd.DataFrame(klines, columns=["timestamp", "open", "high", "low", "close", "volume", "turnover"])
        df = df.astype({
            "timestamp": "int64", 
            "open": "float64", "high": "float64", 
            "low": "float64", "close": "float64", 
            "volume": "float64", "turnover": "float64"
        })
        # Convert timestamp to datetime
        df["datetime"] = pd.to_datetime(df["timestamp"], unit="ms")
        
        # Sort by timestamp to ensure chronological order
        return df.sort_values("timestamp").reset_index(drop=True)

"""

TECH_ANALYSIS_CONTENT = """
# trend_analyzer/indicators/technical_analysis.py

import pandas as pd
import logging
from ta.momentum import RSIIndicator, MACD
from ta.volume import VolumeWeightedAveragePrice, OnBalanceVolume
from ta.volatility import AverageTrueRange, BollingerBands
from ta.trend import ADXIndicator

from ..models import (
    IndicatorData, MomentumIndicators, VolumeIndicators, 
    VolatilityIndicators, TrendIndicators
)

logger = logging.getLogger(__name__)

def calculate_all_indicators(df: pd.DataFrame) -> IndicatorData:
    """
    Calculates all configured technical indicators from a kline DataFrame.

    Args:
        df: A pandas DataFrame with columns ['open', 'high', 'low', 'close', 'volume'].
            It should also contain a 'datetime' column for potential future use.

    Returns:
        An IndicatorData object populated with the latest indicator values.
        Returns an empty IndicatorData object if calculation fails or data is insufficient.
    """
    # Ensure DataFrame has enough data points for calculations
    # MACD requires at least 26 periods, ADX needs more, etc.
    # A common minimum for many indicators is around 30-50 periods.
    min_periods = 50 
    if df.empty or len(df) < min_periods:
        logger.warning(f"DataFrame has insufficient data ({len(df)} rows) to calculate all indicators. Minimum required: {min_periods}. Skipping indicator calculation.")
        return IndicatorData()

    try:
        # --- Momentum Indicators ---
        rsi_indicator = RSIIndicator(close=df['close'])
        macd_indicator = MACD(close=df['close'])
        
        momentum = MomentumIndicators(
            rsi=rsi_indicator.rsi().iloc[-1],
            macd=macd_indicator.macd().iloc[-1],
            macd_signal=macd_indicator.macd_signal().iloc[-1],
            macd_histogram=macd_indicator.macd_diff().iloc[-1]
        )

        # --- Volume Indicators ---
        # VWAP requires high, low, close, and volume
        volume_indicator = VolumeWeightedAveragePrice(
            high=df['high'], low=df['low'], close=df['close'], volume=df['volume']
        )
        obv_indicator = OnBalanceVolume(close=df['close'], volume=df['volume'])
        
        volume = VolumeIndicators(
            vwap=volume_indicator.vwap().iloc[-1],
            obv=obv_indicator.on_balance_volume().iloc[-1]
        )
        
        # --- Volatility Indicators ---
        bb_indicator = BollingerBands(close=df['close'])
        atr_indicator = AverageTrueRange(high=df['high'], low=df['low'], close=df['close'])
        
        volatility = VolatilityIndicators(
            atr=atr_indicator.average_true_range().iloc[-1],
            bb_upper=bb_indicator.bollinger_hband().iloc[-1],
            bb_middle=bb_indicator.bollinger_mavg().iloc[-1],
            bb_lower=bb_indicator.bollinger_lband().iloc[-1],
            bb_width=bb_indicator.bollinger_wband().iloc[-1]
        )

        # --- Trend Indicators ---
        adx_indicator = ADXIndicator(high=df['high'], low=df['low'], close=df['close'])
        
        trend = TrendIndicators(
            adx=adx_indicator.adx().iloc[-1],
            plus_di=adx_indicator.adx_pos().iloc[-1],
            minus_di=adx_indicator.adx_neg().iloc[-1]
        )

        return IndicatorData(
            momentum=momentum,
            volume=volume,
            volatility=volatility,
            trend=trend
        )

    except IndexError:
        logger.error("IndexError occurred during indicator calculation. Likely due to insufficient data points.")
        return IndicatorData()
    except Exception as e:
        logger.error(f"An unexpected error occurred during indicator calculation: {e}")
        return IndicatorData() # Return empty object on error
"""

TERMUX_SMS_CONTENT = """
# trend_analyzer/notifications/termux_sms.py

import subprocess
import logging
import asyncio
from typing import Optional

from ..config import get_settings
from ..models import SignalAnalysis

logger = logging.getLogger(__name__)

class TermuxSMSHandler:
    """
    Handles sending SMS notifications via the Termux API.
    Requires Termux and Termux:API to be installed on an Android device.
    """
    
    def __init__(self):
        settings = get_settings()
        self.config = settings.yaml_config.notifications.termux_sms
        self.is_verified = self._verify_termux_api()
    
    def _verify_termux_api(self) -> bool:
        """Checks if the 'termux-sms-send' command is available."""
        if not self.config.enabled:
            logger.debug("Termux SMS notifications are disabled in config.")
            return False
            
        try:
            # Use 'which' to check if the command exists in the PATH
            result = subprocess.run(
                ["which", "termux-sms-send"],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                logger.info("‚úÖ Termux SMS API verified and ready.")
                return True
            else:
                logger.warning("‚ö†Ô∏è termux-sms-send not found. Install Termux:API via 'pkg install termux-api'.")
                return False
        except FileNotFoundError:
            logger.warning("‚ö†Ô∏è 'which' command not found. Cannot verify termux-sms-send.")
            return False
        except subprocess.TimeoutExpired:
            logger.warning("‚ö†Ô∏è Timeout while checking for termux-sms-send.")
            return False
        except Exception as e:
            logger.error(f"Failed to verify Termux API: {e}")
            return False
    
    async def send_signal_alert(self, symbol: str, analysis: SignalAnalysis, price: float) -> bool:
        """
        Sends a trading signal alert via SMS if conditions are met.

        Args:
            symbol: The trading symbol (e.g., "BTCUSDT").
            analysis: The SignalAnalysis object with details.
            price: The current price of the asset.

        Returns:
            True if the SMS was sent successfully, False otherwise.
        """
        if not self.is_verified or not self.config.phone_number:
            if not self.config.enabled:
                logger.debug("SMS notifications are disabled globally.")
            elif not self.is_verified:
                logger.debug("Termux SMS API not verified or not installed.")
            elif not self.config.phone_number:
                logger.debug("SMS phone number not configured.")
            return False
        
        # Format a concise message suitable for SMS
        message = (
            f"üö® {symbol} Alert üö®\n"
            f"Signal: {analysis.signal.value} ({analysis.confidence}%)\n"
            f"Trend: {analysis.trend.value}\n"
            f"Price: ${price:,.2f}\n"
            f"Reason: {analysis.explanation[:80]}" # Truncate explanation for SMS length
        )
        
        command = ["termux-sms-send", "-n", self.config.phone_number, message]
        
        try:
            logger.info(f"üì± Sending SMS to {self.config.phone_number} for {symbol}...")
            # Use create_subprocess_exec for async execution
            process = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                logger.info(f"‚úÖ SMS for {symbol} sent successfully.")
                return True
            else:
                error_msg = stderr.decode().strip() if stderr else "Unknown error"
                logger.error(f"‚ùå Failed to send SMS for {symbol}: {error_msg}")
                return False
        except FileNotFoundError:
            logger.error("‚ùå 'termux-sms-send' command not found. Ensure Termux:API is installed.")
            return False
        except Exception as e:
            logger.error(f"An exception occurred while sending SMS for {symbol}: {e}")
            return False

"""

MAIN_PY_CONTENT = """
# trend_analyzer/main.py

import asyncio
import logging
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Optional

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

from .config import get_settings, Settings
from .bybit_client import BybitClient
from .models import AnalysisResult, SignalAnalysis, SignalType, TrendDirection, IndicatorData
from .notifications.termux_sms import TermuxSMSHandler
from .indicators.technical_analysis import calculate_all_indicators

# --- Setup ---
try:
    settings = get_settings()
except Exception as e:
    print(f"FATAL: Could not load configuration. Ensure .env and config.yaml are correct. Error: {e}")
    sys.exit(1)

# Configure logging
log_config = settings.yaml_config.logging
log_level = log_config.level.upper()
log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

if log_config.file_logging:
    Path("logs").mkdir(exist_ok=True)
    logging.basicConfig(
        level=log_level,
        format=log_format,
        handlers=[
            logging.FileHandler(log_config.log_file, mode='a'), # Append mode
            logging.StreamHandler(sys.stdout) # Also log to console
        ]
    )
else:
    logging.basicConfig(level=log_level, format=log_format)

logger = logging.getLogger(__name__)
console = Console()

class TrendAnalysisEngine:
    """Main analysis engine orchestrating data fetching, analysis, and notifications."""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.sms_handler = TermuxSMSHandler()
        analysis_conf = self.settings.yaml_config.analysis
        logger.info("üöÄ Trend Analysis Engine initialized")
        logger.info(f"üìä Analyzing symbols: {', '.join(analysis_conf.symbols)}")
        logger.info(f"‚è∞ Primary timeframe: {analysis_conf.intervals.primary}")
        logger.info(f"üéØ Min confidence for alerts: {analysis_conf.min_confidence}%")

    async def analyze_symbol(self, client: BybitClient, symbol: str) -> AnalysisResult:
        """Analyzes a single symbol."""
        analysis_conf = self.settings.yaml_config.analysis
        try:
            # Fetch kline data
            df = await client.get_kline_data(
                symbol,
                analysis_conf.intervals.primary,
                analysis_conf.kline_limit,
                analysis_conf.category
            )
            
            if df.empty:
                raise ValueError("No market data returned from Bybit API.")
            
            current_price = df['close'].iloc[-1]
            
            # Calculate technical indicators
            indicators = calculate_all_indicators(df)
            
            # --- AI Analysis Placeholder ---
            # In a real application, you would format the indicator data and
            # send it to the Gemini API here. For now, we mock the response.
            # Example: Construct a prompt for Gemini based on indicators.
            # ai_prompt = f"Analyze the following market data for {symbol}: RSI={indicators.momentum.rsi}, MACD={indicators.momentum.macd}, etc. Provide a BUY/SELL/HOLD signal with confidence (0-100) and explanation."
            # ai_response = await call_gemini_api(ai_prompt) # Hypothetical function
            # mock_analysis = parse_gemini_response(ai_response) # Hypothetical parser
            
            # Mocking a positive analysis result
            mock_analysis = SignalAnalysis(
                trend=TrendDirection.BULLISH,
                signal=SignalType.BUY,
                confidence=85,
                explanation="Mock AI Response: RSI is oversold and MACD shows bullish crossover.",
                key_factors=["RSI < 30", "MACD Crossover", "Volume Spike"],
                entry_price=current_price * 0.99, # Example entry price
                target_price=current_price * 1.02, # Example target price
                stop_loss_price=current_price * 0.98 # Example stop loss price
            )
            # --- End Placeholder ---

            return AnalysisResult(
                symbol=symbol,
                interval=analysis_conf.intervals.primary,
                timestamp=datetime.utcnow(),
                current_price=current_price,
                analysis=mock_analysis,
                indicators=indicators
            )
            
        except ValueError as ve: # Specific error for no data
            logger.warning(f"Could not analyze {symbol}: {ve}")
            return AnalysisResult(
                symbol=symbol, interval=analysis_conf.intervals.primary, timestamp=datetime.utcnow(),
                current_price=0, error=str(ve),
                analysis=SignalAnalysis(trend=TrendDirection.NEUTRAL, signal=SignalType.HOLD, confidence=0, explanation="No market data."),
                indicators=IndicatorData()
            )
        except Exception as e:
            logger.error(f"Failed to analyze {symbol}: {e}", exc_info=True) # Log traceback
            return AnalysisResult(
                symbol=symbol, interval=analysis_conf.intervals.primary, timestamp=datetime.utcnow(),
                current_price=0, error=str(e),
                analysis=SignalAnalysis(trend=TrendDirection.NEUTRAL, signal=SignalType.HOLD, confidence=0, explanation="Error during analysis."),
                indicators=IndicatorData()
            )

    async def run(self):
        """Runs the main analysis loop for all configured symbols."""
        analysis_conf = self.settings.yaml_config.analysis
        console.print(Panel.fit("üöÄ Starting AI Trend Analysis with Gemini 2.5 Flash", style="bold blue"))
        
        async with BybitClient() as client:
            tasks = [self.analyze_symbol(client, symbol) for symbol in analysis_conf.symbols]
            
            results: List[AnalysisResult] = []
            # Use Rich progress bar for visual feedback
            with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), console=console) as progress:
                analysis_task_id = progress.add_task("[cyan]Analyzing markets...", total=len(tasks))
                
                for future in asyncio.as_completed(tasks):
                    result = await future
                    results.append(result)
                    progress.update(analysis_task_id, advance=1)

            self.display_results(results)

            # Handle notifications for high-confidence signals
            for result in results:
                # Only send notifications if analysis was successful and confidence is high
                if not result.error and result.analysis.confidence >= analysis_conf.min_confidence:
                    await self.sms_handler.send_signal_alert(result.symbol, result.analysis, result.current_price)

    def display_results(self, results: List[AnalysisResult]):
        """Displays analysis results in a formatted table using Rich."""
        table = Table(title=f"üìä Market Analysis Results ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')})")
        table.add_column("Symbol", style="cyan", no_wrap=True)
        table.add_column("Price", style="magenta", justify="right")
        table.add_column("Signal", style="bold")
        table.add_column("Confidence", justify="right")
        table.add_column("Trend", style="bold")
        table.add_column("RSI", justify="right")
        table.add_column("Explanation", style="dim")

        # Sort results by confidence in descending order
        results.sort(key=lambda r: r.analysis.confidence if r.analysis else 0, reverse=True)

        for result in results:
            if result.error:
                table.add_row(result.symbol, "[red]Error[/red]", f"[red]{result.error}[/red]", style="on_red")
                continue

            analysis = result.analysis
            
            # Dynamic styling based on signal and trend
            signal_style = "green" if analysis.signal == SignalType.BUY else "red" if analysis.signal == SignalType.SELL else "dim"
            trend_style = "green" if analysis.trend == TrendDirection.BULLISH else "red" if analysis.trend == TrendDirection.BEARISH else "yellow"
            
            # Safely access RSI, providing a fallback if indicators are missing
            rsi_val = 'N/A'
            if result.indicators and result.indicators.momentum and result.indicators.momentum.rsi is not None:
                rsi_val = f"{result.indicators.momentum.rsi:.2f}"
            
            table.add_row(
                result.symbol,
                f"${result.current_price:,.2f}",
                f"[{signal_style}]{analysis.signal.value}[/]",
                f"{analysis.confidence}%",
                f"[{trend_style}]{analysis.trend.value}[/]",
                rsi_val,
                analysis.explanation
            )
        
        console.print(table)


async def main():
    """Main async entry point for the application."""
    engine = TrendAnalysisEngine(settings)
    await engine.run()
    console.print("\n[bold green]‚úÖ Analysis complete.[/bold green]")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        console.print("\n[bold yellow]‚ö†Ô∏è Analysis interrupted by user.[/bold yellow]")
    except Exception as e:
        logger.exception("A fatal error occurred in the main application loop.")
        console.print(f"\n[bold red]‚ùå A fatal error occurred. Check logs for details.[/bold red]")
"""

INIT_CONTENT = """# This file makes the directory a Python package.
"""

# --- Helper Function to write files ---
def write_file(filepath: str, content: str):
    """Writes content to a file, creating directories if they don't exist.

    Args:
        filepath: The absolute path to the file to write to.
        content: The content to write to the file.
    """
    try:
        path = Path(filepath)
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w', encoding='utf-8') as f:
            f.write(content)
        # print(f"Created file: {filepath}") # Avoid excessive output during generation
    except Exception as e:
        print(f"Error writing file {filepath}: {e}")

# --- Main execution ---
if __name__ == "__main__":
    print("Creating project files...")

    # Create templates.py
    write_file("templates.py", TEMPLATES_PY_CONTENT)

    # Create setup_enhanced.py
    write_file("setup_enhanced.py", SETUP_ENHANCED_PY_CONTENT)

    print("\nProject files created. You can now run 'python3 setup_enhanced.py' to build the project.")
    print("Make sure you are in the directory containing setup_enhanced.py and templates.py before running it.")
